function qk(n, e) {
    for (var t = 0; t < e.length; t++) {
        const i = e[t];
        if (typeof i != "string" && !Array.isArray(i)) {
            for (const r in i)
                if (r !== "default" && !(r in n)) {
                    const s = Object.getOwnPropertyDescriptor(i, r);
                    s && Object.defineProperty(n, r, s.get ? s : {
                        enumerable: !0,
                        get: ()=>i[r]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, {
        value: "Module"
    }))
}
(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const r of document.querySelectorAll('link[rel="modulepreload"]'))
        i(r);
    new MutationObserver(r=>{
        for (const s of r)
            if (s.type === "childList")
                for (const o of s.addedNodes)
                    o.tagName === "LINK" && o.rel === "modulepreload" && i(o)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function t(r) {
        const s = {};
        return r.integrity && (s.integrity = r.integrity),
        r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
        r.crossOrigin === "use-credentials" ? s.credentials = "include" : r.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin",
        s
    }
    function i(r) {
        if (r.ep)
            return;
        r.ep = !0;
        const s = t(r);
        fetch(r.href, s)
    }
}
)();
function bP(n) {
    return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
}
function $k(n) {
    if (n.__esModule)
        return n;
    var e = n.default;
    if (typeof e == "function") {
        var t = function i() {
            if (this instanceof i) {
                var r = [null];
                r.push.apply(r, arguments);
                var s = Function.bind.apply(e, r);
                return new s
            }
            return e.apply(this, arguments)
        };
        t.prototype = e.prototype
    } else
        t = {};
    return Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    Object.keys(n).forEach(function(i) {
        var r = Object.getOwnPropertyDescriptor(n, i);
        Object.defineProperty(t, i, r.get ? r : {
            enumerable: !0,
            get: function() {
                return n[i]
            }
        })
    }),
    t
}
var nd = {}
  , eF = {
    get exports() {
        return nd
    },
    set exports(n) {
        nd = n
    }
}
  , r0 = {}
  , U = {}
  , tF = {
    get exports() {
        return U
    },
    set exports(n) {
        U = n
    }
}
  , bt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Xd = Symbol.for("react.element")
  , nF = Symbol.for("react.portal")
  , iF = Symbol.for("react.fragment")
  , rF = Symbol.for("react.strict_mode")
  , sF = Symbol.for("react.profiler")
  , oF = Symbol.for("react.provider")
  , aF = Symbol.for("react.context")
  , lF = Symbol.for("react.forward_ref")
  , uF = Symbol.for("react.suspense")
  , cF = Symbol.for("react.memo")
  , fF = Symbol.for("react.lazy")
  , Ib = Symbol.iterator;
function dF(n) {
    return n === null || typeof n != "object" ? null : (n = Ib && n[Ib] || n["@@iterator"],
    typeof n == "function" ? n : null)
}
var CP = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , EP = Object.assign
  , TP = {};
function gc(n, e, t) {
    this.props = n,
    this.context = e,
    this.refs = TP,
    this.updater = t || CP
}
gc.prototype.isReactComponent = {};
gc.prototype.setState = function(n, e) {
    if (typeof n != "object" && typeof n != "function" && n != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, n, e, "setState")
}
;
gc.prototype.forceUpdate = function(n) {
    this.updater.enqueueForceUpdate(this, n, "forceUpdate")
}
;
function PP() {}
PP.prototype = gc.prototype;
function gA(n, e, t) {
    this.props = n,
    this.context = e,
    this.refs = TP,
    this.updater = t || CP
}
var vA = gA.prototype = new PP;
vA.constructor = gA;
EP(vA, gc.prototype);
vA.isPureReactComponent = !0;
var Lb = Array.isArray
  , BP = Object.prototype.hasOwnProperty
  , yA = {
    current: null
}
  , RP = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function IP(n, e, t) {
    var i, r = {}, s = null, o = null;
    if (e != null)
        for (i in e.ref !== void 0 && (o = e.ref),
        e.key !== void 0 && (s = "" + e.key),
        e)
            BP.call(e, i) && !RP.hasOwnProperty(i) && (r[i] = e[i]);
    var a = arguments.length - 2;
    if (a === 1)
        r.children = t;
    else if (1 < a) {
        for (var l = Array(a), c = 0; c < a; c++)
            l[c] = arguments[c + 2];
        r.children = l
    }
    if (n && n.defaultProps)
        for (i in a = n.defaultProps,
        a)
            r[i] === void 0 && (r[i] = a[i]);
    return {
        $$typeof: Xd,
        type: n,
        key: s,
        ref: o,
        props: r,
        _owner: yA.current
    }
}
function hF(n, e) {
    return {
        $$typeof: Xd,
        type: n.type,
        key: e,
        ref: n.ref,
        props: n.props,
        _owner: n._owner
    }
}
function xA(n) {
    return typeof n == "object" && n !== null && n.$$typeof === Xd
}
function pF(n) {
    var e = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + n.replace(/[=:]/g, function(t) {
        return e[t]
    })
}
var Db = /\/+/g;
function ay(n, e) {
    return typeof n == "object" && n !== null && n.key != null ? pF("" + n.key) : e.toString(36)
}
function Vm(n, e, t, i, r) {
    var s = typeof n;
    (s === "undefined" || s === "boolean") && (n = null);
    var o = !1;
    if (n === null)
        o = !0;
    else
        switch (s) {
        case "string":
        case "number":
            o = !0;
            break;
        case "object":
            switch (n.$$typeof) {
            case Xd:
            case nF:
                o = !0
            }
        }
    if (o)
        return o = n,
        r = r(o),
        n = i === "" ? "." + ay(o, 0) : i,
        Lb(r) ? (t = "",
        n != null && (t = n.replace(Db, "$&/") + "/"),
        Vm(r, e, t, "", function(c) {
            return c
        })) : r != null && (xA(r) && (r = hF(r, t + (!r.key || o && o.key === r.key ? "" : ("" + r.key).replace(Db, "$&/") + "/") + n)),
        e.push(r)),
        1;
    if (o = 0,
    i = i === "" ? "." : i + ":",
    Lb(n))
        for (var a = 0; a < n.length; a++) {
            s = n[a];
            var l = i + ay(s, a);
            o += Vm(s, e, t, l, r)
        }
    else if (l = dF(n),
    typeof l == "function")
        for (n = l.call(n),
        a = 0; !(s = n.next()).done; )
            s = s.value,
            l = i + ay(s, a++),
            o += Vm(s, e, t, l, r);
    else if (s === "object")
        throw e = String(n),
        Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(n).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
    return o
}
function Sp(n, e, t) {
    if (n == null)
        return n;
    var i = []
      , r = 0;
    return Vm(n, i, "", "", function(s) {
        return e.call(t, s, r++)
    }),
    i
}
function mF(n) {
    if (n._status === -1) {
        var e = n._result;
        e = e(),
        e.then(function(t) {
            (n._status === 0 || n._status === -1) && (n._status = 1,
            n._result = t)
        }, function(t) {
            (n._status === 0 || n._status === -1) && (n._status = 2,
            n._result = t)
        }),
        n._status === -1 && (n._status = 0,
        n._result = e)
    }
    if (n._status === 1)
        return n._result.default;
    throw n._result
}
var xi = {
    current: null
}
  , Wm = {
    transition: null
}
  , gF = {
    ReactCurrentDispatcher: xi,
    ReactCurrentBatchConfig: Wm,
    ReactCurrentOwner: yA
};
bt.Children = {
    map: Sp,
    forEach: function(n, e, t) {
        Sp(n, function() {
            e.apply(this, arguments)
        }, t)
    },
    count: function(n) {
        var e = 0;
        return Sp(n, function() {
            e++
        }),
        e
    },
    toArray: function(n) {
        return Sp(n, function(e) {
            return e
        }) || []
    },
    only: function(n) {
        if (!xA(n))
            throw Error("React.Children.only expected to receive a single React element child.");
        return n
    }
};
bt.Component = gc;
bt.Fragment = iF;
bt.Profiler = sF;
bt.PureComponent = gA;
bt.StrictMode = rF;
bt.Suspense = uF;
bt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = gF;
bt.cloneElement = function(n, e, t) {
    if (n == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + n + ".");
    var i = EP({}, n.props)
      , r = n.key
      , s = n.ref
      , o = n._owner;
    if (e != null) {
        if (e.ref !== void 0 && (s = e.ref,
        o = yA.current),
        e.key !== void 0 && (r = "" + e.key),
        n.type && n.type.defaultProps)
            var a = n.type.defaultProps;
        for (l in e)
            BP.call(e, l) && !RP.hasOwnProperty(l) && (i[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l])
    }
    var l = arguments.length - 2;
    if (l === 1)
        i.children = t;
    else if (1 < l) {
        a = Array(l);
        for (var c = 0; c < l; c++)
            a[c] = arguments[c + 2];
        i.children = a
    }
    return {
        $$typeof: Xd,
        type: n.type,
        key: r,
        ref: s,
        props: i,
        _owner: o
    }
}
;
bt.createContext = function(n) {
    return n = {
        $$typeof: aF,
        _currentValue: n,
        _currentValue2: n,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
    n.Provider = {
        $$typeof: oF,
        _context: n
    },
    n.Consumer = n
}
;
bt.createElement = IP;
bt.createFactory = function(n) {
    var e = IP.bind(null, n);
    return e.type = n,
    e
}
;
bt.createRef = function() {
    return {
        current: null
    }
}
;
bt.forwardRef = function(n) {
    return {
        $$typeof: lF,
        render: n
    }
}
;
bt.isValidElement = xA;
bt.lazy = function(n) {
    return {
        $$typeof: fF,
        _payload: {
            _status: -1,
            _result: n
        },
        _init: mF
    }
}
;
bt.memo = function(n, e) {
    return {
        $$typeof: cF,
        type: n,
        compare: e === void 0 ? null : e
    }
}
;
bt.startTransition = function(n) {
    var e = Wm.transition;
    Wm.transition = {};
    try {
        n()
    } finally {
        Wm.transition = e
    }
}
;
bt.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.")
}
;
bt.useCallback = function(n, e) {
    return xi.current.useCallback(n, e)
}
;
bt.useContext = function(n) {
    return xi.current.useContext(n)
}
;
bt.useDebugValue = function() {}
;
bt.useDeferredValue = function(n) {
    return xi.current.useDeferredValue(n)
}
;
bt.useEffect = function(n, e) {
    return xi.current.useEffect(n, e)
}
;
bt.useId = function() {
    return xi.current.useId()
}
;
bt.useImperativeHandle = function(n, e, t) {
    return xi.current.useImperativeHandle(n, e, t)
}
;
bt.useInsertionEffect = function(n, e) {
    return xi.current.useInsertionEffect(n, e)
}
;
bt.useLayoutEffect = function(n, e) {
    return xi.current.useLayoutEffect(n, e)
}
;
bt.useMemo = function(n, e) {
    return xi.current.useMemo(n, e)
}
;
bt.useReducer = function(n, e, t) {
    return xi.current.useReducer(n, e, t)
}
;
bt.useRef = function(n) {
    return xi.current.useRef(n)
}
;
bt.useState = function(n) {
    return xi.current.useState(n)
}
;
bt.useSyncExternalStore = function(n, e, t) {
    return xi.current.useSyncExternalStore(n, e, t)
}
;
bt.useTransition = function() {
    return xi.current.useTransition()
}
;
bt.version = "18.2.0";
(function(n) {
    n.exports = bt
}
)(tF);
const vc = bP(U)
  , Vx = qk({
    __proto__: null,
    default: vc
}, [U]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var vF = U
  , yF = Symbol.for("react.element")
  , xF = Symbol.for("react.fragment")
  , _F = Object.prototype.hasOwnProperty
  , AF = vF.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
  , wF = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function LP(n, e, t) {
    var i, r = {}, s = null, o = null;
    t !== void 0 && (s = "" + t),
    e.key !== void 0 && (s = "" + e.key),
    e.ref !== void 0 && (o = e.ref);
    for (i in e)
        _F.call(e, i) && !wF.hasOwnProperty(i) && (r[i] = e[i]);
    if (n && n.defaultProps)
        for (i in e = n.defaultProps,
        e)
            r[i] === void 0 && (r[i] = e[i]);
    return {
        $$typeof: yF,
        type: n,
        key: s,
        ref: o,
        props: r,
        _owner: AF.current
    }
}
r0.Fragment = xF;
r0.jsx = LP;
r0.jsxs = LP;
(function(n) {
    n.exports = r0
}
)(eF);
const _A = nd.Fragment
  , he = nd.jsx
  , it = nd.jsxs;
var Wx = {}
  , pg = {}
  , SF = {
    get exports() {
        return pg
    },
    set exports(n) {
        pg = n
    }
}
  , Zi = {}
  , jx = {}
  , MF = {
    get exports() {
        return jx
    },
    set exports(n) {
        jx = n
    }
}
  , DP = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(n) {
    function e(F, V) {
        var Y = F.length;
        F.push(V);
        e: for (; 0 < Y; ) {
            var re = Y - 1 >>> 1
              , j = F[re];
            if (0 < r(j, V))
                F[re] = V,
                F[Y] = j,
                Y = re;
            else
                break e
        }
    }
    function t(F) {
        return F.length === 0 ? null : F[0]
    }
    function i(F) {
        if (F.length === 0)
            return null;
        var V = F[0]
          , Y = F.pop();
        if (Y !== V) {
            F[0] = Y;
            e: for (var re = 0, j = F.length, ie = j >>> 1; re < ie; ) {
                var ye = 2 * (re + 1) - 1
                  , _e = F[ye]
                  , $ = ye + 1
                  , Ne = F[$];
                if (0 > r(_e, Y))
                    $ < j && 0 > r(Ne, _e) ? (F[re] = Ne,
                    F[$] = Y,
                    re = $) : (F[re] = _e,
                    F[ye] = Y,
                    re = ye);
                else if ($ < j && 0 > r(Ne, Y))
                    F[re] = Ne,
                    F[$] = Y,
                    re = $;
                else
                    break e
            }
        }
        return V
    }
    function r(F, V) {
        var Y = F.sortIndex - V.sortIndex;
        return Y !== 0 ? Y : F.id - V.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var s = performance;
        n.unstable_now = function() {
            return s.now()
        }
    } else {
        var o = Date
          , a = o.now();
        n.unstable_now = function() {
            return o.now() - a
        }
    }
    var l = []
      , c = []
      , d = 1
      , h = null
      , p = 3
      , m = !1
      , y = !1
      , v = !1
      , x = typeof setTimeout == "function" ? setTimeout : null
      , _ = typeof clearTimeout == "function" ? clearTimeout : null
      , A = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function w(F) {
        for (var V = t(c); V !== null; ) {
            if (V.callback === null)
                i(c);
            else if (V.startTime <= F)
                i(c),
                V.sortIndex = V.expirationTime,
                e(l, V);
            else
                break;
            V = t(c)
        }
    }
    function M(F) {
        if (v = !1,
        w(F),
        !y)
            if (t(l) !== null)
                y = !0,
                ne(C);
            else {
                var V = t(c);
                V !== null && oe(M, V.startTime - F)
            }
    }
    function C(F, V) {
        y = !1,
        v && (v = !1,
        _(E),
        E = -1),
        m = !0;
        var Y = p;
        try {
            for (w(V),
            h = t(l); h !== null && (!(h.expirationTime > V) || F && !z()); ) {
                var re = h.callback;
                if (typeof re == "function") {
                    h.callback = null,
                    p = h.priorityLevel;
                    var j = re(h.expirationTime <= V);
                    V = n.unstable_now(),
                    typeof j == "function" ? h.callback = j : h === t(l) && i(l),
                    w(V)
                } else
                    i(l);
                h = t(l)
            }
            if (h !== null)
                var ie = !0;
            else {
                var ye = t(c);
                ye !== null && oe(M, ye.startTime - V),
                ie = !1
            }
            return ie
        } finally {
            h = null,
            p = Y,
            m = !1
        }
    }
    var P = !1
      , R = null
      , E = -1
      , B = 5
      , I = -1;
    function z() {
        return !(n.unstable_now() - I < B)
    }
    function q() {
        if (R !== null) {
            var F = n.unstable_now();
            I = F;
            var V = !0;
            try {
                V = R(!0, F)
            } finally {
                V ? W() : (P = !1,
                R = null)
            }
        } else
            P = !1
    }
    var W;
    if (typeof A == "function")
        W = function() {
            A(q)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var G = new MessageChannel
          , K = G.port2;
        G.port1.onmessage = q,
        W = function() {
            K.postMessage(null)
        }
    } else
        W = function() {
            x(q, 0)
        }
        ;
    function ne(F) {
        R = F,
        P || (P = !0,
        W())
    }
    function oe(F, V) {
        E = x(function() {
            F(n.unstable_now())
        }, V)
    }
    n.unstable_IdlePriority = 5,
    n.unstable_ImmediatePriority = 1,
    n.unstable_LowPriority = 4,
    n.unstable_NormalPriority = 3,
    n.unstable_Profiling = null,
    n.unstable_UserBlockingPriority = 2,
    n.unstable_cancelCallback = function(F) {
        F.callback = null
    }
    ,
    n.unstable_continueExecution = function() {
        y || m || (y = !0,
        ne(C))
    }
    ,
    n.unstable_forceFrameRate = function(F) {
        0 > F || 125 < F ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : B = 0 < F ? Math.floor(1e3 / F) : 5
    }
    ,
    n.unstable_getCurrentPriorityLevel = function() {
        return p
    }
    ,
    n.unstable_getFirstCallbackNode = function() {
        return t(l)
    }
    ,
    n.unstable_next = function(F) {
        switch (p) {
        case 1:
        case 2:
        case 3:
            var V = 3;
            break;
        default:
            V = p
        }
        var Y = p;
        p = V;
        try {
            return F()
        } finally {
            p = Y
        }
    }
    ,
    n.unstable_pauseExecution = function() {}
    ,
    n.unstable_requestPaint = function() {}
    ,
    n.unstable_runWithPriority = function(F, V) {
        switch (F) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            F = 3
        }
        var Y = p;
        p = F;
        try {
            return V()
        } finally {
            p = Y
        }
    }
    ,
    n.unstable_scheduleCallback = function(F, V, Y) {
        var re = n.unstable_now();
        switch (typeof Y == "object" && Y !== null ? (Y = Y.delay,
        Y = typeof Y == "number" && 0 < Y ? re + Y : re) : Y = re,
        F) {
        case 1:
            var j = -1;
            break;
        case 2:
            j = 250;
            break;
        case 5:
            j = 1073741823;
            break;
        case 4:
            j = 1e4;
            break;
        default:
            j = 5e3
        }
        return j = Y + j,
        F = {
            id: d++,
            callback: V,
            priorityLevel: F,
            startTime: Y,
            expirationTime: j,
            sortIndex: -1
        },
        Y > re ? (F.sortIndex = Y,
        e(c, F),
        t(l) === null && F === t(c) && (v ? (_(E),
        E = -1) : v = !0,
        oe(M, Y - re))) : (F.sortIndex = j,
        e(l, F),
        y || m || (y = !0,
        ne(C))),
        F
    }
    ,
    n.unstable_shouldYield = z,
    n.unstable_wrapCallback = function(F) {
        var V = p;
        return function() {
            var Y = p;
            p = V;
            try {
                return F.apply(this, arguments)
            } finally {
                p = Y
            }
        }
    }
}
)(DP);
(function(n) {
    n.exports = DP
}
)(MF);
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var kP = U
  , Xi = jx;
function Me(n) {
    for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, t = 1; t < arguments.length; t++)
        e += "&args[]=" + encodeURIComponent(arguments[t]);
    return "Minified React error #" + n + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var FP = new Set
  , id = {};
function El(n, e) {
    Ku(n, e),
    Ku(n + "Capture", e)
}
function Ku(n, e) {
    for (id[n] = e,
    n = 0; n < e.length; n++)
        FP.add(e[n])
}
var Ys = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
  , Jx = Object.prototype.hasOwnProperty
  , bF = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
  , kb = {}
  , Fb = {};
function CF(n) {
    return Jx.call(Fb, n) ? !0 : Jx.call(kb, n) ? !1 : bF.test(n) ? Fb[n] = !0 : (kb[n] = !0,
    !1)
}
function EF(n, e, t, i) {
    if (t !== null && t.type === 0)
        return !1;
    switch (typeof e) {
    case "function":
    case "symbol":
        return !0;
    case "boolean":
        return i ? !1 : t !== null ? !t.acceptsBooleans : (n = n.toLowerCase().slice(0, 5),
        n !== "data-" && n !== "aria-");
    default:
        return !1
    }
}
function TF(n, e, t, i) {
    if (e === null || typeof e > "u" || EF(n, e, t, i))
        return !0;
    if (i)
        return !1;
    if (t !== null)
        switch (t.type) {
        case 3:
            return !e;
        case 4:
            return e === !1;
        case 5:
            return isNaN(e);
        case 6:
            return isNaN(e) || 1 > e
        }
    return !1
}
function _i(n, e, t, i, r, s, o) {
    this.acceptsBooleans = e === 2 || e === 3 || e === 4,
    this.attributeName = i,
    this.attributeNamespace = r,
    this.mustUseProperty = t,
    this.propertyName = n,
    this.type = e,
    this.sanitizeURL = s,
    this.removeEmptyString = o
}
var Zn = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(n) {
    Zn[n] = new _i(n,0,!1,n,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(n) {
    var e = n[0];
    Zn[e] = new _i(e,1,!1,n[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(n) {
    Zn[n] = new _i(n,2,!1,n.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(n) {
    Zn[n] = new _i(n,2,!1,n,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(n) {
    Zn[n] = new _i(n,3,!1,n.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(n) {
    Zn[n] = new _i(n,3,!0,n,null,!1,!1)
});
["capture", "download"].forEach(function(n) {
    Zn[n] = new _i(n,4,!1,n,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(n) {
    Zn[n] = new _i(n,6,!1,n,null,!1,!1)
});
["rowSpan", "start"].forEach(function(n) {
    Zn[n] = new _i(n,5,!1,n.toLowerCase(),null,!1,!1)
});
var AA = /[\-:]([a-z])/g;
function wA(n) {
    return n[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(n) {
    var e = n.replace(AA, wA);
    Zn[e] = new _i(e,1,!1,n,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(n) {
    var e = n.replace(AA, wA);
    Zn[e] = new _i(e,1,!1,n,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(n) {
    var e = n.replace(AA, wA);
    Zn[e] = new _i(e,1,!1,n,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(n) {
    Zn[n] = new _i(n,1,!1,n.toLowerCase(),null,!1,!1)
});
Zn.xlinkHref = new _i("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(n) {
    Zn[n] = new _i(n,1,!1,n.toLowerCase(),null,!0,!0)
});
function SA(n, e, t, i) {
    var r = Zn.hasOwnProperty(e) ? Zn[e] : null;
    (r !== null ? r.type !== 0 : i || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (TF(e, t, r, i) && (t = null),
    i || r === null ? CF(e) && (t === null ? n.removeAttribute(e) : n.setAttribute(e, "" + t)) : r.mustUseProperty ? n[r.propertyName] = t === null ? r.type === 3 ? !1 : "" : t : (e = r.attributeName,
    i = r.attributeNamespace,
    t === null ? n.removeAttribute(e) : (r = r.type,
    t = r === 3 || r === 4 && t === !0 ? "" : "" + t,
    i ? n.setAttributeNS(i, e, t) : n.setAttribute(e, t))))
}
var ro = kP.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , Mp = Symbol.for("react.element")
  , vu = Symbol.for("react.portal")
  , yu = Symbol.for("react.fragment")
  , MA = Symbol.for("react.strict_mode")
  , Xx = Symbol.for("react.profiler")
  , NP = Symbol.for("react.provider")
  , OP = Symbol.for("react.context")
  , bA = Symbol.for("react.forward_ref")
  , Yx = Symbol.for("react.suspense")
  , Kx = Symbol.for("react.suspense_list")
  , CA = Symbol.for("react.memo")
  , Po = Symbol.for("react.lazy")
  , UP = Symbol.for("react.offscreen")
  , Nb = Symbol.iterator;
function Zc(n) {
    return n === null || typeof n != "object" ? null : (n = Nb && n[Nb] || n["@@iterator"],
    typeof n == "function" ? n : null)
}
var cn = Object.assign, ly;
function Tf(n) {
    if (ly === void 0)
        try {
            throw Error()
        } catch (t) {
            var e = t.stack.trim().match(/\n( *(at )?)/);
            ly = e && e[1] || ""
        }
    return `
` + ly + n
}
var uy = !1;
function cy(n, e) {
    if (!n || uy)
        return "";
    uy = !0;
    var t = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (e)
            if (e = function() {
                throw Error()
            }
            ,
            Object.defineProperty(e.prototype, "props", {
                set: function() {
                    throw Error()
                }
            }),
            typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(e, [])
                } catch (c) {
                    var i = c
                }
                Reflect.construct(n, [], e)
            } else {
                try {
                    e.call()
                } catch (c) {
                    i = c
                }
                n.call(e.prototype)
            }
        else {
            try {
                throw Error()
            } catch (c) {
                i = c
            }
            n()
        }
    } catch (c) {
        if (c && i && typeof c.stack == "string") {
            for (var r = c.stack.split(`
`), s = i.stack.split(`
`), o = r.length - 1, a = s.length - 1; 1 <= o && 0 <= a && r[o] !== s[a]; )
                a--;
            for (; 1 <= o && 0 <= a; o--,
            a--)
                if (r[o] !== s[a]) {
                    if (o !== 1 || a !== 1)
                        do
                            if (o--,
                            a--,
                            0 > a || r[o] !== s[a]) {
                                var l = `
` + r[o].replace(" at new ", " at ");
                                return n.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", n.displayName)),
                                l
                            }
                        while (1 <= o && 0 <= a);
                    break
                }
        }
    } finally {
        uy = !1,
        Error.prepareStackTrace = t
    }
    return (n = n ? n.displayName || n.name : "") ? Tf(n) : ""
}
function PF(n) {
    switch (n.tag) {
    case 5:
        return Tf(n.type);
    case 16:
        return Tf("Lazy");
    case 13:
        return Tf("Suspense");
    case 19:
        return Tf("SuspenseList");
    case 0:
    case 2:
    case 15:
        return n = cy(n.type, !1),
        n;
    case 11:
        return n = cy(n.type.render, !1),
        n;
    case 1:
        return n = cy(n.type, !0),
        n;
    default:
        return ""
    }
}
function Qx(n) {
    if (n == null)
        return null;
    if (typeof n == "function")
        return n.displayName || n.name || null;
    if (typeof n == "string")
        return n;
    switch (n) {
    case yu:
        return "Fragment";
    case vu:
        return "Portal";
    case Xx:
        return "Profiler";
    case MA:
        return "StrictMode";
    case Yx:
        return "Suspense";
    case Kx:
        return "SuspenseList"
    }
    if (typeof n == "object")
        switch (n.$$typeof) {
        case OP:
            return (n.displayName || "Context") + ".Consumer";
        case NP:
            return (n._context.displayName || "Context") + ".Provider";
        case bA:
            var e = n.render;
            return n = n.displayName,
            n || (n = e.displayName || e.name || "",
            n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"),
            n;
        case CA:
            return e = n.displayName || null,
            e !== null ? e : Qx(n.type) || "Memo";
        case Po:
            e = n._payload,
            n = n._init;
            try {
                return Qx(n(e))
            } catch {}
        }
    return null
}
function BF(n) {
    var e = n.type;
    switch (n.tag) {
    case 24:
        return "Cache";
    case 9:
        return (e.displayName || "Context") + ".Consumer";
    case 10:
        return (e._context.displayName || "Context") + ".Provider";
    case 18:
        return "DehydratedFragment";
    case 11:
        return n = e.render,
        n = n.displayName || n.name || "",
        e.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef");
    case 7:
        return "Fragment";
    case 5:
        return e;
    case 4:
        return "Portal";
    case 3:
        return "Root";
    case 6:
        return "Text";
    case 16:
        return Qx(e);
    case 8:
        return e === MA ? "StrictMode" : "Mode";
    case 22:
        return "Offscreen";
    case 12:
        return "Profiler";
    case 21:
        return "Scope";
    case 13:
        return "Suspense";
    case 19:
        return "SuspenseList";
    case 25:
        return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof e == "function")
            return e.displayName || e.name || null;
        if (typeof e == "string")
            return e
    }
    return null
}
function qo(n) {
    switch (typeof n) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return n;
    case "object":
        return n;
    default:
        return ""
    }
}
function zP(n) {
    var e = n.type;
    return (n = n.nodeName) && n.toLowerCase() === "input" && (e === "checkbox" || e === "radio")
}
function RF(n) {
    var e = zP(n) ? "checked" : "value"
      , t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e)
      , i = "" + n[e];
    if (!n.hasOwnProperty(e) && typeof t < "u" && typeof t.get == "function" && typeof t.set == "function") {
        var r = t.get
          , s = t.set;
        return Object.defineProperty(n, e, {
            configurable: !0,
            get: function() {
                return r.call(this)
            },
            set: function(o) {
                i = "" + o,
                s.call(this, o)
            }
        }),
        Object.defineProperty(n, e, {
            enumerable: t.enumerable
        }),
        {
            getValue: function() {
                return i
            },
            setValue: function(o) {
                i = "" + o
            },
            stopTracking: function() {
                n._valueTracker = null,
                delete n[e]
            }
        }
    }
}
function bp(n) {
    n._valueTracker || (n._valueTracker = RF(n))
}
function GP(n) {
    if (!n)
        return !1;
    var e = n._valueTracker;
    if (!e)
        return !0;
    var t = e.getValue()
      , i = "";
    return n && (i = zP(n) ? n.checked ? "true" : "false" : n.value),
    n = i,
    n !== t ? (e.setValue(n),
    !0) : !1
}
function mg(n) {
    if (n = n || (typeof document < "u" ? document : void 0),
    typeof n > "u")
        return null;
    try {
        return n.activeElement || n.body
    } catch {
        return n.body
    }
}
function Zx(n, e) {
    var t = e.checked;
    return cn({}, e, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: t ?? n._wrapperState.initialChecked
    })
}
function Ob(n, e) {
    var t = e.defaultValue == null ? "" : e.defaultValue
      , i = e.checked != null ? e.checked : e.defaultChecked;
    t = qo(e.value != null ? e.value : t),
    n._wrapperState = {
        initialChecked: i,
        initialValue: t,
        controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null
    }
}
function HP(n, e) {
    e = e.checked,
    e != null && SA(n, "checked", e, !1)
}
function qx(n, e) {
    HP(n, e);
    var t = qo(e.value)
      , i = e.type;
    if (t != null)
        i === "number" ? (t === 0 && n.value === "" || n.value != t) && (n.value = "" + t) : n.value !== "" + t && (n.value = "" + t);
    else if (i === "submit" || i === "reset") {
        n.removeAttribute("value");
        return
    }
    e.hasOwnProperty("value") ? $x(n, e.type, t) : e.hasOwnProperty("defaultValue") && $x(n, e.type, qo(e.defaultValue)),
    e.checked == null && e.defaultChecked != null && (n.defaultChecked = !!e.defaultChecked)
}
function Ub(n, e, t) {
    if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
        var i = e.type;
        if (!(i !== "submit" && i !== "reset" || e.value !== void 0 && e.value !== null))
            return;
        e = "" + n._wrapperState.initialValue,
        t || e === n.value || (n.value = e),
        n.defaultValue = e
    }
    t = n.name,
    t !== "" && (n.name = ""),
    n.defaultChecked = !!n._wrapperState.initialChecked,
    t !== "" && (n.name = t)
}
function $x(n, e, t) {
    (e !== "number" || mg(n.ownerDocument) !== n) && (t == null ? n.defaultValue = "" + n._wrapperState.initialValue : n.defaultValue !== "" + t && (n.defaultValue = "" + t))
}
var Pf = Array.isArray;
function Uu(n, e, t, i) {
    if (n = n.options,
    e) {
        e = {};
        for (var r = 0; r < t.length; r++)
            e["$" + t[r]] = !0;
        for (t = 0; t < n.length; t++)
            r = e.hasOwnProperty("$" + n[t].value),
            n[t].selected !== r && (n[t].selected = r),
            r && i && (n[t].defaultSelected = !0)
    } else {
        for (t = "" + qo(t),
        e = null,
        r = 0; r < n.length; r++) {
            if (n[r].value === t) {
                n[r].selected = !0,
                i && (n[r].defaultSelected = !0);
                return
            }
            e !== null || n[r].disabled || (e = n[r])
        }
        e !== null && (e.selected = !0)
    }
}
function e1(n, e) {
    if (e.dangerouslySetInnerHTML != null)
        throw Error(Me(91));
    return cn({}, e, {
        value: void 0,
        defaultValue: void 0,
        children: "" + n._wrapperState.initialValue
    })
}
function zb(n, e) {
    var t = e.value;
    if (t == null) {
        if (t = e.children,
        e = e.defaultValue,
        t != null) {
            if (e != null)
                throw Error(Me(92));
            if (Pf(t)) {
                if (1 < t.length)
                    throw Error(Me(93));
                t = t[0]
            }
            e = t
        }
        e == null && (e = ""),
        t = e
    }
    n._wrapperState = {
        initialValue: qo(t)
    }
}
function VP(n, e) {
    var t = qo(e.value)
      , i = qo(e.defaultValue);
    t != null && (t = "" + t,
    t !== n.value && (n.value = t),
    e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)),
    i != null && (n.defaultValue = "" + i)
}
function Gb(n) {
    var e = n.textContent;
    e === n._wrapperState.initialValue && e !== "" && e !== null && (n.value = e)
}
function WP(n) {
    switch (n) {
    case "svg":
        return "http://www.w3.org/2000/svg";
    case "math":
        return "http://www.w3.org/1998/Math/MathML";
    default:
        return "http://www.w3.org/1999/xhtml"
    }
}
function t1(n, e) {
    return n == null || n === "http://www.w3.org/1999/xhtml" ? WP(e) : n === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : n
}
var Cp, jP = function(n) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(e, t, i, r) {
        MSApp.execUnsafeLocalFunction(function() {
            return n(e, t, i, r)
        })
    }
    : n
}(function(n, e) {
    if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in n)
        n.innerHTML = e;
    else {
        for (Cp = Cp || document.createElement("div"),
        Cp.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
        e = Cp.firstChild; n.firstChild; )
            n.removeChild(n.firstChild);
        for (; e.firstChild; )
            n.appendChild(e.firstChild)
    }
});
function rd(n, e) {
    if (e) {
        var t = n.firstChild;
        if (t && t === n.lastChild && t.nodeType === 3) {
            t.nodeValue = e;
            return
        }
    }
    n.textContent = e
}
var kf = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , IF = ["Webkit", "ms", "Moz", "O"];
Object.keys(kf).forEach(function(n) {
    IF.forEach(function(e) {
        e = e + n.charAt(0).toUpperCase() + n.substring(1),
        kf[e] = kf[n]
    })
});
function JP(n, e, t) {
    return e == null || typeof e == "boolean" || e === "" ? "" : t || typeof e != "number" || e === 0 || kf.hasOwnProperty(n) && kf[n] ? ("" + e).trim() : e + "px"
}
function XP(n, e) {
    n = n.style;
    for (var t in e)
        if (e.hasOwnProperty(t)) {
            var i = t.indexOf("--") === 0
              , r = JP(t, e[t], i);
            t === "float" && (t = "cssFloat"),
            i ? n.setProperty(t, r) : n[t] = r
        }
}
var LF = cn({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function n1(n, e) {
    if (e) {
        if (LF[n] && (e.children != null || e.dangerouslySetInnerHTML != null))
            throw Error(Me(137, n));
        if (e.dangerouslySetInnerHTML != null) {
            if (e.children != null)
                throw Error(Me(60));
            if (typeof e.dangerouslySetInnerHTML != "object" || !("__html"in e.dangerouslySetInnerHTML))
                throw Error(Me(61))
        }
        if (e.style != null && typeof e.style != "object")
            throw Error(Me(62))
    }
}
function i1(n, e) {
    if (n.indexOf("-") === -1)
        return typeof e.is == "string";
    switch (n) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var r1 = null;
function EA(n) {
    return n = n.target || n.srcElement || window,
    n.correspondingUseElement && (n = n.correspondingUseElement),
    n.nodeType === 3 ? n.parentNode : n
}
var s1 = null
  , zu = null
  , Gu = null;
function Hb(n) {
    if (n = Qd(n)) {
        if (typeof s1 != "function")
            throw Error(Me(280));
        var e = n.stateNode;
        e && (e = u0(e),
        s1(n.stateNode, n.type, e))
    }
}
function YP(n) {
    zu ? Gu ? Gu.push(n) : Gu = [n] : zu = n
}
function KP() {
    if (zu) {
        var n = zu
          , e = Gu;
        if (Gu = zu = null,
        Hb(n),
        e)
            for (n = 0; n < e.length; n++)
                Hb(e[n])
    }
}
function QP(n, e) {
    return n(e)
}
function ZP() {}
var fy = !1;
function qP(n, e, t) {
    if (fy)
        return n(e, t);
    fy = !0;
    try {
        return QP(n, e, t)
    } finally {
        fy = !1,
        (zu !== null || Gu !== null) && (ZP(),
        KP())
    }
}
function sd(n, e) {
    var t = n.stateNode;
    if (t === null)
        return null;
    var i = u0(t);
    if (i === null)
        return null;
    t = i[e];
    e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (i = !i.disabled) || (n = n.type,
        i = !(n === "button" || n === "input" || n === "select" || n === "textarea")),
        n = !i;
        break e;
    default:
        n = !1
    }
    if (n)
        return null;
    if (t && typeof t != "function")
        throw Error(Me(231, e, typeof t));
    return t
}
var o1 = !1;
if (Ys)
    try {
        var qc = {};
        Object.defineProperty(qc, "passive", {
            get: function() {
                o1 = !0
            }
        }),
        window.addEventListener("test", qc, qc),
        window.removeEventListener("test", qc, qc)
    } catch {
        o1 = !1
    }
function DF(n, e, t, i, r, s, o, a, l) {
    var c = Array.prototype.slice.call(arguments, 3);
    try {
        e.apply(t, c)
    } catch (d) {
        this.onError(d)
    }
}
var Ff = !1
  , gg = null
  , vg = !1
  , a1 = null
  , kF = {
    onError: function(n) {
        Ff = !0,
        gg = n
    }
};
function FF(n, e, t, i, r, s, o, a, l) {
    Ff = !1,
    gg = null,
    DF.apply(kF, arguments)
}
function NF(n, e, t, i, r, s, o, a, l) {
    if (FF.apply(this, arguments),
    Ff) {
        if (Ff) {
            var c = gg;
            Ff = !1,
            gg = null
        } else
            throw Error(Me(198));
        vg || (vg = !0,
        a1 = c)
    }
}
function Tl(n) {
    var e = n
      , t = n;
    if (n.alternate)
        for (; e.return; )
            e = e.return;
    else {
        n = e;
        do
            e = n,
            e.flags & 4098 && (t = e.return),
            n = e.return;
        while (n)
    }
    return e.tag === 3 ? t : null
}
function $P(n) {
    if (n.tag === 13) {
        var e = n.memoizedState;
        if (e === null && (n = n.alternate,
        n !== null && (e = n.memoizedState)),
        e !== null)
            return e.dehydrated
    }
    return null
}
function Vb(n) {
    if (Tl(n) !== n)
        throw Error(Me(188))
}
function OF(n) {
    var e = n.alternate;
    if (!e) {
        if (e = Tl(n),
        e === null)
            throw Error(Me(188));
        return e !== n ? null : n
    }
    for (var t = n, i = e; ; ) {
        var r = t.return;
        if (r === null)
            break;
        var s = r.alternate;
        if (s === null) {
            if (i = r.return,
            i !== null) {
                t = i;
                continue
            }
            break
        }
        if (r.child === s.child) {
            for (s = r.child; s; ) {
                if (s === t)
                    return Vb(r),
                    n;
                if (s === i)
                    return Vb(r),
                    e;
                s = s.sibling
            }
            throw Error(Me(188))
        }
        if (t.return !== i.return)
            t = r,
            i = s;
        else {
            for (var o = !1, a = r.child; a; ) {
                if (a === t) {
                    o = !0,
                    t = r,
                    i = s;
                    break
                }
                if (a === i) {
                    o = !0,
                    i = r,
                    t = s;
                    break
                }
                a = a.sibling
            }
            if (!o) {
                for (a = s.child; a; ) {
                    if (a === t) {
                        o = !0,
                        t = s,
                        i = r;
                        break
                    }
                    if (a === i) {
                        o = !0,
                        i = s,
                        t = r;
                        break
                    }
                    a = a.sibling
                }
                if (!o)
                    throw Error(Me(189))
            }
        }
        if (t.alternate !== i)
            throw Error(Me(190))
    }
    if (t.tag !== 3)
        throw Error(Me(188));
    return t.stateNode.current === t ? n : e
}
function e3(n) {
    return n = OF(n),
    n !== null ? t3(n) : null
}
function t3(n) {
    if (n.tag === 5 || n.tag === 6)
        return n;
    for (n = n.child; n !== null; ) {
        var e = t3(n);
        if (e !== null)
            return e;
        n = n.sibling
    }
    return null
}
var n3 = Xi.unstable_scheduleCallback
  , Wb = Xi.unstable_cancelCallback
  , UF = Xi.unstable_shouldYield
  , zF = Xi.unstable_requestPaint
  , An = Xi.unstable_now
  , GF = Xi.unstable_getCurrentPriorityLevel
  , TA = Xi.unstable_ImmediatePriority
  , i3 = Xi.unstable_UserBlockingPriority
  , yg = Xi.unstable_NormalPriority
  , HF = Xi.unstable_LowPriority
  , r3 = Xi.unstable_IdlePriority
  , s0 = null
  , ls = null;
function VF(n) {
    if (ls && typeof ls.onCommitFiberRoot == "function")
        try {
            ls.onCommitFiberRoot(s0, n, void 0, (n.current.flags & 128) === 128)
        } catch {}
}
var zr = Math.clz32 ? Math.clz32 : JF
  , WF = Math.log
  , jF = Math.LN2;
function JF(n) {
    return n >>>= 0,
    n === 0 ? 32 : 31 - (WF(n) / jF | 0) | 0
}
var Ep = 64
  , Tp = 4194304;
function Bf(n) {
    switch (n & -n) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return n & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return n & 130023424;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 1073741824;
    default:
        return n
    }
}
function xg(n, e) {
    var t = n.pendingLanes;
    if (t === 0)
        return 0;
    var i = 0
      , r = n.suspendedLanes
      , s = n.pingedLanes
      , o = t & 268435455;
    if (o !== 0) {
        var a = o & ~r;
        a !== 0 ? i = Bf(a) : (s &= o,
        s !== 0 && (i = Bf(s)))
    } else
        o = t & ~r,
        o !== 0 ? i = Bf(o) : s !== 0 && (i = Bf(s));
    if (i === 0)
        return 0;
    if (e !== 0 && e !== i && !(e & r) && (r = i & -i,
    s = e & -e,
    r >= s || r === 16 && (s & 4194240) !== 0))
        return e;
    if (i & 4 && (i |= t & 16),
    e = n.entangledLanes,
    e !== 0)
        for (n = n.entanglements,
        e &= i; 0 < e; )
            t = 31 - zr(e),
            r = 1 << t,
            i |= n[t],
            e &= ~r;
    return i
}
function XF(n, e) {
    switch (n) {
    case 1:
    case 2:
    case 4:
        return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function YF(n, e) {
    for (var t = n.suspendedLanes, i = n.pingedLanes, r = n.expirationTimes, s = n.pendingLanes; 0 < s; ) {
        var o = 31 - zr(s)
          , a = 1 << o
          , l = r[o];
        l === -1 ? (!(a & t) || a & i) && (r[o] = XF(a, e)) : l <= e && (n.expiredLanes |= a),
        s &= ~a
    }
}
function l1(n) {
    return n = n.pendingLanes & -1073741825,
    n !== 0 ? n : n & 1073741824 ? 1073741824 : 0
}
function s3() {
    var n = Ep;
    return Ep <<= 1,
    !(Ep & 4194240) && (Ep = 64),
    n
}
function dy(n) {
    for (var e = [], t = 0; 31 > t; t++)
        e.push(n);
    return e
}
function Yd(n, e, t) {
    n.pendingLanes |= e,
    e !== 536870912 && (n.suspendedLanes = 0,
    n.pingedLanes = 0),
    n = n.eventTimes,
    e = 31 - zr(e),
    n[e] = t
}
function KF(n, e) {
    var t = n.pendingLanes & ~e;
    n.pendingLanes = e,
    n.suspendedLanes = 0,
    n.pingedLanes = 0,
    n.expiredLanes &= e,
    n.mutableReadLanes &= e,
    n.entangledLanes &= e,
    e = n.entanglements;
    var i = n.eventTimes;
    for (n = n.expirationTimes; 0 < t; ) {
        var r = 31 - zr(t)
          , s = 1 << r;
        e[r] = 0,
        i[r] = -1,
        n[r] = -1,
        t &= ~s
    }
}
function PA(n, e) {
    var t = n.entangledLanes |= e;
    for (n = n.entanglements; t; ) {
        var i = 31 - zr(t)
          , r = 1 << i;
        r & e | n[i] & e && (n[i] |= e),
        t &= ~r
    }
}
var zt = 0;
function o3(n) {
    return n &= -n,
    1 < n ? 4 < n ? n & 268435455 ? 16 : 536870912 : 4 : 1
}
var a3, BA, l3, u3, c3, u1 = !1, Pp = [], Go = null, Ho = null, Vo = null, od = new Map, ad = new Map, Lo = [], QF = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function jb(n, e) {
    switch (n) {
    case "focusin":
    case "focusout":
        Go = null;
        break;
    case "dragenter":
    case "dragleave":
        Ho = null;
        break;
    case "mouseover":
    case "mouseout":
        Vo = null;
        break;
    case "pointerover":
    case "pointerout":
        od.delete(e.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        ad.delete(e.pointerId)
    }
}
function $c(n, e, t, i, r, s) {
    return n === null || n.nativeEvent !== s ? (n = {
        blockedOn: e,
        domEventName: t,
        eventSystemFlags: i,
        nativeEvent: s,
        targetContainers: [r]
    },
    e !== null && (e = Qd(e),
    e !== null && BA(e)),
    n) : (n.eventSystemFlags |= i,
    e = n.targetContainers,
    r !== null && e.indexOf(r) === -1 && e.push(r),
    n)
}
function ZF(n, e, t, i, r) {
    switch (e) {
    case "focusin":
        return Go = $c(Go, n, e, t, i, r),
        !0;
    case "dragenter":
        return Ho = $c(Ho, n, e, t, i, r),
        !0;
    case "mouseover":
        return Vo = $c(Vo, n, e, t, i, r),
        !0;
    case "pointerover":
        var s = r.pointerId;
        return od.set(s, $c(od.get(s) || null, n, e, t, i, r)),
        !0;
    case "gotpointercapture":
        return s = r.pointerId,
        ad.set(s, $c(ad.get(s) || null, n, e, t, i, r)),
        !0
    }
    return !1
}
function f3(n) {
    var e = Ka(n.target);
    if (e !== null) {
        var t = Tl(e);
        if (t !== null) {
            if (e = t.tag,
            e === 13) {
                if (e = $P(t),
                e !== null) {
                    n.blockedOn = e,
                    c3(n.priority, function() {
                        l3(t)
                    });
                    return
                }
            } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) {
                n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
                return
            }
        }
    }
    n.blockedOn = null
}
function jm(n) {
    if (n.blockedOn !== null)
        return !1;
    for (var e = n.targetContainers; 0 < e.length; ) {
        var t = c1(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent);
        if (t === null) {
            t = n.nativeEvent;
            var i = new t.constructor(t.type,t);
            r1 = i,
            t.target.dispatchEvent(i),
            r1 = null
        } else
            return e = Qd(t),
            e !== null && BA(e),
            n.blockedOn = t,
            !1;
        e.shift()
    }
    return !0
}
function Jb(n, e, t) {
    jm(n) && t.delete(e)
}
function qF() {
    u1 = !1,
    Go !== null && jm(Go) && (Go = null),
    Ho !== null && jm(Ho) && (Ho = null),
    Vo !== null && jm(Vo) && (Vo = null),
    od.forEach(Jb),
    ad.forEach(Jb)
}
function ef(n, e) {
    n.blockedOn === e && (n.blockedOn = null,
    u1 || (u1 = !0,
    Xi.unstable_scheduleCallback(Xi.unstable_NormalPriority, qF)))
}
function ld(n) {
    function e(r) {
        return ef(r, n)
    }
    if (0 < Pp.length) {
        ef(Pp[0], n);
        for (var t = 1; t < Pp.length; t++) {
            var i = Pp[t];
            i.blockedOn === n && (i.blockedOn = null)
        }
    }
    for (Go !== null && ef(Go, n),
    Ho !== null && ef(Ho, n),
    Vo !== null && ef(Vo, n),
    od.forEach(e),
    ad.forEach(e),
    t = 0; t < Lo.length; t++)
        i = Lo[t],
        i.blockedOn === n && (i.blockedOn = null);
    for (; 0 < Lo.length && (t = Lo[0],
    t.blockedOn === null); )
        f3(t),
        t.blockedOn === null && Lo.shift()
}
var Hu = ro.ReactCurrentBatchConfig
  , _g = !0;
function $F(n, e, t, i) {
    var r = zt
      , s = Hu.transition;
    Hu.transition = null;
    try {
        zt = 1,
        RA(n, e, t, i)
    } finally {
        zt = r,
        Hu.transition = s
    }
}
function eN(n, e, t, i) {
    var r = zt
      , s = Hu.transition;
    Hu.transition = null;
    try {
        zt = 4,
        RA(n, e, t, i)
    } finally {
        zt = r,
        Hu.transition = s
    }
}
function RA(n, e, t, i) {
    if (_g) {
        var r = c1(n, e, t, i);
        if (r === null)
            wy(n, e, i, Ag, t),
            jb(n, i);
        else if (ZF(r, n, e, t, i))
            i.stopPropagation();
        else if (jb(n, i),
        e & 4 && -1 < QF.indexOf(n)) {
            for (; r !== null; ) {
                var s = Qd(r);
                if (s !== null && a3(s),
                s = c1(n, e, t, i),
                s === null && wy(n, e, i, Ag, t),
                s === r)
                    break;
                r = s
            }
            r !== null && i.stopPropagation()
        } else
            wy(n, e, i, null, t)
    }
}
var Ag = null;
function c1(n, e, t, i) {
    if (Ag = null,
    n = EA(i),
    n = Ka(n),
    n !== null)
        if (e = Tl(n),
        e === null)
            n = null;
        else if (t = e.tag,
        t === 13) {
            if (n = $P(e),
            n !== null)
                return n;
            n = null
        } else if (t === 3) {
            if (e.stateNode.current.memoizedState.isDehydrated)
                return e.tag === 3 ? e.stateNode.containerInfo : null;
            n = null
        } else
            e !== n && (n = null);
    return Ag = n,
    null
}
function d3(n) {
    switch (n) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 4;
    case "message":
        switch (GF()) {
        case TA:
            return 1;
        case i3:
            return 4;
        case yg:
        case HF:
            return 16;
        case r3:
            return 536870912;
        default:
            return 16
        }
    default:
        return 16
    }
}
var ko = null
  , IA = null
  , Jm = null;
function h3() {
    if (Jm)
        return Jm;
    var n, e = IA, t = e.length, i, r = "value"in ko ? ko.value : ko.textContent, s = r.length;
    for (n = 0; n < t && e[n] === r[n]; n++)
        ;
    var o = t - n;
    for (i = 1; i <= o && e[t - i] === r[s - i]; i++)
        ;
    return Jm = r.slice(n, 1 < i ? 1 - i : void 0)
}
function Xm(n) {
    var e = n.keyCode;
    return "charCode"in n ? (n = n.charCode,
    n === 0 && e === 13 && (n = 13)) : n = e,
    n === 10 && (n = 13),
    32 <= n || n === 13 ? n : 0
}
function Bp() {
    return !0
}
function Xb() {
    return !1
}
function qi(n) {
    function e(t, i, r, s, o) {
        this._reactName = t,
        this._targetInst = r,
        this.type = i,
        this.nativeEvent = s,
        this.target = o,
        this.currentTarget = null;
        for (var a in n)
            n.hasOwnProperty(a) && (t = n[a],
            this[a] = t ? t(s) : s[a]);
        return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? Bp : Xb,
        this.isPropagationStopped = Xb,
        this
    }
    return cn(e.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var t = this.nativeEvent;
            t && (t.preventDefault ? t.preventDefault() : typeof t.returnValue != "unknown" && (t.returnValue = !1),
            this.isDefaultPrevented = Bp)
        },
        stopPropagation: function() {
            var t = this.nativeEvent;
            t && (t.stopPropagation ? t.stopPropagation() : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0),
            this.isPropagationStopped = Bp)
        },
        persist: function() {},
        isPersistent: Bp
    }),
    e
}
var yc = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(n) {
        return n.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, LA = qi(yc), Kd = cn({}, yc, {
    view: 0,
    detail: 0
}), tN = qi(Kd), hy, py, tf, o0 = cn({}, Kd, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: DA,
    button: 0,
    buttons: 0,
    relatedTarget: function(n) {
        return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget
    },
    movementX: function(n) {
        return "movementX"in n ? n.movementX : (n !== tf && (tf && n.type === "mousemove" ? (hy = n.screenX - tf.screenX,
        py = n.screenY - tf.screenY) : py = hy = 0,
        tf = n),
        hy)
    },
    movementY: function(n) {
        return "movementY"in n ? n.movementY : py
    }
}), Yb = qi(o0), nN = cn({}, o0, {
    dataTransfer: 0
}), iN = qi(nN), rN = cn({}, Kd, {
    relatedTarget: 0
}), my = qi(rN), sN = cn({}, yc, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), oN = qi(sN), aN = cn({}, yc, {
    clipboardData: function(n) {
        return "clipboardData"in n ? n.clipboardData : window.clipboardData
    }
}), lN = qi(aN), uN = cn({}, yc, {
    data: 0
}), Kb = qi(uN), cN = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, fN = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, dN = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function hN(n) {
    var e = this.nativeEvent;
    return e.getModifierState ? e.getModifierState(n) : (n = dN[n]) ? !!e[n] : !1
}
function DA() {
    return hN
}
var pN = cn({}, Kd, {
    key: function(n) {
        if (n.key) {
            var e = cN[n.key] || n.key;
            if (e !== "Unidentified")
                return e
        }
        return n.type === "keypress" ? (n = Xm(n),
        n === 13 ? "Enter" : String.fromCharCode(n)) : n.type === "keydown" || n.type === "keyup" ? fN[n.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: DA,
    charCode: function(n) {
        return n.type === "keypress" ? Xm(n) : 0
    },
    keyCode: function(n) {
        return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0
    },
    which: function(n) {
        return n.type === "keypress" ? Xm(n) : n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0
    }
})
  , mN = qi(pN)
  , gN = cn({}, o0, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , Qb = qi(gN)
  , vN = cn({}, Kd, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: DA
})
  , yN = qi(vN)
  , xN = cn({}, yc, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , _N = qi(xN)
  , AN = cn({}, o0, {
    deltaX: function(n) {
        return "deltaX"in n ? n.deltaX : "wheelDeltaX"in n ? -n.wheelDeltaX : 0
    },
    deltaY: function(n) {
        return "deltaY"in n ? n.deltaY : "wheelDeltaY"in n ? -n.wheelDeltaY : "wheelDelta"in n ? -n.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , wN = qi(AN)
  , SN = [9, 13, 27, 32]
  , kA = Ys && "CompositionEvent"in window
  , Nf = null;
Ys && "documentMode"in document && (Nf = document.documentMode);
var MN = Ys && "TextEvent"in window && !Nf
  , p3 = Ys && (!kA || Nf && 8 < Nf && 11 >= Nf)
  , Zb = String.fromCharCode(32)
  , qb = !1;
function m3(n, e) {
    switch (n) {
    case "keyup":
        return SN.indexOf(e.keyCode) !== -1;
    case "keydown":
        return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function g3(n) {
    return n = n.detail,
    typeof n == "object" && "data"in n ? n.data : null
}
var xu = !1;
function bN(n, e) {
    switch (n) {
    case "compositionend":
        return g3(e);
    case "keypress":
        return e.which !== 32 ? null : (qb = !0,
        Zb);
    case "textInput":
        return n = e.data,
        n === Zb && qb ? null : n;
    default:
        return null
    }
}
function CN(n, e) {
    if (xu)
        return n === "compositionend" || !kA && m3(n, e) ? (n = h3(),
        Jm = IA = ko = null,
        xu = !1,
        n) : null;
    switch (n) {
    case "paste":
        return null;
    case "keypress":
        if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
            if (e.char && 1 < e.char.length)
                return e.char;
            if (e.which)
                return String.fromCharCode(e.which)
        }
        return null;
    case "compositionend":
        return p3 && e.locale !== "ko" ? null : e.data;
    default:
        return null
    }
}
var EN = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function $b(n) {
    var e = n && n.nodeName && n.nodeName.toLowerCase();
    return e === "input" ? !!EN[n.type] : e === "textarea"
}
function v3(n, e, t, i) {
    YP(i),
    e = wg(e, "onChange"),
    0 < e.length && (t = new LA("onChange","change",null,t,i),
    n.push({
        event: t,
        listeners: e
    }))
}
var Of = null
  , ud = null;
function TN(n) {
    T3(n, 0)
}
function a0(n) {
    var e = wu(n);
    if (GP(e))
        return n
}
function PN(n, e) {
    if (n === "change")
        return e
}
var y3 = !1;
if (Ys) {
    var gy;
    if (Ys) {
        var vy = "oninput"in document;
        if (!vy) {
            var eC = document.createElement("div");
            eC.setAttribute("oninput", "return;"),
            vy = typeof eC.oninput == "function"
        }
        gy = vy
    } else
        gy = !1;
    y3 = gy && (!document.documentMode || 9 < document.documentMode)
}
function tC() {
    Of && (Of.detachEvent("onpropertychange", x3),
    ud = Of = null)
}
function x3(n) {
    if (n.propertyName === "value" && a0(ud)) {
        var e = [];
        v3(e, ud, n, EA(n)),
        qP(TN, e)
    }
}
function BN(n, e, t) {
    n === "focusin" ? (tC(),
    Of = e,
    ud = t,
    Of.attachEvent("onpropertychange", x3)) : n === "focusout" && tC()
}
function RN(n) {
    if (n === "selectionchange" || n === "keyup" || n === "keydown")
        return a0(ud)
}
function IN(n, e) {
    if (n === "click")
        return a0(e)
}
function LN(n, e) {
    if (n === "input" || n === "change")
        return a0(e)
}
function DN(n, e) {
    return n === e && (n !== 0 || 1 / n === 1 / e) || n !== n && e !== e
}
var Wr = typeof Object.is == "function" ? Object.is : DN;
function cd(n, e) {
    if (Wr(n, e))
        return !0;
    if (typeof n != "object" || n === null || typeof e != "object" || e === null)
        return !1;
    var t = Object.keys(n)
      , i = Object.keys(e);
    if (t.length !== i.length)
        return !1;
    for (i = 0; i < t.length; i++) {
        var r = t[i];
        if (!Jx.call(e, r) || !Wr(n[r], e[r]))
            return !1
    }
    return !0
}
function nC(n) {
    for (; n && n.firstChild; )
        n = n.firstChild;
    return n
}
function iC(n, e) {
    var t = nC(n);
    n = 0;
    for (var i; t; ) {
        if (t.nodeType === 3) {
            if (i = n + t.textContent.length,
            n <= e && i >= e)
                return {
                    node: t,
                    offset: e - n
                };
            n = i
        }
        e: {
            for (; t; ) {
                if (t.nextSibling) {
                    t = t.nextSibling;
                    break e
                }
                t = t.parentNode
            }
            t = void 0
        }
        t = nC(t)
    }
}
function _3(n, e) {
    return n && e ? n === e ? !0 : n && n.nodeType === 3 ? !1 : e && e.nodeType === 3 ? _3(n, e.parentNode) : "contains"in n ? n.contains(e) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(e) & 16) : !1 : !1
}
function A3() {
    for (var n = window, e = mg(); e instanceof n.HTMLIFrameElement; ) {
        try {
            var t = typeof e.contentWindow.location.href == "string"
        } catch {
            t = !1
        }
        if (t)
            n = e.contentWindow;
        else
            break;
        e = mg(n.document)
    }
    return e
}
function FA(n) {
    var e = n && n.nodeName && n.nodeName.toLowerCase();
    return e && (e === "input" && (n.type === "text" || n.type === "search" || n.type === "tel" || n.type === "url" || n.type === "password") || e === "textarea" || n.contentEditable === "true")
}
function kN(n) {
    var e = A3()
      , t = n.focusedElem
      , i = n.selectionRange;
    if (e !== t && t && t.ownerDocument && _3(t.ownerDocument.documentElement, t)) {
        if (i !== null && FA(t)) {
            if (e = i.start,
            n = i.end,
            n === void 0 && (n = e),
            "selectionStart"in t)
                t.selectionStart = e,
                t.selectionEnd = Math.min(n, t.value.length);
            else if (n = (e = t.ownerDocument || document) && e.defaultView || window,
            n.getSelection) {
                n = n.getSelection();
                var r = t.textContent.length
                  , s = Math.min(i.start, r);
                i = i.end === void 0 ? s : Math.min(i.end, r),
                !n.extend && s > i && (r = i,
                i = s,
                s = r),
                r = iC(t, s);
                var o = iC(t, i);
                r && o && (n.rangeCount !== 1 || n.anchorNode !== r.node || n.anchorOffset !== r.offset || n.focusNode !== o.node || n.focusOffset !== o.offset) && (e = e.createRange(),
                e.setStart(r.node, r.offset),
                n.removeAllRanges(),
                s > i ? (n.addRange(e),
                n.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset),
                n.addRange(e)))
            }
        }
        for (e = [],
        n = t; n = n.parentNode; )
            n.nodeType === 1 && e.push({
                element: n,
                left: n.scrollLeft,
                top: n.scrollTop
            });
        for (typeof t.focus == "function" && t.focus(),
        t = 0; t < e.length; t++)
            n = e[t],
            n.element.scrollLeft = n.left,
            n.element.scrollTop = n.top
    }
}
var FN = Ys && "documentMode"in document && 11 >= document.documentMode
  , _u = null
  , f1 = null
  , Uf = null
  , d1 = !1;
function rC(n, e, t) {
    var i = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;
    d1 || _u == null || _u !== mg(i) || (i = _u,
    "selectionStart"in i && FA(i) ? i = {
        start: i.selectionStart,
        end: i.selectionEnd
    } : (i = (i.ownerDocument && i.ownerDocument.defaultView || window).getSelection(),
    i = {
        anchorNode: i.anchorNode,
        anchorOffset: i.anchorOffset,
        focusNode: i.focusNode,
        focusOffset: i.focusOffset
    }),
    Uf && cd(Uf, i) || (Uf = i,
    i = wg(f1, "onSelect"),
    0 < i.length && (e = new LA("onSelect","select",null,e,t),
    n.push({
        event: e,
        listeners: i
    }),
    e.target = _u)))
}
function Rp(n, e) {
    var t = {};
    return t[n.toLowerCase()] = e.toLowerCase(),
    t["Webkit" + n] = "webkit" + e,
    t["Moz" + n] = "moz" + e,
    t
}
var Au = {
    animationend: Rp("Animation", "AnimationEnd"),
    animationiteration: Rp("Animation", "AnimationIteration"),
    animationstart: Rp("Animation", "AnimationStart"),
    transitionend: Rp("Transition", "TransitionEnd")
}
  , yy = {}
  , w3 = {};
Ys && (w3 = document.createElement("div").style,
"AnimationEvent"in window || (delete Au.animationend.animation,
delete Au.animationiteration.animation,
delete Au.animationstart.animation),
"TransitionEvent"in window || delete Au.transitionend.transition);
function l0(n) {
    if (yy[n])
        return yy[n];
    if (!Au[n])
        return n;
    var e = Au[n], t;
    for (t in e)
        if (e.hasOwnProperty(t) && t in w3)
            return yy[n] = e[t];
    return n
}
var S3 = l0("animationend")
  , M3 = l0("animationiteration")
  , b3 = l0("animationstart")
  , C3 = l0("transitionend")
  , E3 = new Map
  , sC = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ca(n, e) {
    E3.set(n, e),
    El(e, [n])
}
for (var xy = 0; xy < sC.length; xy++) {
    var _y = sC[xy]
      , NN = _y.toLowerCase()
      , ON = _y[0].toUpperCase() + _y.slice(1);
    ca(NN, "on" + ON)
}
ca(S3, "onAnimationEnd");
ca(M3, "onAnimationIteration");
ca(b3, "onAnimationStart");
ca("dblclick", "onDoubleClick");
ca("focusin", "onFocus");
ca("focusout", "onBlur");
ca(C3, "onTransitionEnd");
Ku("onMouseEnter", ["mouseout", "mouseover"]);
Ku("onMouseLeave", ["mouseout", "mouseover"]);
Ku("onPointerEnter", ["pointerout", "pointerover"]);
Ku("onPointerLeave", ["pointerout", "pointerover"]);
El("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
El("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
El("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
El("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
El("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
El("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Rf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , UN = new Set("cancel close invalid load scroll toggle".split(" ").concat(Rf));
function oC(n, e, t) {
    var i = n.type || "unknown-event";
    n.currentTarget = t,
    NF(i, e, void 0, n),
    n.currentTarget = null
}
function T3(n, e) {
    e = (e & 4) !== 0;
    for (var t = 0; t < n.length; t++) {
        var i = n[t]
          , r = i.event;
        i = i.listeners;
        e: {
            var s = void 0;
            if (e)
                for (var o = i.length - 1; 0 <= o; o--) {
                    var a = i[o]
                      , l = a.instance
                      , c = a.currentTarget;
                    if (a = a.listener,
                    l !== s && r.isPropagationStopped())
                        break e;
                    oC(r, a, c),
                    s = l
                }
            else
                for (o = 0; o < i.length; o++) {
                    if (a = i[o],
                    l = a.instance,
                    c = a.currentTarget,
                    a = a.listener,
                    l !== s && r.isPropagationStopped())
                        break e;
                    oC(r, a, c),
                    s = l
                }
        }
    }
    if (vg)
        throw n = a1,
        vg = !1,
        a1 = null,
        n
}
function Xt(n, e) {
    var t = e[v1];
    t === void 0 && (t = e[v1] = new Set);
    var i = n + "__bubble";
    t.has(i) || (P3(e, n, 2, !1),
    t.add(i))
}
function Ay(n, e, t) {
    var i = 0;
    e && (i |= 4),
    P3(t, n, i, e)
}
var Ip = "_reactListening" + Math.random().toString(36).slice(2);
function fd(n) {
    if (!n[Ip]) {
        n[Ip] = !0,
        FP.forEach(function(t) {
            t !== "selectionchange" && (UN.has(t) || Ay(t, !1, n),
            Ay(t, !0, n))
        });
        var e = n.nodeType === 9 ? n : n.ownerDocument;
        e === null || e[Ip] || (e[Ip] = !0,
        Ay("selectionchange", !1, e))
    }
}
function P3(n, e, t, i) {
    switch (d3(e)) {
    case 1:
        var r = $F;
        break;
    case 4:
        r = eN;
        break;
    default:
        r = RA
    }
    t = r.bind(null, e, t, n),
    r = void 0,
    !o1 || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (r = !0),
    i ? r !== void 0 ? n.addEventListener(e, t, {
        capture: !0,
        passive: r
    }) : n.addEventListener(e, t, !0) : r !== void 0 ? n.addEventListener(e, t, {
        passive: r
    }) : n.addEventListener(e, t, !1)
}
function wy(n, e, t, i, r) {
    var s = i;
    if (!(e & 1) && !(e & 2) && i !== null)
        e: for (; ; ) {
            if (i === null)
                return;
            var o = i.tag;
            if (o === 3 || o === 4) {
                var a = i.stateNode.containerInfo;
                if (a === r || a.nodeType === 8 && a.parentNode === r)
                    break;
                if (o === 4)
                    for (o = i.return; o !== null; ) {
                        var l = o.tag;
                        if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo,
                        l === r || l.nodeType === 8 && l.parentNode === r))
                            return;
                        o = o.return
                    }
                for (; a !== null; ) {
                    if (o = Ka(a),
                    o === null)
                        return;
                    if (l = o.tag,
                    l === 5 || l === 6) {
                        i = s = o;
                        continue e
                    }
                    a = a.parentNode
                }
            }
            i = i.return
        }
    qP(function() {
        var c = s
          , d = EA(t)
          , h = [];
        e: {
            var p = E3.get(n);
            if (p !== void 0) {
                var m = LA
                  , y = n;
                switch (n) {
                case "keypress":
                    if (Xm(t) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    m = mN;
                    break;
                case "focusin":
                    y = "focus",
                    m = my;
                    break;
                case "focusout":
                    y = "blur",
                    m = my;
                    break;
                case "beforeblur":
                case "afterblur":
                    m = my;
                    break;
                case "click":
                    if (t.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    m = Yb;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    m = iN;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    m = yN;
                    break;
                case S3:
                case M3:
                case b3:
                    m = oN;
                    break;
                case C3:
                    m = _N;
                    break;
                case "scroll":
                    m = tN;
                    break;
                case "wheel":
                    m = wN;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    m = lN;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    m = Qb
                }
                var v = (e & 4) !== 0
                  , x = !v && n === "scroll"
                  , _ = v ? p !== null ? p + "Capture" : null : p;
                v = [];
                for (var A = c, w; A !== null; ) {
                    w = A;
                    var M = w.stateNode;
                    if (w.tag === 5 && M !== null && (w = M,
                    _ !== null && (M = sd(A, _),
                    M != null && v.push(dd(A, M, w)))),
                    x)
                        break;
                    A = A.return
                }
                0 < v.length && (p = new m(p,y,null,t,d),
                h.push({
                    event: p,
                    listeners: v
                }))
            }
        }
        if (!(e & 7)) {
            e: {
                if (p = n === "mouseover" || n === "pointerover",
                m = n === "mouseout" || n === "pointerout",
                p && t !== r1 && (y = t.relatedTarget || t.fromElement) && (Ka(y) || y[Ks]))
                    break e;
                if ((m || p) && (p = d.window === d ? d : (p = d.ownerDocument) ? p.defaultView || p.parentWindow : window,
                m ? (y = t.relatedTarget || t.toElement,
                m = c,
                y = y ? Ka(y) : null,
                y !== null && (x = Tl(y),
                y !== x || y.tag !== 5 && y.tag !== 6) && (y = null)) : (m = null,
                y = c),
                m !== y)) {
                    if (v = Yb,
                    M = "onMouseLeave",
                    _ = "onMouseEnter",
                    A = "mouse",
                    (n === "pointerout" || n === "pointerover") && (v = Qb,
                    M = "onPointerLeave",
                    _ = "onPointerEnter",
                    A = "pointer"),
                    x = m == null ? p : wu(m),
                    w = y == null ? p : wu(y),
                    p = new v(M,A + "leave",m,t,d),
                    p.target = x,
                    p.relatedTarget = w,
                    M = null,
                    Ka(d) === c && (v = new v(_,A + "enter",y,t,d),
                    v.target = w,
                    v.relatedTarget = x,
                    M = v),
                    x = M,
                    m && y)
                        t: {
                            for (v = m,
                            _ = y,
                            A = 0,
                            w = v; w; w = Kl(w))
                                A++;
                            for (w = 0,
                            M = _; M; M = Kl(M))
                                w++;
                            for (; 0 < A - w; )
                                v = Kl(v),
                                A--;
                            for (; 0 < w - A; )
                                _ = Kl(_),
                                w--;
                            for (; A--; ) {
                                if (v === _ || _ !== null && v === _.alternate)
                                    break t;
                                v = Kl(v),
                                _ = Kl(_)
                            }
                            v = null
                        }
                    else
                        v = null;
                    m !== null && aC(h, p, m, v, !1),
                    y !== null && x !== null && aC(h, x, y, v, !0)
                }
            }
            e: {
                if (p = c ? wu(c) : window,
                m = p.nodeName && p.nodeName.toLowerCase(),
                m === "select" || m === "input" && p.type === "file")
                    var C = PN;
                else if ($b(p))
                    if (y3)
                        C = LN;
                    else {
                        C = RN;
                        var P = BN
                    }
                else
                    (m = p.nodeName) && m.toLowerCase() === "input" && (p.type === "checkbox" || p.type === "radio") && (C = IN);
                if (C && (C = C(n, c))) {
                    v3(h, C, t, d);
                    break e
                }
                P && P(n, p, c),
                n === "focusout" && (P = p._wrapperState) && P.controlled && p.type === "number" && $x(p, "number", p.value)
            }
            switch (P = c ? wu(c) : window,
            n) {
            case "focusin":
                ($b(P) || P.contentEditable === "true") && (_u = P,
                f1 = c,
                Uf = null);
                break;
            case "focusout":
                Uf = f1 = _u = null;
                break;
            case "mousedown":
                d1 = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                d1 = !1,
                rC(h, t, d);
                break;
            case "selectionchange":
                if (FN)
                    break;
            case "keydown":
            case "keyup":
                rC(h, t, d)
            }
            var R;
            if (kA)
                e: {
                    switch (n) {
                    case "compositionstart":
                        var E = "onCompositionStart";
                        break e;
                    case "compositionend":
                        E = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        E = "onCompositionUpdate";
                        break e
                    }
                    E = void 0
                }
            else
                xu ? m3(n, t) && (E = "onCompositionEnd") : n === "keydown" && t.keyCode === 229 && (E = "onCompositionStart");
            E && (p3 && t.locale !== "ko" && (xu || E !== "onCompositionStart" ? E === "onCompositionEnd" && xu && (R = h3()) : (ko = d,
            IA = "value"in ko ? ko.value : ko.textContent,
            xu = !0)),
            P = wg(c, E),
            0 < P.length && (E = new Kb(E,n,null,t,d),
            h.push({
                event: E,
                listeners: P
            }),
            R ? E.data = R : (R = g3(t),
            R !== null && (E.data = R)))),
            (R = MN ? bN(n, t) : CN(n, t)) && (c = wg(c, "onBeforeInput"),
            0 < c.length && (d = new Kb("onBeforeInput","beforeinput",null,t,d),
            h.push({
                event: d,
                listeners: c
            }),
            d.data = R))
        }
        T3(h, e)
    })
}
function dd(n, e, t) {
    return {
        instance: n,
        listener: e,
        currentTarget: t
    }
}
function wg(n, e) {
    for (var t = e + "Capture", i = []; n !== null; ) {
        var r = n
          , s = r.stateNode;
        r.tag === 5 && s !== null && (r = s,
        s = sd(n, t),
        s != null && i.unshift(dd(n, s, r)),
        s = sd(n, e),
        s != null && i.push(dd(n, s, r))),
        n = n.return
    }
    return i
}
function Kl(n) {
    if (n === null)
        return null;
    do
        n = n.return;
    while (n && n.tag !== 5);
    return n || null
}
function aC(n, e, t, i, r) {
    for (var s = e._reactName, o = []; t !== null && t !== i; ) {
        var a = t
          , l = a.alternate
          , c = a.stateNode;
        if (l !== null && l === i)
            break;
        a.tag === 5 && c !== null && (a = c,
        r ? (l = sd(t, s),
        l != null && o.unshift(dd(t, l, a))) : r || (l = sd(t, s),
        l != null && o.push(dd(t, l, a)))),
        t = t.return
    }
    o.length !== 0 && n.push({
        event: e,
        listeners: o
    })
}
var zN = /\r\n?/g
  , GN = /\u0000|\uFFFD/g;
function lC(n) {
    return (typeof n == "string" ? n : "" + n).replace(zN, `
`).replace(GN, "")
}
function Lp(n, e, t) {
    if (e = lC(e),
    lC(n) !== e && t)
        throw Error(Me(425))
}
function Sg() {}
var h1 = null
  , p1 = null;
function m1(n, e) {
    return n === "textarea" || n === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null
}
var g1 = typeof setTimeout == "function" ? setTimeout : void 0
  , HN = typeof clearTimeout == "function" ? clearTimeout : void 0
  , uC = typeof Promise == "function" ? Promise : void 0
  , VN = typeof queueMicrotask == "function" ? queueMicrotask : typeof uC < "u" ? function(n) {
    return uC.resolve(null).then(n).catch(WN)
}
: g1;
function WN(n) {
    setTimeout(function() {
        throw n
    })
}
function Sy(n, e) {
    var t = e
      , i = 0;
    do {
        var r = t.nextSibling;
        if (n.removeChild(t),
        r && r.nodeType === 8)
            if (t = r.data,
            t === "/$") {
                if (i === 0) {
                    n.removeChild(r),
                    ld(e);
                    return
                }
                i--
            } else
                t !== "$" && t !== "$?" && t !== "$!" || i++;
        t = r
    } while (t);
    ld(e)
}
function Wo(n) {
    for (; n != null; n = n.nextSibling) {
        var e = n.nodeType;
        if (e === 1 || e === 3)
            break;
        if (e === 8) {
            if (e = n.data,
            e === "$" || e === "$!" || e === "$?")
                break;
            if (e === "/$")
                return null
        }
    }
    return n
}
function cC(n) {
    n = n.previousSibling;
    for (var e = 0; n; ) {
        if (n.nodeType === 8) {
            var t = n.data;
            if (t === "$" || t === "$!" || t === "$?") {
                if (e === 0)
                    return n;
                e--
            } else
                t === "/$" && e++
        }
        n = n.previousSibling
    }
    return null
}
var xc = Math.random().toString(36).slice(2)
  , os = "__reactFiber$" + xc
  , hd = "__reactProps$" + xc
  , Ks = "__reactContainer$" + xc
  , v1 = "__reactEvents$" + xc
  , jN = "__reactListeners$" + xc
  , JN = "__reactHandles$" + xc;
function Ka(n) {
    var e = n[os];
    if (e)
        return e;
    for (var t = n.parentNode; t; ) {
        if (e = t[Ks] || t[os]) {
            if (t = e.alternate,
            e.child !== null || t !== null && t.child !== null)
                for (n = cC(n); n !== null; ) {
                    if (t = n[os])
                        return t;
                    n = cC(n)
                }
            return e
        }
        n = t,
        t = n.parentNode
    }
    return null
}
function Qd(n) {
    return n = n[os] || n[Ks],
    !n || n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3 ? null : n
}
function wu(n) {
    if (n.tag === 5 || n.tag === 6)
        return n.stateNode;
    throw Error(Me(33))
}
function u0(n) {
    return n[hd] || null
}
var y1 = []
  , Su = -1;
function fa(n) {
    return {
        current: n
    }
}
function Kt(n) {
    0 > Su || (n.current = y1[Su],
    y1[Su] = null,
    Su--)
}
function jt(n, e) {
    Su++,
    y1[Su] = n.current,
    n.current = e
}
var $o = {}
  , ai = fa($o)
  , Bi = fa(!1)
  , gl = $o;
function Qu(n, e) {
    var t = n.type.contextTypes;
    if (!t)
        return $o;
    var i = n.stateNode;
    if (i && i.__reactInternalMemoizedUnmaskedChildContext === e)
        return i.__reactInternalMemoizedMaskedChildContext;
    var r = {}, s;
    for (s in t)
        r[s] = e[s];
    return i && (n = n.stateNode,
    n.__reactInternalMemoizedUnmaskedChildContext = e,
    n.__reactInternalMemoizedMaskedChildContext = r),
    r
}
function Ri(n) {
    return n = n.childContextTypes,
    n != null
}
function Mg() {
    Kt(Bi),
    Kt(ai)
}
function fC(n, e, t) {
    if (ai.current !== $o)
        throw Error(Me(168));
    jt(ai, e),
    jt(Bi, t)
}
function B3(n, e, t) {
    var i = n.stateNode;
    if (e = e.childContextTypes,
    typeof i.getChildContext != "function")
        return t;
    i = i.getChildContext();
    for (var r in i)
        if (!(r in e))
            throw Error(Me(108, BF(n) || "Unknown", r));
    return cn({}, t, i)
}
function bg(n) {
    return n = (n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext || $o,
    gl = ai.current,
    jt(ai, n),
    jt(Bi, Bi.current),
    !0
}
function dC(n, e, t) {
    var i = n.stateNode;
    if (!i)
        throw Error(Me(169));
    t ? (n = B3(n, e, gl),
    i.__reactInternalMemoizedMergedChildContext = n,
    Kt(Bi),
    Kt(ai),
    jt(ai, n)) : Kt(Bi),
    jt(Bi, t)
}
var ks = null
  , c0 = !1
  , My = !1;
function R3(n) {
    ks === null ? ks = [n] : ks.push(n)
}
function XN(n) {
    c0 = !0,
    R3(n)
}
function da() {
    if (!My && ks !== null) {
        My = !0;
        var n = 0
          , e = zt;
        try {
            var t = ks;
            for (zt = 1; n < t.length; n++) {
                var i = t[n];
                do
                    i = i(!0);
                while (i !== null)
            }
            ks = null,
            c0 = !1
        } catch (r) {
            throw ks !== null && (ks = ks.slice(n + 1)),
            n3(TA, da),
            r
        } finally {
            zt = e,
            My = !1
        }
    }
    return null
}
var Mu = []
  , bu = 0
  , Cg = null
  , Eg = 0
  , gr = []
  , vr = 0
  , vl = null
  , Os = 1
  , Us = "";
function Ua(n, e) {
    Mu[bu++] = Eg,
    Mu[bu++] = Cg,
    Cg = n,
    Eg = e
}
function I3(n, e, t) {
    gr[vr++] = Os,
    gr[vr++] = Us,
    gr[vr++] = vl,
    vl = n;
    var i = Os;
    n = Us;
    var r = 32 - zr(i) - 1;
    i &= ~(1 << r),
    t += 1;
    var s = 32 - zr(e) + r;
    if (30 < s) {
        var o = r - r % 5;
        s = (i & (1 << o) - 1).toString(32),
        i >>= o,
        r -= o,
        Os = 1 << 32 - zr(e) + r | t << r | i,
        Us = s + n
    } else
        Os = 1 << s | t << r | i,
        Us = n
}
function NA(n) {
    n.return !== null && (Ua(n, 1),
    I3(n, 1, 0))
}
function OA(n) {
    for (; n === Cg; )
        Cg = Mu[--bu],
        Mu[bu] = null,
        Eg = Mu[--bu],
        Mu[bu] = null;
    for (; n === vl; )
        vl = gr[--vr],
        gr[vr] = null,
        Us = gr[--vr],
        gr[vr] = null,
        Os = gr[--vr],
        gr[vr] = null
}
var ji = null
  , Vi = null
  , en = !1
  , Fr = null;
function L3(n, e) {
    var t = xr(5, null, null, 0);
    t.elementType = "DELETED",
    t.stateNode = e,
    t.return = n,
    e = n.deletions,
    e === null ? (n.deletions = [t],
    n.flags |= 16) : e.push(t)
}
function hC(n, e) {
    switch (n.tag) {
    case 5:
        var t = n.type;
        return e = e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase() ? null : e,
        e !== null ? (n.stateNode = e,
        ji = n,
        Vi = Wo(e.firstChild),
        !0) : !1;
    case 6:
        return e = n.pendingProps === "" || e.nodeType !== 3 ? null : e,
        e !== null ? (n.stateNode = e,
        ji = n,
        Vi = null,
        !0) : !1;
    case 13:
        return e = e.nodeType !== 8 ? null : e,
        e !== null ? (t = vl !== null ? {
            id: Os,
            overflow: Us
        } : null,
        n.memoizedState = {
            dehydrated: e,
            treeContext: t,
            retryLane: 1073741824
        },
        t = xr(18, null, null, 0),
        t.stateNode = e,
        t.return = n,
        n.child = t,
        ji = n,
        Vi = null,
        !0) : !1;
    default:
        return !1
    }
}
function x1(n) {
    return (n.mode & 1) !== 0 && (n.flags & 128) === 0
}
function _1(n) {
    if (en) {
        var e = Vi;
        if (e) {
            var t = e;
            if (!hC(n, e)) {
                if (x1(n))
                    throw Error(Me(418));
                e = Wo(t.nextSibling);
                var i = ji;
                e && hC(n, e) ? L3(i, t) : (n.flags = n.flags & -4097 | 2,
                en = !1,
                ji = n)
            }
        } else {
            if (x1(n))
                throw Error(Me(418));
            n.flags = n.flags & -4097 | 2,
            en = !1,
            ji = n
        }
    }
}
function pC(n) {
    for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13; )
        n = n.return;
    ji = n
}
function Dp(n) {
    if (n !== ji)
        return !1;
    if (!en)
        return pC(n),
        en = !0,
        !1;
    var e;
    if ((e = n.tag !== 3) && !(e = n.tag !== 5) && (e = n.type,
    e = e !== "head" && e !== "body" && !m1(n.type, n.memoizedProps)),
    e && (e = Vi)) {
        if (x1(n))
            throw D3(),
            Error(Me(418));
        for (; e; )
            L3(n, e),
            e = Wo(e.nextSibling)
    }
    if (pC(n),
    n.tag === 13) {
        if (n = n.memoizedState,
        n = n !== null ? n.dehydrated : null,
        !n)
            throw Error(Me(317));
        e: {
            for (n = n.nextSibling,
            e = 0; n; ) {
                if (n.nodeType === 8) {
                    var t = n.data;
                    if (t === "/$") {
                        if (e === 0) {
                            Vi = Wo(n.nextSibling);
                            break e
                        }
                        e--
                    } else
                        t !== "$" && t !== "$!" && t !== "$?" || e++
                }
                n = n.nextSibling
            }
            Vi = null
        }
    } else
        Vi = ji ? Wo(n.stateNode.nextSibling) : null;
    return !0
}
function D3() {
    for (var n = Vi; n; )
        n = Wo(n.nextSibling)
}
function Zu() {
    Vi = ji = null,
    en = !1
}
function UA(n) {
    Fr === null ? Fr = [n] : Fr.push(n)
}
var YN = ro.ReactCurrentBatchConfig;
function Lr(n, e) {
    if (n && n.defaultProps) {
        e = cn({}, e),
        n = n.defaultProps;
        for (var t in n)
            e[t] === void 0 && (e[t] = n[t]);
        return e
    }
    return e
}
var Tg = fa(null)
  , Pg = null
  , Cu = null
  , zA = null;
function GA() {
    zA = Cu = Pg = null
}
function HA(n) {
    var e = Tg.current;
    Kt(Tg),
    n._currentValue = e
}
function A1(n, e, t) {
    for (; n !== null; ) {
        var i = n.alternate;
        if ((n.childLanes & e) !== e ? (n.childLanes |= e,
        i !== null && (i.childLanes |= e)) : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e),
        n === t)
            break;
        n = n.return
    }
}
function Vu(n, e) {
    Pg = n,
    zA = Cu = null,
    n = n.dependencies,
    n !== null && n.firstContext !== null && (n.lanes & e && (Pi = !0),
    n.firstContext = null)
}
function wr(n) {
    var e = n._currentValue;
    if (zA !== n)
        if (n = {
            context: n,
            memoizedValue: e,
            next: null
        },
        Cu === null) {
            if (Pg === null)
                throw Error(Me(308));
            Cu = n,
            Pg.dependencies = {
                lanes: 0,
                firstContext: n
            }
        } else
            Cu = Cu.next = n;
    return e
}
var Qa = null;
function VA(n) {
    Qa === null ? Qa = [n] : Qa.push(n)
}
function k3(n, e, t, i) {
    var r = e.interleaved;
    return r === null ? (t.next = t,
    VA(e)) : (t.next = r.next,
    r.next = t),
    e.interleaved = t,
    Qs(n, i)
}
function Qs(n, e) {
    n.lanes |= e;
    var t = n.alternate;
    for (t !== null && (t.lanes |= e),
    t = n,
    n = n.return; n !== null; )
        n.childLanes |= e,
        t = n.alternate,
        t !== null && (t.childLanes |= e),
        t = n,
        n = n.return;
    return t.tag === 3 ? t.stateNode : null
}
var Bo = !1;
function WA(n) {
    n.updateQueue = {
        baseState: n.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function F3(n, e) {
    n = n.updateQueue,
    e.updateQueue === n && (e.updateQueue = {
        baseState: n.baseState,
        firstBaseUpdate: n.firstBaseUpdate,
        lastBaseUpdate: n.lastBaseUpdate,
        shared: n.shared,
        effects: n.effects
    })
}
function Ws(n, e) {
    return {
        eventTime: n,
        lane: e,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function jo(n, e, t) {
    var i = n.updateQueue;
    if (i === null)
        return null;
    if (i = i.shared,
    Lt & 2) {
        var r = i.pending;
        return r === null ? e.next = e : (e.next = r.next,
        r.next = e),
        i.pending = e,
        Qs(n, t)
    }
    return r = i.interleaved,
    r === null ? (e.next = e,
    VA(i)) : (e.next = r.next,
    r.next = e),
    i.interleaved = e,
    Qs(n, t)
}
function Ym(n, e, t) {
    if (e = e.updateQueue,
    e !== null && (e = e.shared,
    (t & 4194240) !== 0)) {
        var i = e.lanes;
        i &= n.pendingLanes,
        t |= i,
        e.lanes = t,
        PA(n, t)
    }
}
function mC(n, e) {
    var t = n.updateQueue
      , i = n.alternate;
    if (i !== null && (i = i.updateQueue,
    t === i)) {
        var r = null
          , s = null;
        if (t = t.firstBaseUpdate,
        t !== null) {
            do {
                var o = {
                    eventTime: t.eventTime,
                    lane: t.lane,
                    tag: t.tag,
                    payload: t.payload,
                    callback: t.callback,
                    next: null
                };
                s === null ? r = s = o : s = s.next = o,
                t = t.next
            } while (t !== null);
            s === null ? r = s = e : s = s.next = e
        } else
            r = s = e;
        t = {
            baseState: i.baseState,
            firstBaseUpdate: r,
            lastBaseUpdate: s,
            shared: i.shared,
            effects: i.effects
        },
        n.updateQueue = t;
        return
    }
    n = t.lastBaseUpdate,
    n === null ? t.firstBaseUpdate = e : n.next = e,
    t.lastBaseUpdate = e
}
function Bg(n, e, t, i) {
    var r = n.updateQueue;
    Bo = !1;
    var s = r.firstBaseUpdate
      , o = r.lastBaseUpdate
      , a = r.shared.pending;
    if (a !== null) {
        r.shared.pending = null;
        var l = a
          , c = l.next;
        l.next = null,
        o === null ? s = c : o.next = c,
        o = l;
        var d = n.alternate;
        d !== null && (d = d.updateQueue,
        a = d.lastBaseUpdate,
        a !== o && (a === null ? d.firstBaseUpdate = c : a.next = c,
        d.lastBaseUpdate = l))
    }
    if (s !== null) {
        var h = r.baseState;
        o = 0,
        d = c = l = null,
        a = s;
        do {
            var p = a.lane
              , m = a.eventTime;
            if ((i & p) === p) {
                d !== null && (d = d.next = {
                    eventTime: m,
                    lane: 0,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                });
                e: {
                    var y = n
                      , v = a;
                    switch (p = e,
                    m = t,
                    v.tag) {
                    case 1:
                        if (y = v.payload,
                        typeof y == "function") {
                            h = y.call(m, h, p);
                            break e
                        }
                        h = y;
                        break e;
                    case 3:
                        y.flags = y.flags & -65537 | 128;
                    case 0:
                        if (y = v.payload,
                        p = typeof y == "function" ? y.call(m, h, p) : y,
                        p == null)
                            break e;
                        h = cn({}, h, p);
                        break e;
                    case 2:
                        Bo = !0
                    }
                }
                a.callback !== null && a.lane !== 0 && (n.flags |= 64,
                p = r.effects,
                p === null ? r.effects = [a] : p.push(a))
            } else
                m = {
                    eventTime: m,
                    lane: p,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                },
                d === null ? (c = d = m,
                l = h) : d = d.next = m,
                o |= p;
            if (a = a.next,
            a === null) {
                if (a = r.shared.pending,
                a === null)
                    break;
                p = a,
                a = p.next,
                p.next = null,
                r.lastBaseUpdate = p,
                r.shared.pending = null
            }
        } while (1);
        if (d === null && (l = h),
        r.baseState = l,
        r.firstBaseUpdate = c,
        r.lastBaseUpdate = d,
        e = r.shared.interleaved,
        e !== null) {
            r = e;
            do
                o |= r.lane,
                r = r.next;
            while (r !== e)
        } else
            s === null && (r.shared.lanes = 0);
        xl |= o,
        n.lanes = o,
        n.memoizedState = h
    }
}
function gC(n, e, t) {
    if (n = e.effects,
    e.effects = null,
    n !== null)
        for (e = 0; e < n.length; e++) {
            var i = n[e]
              , r = i.callback;
            if (r !== null) {
                if (i.callback = null,
                i = t,
                typeof r != "function")
                    throw Error(Me(191, r));
                r.call(i)
            }
        }
}
var N3 = new kP.Component().refs;
function w1(n, e, t, i) {
    e = n.memoizedState,
    t = t(i, e),
    t = t == null ? e : cn({}, e, t),
    n.memoizedState = t,
    n.lanes === 0 && (n.updateQueue.baseState = t)
}
var f0 = {
    isMounted: function(n) {
        return (n = n._reactInternals) ? Tl(n) === n : !1
    },
    enqueueSetState: function(n, e, t) {
        n = n._reactInternals;
        var i = vi()
          , r = Xo(n)
          , s = Ws(i, r);
        s.payload = e,
        t != null && (s.callback = t),
        e = jo(n, s, r),
        e !== null && (Gr(e, n, r, i),
        Ym(e, n, r))
    },
    enqueueReplaceState: function(n, e, t) {
        n = n._reactInternals;
        var i = vi()
          , r = Xo(n)
          , s = Ws(i, r);
        s.tag = 1,
        s.payload = e,
        t != null && (s.callback = t),
        e = jo(n, s, r),
        e !== null && (Gr(e, n, r, i),
        Ym(e, n, r))
    },
    enqueueForceUpdate: function(n, e) {
        n = n._reactInternals;
        var t = vi()
          , i = Xo(n)
          , r = Ws(t, i);
        r.tag = 2,
        e != null && (r.callback = e),
        e = jo(n, r, i),
        e !== null && (Gr(e, n, i, t),
        Ym(e, n, i))
    }
};
function vC(n, e, t, i, r, s, o) {
    return n = n.stateNode,
    typeof n.shouldComponentUpdate == "function" ? n.shouldComponentUpdate(i, s, o) : e.prototype && e.prototype.isPureReactComponent ? !cd(t, i) || !cd(r, s) : !0
}
function O3(n, e, t) {
    var i = !1
      , r = $o
      , s = e.contextType;
    return typeof s == "object" && s !== null ? s = wr(s) : (r = Ri(e) ? gl : ai.current,
    i = e.contextTypes,
    s = (i = i != null) ? Qu(n, r) : $o),
    e = new e(t,s),
    n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null,
    e.updater = f0,
    n.stateNode = e,
    e._reactInternals = n,
    i && (n = n.stateNode,
    n.__reactInternalMemoizedUnmaskedChildContext = r,
    n.__reactInternalMemoizedMaskedChildContext = s),
    e
}
function yC(n, e, t, i) {
    n = e.state,
    typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(t, i),
    typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(t, i),
    e.state !== n && f0.enqueueReplaceState(e, e.state, null)
}
function S1(n, e, t, i) {
    var r = n.stateNode;
    r.props = t,
    r.state = n.memoizedState,
    r.refs = N3,
    WA(n);
    var s = e.contextType;
    typeof s == "object" && s !== null ? r.context = wr(s) : (s = Ri(e) ? gl : ai.current,
    r.context = Qu(n, s)),
    r.state = n.memoizedState,
    s = e.getDerivedStateFromProps,
    typeof s == "function" && (w1(n, e, s, t),
    r.state = n.memoizedState),
    typeof e.getDerivedStateFromProps == "function" || typeof r.getSnapshotBeforeUpdate == "function" || typeof r.UNSAFE_componentWillMount != "function" && typeof r.componentWillMount != "function" || (e = r.state,
    typeof r.componentWillMount == "function" && r.componentWillMount(),
    typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(),
    e !== r.state && f0.enqueueReplaceState(r, r.state, null),
    Bg(n, t, r, i),
    r.state = n.memoizedState),
    typeof r.componentDidMount == "function" && (n.flags |= 4194308)
}
function nf(n, e, t) {
    if (n = t.ref,
    n !== null && typeof n != "function" && typeof n != "object") {
        if (t._owner) {
            if (t = t._owner,
            t) {
                if (t.tag !== 1)
                    throw Error(Me(309));
                var i = t.stateNode
            }
            if (!i)
                throw Error(Me(147, n));
            var r = i
              , s = "" + n;
            return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function(o) {
                var a = r.refs;
                a === N3 && (a = r.refs = {}),
                o === null ? delete a[s] : a[s] = o
            }
            ,
            e._stringRef = s,
            e)
        }
        if (typeof n != "string")
            throw Error(Me(284));
        if (!t._owner)
            throw Error(Me(290, n))
    }
    return n
}
function kp(n, e) {
    throw n = Object.prototype.toString.call(e),
    Error(Me(31, n === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : n))
}
function xC(n) {
    var e = n._init;
    return e(n._payload)
}
function U3(n) {
    function e(_, A) {
        if (n) {
            var w = _.deletions;
            w === null ? (_.deletions = [A],
            _.flags |= 16) : w.push(A)
        }
    }
    function t(_, A) {
        if (!n)
            return null;
        for (; A !== null; )
            e(_, A),
            A = A.sibling;
        return null
    }
    function i(_, A) {
        for (_ = new Map; A !== null; )
            A.key !== null ? _.set(A.key, A) : _.set(A.index, A),
            A = A.sibling;
        return _
    }
    function r(_, A) {
        return _ = Yo(_, A),
        _.index = 0,
        _.sibling = null,
        _
    }
    function s(_, A, w) {
        return _.index = w,
        n ? (w = _.alternate,
        w !== null ? (w = w.index,
        w < A ? (_.flags |= 2,
        A) : w) : (_.flags |= 2,
        A)) : (_.flags |= 1048576,
        A)
    }
    function o(_) {
        return n && _.alternate === null && (_.flags |= 2),
        _
    }
    function a(_, A, w, M) {
        return A === null || A.tag !== 6 ? (A = Ry(w, _.mode, M),
        A.return = _,
        A) : (A = r(A, w),
        A.return = _,
        A)
    }
    function l(_, A, w, M) {
        var C = w.type;
        return C === yu ? d(_, A, w.props.children, M, w.key) : A !== null && (A.elementType === C || typeof C == "object" && C !== null && C.$$typeof === Po && xC(C) === A.type) ? (M = r(A, w.props),
        M.ref = nf(_, A, w),
        M.return = _,
        M) : (M = eg(w.type, w.key, w.props, null, _.mode, M),
        M.ref = nf(_, A, w),
        M.return = _,
        M)
    }
    function c(_, A, w, M) {
        return A === null || A.tag !== 4 || A.stateNode.containerInfo !== w.containerInfo || A.stateNode.implementation !== w.implementation ? (A = Iy(w, _.mode, M),
        A.return = _,
        A) : (A = r(A, w.children || []),
        A.return = _,
        A)
    }
    function d(_, A, w, M, C) {
        return A === null || A.tag !== 7 ? (A = ll(w, _.mode, M, C),
        A.return = _,
        A) : (A = r(A, w),
        A.return = _,
        A)
    }
    function h(_, A, w) {
        if (typeof A == "string" && A !== "" || typeof A == "number")
            return A = Ry("" + A, _.mode, w),
            A.return = _,
            A;
        if (typeof A == "object" && A !== null) {
            switch (A.$$typeof) {
            case Mp:
                return w = eg(A.type, A.key, A.props, null, _.mode, w),
                w.ref = nf(_, null, A),
                w.return = _,
                w;
            case vu:
                return A = Iy(A, _.mode, w),
                A.return = _,
                A;
            case Po:
                var M = A._init;
                return h(_, M(A._payload), w)
            }
            if (Pf(A) || Zc(A))
                return A = ll(A, _.mode, w, null),
                A.return = _,
                A;
            kp(_, A)
        }
        return null
    }
    function p(_, A, w, M) {
        var C = A !== null ? A.key : null;
        if (typeof w == "string" && w !== "" || typeof w == "number")
            return C !== null ? null : a(_, A, "" + w, M);
        if (typeof w == "object" && w !== null) {
            switch (w.$$typeof) {
            case Mp:
                return w.key === C ? l(_, A, w, M) : null;
            case vu:
                return w.key === C ? c(_, A, w, M) : null;
            case Po:
                return C = w._init,
                p(_, A, C(w._payload), M)
            }
            if (Pf(w) || Zc(w))
                return C !== null ? null : d(_, A, w, M, null);
            kp(_, w)
        }
        return null
    }
    function m(_, A, w, M, C) {
        if (typeof M == "string" && M !== "" || typeof M == "number")
            return _ = _.get(w) || null,
            a(A, _, "" + M, C);
        if (typeof M == "object" && M !== null) {
            switch (M.$$typeof) {
            case Mp:
                return _ = _.get(M.key === null ? w : M.key) || null,
                l(A, _, M, C);
            case vu:
                return _ = _.get(M.key === null ? w : M.key) || null,
                c(A, _, M, C);
            case Po:
                var P = M._init;
                return m(_, A, w, P(M._payload), C)
            }
            if (Pf(M) || Zc(M))
                return _ = _.get(w) || null,
                d(A, _, M, C, null);
            kp(A, M)
        }
        return null
    }
    function y(_, A, w, M) {
        for (var C = null, P = null, R = A, E = A = 0, B = null; R !== null && E < w.length; E++) {
            R.index > E ? (B = R,
            R = null) : B = R.sibling;
            var I = p(_, R, w[E], M);
            if (I === null) {
                R === null && (R = B);
                break
            }
            n && R && I.alternate === null && e(_, R),
            A = s(I, A, E),
            P === null ? C = I : P.sibling = I,
            P = I,
            R = B
        }
        if (E === w.length)
            return t(_, R),
            en && Ua(_, E),
            C;
        if (R === null) {
            for (; E < w.length; E++)
                R = h(_, w[E], M),
                R !== null && (A = s(R, A, E),
                P === null ? C = R : P.sibling = R,
                P = R);
            return en && Ua(_, E),
            C
        }
        for (R = i(_, R); E < w.length; E++)
            B = m(R, _, E, w[E], M),
            B !== null && (n && B.alternate !== null && R.delete(B.key === null ? E : B.key),
            A = s(B, A, E),
            P === null ? C = B : P.sibling = B,
            P = B);
        return n && R.forEach(function(z) {
            return e(_, z)
        }),
        en && Ua(_, E),
        C
    }
    function v(_, A, w, M) {
        var C = Zc(w);
        if (typeof C != "function")
            throw Error(Me(150));
        if (w = C.call(w),
        w == null)
            throw Error(Me(151));
        for (var P = C = null, R = A, E = A = 0, B = null, I = w.next(); R !== null && !I.done; E++,
        I = w.next()) {
            R.index > E ? (B = R,
            R = null) : B = R.sibling;
            var z = p(_, R, I.value, M);
            if (z === null) {
                R === null && (R = B);
                break
            }
            n && R && z.alternate === null && e(_, R),
            A = s(z, A, E),
            P === null ? C = z : P.sibling = z,
            P = z,
            R = B
        }
        if (I.done)
            return t(_, R),
            en && Ua(_, E),
            C;
        if (R === null) {
            for (; !I.done; E++,
            I = w.next())
                I = h(_, I.value, M),
                I !== null && (A = s(I, A, E),
                P === null ? C = I : P.sibling = I,
                P = I);
            return en && Ua(_, E),
            C
        }
        for (R = i(_, R); !I.done; E++,
        I = w.next())
            I = m(R, _, E, I.value, M),
            I !== null && (n && I.alternate !== null && R.delete(I.key === null ? E : I.key),
            A = s(I, A, E),
            P === null ? C = I : P.sibling = I,
            P = I);
        return n && R.forEach(function(q) {
            return e(_, q)
        }),
        en && Ua(_, E),
        C
    }
    function x(_, A, w, M) {
        if (typeof w == "object" && w !== null && w.type === yu && w.key === null && (w = w.props.children),
        typeof w == "object" && w !== null) {
            switch (w.$$typeof) {
            case Mp:
                e: {
                    for (var C = w.key, P = A; P !== null; ) {
                        if (P.key === C) {
                            if (C = w.type,
                            C === yu) {
                                if (P.tag === 7) {
                                    t(_, P.sibling),
                                    A = r(P, w.props.children),
                                    A.return = _,
                                    _ = A;
                                    break e
                                }
                            } else if (P.elementType === C || typeof C == "object" && C !== null && C.$$typeof === Po && xC(C) === P.type) {
                                t(_, P.sibling),
                                A = r(P, w.props),
                                A.ref = nf(_, P, w),
                                A.return = _,
                                _ = A;
                                break e
                            }
                            t(_, P);
                            break
                        } else
                            e(_, P);
                        P = P.sibling
                    }
                    w.type === yu ? (A = ll(w.props.children, _.mode, M, w.key),
                    A.return = _,
                    _ = A) : (M = eg(w.type, w.key, w.props, null, _.mode, M),
                    M.ref = nf(_, A, w),
                    M.return = _,
                    _ = M)
                }
                return o(_);
            case vu:
                e: {
                    for (P = w.key; A !== null; ) {
                        if (A.key === P)
                            if (A.tag === 4 && A.stateNode.containerInfo === w.containerInfo && A.stateNode.implementation === w.implementation) {
                                t(_, A.sibling),
                                A = r(A, w.children || []),
                                A.return = _,
                                _ = A;
                                break e
                            } else {
                                t(_, A);
                                break
                            }
                        else
                            e(_, A);
                        A = A.sibling
                    }
                    A = Iy(w, _.mode, M),
                    A.return = _,
                    _ = A
                }
                return o(_);
            case Po:
                return P = w._init,
                x(_, A, P(w._payload), M)
            }
            if (Pf(w))
                return y(_, A, w, M);
            if (Zc(w))
                return v(_, A, w, M);
            kp(_, w)
        }
        return typeof w == "string" && w !== "" || typeof w == "number" ? (w = "" + w,
        A !== null && A.tag === 6 ? (t(_, A.sibling),
        A = r(A, w),
        A.return = _,
        _ = A) : (t(_, A),
        A = Ry(w, _.mode, M),
        A.return = _,
        _ = A),
        o(_)) : t(_, A)
    }
    return x
}
var qu = U3(!0)
  , z3 = U3(!1)
  , Zd = {}
  , us = fa(Zd)
  , pd = fa(Zd)
  , md = fa(Zd);
function Za(n) {
    if (n === Zd)
        throw Error(Me(174));
    return n
}
function jA(n, e) {
    switch (jt(md, e),
    jt(pd, n),
    jt(us, Zd),
    n = e.nodeType,
    n) {
    case 9:
    case 11:
        e = (e = e.documentElement) ? e.namespaceURI : t1(null, "");
        break;
    default:
        n = n === 8 ? e.parentNode : e,
        e = n.namespaceURI || null,
        n = n.tagName,
        e = t1(e, n)
    }
    Kt(us),
    jt(us, e)
}
function $u() {
    Kt(us),
    Kt(pd),
    Kt(md)
}
function G3(n) {
    Za(md.current);
    var e = Za(us.current)
      , t = t1(e, n.type);
    e !== t && (jt(pd, n),
    jt(us, t))
}
function JA(n) {
    pd.current === n && (Kt(us),
    Kt(pd))
}
var sn = fa(0);
function Rg(n) {
    for (var e = n; e !== null; ) {
        if (e.tag === 13) {
            var t = e.memoizedState;
            if (t !== null && (t = t.dehydrated,
            t === null || t.data === "$?" || t.data === "$!"))
                return e
        } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
            if (e.flags & 128)
                return e
        } else if (e.child !== null) {
            e.child.return = e,
            e = e.child;
            continue
        }
        if (e === n)
            break;
        for (; e.sibling === null; ) {
            if (e.return === null || e.return === n)
                return null;
            e = e.return
        }
        e.sibling.return = e.return,
        e = e.sibling
    }
    return null
}
var by = [];
function XA() {
    for (var n = 0; n < by.length; n++)
        by[n]._workInProgressVersionPrimary = null;
    by.length = 0
}
var Km = ro.ReactCurrentDispatcher
  , Cy = ro.ReactCurrentBatchConfig
  , yl = 0
  , un = null
  , Rn = null
  , Vn = null
  , Ig = !1
  , zf = !1
  , gd = 0
  , KN = 0;
function ni() {
    throw Error(Me(321))
}
function YA(n, e) {
    if (e === null)
        return !1;
    for (var t = 0; t < e.length && t < n.length; t++)
        if (!Wr(n[t], e[t]))
            return !1;
    return !0
}
function KA(n, e, t, i, r, s) {
    if (yl = s,
    un = e,
    e.memoizedState = null,
    e.updateQueue = null,
    e.lanes = 0,
    Km.current = n === null || n.memoizedState === null ? $N : eO,
    n = t(i, r),
    zf) {
        s = 0;
        do {
            if (zf = !1,
            gd = 0,
            25 <= s)
                throw Error(Me(301));
            s += 1,
            Vn = Rn = null,
            e.updateQueue = null,
            Km.current = tO,
            n = t(i, r)
        } while (zf)
    }
    if (Km.current = Lg,
    e = Rn !== null && Rn.next !== null,
    yl = 0,
    Vn = Rn = un = null,
    Ig = !1,
    e)
        throw Error(Me(300));
    return n
}
function QA() {
    var n = gd !== 0;
    return gd = 0,
    n
}
function rs() {
    var n = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return Vn === null ? un.memoizedState = Vn = n : Vn = Vn.next = n,
    Vn
}
function Sr() {
    if (Rn === null) {
        var n = un.alternate;
        n = n !== null ? n.memoizedState : null
    } else
        n = Rn.next;
    var e = Vn === null ? un.memoizedState : Vn.next;
    if (e !== null)
        Vn = e,
        Rn = n;
    else {
        if (n === null)
            throw Error(Me(310));
        Rn = n,
        n = {
            memoizedState: Rn.memoizedState,
            baseState: Rn.baseState,
            baseQueue: Rn.baseQueue,
            queue: Rn.queue,
            next: null
        },
        Vn === null ? un.memoizedState = Vn = n : Vn = Vn.next = n
    }
    return Vn
}
function vd(n, e) {
    return typeof e == "function" ? e(n) : e
}
function Ey(n) {
    var e = Sr()
      , t = e.queue;
    if (t === null)
        throw Error(Me(311));
    t.lastRenderedReducer = n;
    var i = Rn
      , r = i.baseQueue
      , s = t.pending;
    if (s !== null) {
        if (r !== null) {
            var o = r.next;
            r.next = s.next,
            s.next = o
        }
        i.baseQueue = r = s,
        t.pending = null
    }
    if (r !== null) {
        s = r.next,
        i = i.baseState;
        var a = o = null
          , l = null
          , c = s;
        do {
            var d = c.lane;
            if ((yl & d) === d)
                l !== null && (l = l.next = {
                    lane: 0,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                }),
                i = c.hasEagerState ? c.eagerState : n(i, c.action);
            else {
                var h = {
                    lane: d,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                };
                l === null ? (a = l = h,
                o = i) : l = l.next = h,
                un.lanes |= d,
                xl |= d
            }
            c = c.next
        } while (c !== null && c !== s);
        l === null ? o = i : l.next = a,
        Wr(i, e.memoizedState) || (Pi = !0),
        e.memoizedState = i,
        e.baseState = o,
        e.baseQueue = l,
        t.lastRenderedState = i
    }
    if (n = t.interleaved,
    n !== null) {
        r = n;
        do
            s = r.lane,
            un.lanes |= s,
            xl |= s,
            r = r.next;
        while (r !== n)
    } else
        r === null && (t.lanes = 0);
    return [e.memoizedState, t.dispatch]
}
function Ty(n) {
    var e = Sr()
      , t = e.queue;
    if (t === null)
        throw Error(Me(311));
    t.lastRenderedReducer = n;
    var i = t.dispatch
      , r = t.pending
      , s = e.memoizedState;
    if (r !== null) {
        t.pending = null;
        var o = r = r.next;
        do
            s = n(s, o.action),
            o = o.next;
        while (o !== r);
        Wr(s, e.memoizedState) || (Pi = !0),
        e.memoizedState = s,
        e.baseQueue === null && (e.baseState = s),
        t.lastRenderedState = s
    }
    return [s, i]
}
function H3() {}
function V3(n, e) {
    var t = un
      , i = Sr()
      , r = e()
      , s = !Wr(i.memoizedState, r);
    if (s && (i.memoizedState = r,
    Pi = !0),
    i = i.queue,
    ZA(J3.bind(null, t, i, n), [n]),
    i.getSnapshot !== e || s || Vn !== null && Vn.memoizedState.tag & 1) {
        if (t.flags |= 2048,
        yd(9, j3.bind(null, t, i, r, e), void 0, null),
        Wn === null)
            throw Error(Me(349));
        yl & 30 || W3(t, e, r)
    }
    return r
}
function W3(n, e, t) {
    n.flags |= 16384,
    n = {
        getSnapshot: e,
        value: t
    },
    e = un.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    un.updateQueue = e,
    e.stores = [n]) : (t = e.stores,
    t === null ? e.stores = [n] : t.push(n))
}
function j3(n, e, t, i) {
    e.value = t,
    e.getSnapshot = i,
    X3(e) && Y3(n)
}
function J3(n, e, t) {
    return t(function() {
        X3(e) && Y3(n)
    })
}
function X3(n) {
    var e = n.getSnapshot;
    n = n.value;
    try {
        var t = e();
        return !Wr(n, t)
    } catch {
        return !0
    }
}
function Y3(n) {
    var e = Qs(n, 1);
    e !== null && Gr(e, n, 1, -1)
}
function _C(n) {
    var e = rs();
    return typeof n == "function" && (n = n()),
    e.memoizedState = e.baseState = n,
    n = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: vd,
        lastRenderedState: n
    },
    e.queue = n,
    n = n.dispatch = qN.bind(null, un, n),
    [e.memoizedState, n]
}
function yd(n, e, t, i) {
    return n = {
        tag: n,
        create: e,
        destroy: t,
        deps: i,
        next: null
    },
    e = un.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    un.updateQueue = e,
    e.lastEffect = n.next = n) : (t = e.lastEffect,
    t === null ? e.lastEffect = n.next = n : (i = t.next,
    t.next = n,
    n.next = i,
    e.lastEffect = n)),
    n
}
function K3() {
    return Sr().memoizedState
}
function Qm(n, e, t, i) {
    var r = rs();
    un.flags |= n,
    r.memoizedState = yd(1 | e, t, void 0, i === void 0 ? null : i)
}
function d0(n, e, t, i) {
    var r = Sr();
    i = i === void 0 ? null : i;
    var s = void 0;
    if (Rn !== null) {
        var o = Rn.memoizedState;
        if (s = o.destroy,
        i !== null && YA(i, o.deps)) {
            r.memoizedState = yd(e, t, s, i);
            return
        }
    }
    un.flags |= n,
    r.memoizedState = yd(1 | e, t, s, i)
}
function AC(n, e) {
    return Qm(8390656, 8, n, e)
}
function ZA(n, e) {
    return d0(2048, 8, n, e)
}
function Q3(n, e) {
    return d0(4, 2, n, e)
}
function Z3(n, e) {
    return d0(4, 4, n, e)
}
function q3(n, e) {
    if (typeof e == "function")
        return n = n(),
        e(n),
        function() {
            e(null)
        }
        ;
    if (e != null)
        return n = n(),
        e.current = n,
        function() {
            e.current = null
        }
}
function $3(n, e, t) {
    return t = t != null ? t.concat([n]) : null,
    d0(4, 4, q3.bind(null, e, n), t)
}
function qA() {}
function eB(n, e) {
    var t = Sr();
    e = e === void 0 ? null : e;
    var i = t.memoizedState;
    return i !== null && e !== null && YA(e, i[1]) ? i[0] : (t.memoizedState = [n, e],
    n)
}
function tB(n, e) {
    var t = Sr();
    e = e === void 0 ? null : e;
    var i = t.memoizedState;
    return i !== null && e !== null && YA(e, i[1]) ? i[0] : (n = n(),
    t.memoizedState = [n, e],
    n)
}
function nB(n, e, t) {
    return yl & 21 ? (Wr(t, e) || (t = s3(),
    un.lanes |= t,
    xl |= t,
    n.baseState = !0),
    e) : (n.baseState && (n.baseState = !1,
    Pi = !0),
    n.memoizedState = t)
}
function QN(n, e) {
    var t = zt;
    zt = t !== 0 && 4 > t ? t : 4,
    n(!0);
    var i = Cy.transition;
    Cy.transition = {};
    try {
        n(!1),
        e()
    } finally {
        zt = t,
        Cy.transition = i
    }
}
function iB() {
    return Sr().memoizedState
}
function ZN(n, e, t) {
    var i = Xo(n);
    if (t = {
        lane: i,
        action: t,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    rB(n))
        sB(e, t);
    else if (t = k3(n, e, t, i),
    t !== null) {
        var r = vi();
        Gr(t, n, i, r),
        oB(t, e, i)
    }
}
function qN(n, e, t) {
    var i = Xo(n)
      , r = {
        lane: i,
        action: t,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (rB(n))
        sB(e, r);
    else {
        var s = n.alternate;
        if (n.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer,
        s !== null))
            try {
                var o = e.lastRenderedState
                  , a = s(o, t);
                if (r.hasEagerState = !0,
                r.eagerState = a,
                Wr(a, o)) {
                    var l = e.interleaved;
                    l === null ? (r.next = r,
                    VA(e)) : (r.next = l.next,
                    l.next = r),
                    e.interleaved = r;
                    return
                }
            } catch {} finally {}
        t = k3(n, e, r, i),
        t !== null && (r = vi(),
        Gr(t, n, i, r),
        oB(t, e, i))
    }
}
function rB(n) {
    var e = n.alternate;
    return n === un || e !== null && e === un
}
function sB(n, e) {
    zf = Ig = !0;
    var t = n.pending;
    t === null ? e.next = e : (e.next = t.next,
    t.next = e),
    n.pending = e
}
function oB(n, e, t) {
    if (t & 4194240) {
        var i = e.lanes;
        i &= n.pendingLanes,
        t |= i,
        e.lanes = t,
        PA(n, t)
    }
}
var Lg = {
    readContext: wr,
    useCallback: ni,
    useContext: ni,
    useEffect: ni,
    useImperativeHandle: ni,
    useInsertionEffect: ni,
    useLayoutEffect: ni,
    useMemo: ni,
    useReducer: ni,
    useRef: ni,
    useState: ni,
    useDebugValue: ni,
    useDeferredValue: ni,
    useTransition: ni,
    useMutableSource: ni,
    useSyncExternalStore: ni,
    useId: ni,
    unstable_isNewReconciler: !1
}
  , $N = {
    readContext: wr,
    useCallback: function(n, e) {
        return rs().memoizedState = [n, e === void 0 ? null : e],
        n
    },
    useContext: wr,
    useEffect: AC,
    useImperativeHandle: function(n, e, t) {
        return t = t != null ? t.concat([n]) : null,
        Qm(4194308, 4, q3.bind(null, e, n), t)
    },
    useLayoutEffect: function(n, e) {
        return Qm(4194308, 4, n, e)
    },
    useInsertionEffect: function(n, e) {
        return Qm(4, 2, n, e)
    },
    useMemo: function(n, e) {
        var t = rs();
        return e = e === void 0 ? null : e,
        n = n(),
        t.memoizedState = [n, e],
        n
    },
    useReducer: function(n, e, t) {
        var i = rs();
        return e = t !== void 0 ? t(e) : e,
        i.memoizedState = i.baseState = e,
        n = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: n,
            lastRenderedState: e
        },
        i.queue = n,
        n = n.dispatch = ZN.bind(null, un, n),
        [i.memoizedState, n]
    },
    useRef: function(n) {
        var e = rs();
        return n = {
            current: n
        },
        e.memoizedState = n
    },
    useState: _C,
    useDebugValue: qA,
    useDeferredValue: function(n) {
        return rs().memoizedState = n
    },
    useTransition: function() {
        var n = _C(!1)
          , e = n[0];
        return n = QN.bind(null, n[1]),
        rs().memoizedState = n,
        [e, n]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(n, e, t) {
        var i = un
          , r = rs();
        if (en) {
            if (t === void 0)
                throw Error(Me(407));
            t = t()
        } else {
            if (t = e(),
            Wn === null)
                throw Error(Me(349));
            yl & 30 || W3(i, e, t)
        }
        r.memoizedState = t;
        var s = {
            value: t,
            getSnapshot: e
        };
        return r.queue = s,
        AC(J3.bind(null, i, s, n), [n]),
        i.flags |= 2048,
        yd(9, j3.bind(null, i, s, t, e), void 0, null),
        t
    },
    useId: function() {
        var n = rs()
          , e = Wn.identifierPrefix;
        if (en) {
            var t = Us
              , i = Os;
            t = (i & ~(1 << 32 - zr(i) - 1)).toString(32) + t,
            e = ":" + e + "R" + t,
            t = gd++,
            0 < t && (e += "H" + t.toString(32)),
            e += ":"
        } else
            t = KN++,
            e = ":" + e + "r" + t.toString(32) + ":";
        return n.memoizedState = e
    },
    unstable_isNewReconciler: !1
}
  , eO = {
    readContext: wr,
    useCallback: eB,
    useContext: wr,
    useEffect: ZA,
    useImperativeHandle: $3,
    useInsertionEffect: Q3,
    useLayoutEffect: Z3,
    useMemo: tB,
    useReducer: Ey,
    useRef: K3,
    useState: function() {
        return Ey(vd)
    },
    useDebugValue: qA,
    useDeferredValue: function(n) {
        var e = Sr();
        return nB(e, Rn.memoizedState, n)
    },
    useTransition: function() {
        var n = Ey(vd)[0]
          , e = Sr().memoizedState;
        return [n, e]
    },
    useMutableSource: H3,
    useSyncExternalStore: V3,
    useId: iB,
    unstable_isNewReconciler: !1
}
  , tO = {
    readContext: wr,
    useCallback: eB,
    useContext: wr,
    useEffect: ZA,
    useImperativeHandle: $3,
    useInsertionEffect: Q3,
    useLayoutEffect: Z3,
    useMemo: tB,
    useReducer: Ty,
    useRef: K3,
    useState: function() {
        return Ty(vd)
    },
    useDebugValue: qA,
    useDeferredValue: function(n) {
        var e = Sr();
        return Rn === null ? e.memoizedState = n : nB(e, Rn.memoizedState, n)
    },
    useTransition: function() {
        var n = Ty(vd)[0]
          , e = Sr().memoizedState;
        return [n, e]
    },
    useMutableSource: H3,
    useSyncExternalStore: V3,
    useId: iB,
    unstable_isNewReconciler: !1
};
function ec(n, e) {
    try {
        var t = ""
          , i = e;
        do
            t += PF(i),
            i = i.return;
        while (i);
        var r = t
    } catch (s) {
        r = `
Error generating stack: ` + s.message + `
` + s.stack
    }
    return {
        value: n,
        source: e,
        stack: r,
        digest: null
    }
}
function Py(n, e, t) {
    return {
        value: n,
        source: null,
        stack: t ?? null,
        digest: e ?? null
    }
}
function M1(n, e) {
    try {
        console.error(e.value)
    } catch (t) {
        setTimeout(function() {
            throw t
        })
    }
}
var nO = typeof WeakMap == "function" ? WeakMap : Map;
function aB(n, e, t) {
    t = Ws(-1, t),
    t.tag = 3,
    t.payload = {
        element: null
    };
    var i = e.value;
    return t.callback = function() {
        kg || (kg = !0,
        D1 = i),
        M1(n, e)
    }
    ,
    t
}
function lB(n, e, t) {
    t = Ws(-1, t),
    t.tag = 3;
    var i = n.type.getDerivedStateFromError;
    if (typeof i == "function") {
        var r = e.value;
        t.payload = function() {
            return i(r)
        }
        ,
        t.callback = function() {
            M1(n, e)
        }
    }
    var s = n.stateNode;
    return s !== null && typeof s.componentDidCatch == "function" && (t.callback = function() {
        M1(n, e),
        typeof i != "function" && (Jo === null ? Jo = new Set([this]) : Jo.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
            componentStack: o !== null ? o : ""
        })
    }
    ),
    t
}
function wC(n, e, t) {
    var i = n.pingCache;
    if (i === null) {
        i = n.pingCache = new nO;
        var r = new Set;
        i.set(e, r)
    } else
        r = i.get(e),
        r === void 0 && (r = new Set,
        i.set(e, r));
    r.has(t) || (r.add(t),
    n = gO.bind(null, n, e, t),
    e.then(n, n))
}
function SC(n) {
    do {
        var e;
        if ((e = n.tag === 13) && (e = n.memoizedState,
        e = e !== null ? e.dehydrated !== null : !0),
        e)
            return n;
        n = n.return
    } while (n !== null);
    return null
}
function MC(n, e, t, i, r) {
    return n.mode & 1 ? (n.flags |= 65536,
    n.lanes = r,
    n) : (n === e ? n.flags |= 65536 : (n.flags |= 128,
    t.flags |= 131072,
    t.flags &= -52805,
    t.tag === 1 && (t.alternate === null ? t.tag = 17 : (e = Ws(-1, 1),
    e.tag = 2,
    jo(t, e, 1))),
    t.lanes |= 1),
    n)
}
var iO = ro.ReactCurrentOwner
  , Pi = !1;
function mi(n, e, t, i) {
    e.child = n === null ? z3(e, null, t, i) : qu(e, n.child, t, i)
}
function bC(n, e, t, i, r) {
    t = t.render;
    var s = e.ref;
    return Vu(e, r),
    i = KA(n, e, t, i, s, r),
    t = QA(),
    n !== null && !Pi ? (e.updateQueue = n.updateQueue,
    e.flags &= -2053,
    n.lanes &= ~r,
    Zs(n, e, r)) : (en && t && NA(e),
    e.flags |= 1,
    mi(n, e, i, r),
    e.child)
}
function CC(n, e, t, i, r) {
    if (n === null) {
        var s = t.type;
        return typeof s == "function" && !ow(s) && s.defaultProps === void 0 && t.compare === null && t.defaultProps === void 0 ? (e.tag = 15,
        e.type = s,
        uB(n, e, s, i, r)) : (n = eg(t.type, null, i, e, e.mode, r),
        n.ref = e.ref,
        n.return = e,
        e.child = n)
    }
    if (s = n.child,
    !(n.lanes & r)) {
        var o = s.memoizedProps;
        if (t = t.compare,
        t = t !== null ? t : cd,
        t(o, i) && n.ref === e.ref)
            return Zs(n, e, r)
    }
    return e.flags |= 1,
    n = Yo(s, i),
    n.ref = e.ref,
    n.return = e,
    e.child = n
}
function uB(n, e, t, i, r) {
    if (n !== null) {
        var s = n.memoizedProps;
        if (cd(s, i) && n.ref === e.ref)
            if (Pi = !1,
            e.pendingProps = i = s,
            (n.lanes & r) !== 0)
                n.flags & 131072 && (Pi = !0);
            else
                return e.lanes = n.lanes,
                Zs(n, e, r)
    }
    return b1(n, e, t, i, r)
}
function cB(n, e, t) {
    var i = e.pendingProps
      , r = i.children
      , s = n !== null ? n.memoizedState : null;
    if (i.mode === "hidden")
        if (!(e.mode & 1))
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            jt(Tu, Gi),
            Gi |= t;
        else {
            if (!(t & 1073741824))
                return n = s !== null ? s.baseLanes | t : t,
                e.lanes = e.childLanes = 1073741824,
                e.memoizedState = {
                    baseLanes: n,
                    cachePool: null,
                    transitions: null
                },
                e.updateQueue = null,
                jt(Tu, Gi),
                Gi |= n,
                null;
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            i = s !== null ? s.baseLanes : t,
            jt(Tu, Gi),
            Gi |= i
        }
    else
        s !== null ? (i = s.baseLanes | t,
        e.memoizedState = null) : i = t,
        jt(Tu, Gi),
        Gi |= i;
    return mi(n, e, r, t),
    e.child
}
function fB(n, e) {
    var t = e.ref;
    (n === null && t !== null || n !== null && n.ref !== t) && (e.flags |= 512,
    e.flags |= 2097152)
}
function b1(n, e, t, i, r) {
    var s = Ri(t) ? gl : ai.current;
    return s = Qu(e, s),
    Vu(e, r),
    t = KA(n, e, t, i, s, r),
    i = QA(),
    n !== null && !Pi ? (e.updateQueue = n.updateQueue,
    e.flags &= -2053,
    n.lanes &= ~r,
    Zs(n, e, r)) : (en && i && NA(e),
    e.flags |= 1,
    mi(n, e, t, r),
    e.child)
}
function EC(n, e, t, i, r) {
    if (Ri(t)) {
        var s = !0;
        bg(e)
    } else
        s = !1;
    if (Vu(e, r),
    e.stateNode === null)
        Zm(n, e),
        O3(e, t, i),
        S1(e, t, i, r),
        i = !0;
    else if (n === null) {
        var o = e.stateNode
          , a = e.memoizedProps;
        o.props = a;
        var l = o.context
          , c = t.contextType;
        typeof c == "object" && c !== null ? c = wr(c) : (c = Ri(t) ? gl : ai.current,
        c = Qu(e, c));
        var d = t.getDerivedStateFromProps
          , h = typeof d == "function" || typeof o.getSnapshotBeforeUpdate == "function";
        h || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== i || l !== c) && yC(e, o, i, c),
        Bo = !1;
        var p = e.memoizedState;
        o.state = p,
        Bg(e, i, o, r),
        l = e.memoizedState,
        a !== i || p !== l || Bi.current || Bo ? (typeof d == "function" && (w1(e, t, d, i),
        l = e.memoizedState),
        (a = Bo || vC(e, t, a, i, p, l, c)) ? (h || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(),
        typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()),
        typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
        e.memoizedProps = i,
        e.memoizedState = l),
        o.props = i,
        o.state = l,
        o.context = c,
        i = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
        i = !1)
    } else {
        o = e.stateNode,
        F3(n, e),
        a = e.memoizedProps,
        c = e.type === e.elementType ? a : Lr(e.type, a),
        o.props = c,
        h = e.pendingProps,
        p = o.context,
        l = t.contextType,
        typeof l == "object" && l !== null ? l = wr(l) : (l = Ri(t) ? gl : ai.current,
        l = Qu(e, l));
        var m = t.getDerivedStateFromProps;
        (d = typeof m == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== h || p !== l) && yC(e, o, i, l),
        Bo = !1,
        p = e.memoizedState,
        o.state = p,
        Bg(e, i, o, r);
        var y = e.memoizedState;
        a !== h || p !== y || Bi.current || Bo ? (typeof m == "function" && (w1(e, t, m, i),
        y = e.memoizedState),
        (c = Bo || vC(e, t, c, i, p, y, l) || !1) ? (d || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(i, y, l),
        typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(i, y, l)),
        typeof o.componentDidUpdate == "function" && (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 1024),
        e.memoizedProps = i,
        e.memoizedState = y),
        o.props = i,
        o.state = y,
        o.context = l,
        i = c) : (typeof o.componentDidUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 1024),
        i = !1)
    }
    return C1(n, e, t, i, s, r)
}
function C1(n, e, t, i, r, s) {
    fB(n, e);
    var o = (e.flags & 128) !== 0;
    if (!i && !o)
        return r && dC(e, t, !1),
        Zs(n, e, s);
    i = e.stateNode,
    iO.current = e;
    var a = o && typeof t.getDerivedStateFromError != "function" ? null : i.render();
    return e.flags |= 1,
    n !== null && o ? (e.child = qu(e, n.child, null, s),
    e.child = qu(e, null, a, s)) : mi(n, e, a, s),
    e.memoizedState = i.state,
    r && dC(e, t, !0),
    e.child
}
function dB(n) {
    var e = n.stateNode;
    e.pendingContext ? fC(n, e.pendingContext, e.pendingContext !== e.context) : e.context && fC(n, e.context, !1),
    jA(n, e.containerInfo)
}
function TC(n, e, t, i, r) {
    return Zu(),
    UA(r),
    e.flags |= 256,
    mi(n, e, t, i),
    e.child
}
var E1 = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function T1(n) {
    return {
        baseLanes: n,
        cachePool: null,
        transitions: null
    }
}
function hB(n, e, t) {
    var i = e.pendingProps, r = sn.current, s = !1, o = (e.flags & 128) !== 0, a;
    if ((a = o) || (a = n !== null && n.memoizedState === null ? !1 : (r & 2) !== 0),
    a ? (s = !0,
    e.flags &= -129) : (n === null || n.memoizedState !== null) && (r |= 1),
    jt(sn, r & 1),
    n === null)
        return _1(e),
        n = e.memoizedState,
        n !== null && (n = n.dehydrated,
        n !== null) ? (e.mode & 1 ? n.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1,
        null) : (o = i.children,
        n = i.fallback,
        s ? (i = e.mode,
        s = e.child,
        o = {
            mode: "hidden",
            children: o
        },
        !(i & 1) && s !== null ? (s.childLanes = 0,
        s.pendingProps = o) : s = m0(o, i, 0, null),
        n = ll(n, i, t, null),
        s.return = e,
        n.return = e,
        s.sibling = n,
        e.child = s,
        e.child.memoizedState = T1(t),
        e.memoizedState = E1,
        n) : $A(e, o));
    if (r = n.memoizedState,
    r !== null && (a = r.dehydrated,
    a !== null))
        return rO(n, e, o, i, a, r, t);
    if (s) {
        s = i.fallback,
        o = e.mode,
        r = n.child,
        a = r.sibling;
        var l = {
            mode: "hidden",
            children: i.children
        };
        return !(o & 1) && e.child !== r ? (i = e.child,
        i.childLanes = 0,
        i.pendingProps = l,
        e.deletions = null) : (i = Yo(r, l),
        i.subtreeFlags = r.subtreeFlags & 14680064),
        a !== null ? s = Yo(a, s) : (s = ll(s, o, t, null),
        s.flags |= 2),
        s.return = e,
        i.return = e,
        i.sibling = s,
        e.child = i,
        i = s,
        s = e.child,
        o = n.child.memoizedState,
        o = o === null ? T1(t) : {
            baseLanes: o.baseLanes | t,
            cachePool: null,
            transitions: o.transitions
        },
        s.memoizedState = o,
        s.childLanes = n.childLanes & ~t,
        e.memoizedState = E1,
        i
    }
    return s = n.child,
    n = s.sibling,
    i = Yo(s, {
        mode: "visible",
        children: i.children
    }),
    !(e.mode & 1) && (i.lanes = t),
    i.return = e,
    i.sibling = null,
    n !== null && (t = e.deletions,
    t === null ? (e.deletions = [n],
    e.flags |= 16) : t.push(n)),
    e.child = i,
    e.memoizedState = null,
    i
}
function $A(n, e) {
    return e = m0({
        mode: "visible",
        children: e
    }, n.mode, 0, null),
    e.return = n,
    n.child = e
}
function Fp(n, e, t, i) {
    return i !== null && UA(i),
    qu(e, n.child, null, t),
    n = $A(e, e.pendingProps.children),
    n.flags |= 2,
    e.memoizedState = null,
    n
}
function rO(n, e, t, i, r, s, o) {
    if (t)
        return e.flags & 256 ? (e.flags &= -257,
        i = Py(Error(Me(422))),
        Fp(n, e, o, i)) : e.memoizedState !== null ? (e.child = n.child,
        e.flags |= 128,
        null) : (s = i.fallback,
        r = e.mode,
        i = m0({
            mode: "visible",
            children: i.children
        }, r, 0, null),
        s = ll(s, r, o, null),
        s.flags |= 2,
        i.return = e,
        s.return = e,
        i.sibling = s,
        e.child = i,
        e.mode & 1 && qu(e, n.child, null, o),
        e.child.memoizedState = T1(o),
        e.memoizedState = E1,
        s);
    if (!(e.mode & 1))
        return Fp(n, e, o, null);
    if (r.data === "$!") {
        if (i = r.nextSibling && r.nextSibling.dataset,
        i)
            var a = i.dgst;
        return i = a,
        s = Error(Me(419)),
        i = Py(s, i, void 0),
        Fp(n, e, o, i)
    }
    if (a = (o & n.childLanes) !== 0,
    Pi || a) {
        if (i = Wn,
        i !== null) {
            switch (o & -o) {
            case 4:
                r = 2;
                break;
            case 16:
                r = 8;
                break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                r = 32;
                break;
            case 536870912:
                r = 268435456;
                break;
            default:
                r = 0
            }
            r = r & (i.suspendedLanes | o) ? 0 : r,
            r !== 0 && r !== s.retryLane && (s.retryLane = r,
            Qs(n, r),
            Gr(i, n, r, -1))
        }
        return sw(),
        i = Py(Error(Me(421))),
        Fp(n, e, o, i)
    }
    return r.data === "$?" ? (e.flags |= 128,
    e.child = n.child,
    e = vO.bind(null, n),
    r._reactRetry = e,
    null) : (n = s.treeContext,
    Vi = Wo(r.nextSibling),
    ji = e,
    en = !0,
    Fr = null,
    n !== null && (gr[vr++] = Os,
    gr[vr++] = Us,
    gr[vr++] = vl,
    Os = n.id,
    Us = n.overflow,
    vl = e),
    e = $A(e, i.children),
    e.flags |= 4096,
    e)
}
function PC(n, e, t) {
    n.lanes |= e;
    var i = n.alternate;
    i !== null && (i.lanes |= e),
    A1(n.return, e, t)
}
function By(n, e, t, i, r) {
    var s = n.memoizedState;
    s === null ? n.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: i,
        tail: t,
        tailMode: r
    } : (s.isBackwards = e,
    s.rendering = null,
    s.renderingStartTime = 0,
    s.last = i,
    s.tail = t,
    s.tailMode = r)
}
function pB(n, e, t) {
    var i = e.pendingProps
      , r = i.revealOrder
      , s = i.tail;
    if (mi(n, e, i.children, t),
    i = sn.current,
    i & 2)
        i = i & 1 | 2,
        e.flags |= 128;
    else {
        if (n !== null && n.flags & 128)
            e: for (n = e.child; n !== null; ) {
                if (n.tag === 13)
                    n.memoizedState !== null && PC(n, t, e);
                else if (n.tag === 19)
                    PC(n, t, e);
                else if (n.child !== null) {
                    n.child.return = n,
                    n = n.child;
                    continue
                }
                if (n === e)
                    break e;
                for (; n.sibling === null; ) {
                    if (n.return === null || n.return === e)
                        break e;
                    n = n.return
                }
                n.sibling.return = n.return,
                n = n.sibling
            }
        i &= 1
    }
    if (jt(sn, i),
    !(e.mode & 1))
        e.memoizedState = null;
    else
        switch (r) {
        case "forwards":
            for (t = e.child,
            r = null; t !== null; )
                n = t.alternate,
                n !== null && Rg(n) === null && (r = t),
                t = t.sibling;
            t = r,
            t === null ? (r = e.child,
            e.child = null) : (r = t.sibling,
            t.sibling = null),
            By(e, !1, r, t, s);
            break;
        case "backwards":
            for (t = null,
            r = e.child,
            e.child = null; r !== null; ) {
                if (n = r.alternate,
                n !== null && Rg(n) === null) {
                    e.child = r;
                    break
                }
                n = r.sibling,
                r.sibling = t,
                t = r,
                r = n
            }
            By(e, !0, t, null, s);
            break;
        case "together":
            By(e, !1, null, null, void 0);
            break;
        default:
            e.memoizedState = null
        }
    return e.child
}
function Zm(n, e) {
    !(e.mode & 1) && n !== null && (n.alternate = null,
    e.alternate = null,
    e.flags |= 2)
}
function Zs(n, e, t) {
    if (n !== null && (e.dependencies = n.dependencies),
    xl |= e.lanes,
    !(t & e.childLanes))
        return null;
    if (n !== null && e.child !== n.child)
        throw Error(Me(153));
    if (e.child !== null) {
        for (n = e.child,
        t = Yo(n, n.pendingProps),
        e.child = t,
        t.return = e; n.sibling !== null; )
            n = n.sibling,
            t = t.sibling = Yo(n, n.pendingProps),
            t.return = e;
        t.sibling = null
    }
    return e.child
}
function sO(n, e, t) {
    switch (e.tag) {
    case 3:
        dB(e),
        Zu();
        break;
    case 5:
        G3(e);
        break;
    case 1:
        Ri(e.type) && bg(e);
        break;
    case 4:
        jA(e, e.stateNode.containerInfo);
        break;
    case 10:
        var i = e.type._context
          , r = e.memoizedProps.value;
        jt(Tg, i._currentValue),
        i._currentValue = r;
        break;
    case 13:
        if (i = e.memoizedState,
        i !== null)
            return i.dehydrated !== null ? (jt(sn, sn.current & 1),
            e.flags |= 128,
            null) : t & e.child.childLanes ? hB(n, e, t) : (jt(sn, sn.current & 1),
            n = Zs(n, e, t),
            n !== null ? n.sibling : null);
        jt(sn, sn.current & 1);
        break;
    case 19:
        if (i = (t & e.childLanes) !== 0,
        n.flags & 128) {
            if (i)
                return pB(n, e, t);
            e.flags |= 128
        }
        if (r = e.memoizedState,
        r !== null && (r.rendering = null,
        r.tail = null,
        r.lastEffect = null),
        jt(sn, sn.current),
        i)
            break;
        return null;
    case 22:
    case 23:
        return e.lanes = 0,
        cB(n, e, t)
    }
    return Zs(n, e, t)
}
var mB, P1, gB, vB;
mB = function(n, e) {
    for (var t = e.child; t !== null; ) {
        if (t.tag === 5 || t.tag === 6)
            n.appendChild(t.stateNode);
        else if (t.tag !== 4 && t.child !== null) {
            t.child.return = t,
            t = t.child;
            continue
        }
        if (t === e)
            break;
        for (; t.sibling === null; ) {
            if (t.return === null || t.return === e)
                return;
            t = t.return
        }
        t.sibling.return = t.return,
        t = t.sibling
    }
}
;
P1 = function() {}
;
gB = function(n, e, t, i) {
    var r = n.memoizedProps;
    if (r !== i) {
        n = e.stateNode,
        Za(us.current);
        var s = null;
        switch (t) {
        case "input":
            r = Zx(n, r),
            i = Zx(n, i),
            s = [];
            break;
        case "select":
            r = cn({}, r, {
                value: void 0
            }),
            i = cn({}, i, {
                value: void 0
            }),
            s = [];
            break;
        case "textarea":
            r = e1(n, r),
            i = e1(n, i),
            s = [];
            break;
        default:
            typeof r.onClick != "function" && typeof i.onClick == "function" && (n.onclick = Sg)
        }
        n1(t, i);
        var o;
        t = null;
        for (c in r)
            if (!i.hasOwnProperty(c) && r.hasOwnProperty(c) && r[c] != null)
                if (c === "style") {
                    var a = r[c];
                    for (o in a)
                        a.hasOwnProperty(o) && (t || (t = {}),
                        t[o] = "")
                } else
                    c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (id.hasOwnProperty(c) ? s || (s = []) : (s = s || []).push(c, null));
        for (c in i) {
            var l = i[c];
            if (a = r != null ? r[c] : void 0,
            i.hasOwnProperty(c) && l !== a && (l != null || a != null))
                if (c === "style")
                    if (a) {
                        for (o in a)
                            !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (t || (t = {}),
                            t[o] = "");
                        for (o in l)
                            l.hasOwnProperty(o) && a[o] !== l[o] && (t || (t = {}),
                            t[o] = l[o])
                    } else
                        t || (s || (s = []),
                        s.push(c, t)),
                        t = l;
                else
                    c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                    a = a ? a.__html : void 0,
                    l != null && a !== l && (s = s || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (id.hasOwnProperty(c) ? (l != null && c === "onScroll" && Xt("scroll", n),
                    s || a === l || (s = [])) : (s = s || []).push(c, l))
        }
        t && (s = s || []).push("style", t);
        var c = s;
        (e.updateQueue = c) && (e.flags |= 4)
    }
}
;
vB = function(n, e, t, i) {
    t !== i && (e.flags |= 4)
}
;
function rf(n, e) {
    if (!en)
        switch (n.tailMode) {
        case "hidden":
            e = n.tail;
            for (var t = null; e !== null; )
                e.alternate !== null && (t = e),
                e = e.sibling;
            t === null ? n.tail = null : t.sibling = null;
            break;
        case "collapsed":
            t = n.tail;
            for (var i = null; t !== null; )
                t.alternate !== null && (i = t),
                t = t.sibling;
            i === null ? e || n.tail === null ? n.tail = null : n.tail.sibling = null : i.sibling = null
        }
}
function ii(n) {
    var e = n.alternate !== null && n.alternate.child === n.child
      , t = 0
      , i = 0;
    if (e)
        for (var r = n.child; r !== null; )
            t |= r.lanes | r.childLanes,
            i |= r.subtreeFlags & 14680064,
            i |= r.flags & 14680064,
            r.return = n,
            r = r.sibling;
    else
        for (r = n.child; r !== null; )
            t |= r.lanes | r.childLanes,
            i |= r.subtreeFlags,
            i |= r.flags,
            r.return = n,
            r = r.sibling;
    return n.subtreeFlags |= i,
    n.childLanes = t,
    e
}
function oO(n, e, t) {
    var i = e.pendingProps;
    switch (OA(e),
    e.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return ii(e),
        null;
    case 1:
        return Ri(e.type) && Mg(),
        ii(e),
        null;
    case 3:
        return i = e.stateNode,
        $u(),
        Kt(Bi),
        Kt(ai),
        XA(),
        i.pendingContext && (i.context = i.pendingContext,
        i.pendingContext = null),
        (n === null || n.child === null) && (Dp(e) ? e.flags |= 4 : n === null || n.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024,
        Fr !== null && (N1(Fr),
        Fr = null))),
        P1(n, e),
        ii(e),
        null;
    case 5:
        JA(e);
        var r = Za(md.current);
        if (t = e.type,
        n !== null && e.stateNode != null)
            gB(n, e, t, i, r),
            n.ref !== e.ref && (e.flags |= 512,
            e.flags |= 2097152);
        else {
            if (!i) {
                if (e.stateNode === null)
                    throw Error(Me(166));
                return ii(e),
                null
            }
            if (n = Za(us.current),
            Dp(e)) {
                i = e.stateNode,
                t = e.type;
                var s = e.memoizedProps;
                switch (i[os] = e,
                i[hd] = s,
                n = (e.mode & 1) !== 0,
                t) {
                case "dialog":
                    Xt("cancel", i),
                    Xt("close", i);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    Xt("load", i);
                    break;
                case "video":
                case "audio":
                    for (r = 0; r < Rf.length; r++)
                        Xt(Rf[r], i);
                    break;
                case "source":
                    Xt("error", i);
                    break;
                case "img":
                case "image":
                case "link":
                    Xt("error", i),
                    Xt("load", i);
                    break;
                case "details":
                    Xt("toggle", i);
                    break;
                case "input":
                    Ob(i, s),
                    Xt("invalid", i);
                    break;
                case "select":
                    i._wrapperState = {
                        wasMultiple: !!s.multiple
                    },
                    Xt("invalid", i);
                    break;
                case "textarea":
                    zb(i, s),
                    Xt("invalid", i)
                }
                n1(t, s),
                r = null;
                for (var o in s)
                    if (s.hasOwnProperty(o)) {
                        var a = s[o];
                        o === "children" ? typeof a == "string" ? i.textContent !== a && (s.suppressHydrationWarning !== !0 && Lp(i.textContent, a, n),
                        r = ["children", a]) : typeof a == "number" && i.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && Lp(i.textContent, a, n),
                        r = ["children", "" + a]) : id.hasOwnProperty(o) && a != null && o === "onScroll" && Xt("scroll", i)
                    }
                switch (t) {
                case "input":
                    bp(i),
                    Ub(i, s, !0);
                    break;
                case "textarea":
                    bp(i),
                    Gb(i);
                    break;
                case "select":
                case "option":
                    break;
                default:
                    typeof s.onClick == "function" && (i.onclick = Sg)
                }
                i = r,
                e.updateQueue = i,
                i !== null && (e.flags |= 4)
            } else {
                o = r.nodeType === 9 ? r : r.ownerDocument,
                n === "http://www.w3.org/1999/xhtml" && (n = WP(t)),
                n === "http://www.w3.org/1999/xhtml" ? t === "script" ? (n = o.createElement("div"),
                n.innerHTML = "<script><\/script>",
                n = n.removeChild(n.firstChild)) : typeof i.is == "string" ? n = o.createElement(t, {
                    is: i.is
                }) : (n = o.createElement(t),
                t === "select" && (o = n,
                i.multiple ? o.multiple = !0 : i.size && (o.size = i.size))) : n = o.createElementNS(n, t),
                n[os] = e,
                n[hd] = i,
                mB(n, e, !1, !1),
                e.stateNode = n;
                e: {
                    switch (o = i1(t, i),
                    t) {
                    case "dialog":
                        Xt("cancel", n),
                        Xt("close", n),
                        r = i;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        Xt("load", n),
                        r = i;
                        break;
                    case "video":
                    case "audio":
                        for (r = 0; r < Rf.length; r++)
                            Xt(Rf[r], n);
                        r = i;
                        break;
                    case "source":
                        Xt("error", n),
                        r = i;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        Xt("error", n),
                        Xt("load", n),
                        r = i;
                        break;
                    case "details":
                        Xt("toggle", n),
                        r = i;
                        break;
                    case "input":
                        Ob(n, i),
                        r = Zx(n, i),
                        Xt("invalid", n);
                        break;
                    case "option":
                        r = i;
                        break;
                    case "select":
                        n._wrapperState = {
                            wasMultiple: !!i.multiple
                        },
                        r = cn({}, i, {
                            value: void 0
                        }),
                        Xt("invalid", n);
                        break;
                    case "textarea":
                        zb(n, i),
                        r = e1(n, i),
                        Xt("invalid", n);
                        break;
                    default:
                        r = i
                    }
                    n1(t, r),
                    a = r;
                    for (s in a)
                        if (a.hasOwnProperty(s)) {
                            var l = a[s];
                            s === "style" ? XP(n, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                            l != null && jP(n, l)) : s === "children" ? typeof l == "string" ? (t !== "textarea" || l !== "") && rd(n, l) : typeof l == "number" && rd(n, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (id.hasOwnProperty(s) ? l != null && s === "onScroll" && Xt("scroll", n) : l != null && SA(n, s, l, o))
                        }
                    switch (t) {
                    case "input":
                        bp(n),
                        Ub(n, i, !1);
                        break;
                    case "textarea":
                        bp(n),
                        Gb(n);
                        break;
                    case "option":
                        i.value != null && n.setAttribute("value", "" + qo(i.value));
                        break;
                    case "select":
                        n.multiple = !!i.multiple,
                        s = i.value,
                        s != null ? Uu(n, !!i.multiple, s, !1) : i.defaultValue != null && Uu(n, !!i.multiple, i.defaultValue, !0);
                        break;
                    default:
                        typeof r.onClick == "function" && (n.onclick = Sg)
                    }
                    switch (t) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        i = !!i.autoFocus;
                        break e;
                    case "img":
                        i = !0;
                        break e;
                    default:
                        i = !1
                    }
                }
                i && (e.flags |= 4)
            }
            e.ref !== null && (e.flags |= 512,
            e.flags |= 2097152)
        }
        return ii(e),
        null;
    case 6:
        if (n && e.stateNode != null)
            vB(n, e, n.memoizedProps, i);
        else {
            if (typeof i != "string" && e.stateNode === null)
                throw Error(Me(166));
            if (t = Za(md.current),
            Za(us.current),
            Dp(e)) {
                if (i = e.stateNode,
                t = e.memoizedProps,
                i[os] = e,
                (s = i.nodeValue !== t) && (n = ji,
                n !== null))
                    switch (n.tag) {
                    case 3:
                        Lp(i.nodeValue, t, (n.mode & 1) !== 0);
                        break;
                    case 5:
                        n.memoizedProps.suppressHydrationWarning !== !0 && Lp(i.nodeValue, t, (n.mode & 1) !== 0)
                    }
                s && (e.flags |= 4)
            } else
                i = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(i),
                i[os] = e,
                e.stateNode = i
        }
        return ii(e),
        null;
    case 13:
        if (Kt(sn),
        i = e.memoizedState,
        n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) {
            if (en && Vi !== null && e.mode & 1 && !(e.flags & 128))
                D3(),
                Zu(),
                e.flags |= 98560,
                s = !1;
            else if (s = Dp(e),
            i !== null && i.dehydrated !== null) {
                if (n === null) {
                    if (!s)
                        throw Error(Me(318));
                    if (s = e.memoizedState,
                    s = s !== null ? s.dehydrated : null,
                    !s)
                        throw Error(Me(317));
                    s[os] = e
                } else
                    Zu(),
                    !(e.flags & 128) && (e.memoizedState = null),
                    e.flags |= 4;
                ii(e),
                s = !1
            } else
                Fr !== null && (N1(Fr),
                Fr = null),
                s = !0;
            if (!s)
                return e.flags & 65536 ? e : null
        }
        return e.flags & 128 ? (e.lanes = t,
        e) : (i = i !== null,
        i !== (n !== null && n.memoizedState !== null) && i && (e.child.flags |= 8192,
        e.mode & 1 && (n === null || sn.current & 1 ? In === 0 && (In = 3) : sw())),
        e.updateQueue !== null && (e.flags |= 4),
        ii(e),
        null);
    case 4:
        return $u(),
        P1(n, e),
        n === null && fd(e.stateNode.containerInfo),
        ii(e),
        null;
    case 10:
        return HA(e.type._context),
        ii(e),
        null;
    case 17:
        return Ri(e.type) && Mg(),
        ii(e),
        null;
    case 19:
        if (Kt(sn),
        s = e.memoizedState,
        s === null)
            return ii(e),
            null;
        if (i = (e.flags & 128) !== 0,
        o = s.rendering,
        o === null)
            if (i)
                rf(s, !1);
            else {
                if (In !== 0 || n !== null && n.flags & 128)
                    for (n = e.child; n !== null; ) {
                        if (o = Rg(n),
                        o !== null) {
                            for (e.flags |= 128,
                            rf(s, !1),
                            i = o.updateQueue,
                            i !== null && (e.updateQueue = i,
                            e.flags |= 4),
                            e.subtreeFlags = 0,
                            i = t,
                            t = e.child; t !== null; )
                                s = t,
                                n = i,
                                s.flags &= 14680066,
                                o = s.alternate,
                                o === null ? (s.childLanes = 0,
                                s.lanes = n,
                                s.child = null,
                                s.subtreeFlags = 0,
                                s.memoizedProps = null,
                                s.memoizedState = null,
                                s.updateQueue = null,
                                s.dependencies = null,
                                s.stateNode = null) : (s.childLanes = o.childLanes,
                                s.lanes = o.lanes,
                                s.child = o.child,
                                s.subtreeFlags = 0,
                                s.deletions = null,
                                s.memoizedProps = o.memoizedProps,
                                s.memoizedState = o.memoizedState,
                                s.updateQueue = o.updateQueue,
                                s.type = o.type,
                                n = o.dependencies,
                                s.dependencies = n === null ? null : {
                                    lanes: n.lanes,
                                    firstContext: n.firstContext
                                }),
                                t = t.sibling;
                            return jt(sn, sn.current & 1 | 2),
                            e.child
                        }
                        n = n.sibling
                    }
                s.tail !== null && An() > tc && (e.flags |= 128,
                i = !0,
                rf(s, !1),
                e.lanes = 4194304)
            }
        else {
            if (!i)
                if (n = Rg(o),
                n !== null) {
                    if (e.flags |= 128,
                    i = !0,
                    t = n.updateQueue,
                    t !== null && (e.updateQueue = t,
                    e.flags |= 4),
                    rf(s, !0),
                    s.tail === null && s.tailMode === "hidden" && !o.alternate && !en)
                        return ii(e),
                        null
                } else
                    2 * An() - s.renderingStartTime > tc && t !== 1073741824 && (e.flags |= 128,
                    i = !0,
                    rf(s, !1),
                    e.lanes = 4194304);
            s.isBackwards ? (o.sibling = e.child,
            e.child = o) : (t = s.last,
            t !== null ? t.sibling = o : e.child = o,
            s.last = o)
        }
        return s.tail !== null ? (e = s.tail,
        s.rendering = e,
        s.tail = e.sibling,
        s.renderingStartTime = An(),
        e.sibling = null,
        t = sn.current,
        jt(sn, i ? t & 1 | 2 : t & 1),
        e) : (ii(e),
        null);
    case 22:
    case 23:
        return rw(),
        i = e.memoizedState !== null,
        n !== null && n.memoizedState !== null !== i && (e.flags |= 8192),
        i && e.mode & 1 ? Gi & 1073741824 && (ii(e),
        e.subtreeFlags & 6 && (e.flags |= 8192)) : ii(e),
        null;
    case 24:
        return null;
    case 25:
        return null
    }
    throw Error(Me(156, e.tag))
}
function aO(n, e) {
    switch (OA(e),
    e.tag) {
    case 1:
        return Ri(e.type) && Mg(),
        n = e.flags,
        n & 65536 ? (e.flags = n & -65537 | 128,
        e) : null;
    case 3:
        return $u(),
        Kt(Bi),
        Kt(ai),
        XA(),
        n = e.flags,
        n & 65536 && !(n & 128) ? (e.flags = n & -65537 | 128,
        e) : null;
    case 5:
        return JA(e),
        null;
    case 13:
        if (Kt(sn),
        n = e.memoizedState,
        n !== null && n.dehydrated !== null) {
            if (e.alternate === null)
                throw Error(Me(340));
            Zu()
        }
        return n = e.flags,
        n & 65536 ? (e.flags = n & -65537 | 128,
        e) : null;
    case 19:
        return Kt(sn),
        null;
    case 4:
        return $u(),
        null;
    case 10:
        return HA(e.type._context),
        null;
    case 22:
    case 23:
        return rw(),
        null;
    case 24:
        return null;
    default:
        return null
    }
}
var Np = !1
  , oi = !1
  , lO = typeof WeakSet == "function" ? WeakSet : Set
  , He = null;
function Eu(n, e) {
    var t = n.ref;
    if (t !== null)
        if (typeof t == "function")
            try {
                t(null)
            } catch (i) {
                mn(n, e, i)
            }
        else
            t.current = null
}
function B1(n, e, t) {
    try {
        t()
    } catch (i) {
        mn(n, e, i)
    }
}
var BC = !1;
function uO(n, e) {
    if (h1 = _g,
    n = A3(),
    FA(n)) {
        if ("selectionStart"in n)
            var t = {
                start: n.selectionStart,
                end: n.selectionEnd
            };
        else
            e: {
                t = (t = n.ownerDocument) && t.defaultView || window;
                var i = t.getSelection && t.getSelection();
                if (i && i.rangeCount !== 0) {
                    t = i.anchorNode;
                    var r = i.anchorOffset
                      , s = i.focusNode;
                    i = i.focusOffset;
                    try {
                        t.nodeType,
                        s.nodeType
                    } catch {
                        t = null;
                        break e
                    }
                    var o = 0
                      , a = -1
                      , l = -1
                      , c = 0
                      , d = 0
                      , h = n
                      , p = null;
                    t: for (; ; ) {
                        for (var m; h !== t || r !== 0 && h.nodeType !== 3 || (a = o + r),
                        h !== s || i !== 0 && h.nodeType !== 3 || (l = o + i),
                        h.nodeType === 3 && (o += h.nodeValue.length),
                        (m = h.firstChild) !== null; )
                            p = h,
                            h = m;
                        for (; ; ) {
                            if (h === n)
                                break t;
                            if (p === t && ++c === r && (a = o),
                            p === s && ++d === i && (l = o),
                            (m = h.nextSibling) !== null)
                                break;
                            h = p,
                            p = h.parentNode
                        }
                        h = m
                    }
                    t = a === -1 || l === -1 ? null : {
                        start: a,
                        end: l
                    }
                } else
                    t = null
            }
        t = t || {
            start: 0,
            end: 0
        }
    } else
        t = null;
    for (p1 = {
        focusedElem: n,
        selectionRange: t
    },
    _g = !1,
    He = e; He !== null; )
        if (e = He,
        n = e.child,
        (e.subtreeFlags & 1028) !== 0 && n !== null)
            n.return = e,
            He = n;
        else
            for (; He !== null; ) {
                e = He;
                try {
                    var y = e.alternate;
                    if (e.flags & 1024)
                        switch (e.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (y !== null) {
                                var v = y.memoizedProps
                                  , x = y.memoizedState
                                  , _ = e.stateNode
                                  , A = _.getSnapshotBeforeUpdate(e.elementType === e.type ? v : Lr(e.type, v), x);
                                _.__reactInternalSnapshotBeforeUpdate = A
                            }
                            break;
                        case 3:
                            var w = e.stateNode.containerInfo;
                            w.nodeType === 1 ? w.textContent = "" : w.nodeType === 9 && w.documentElement && w.removeChild(w.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(Me(163))
                        }
                } catch (M) {
                    mn(e, e.return, M)
                }
                if (n = e.sibling,
                n !== null) {
                    n.return = e.return,
                    He = n;
                    break
                }
                He = e.return
            }
    return y = BC,
    BC = !1,
    y
}
function Gf(n, e, t) {
    var i = e.updateQueue;
    if (i = i !== null ? i.lastEffect : null,
    i !== null) {
        var r = i = i.next;
        do {
            if ((r.tag & n) === n) {
                var s = r.destroy;
                r.destroy = void 0,
                s !== void 0 && B1(e, t, s)
            }
            r = r.next
        } while (r !== i)
    }
}
function h0(n, e) {
    if (e = e.updateQueue,
    e = e !== null ? e.lastEffect : null,
    e !== null) {
        var t = e = e.next;
        do {
            if ((t.tag & n) === n) {
                var i = t.create;
                t.destroy = i()
            }
            t = t.next
        } while (t !== e)
    }
}
function R1(n) {
    var e = n.ref;
    if (e !== null) {
        var t = n.stateNode;
        switch (n.tag) {
        case 5:
            n = t;
            break;
        default:
            n = t
        }
        typeof e == "function" ? e(n) : e.current = n
    }
}
function yB(n) {
    var e = n.alternate;
    e !== null && (n.alternate = null,
    yB(e)),
    n.child = null,
    n.deletions = null,
    n.sibling = null,
    n.tag === 5 && (e = n.stateNode,
    e !== null && (delete e[os],
    delete e[hd],
    delete e[v1],
    delete e[jN],
    delete e[JN])),
    n.stateNode = null,
    n.return = null,
    n.dependencies = null,
    n.memoizedProps = null,
    n.memoizedState = null,
    n.pendingProps = null,
    n.stateNode = null,
    n.updateQueue = null
}
function xB(n) {
    return n.tag === 5 || n.tag === 3 || n.tag === 4
}
function RC(n) {
    e: for (; ; ) {
        for (; n.sibling === null; ) {
            if (n.return === null || xB(n.return))
                return null;
            n = n.return
        }
        for (n.sibling.return = n.return,
        n = n.sibling; n.tag !== 5 && n.tag !== 6 && n.tag !== 18; ) {
            if (n.flags & 2 || n.child === null || n.tag === 4)
                continue e;
            n.child.return = n,
            n = n.child
        }
        if (!(n.flags & 2))
            return n.stateNode
    }
}
function I1(n, e, t) {
    var i = n.tag;
    if (i === 5 || i === 6)
        n = n.stateNode,
        e ? t.nodeType === 8 ? t.parentNode.insertBefore(n, e) : t.insertBefore(n, e) : (t.nodeType === 8 ? (e = t.parentNode,
        e.insertBefore(n, t)) : (e = t,
        e.appendChild(n)),
        t = t._reactRootContainer,
        t != null || e.onclick !== null || (e.onclick = Sg));
    else if (i !== 4 && (n = n.child,
    n !== null))
        for (I1(n, e, t),
        n = n.sibling; n !== null; )
            I1(n, e, t),
            n = n.sibling
}
function L1(n, e, t) {
    var i = n.tag;
    if (i === 5 || i === 6)
        n = n.stateNode,
        e ? t.insertBefore(n, e) : t.appendChild(n);
    else if (i !== 4 && (n = n.child,
    n !== null))
        for (L1(n, e, t),
        n = n.sibling; n !== null; )
            L1(n, e, t),
            n = n.sibling
}
var Jn = null
  , Dr = !1;
function yo(n, e, t) {
    for (t = t.child; t !== null; )
        _B(n, e, t),
        t = t.sibling
}
function _B(n, e, t) {
    if (ls && typeof ls.onCommitFiberUnmount == "function")
        try {
            ls.onCommitFiberUnmount(s0, t)
        } catch {}
    switch (t.tag) {
    case 5:
        oi || Eu(t, e);
    case 6:
        var i = Jn
          , r = Dr;
        Jn = null,
        yo(n, e, t),
        Jn = i,
        Dr = r,
        Jn !== null && (Dr ? (n = Jn,
        t = t.stateNode,
        n.nodeType === 8 ? n.parentNode.removeChild(t) : n.removeChild(t)) : Jn.removeChild(t.stateNode));
        break;
    case 18:
        Jn !== null && (Dr ? (n = Jn,
        t = t.stateNode,
        n.nodeType === 8 ? Sy(n.parentNode, t) : n.nodeType === 1 && Sy(n, t),
        ld(n)) : Sy(Jn, t.stateNode));
        break;
    case 4:
        i = Jn,
        r = Dr,
        Jn = t.stateNode.containerInfo,
        Dr = !0,
        yo(n, e, t),
        Jn = i,
        Dr = r;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!oi && (i = t.updateQueue,
        i !== null && (i = i.lastEffect,
        i !== null))) {
            r = i = i.next;
            do {
                var s = r
                  , o = s.destroy;
                s = s.tag,
                o !== void 0 && (s & 2 || s & 4) && B1(t, e, o),
                r = r.next
            } while (r !== i)
        }
        yo(n, e, t);
        break;
    case 1:
        if (!oi && (Eu(t, e),
        i = t.stateNode,
        typeof i.componentWillUnmount == "function"))
            try {
                i.props = t.memoizedProps,
                i.state = t.memoizedState,
                i.componentWillUnmount()
            } catch (a) {
                mn(t, e, a)
            }
        yo(n, e, t);
        break;
    case 21:
        yo(n, e, t);
        break;
    case 22:
        t.mode & 1 ? (oi = (i = oi) || t.memoizedState !== null,
        yo(n, e, t),
        oi = i) : yo(n, e, t);
        break;
    default:
        yo(n, e, t)
    }
}
function IC(n) {
    var e = n.updateQueue;
    if (e !== null) {
        n.updateQueue = null;
        var t = n.stateNode;
        t === null && (t = n.stateNode = new lO),
        e.forEach(function(i) {
            var r = yO.bind(null, n, i);
            t.has(i) || (t.add(i),
            i.then(r, r))
        })
    }
}
function Pr(n, e) {
    var t = e.deletions;
    if (t !== null)
        for (var i = 0; i < t.length; i++) {
            var r = t[i];
            try {
                var s = n
                  , o = e
                  , a = o;
                e: for (; a !== null; ) {
                    switch (a.tag) {
                    case 5:
                        Jn = a.stateNode,
                        Dr = !1;
                        break e;
                    case 3:
                        Jn = a.stateNode.containerInfo,
                        Dr = !0;
                        break e;
                    case 4:
                        Jn = a.stateNode.containerInfo,
                        Dr = !0;
                        break e
                    }
                    a = a.return
                }
                if (Jn === null)
                    throw Error(Me(160));
                _B(s, o, r),
                Jn = null,
                Dr = !1;
                var l = r.alternate;
                l !== null && (l.return = null),
                r.return = null
            } catch (c) {
                mn(r, e, c)
            }
        }
    if (e.subtreeFlags & 12854)
        for (e = e.child; e !== null; )
            AB(e, n),
            e = e.sibling
}
function AB(n, e) {
    var t = n.alternate
      , i = n.flags;
    switch (n.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (Pr(e, n),
        is(n),
        i & 4) {
            try {
                Gf(3, n, n.return),
                h0(3, n)
            } catch (v) {
                mn(n, n.return, v)
            }
            try {
                Gf(5, n, n.return)
            } catch (v) {
                mn(n, n.return, v)
            }
        }
        break;
    case 1:
        Pr(e, n),
        is(n),
        i & 512 && t !== null && Eu(t, t.return);
        break;
    case 5:
        if (Pr(e, n),
        is(n),
        i & 512 && t !== null && Eu(t, t.return),
        n.flags & 32) {
            var r = n.stateNode;
            try {
                rd(r, "")
            } catch (v) {
                mn(n, n.return, v)
            }
        }
        if (i & 4 && (r = n.stateNode,
        r != null)) {
            var s = n.memoizedProps
              , o = t !== null ? t.memoizedProps : s
              , a = n.type
              , l = n.updateQueue;
            if (n.updateQueue = null,
            l !== null)
                try {
                    a === "input" && s.type === "radio" && s.name != null && HP(r, s),
                    i1(a, o);
                    var c = i1(a, s);
                    for (o = 0; o < l.length; o += 2) {
                        var d = l[o]
                          , h = l[o + 1];
                        d === "style" ? XP(r, h) : d === "dangerouslySetInnerHTML" ? jP(r, h) : d === "children" ? rd(r, h) : SA(r, d, h, c)
                    }
                    switch (a) {
                    case "input":
                        qx(r, s);
                        break;
                    case "textarea":
                        VP(r, s);
                        break;
                    case "select":
                        var p = r._wrapperState.wasMultiple;
                        r._wrapperState.wasMultiple = !!s.multiple;
                        var m = s.value;
                        m != null ? Uu(r, !!s.multiple, m, !1) : p !== !!s.multiple && (s.defaultValue != null ? Uu(r, !!s.multiple, s.defaultValue, !0) : Uu(r, !!s.multiple, s.multiple ? [] : "", !1))
                    }
                    r[hd] = s
                } catch (v) {
                    mn(n, n.return, v)
                }
        }
        break;
    case 6:
        if (Pr(e, n),
        is(n),
        i & 4) {
            if (n.stateNode === null)
                throw Error(Me(162));
            r = n.stateNode,
            s = n.memoizedProps;
            try {
                r.nodeValue = s
            } catch (v) {
                mn(n, n.return, v)
            }
        }
        break;
    case 3:
        if (Pr(e, n),
        is(n),
        i & 4 && t !== null && t.memoizedState.isDehydrated)
            try {
                ld(e.containerInfo)
            } catch (v) {
                mn(n, n.return, v)
            }
        break;
    case 4:
        Pr(e, n),
        is(n);
        break;
    case 13:
        Pr(e, n),
        is(n),
        r = n.child,
        r.flags & 8192 && (s = r.memoizedState !== null,
        r.stateNode.isHidden = s,
        !s || r.alternate !== null && r.alternate.memoizedState !== null || (nw = An())),
        i & 4 && IC(n);
        break;
    case 22:
        if (d = t !== null && t.memoizedState !== null,
        n.mode & 1 ? (oi = (c = oi) || d,
        Pr(e, n),
        oi = c) : Pr(e, n),
        is(n),
        i & 8192) {
            if (c = n.memoizedState !== null,
            (n.stateNode.isHidden = c) && !d && n.mode & 1)
                for (He = n,
                d = n.child; d !== null; ) {
                    for (h = He = d; He !== null; ) {
                        switch (p = He,
                        m = p.child,
                        p.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            Gf(4, p, p.return);
                            break;
                        case 1:
                            Eu(p, p.return);
                            var y = p.stateNode;
                            if (typeof y.componentWillUnmount == "function") {
                                i = p,
                                t = p.return;
                                try {
                                    e = i,
                                    y.props = e.memoizedProps,
                                    y.state = e.memoizedState,
                                    y.componentWillUnmount()
                                } catch (v) {
                                    mn(i, t, v)
                                }
                            }
                            break;
                        case 5:
                            Eu(p, p.return);
                            break;
                        case 22:
                            if (p.memoizedState !== null) {
                                DC(h);
                                continue
                            }
                        }
                        m !== null ? (m.return = p,
                        He = m) : DC(h)
                    }
                    d = d.sibling
                }
            e: for (d = null,
            h = n; ; ) {
                if (h.tag === 5) {
                    if (d === null) {
                        d = h;
                        try {
                            r = h.stateNode,
                            c ? (s = r.style,
                            typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = h.stateNode,
                            l = h.memoizedProps.style,
                            o = l != null && l.hasOwnProperty("display") ? l.display : null,
                            a.style.display = JP("display", o))
                        } catch (v) {
                            mn(n, n.return, v)
                        }
                    }
                } else if (h.tag === 6) {
                    if (d === null)
                        try {
                            h.stateNode.nodeValue = c ? "" : h.memoizedProps
                        } catch (v) {
                            mn(n, n.return, v)
                        }
                } else if ((h.tag !== 22 && h.tag !== 23 || h.memoizedState === null || h === n) && h.child !== null) {
                    h.child.return = h,
                    h = h.child;
                    continue
                }
                if (h === n)
                    break e;
                for (; h.sibling === null; ) {
                    if (h.return === null || h.return === n)
                        break e;
                    d === h && (d = null),
                    h = h.return
                }
                d === h && (d = null),
                h.sibling.return = h.return,
                h = h.sibling
            }
        }
        break;
    case 19:
        Pr(e, n),
        is(n),
        i & 4 && IC(n);
        break;
    case 21:
        break;
    default:
        Pr(e, n),
        is(n)
    }
}
function is(n) {
    var e = n.flags;
    if (e & 2) {
        try {
            e: {
                for (var t = n.return; t !== null; ) {
                    if (xB(t)) {
                        var i = t;
                        break e
                    }
                    t = t.return
                }
                throw Error(Me(160))
            }
            switch (i.tag) {
            case 5:
                var r = i.stateNode;
                i.flags & 32 && (rd(r, ""),
                i.flags &= -33);
                var s = RC(n);
                L1(n, s, r);
                break;
            case 3:
            case 4:
                var o = i.stateNode.containerInfo
                  , a = RC(n);
                I1(n, a, o);
                break;
            default:
                throw Error(Me(161))
            }
        } catch (l) {
            mn(n, n.return, l)
        }
        n.flags &= -3
    }
    e & 4096 && (n.flags &= -4097)
}
function cO(n, e, t) {
    He = n,
    wB(n)
}
function wB(n, e, t) {
    for (var i = (n.mode & 1) !== 0; He !== null; ) {
        var r = He
          , s = r.child;
        if (r.tag === 22 && i) {
            var o = r.memoizedState !== null || Np;
            if (!o) {
                var a = r.alternate
                  , l = a !== null && a.memoizedState !== null || oi;
                a = Np;
                var c = oi;
                if (Np = o,
                (oi = l) && !c)
                    for (He = r; He !== null; )
                        o = He,
                        l = o.child,
                        o.tag === 22 && o.memoizedState !== null ? kC(r) : l !== null ? (l.return = o,
                        He = l) : kC(r);
                for (; s !== null; )
                    He = s,
                    wB(s),
                    s = s.sibling;
                He = r,
                Np = a,
                oi = c
            }
            LC(n)
        } else
            r.subtreeFlags & 8772 && s !== null ? (s.return = r,
            He = s) : LC(n)
    }
}
function LC(n) {
    for (; He !== null; ) {
        var e = He;
        if (e.flags & 8772) {
            var t = e.alternate;
            try {
                if (e.flags & 8772)
                    switch (e.tag) {
                    case 0:
                    case 11:
                    case 15:
                        oi || h0(5, e);
                        break;
                    case 1:
                        var i = e.stateNode;
                        if (e.flags & 4 && !oi)
                            if (t === null)
                                i.componentDidMount();
                            else {
                                var r = e.elementType === e.type ? t.memoizedProps : Lr(e.type, t.memoizedProps);
                                i.componentDidUpdate(r, t.memoizedState, i.__reactInternalSnapshotBeforeUpdate)
                            }
                        var s = e.updateQueue;
                        s !== null && gC(e, s, i);
                        break;
                    case 3:
                        var o = e.updateQueue;
                        if (o !== null) {
                            if (t = null,
                            e.child !== null)
                                switch (e.child.tag) {
                                case 5:
                                    t = e.child.stateNode;
                                    break;
                                case 1:
                                    t = e.child.stateNode
                                }
                            gC(e, o, t)
                        }
                        break;
                    case 5:
                        var a = e.stateNode;
                        if (t === null && e.flags & 4) {
                            t = a;
                            var l = e.memoizedProps;
                            switch (e.type) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                l.autoFocus && t.focus();
                                break;
                            case "img":
                                l.src && (t.src = l.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (e.memoizedState === null) {
                            var c = e.alternate;
                            if (c !== null) {
                                var d = c.memoizedState;
                                if (d !== null) {
                                    var h = d.dehydrated;
                                    h !== null && ld(h)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(Me(163))
                    }
                oi || e.flags & 512 && R1(e)
            } catch (p) {
                mn(e, e.return, p)
            }
        }
        if (e === n) {
            He = null;
            break
        }
        if (t = e.sibling,
        t !== null) {
            t.return = e.return,
            He = t;
            break
        }
        He = e.return
    }
}
function DC(n) {
    for (; He !== null; ) {
        var e = He;
        if (e === n) {
            He = null;
            break
        }
        var t = e.sibling;
        if (t !== null) {
            t.return = e.return,
            He = t;
            break
        }
        He = e.return
    }
}
function kC(n) {
    for (; He !== null; ) {
        var e = He;
        try {
            switch (e.tag) {
            case 0:
            case 11:
            case 15:
                var t = e.return;
                try {
                    h0(4, e)
                } catch (l) {
                    mn(e, t, l)
                }
                break;
            case 1:
                var i = e.stateNode;
                if (typeof i.componentDidMount == "function") {
                    var r = e.return;
                    try {
                        i.componentDidMount()
                    } catch (l) {
                        mn(e, r, l)
                    }
                }
                var s = e.return;
                try {
                    R1(e)
                } catch (l) {
                    mn(e, s, l)
                }
                break;
            case 5:
                var o = e.return;
                try {
                    R1(e)
                } catch (l) {
                    mn(e, o, l)
                }
            }
        } catch (l) {
            mn(e, e.return, l)
        }
        if (e === n) {
            He = null;
            break
        }
        var a = e.sibling;
        if (a !== null) {
            a.return = e.return,
            He = a;
            break
        }
        He = e.return
    }
}
var fO = Math.ceil
  , Dg = ro.ReactCurrentDispatcher
  , ew = ro.ReactCurrentOwner
  , _r = ro.ReactCurrentBatchConfig
  , Lt = 0
  , Wn = null
  , En = null
  , Kn = 0
  , Gi = 0
  , Tu = fa(0)
  , In = 0
  , xd = null
  , xl = 0
  , p0 = 0
  , tw = 0
  , Hf = null
  , Ei = null
  , nw = 0
  , tc = 1 / 0
  , Ds = null
  , kg = !1
  , D1 = null
  , Jo = null
  , Op = !1
  , Fo = null
  , Fg = 0
  , Vf = 0
  , k1 = null
  , qm = -1
  , $m = 0;
function vi() {
    return Lt & 6 ? An() : qm !== -1 ? qm : qm = An()
}
function Xo(n) {
    return n.mode & 1 ? Lt & 2 && Kn !== 0 ? Kn & -Kn : YN.transition !== null ? ($m === 0 && ($m = s3()),
    $m) : (n = zt,
    n !== 0 || (n = window.event,
    n = n === void 0 ? 16 : d3(n.type)),
    n) : 1
}
function Gr(n, e, t, i) {
    if (50 < Vf)
        throw Vf = 0,
        k1 = null,
        Error(Me(185));
    Yd(n, t, i),
    (!(Lt & 2) || n !== Wn) && (n === Wn && (!(Lt & 2) && (p0 |= t),
    In === 4 && Do(n, Kn)),
    Ii(n, i),
    t === 1 && Lt === 0 && !(e.mode & 1) && (tc = An() + 500,
    c0 && da()))
}
function Ii(n, e) {
    var t = n.callbackNode;
    YF(n, e);
    var i = xg(n, n === Wn ? Kn : 0);
    if (i === 0)
        t !== null && Wb(t),
        n.callbackNode = null,
        n.callbackPriority = 0;
    else if (e = i & -i,
    n.callbackPriority !== e) {
        if (t != null && Wb(t),
        e === 1)
            n.tag === 0 ? XN(FC.bind(null, n)) : R3(FC.bind(null, n)),
            VN(function() {
                !(Lt & 6) && da()
            }),
            t = null;
        else {
            switch (o3(i)) {
            case 1:
                t = TA;
                break;
            case 4:
                t = i3;
                break;
            case 16:
                t = yg;
                break;
            case 536870912:
                t = r3;
                break;
            default:
                t = yg
            }
            t = BB(t, SB.bind(null, n))
        }
        n.callbackPriority = e,
        n.callbackNode = t
    }
}
function SB(n, e) {
    if (qm = -1,
    $m = 0,
    Lt & 6)
        throw Error(Me(327));
    var t = n.callbackNode;
    if (Wu() && n.callbackNode !== t)
        return null;
    var i = xg(n, n === Wn ? Kn : 0);
    if (i === 0)
        return null;
    if (i & 30 || i & n.expiredLanes || e)
        e = Ng(n, i);
    else {
        e = i;
        var r = Lt;
        Lt |= 2;
        var s = bB();
        (Wn !== n || Kn !== e) && (Ds = null,
        tc = An() + 500,
        al(n, e));
        do
            try {
                pO();
                break
            } catch (a) {
                MB(n, a)
            }
        while (1);
        GA(),
        Dg.current = s,
        Lt = r,
        En !== null ? e = 0 : (Wn = null,
        Kn = 0,
        e = In)
    }
    if (e !== 0) {
        if (e === 2 && (r = l1(n),
        r !== 0 && (i = r,
        e = F1(n, r))),
        e === 1)
            throw t = xd,
            al(n, 0),
            Do(n, i),
            Ii(n, An()),
            t;
        if (e === 6)
            Do(n, i);
        else {
            if (r = n.current.alternate,
            !(i & 30) && !dO(r) && (e = Ng(n, i),
            e === 2 && (s = l1(n),
            s !== 0 && (i = s,
            e = F1(n, s))),
            e === 1))
                throw t = xd,
                al(n, 0),
                Do(n, i),
                Ii(n, An()),
                t;
            switch (n.finishedWork = r,
            n.finishedLanes = i,
            e) {
            case 0:
            case 1:
                throw Error(Me(345));
            case 2:
                za(n, Ei, Ds);
                break;
            case 3:
                if (Do(n, i),
                (i & 130023424) === i && (e = nw + 500 - An(),
                10 < e)) {
                    if (xg(n, 0) !== 0)
                        break;
                    if (r = n.suspendedLanes,
                    (r & i) !== i) {
                        vi(),
                        n.pingedLanes |= n.suspendedLanes & r;
                        break
                    }
                    n.timeoutHandle = g1(za.bind(null, n, Ei, Ds), e);
                    break
                }
                za(n, Ei, Ds);
                break;
            case 4:
                if (Do(n, i),
                (i & 4194240) === i)
                    break;
                for (e = n.eventTimes,
                r = -1; 0 < i; ) {
                    var o = 31 - zr(i);
                    s = 1 << o,
                    o = e[o],
                    o > r && (r = o),
                    i &= ~s
                }
                if (i = r,
                i = An() - i,
                i = (120 > i ? 120 : 480 > i ? 480 : 1080 > i ? 1080 : 1920 > i ? 1920 : 3e3 > i ? 3e3 : 4320 > i ? 4320 : 1960 * fO(i / 1960)) - i,
                10 < i) {
                    n.timeoutHandle = g1(za.bind(null, n, Ei, Ds), i);
                    break
                }
                za(n, Ei, Ds);
                break;
            case 5:
                za(n, Ei, Ds);
                break;
            default:
                throw Error(Me(329))
            }
        }
    }
    return Ii(n, An()),
    n.callbackNode === t ? SB.bind(null, n) : null
}
function F1(n, e) {
    var t = Hf;
    return n.current.memoizedState.isDehydrated && (al(n, e).flags |= 256),
    n = Ng(n, e),
    n !== 2 && (e = Ei,
    Ei = t,
    e !== null && N1(e)),
    n
}
function N1(n) {
    Ei === null ? Ei = n : Ei.push.apply(Ei, n)
}
function dO(n) {
    for (var e = n; ; ) {
        if (e.flags & 16384) {
            var t = e.updateQueue;
            if (t !== null && (t = t.stores,
            t !== null))
                for (var i = 0; i < t.length; i++) {
                    var r = t[i]
                      , s = r.getSnapshot;
                    r = r.value;
                    try {
                        if (!Wr(s(), r))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (t = e.child,
        e.subtreeFlags & 16384 && t !== null)
            t.return = e,
            e = t;
        else {
            if (e === n)
                break;
            for (; e.sibling === null; ) {
                if (e.return === null || e.return === n)
                    return !0;
                e = e.return
            }
            e.sibling.return = e.return,
            e = e.sibling
        }
    }
    return !0
}
function Do(n, e) {
    for (e &= ~tw,
    e &= ~p0,
    n.suspendedLanes |= e,
    n.pingedLanes &= ~e,
    n = n.expirationTimes; 0 < e; ) {
        var t = 31 - zr(e)
          , i = 1 << t;
        n[t] = -1,
        e &= ~i
    }
}
function FC(n) {
    if (Lt & 6)
        throw Error(Me(327));
    Wu();
    var e = xg(n, 0);
    if (!(e & 1))
        return Ii(n, An()),
        null;
    var t = Ng(n, e);
    if (n.tag !== 0 && t === 2) {
        var i = l1(n);
        i !== 0 && (e = i,
        t = F1(n, i))
    }
    if (t === 1)
        throw t = xd,
        al(n, 0),
        Do(n, e),
        Ii(n, An()),
        t;
    if (t === 6)
        throw Error(Me(345));
    return n.finishedWork = n.current.alternate,
    n.finishedLanes = e,
    za(n, Ei, Ds),
    Ii(n, An()),
    null
}
function iw(n, e) {
    var t = Lt;
    Lt |= 1;
    try {
        return n(e)
    } finally {
        Lt = t,
        Lt === 0 && (tc = An() + 500,
        c0 && da())
    }
}
function _l(n) {
    Fo !== null && Fo.tag === 0 && !(Lt & 6) && Wu();
    var e = Lt;
    Lt |= 1;
    var t = _r.transition
      , i = zt;
    try {
        if (_r.transition = null,
        zt = 1,
        n)
            return n()
    } finally {
        zt = i,
        _r.transition = t,
        Lt = e,
        !(Lt & 6) && da()
    }
}
function rw() {
    Gi = Tu.current,
    Kt(Tu)
}
function al(n, e) {
    n.finishedWork = null,
    n.finishedLanes = 0;
    var t = n.timeoutHandle;
    if (t !== -1 && (n.timeoutHandle = -1,
    HN(t)),
    En !== null)
        for (t = En.return; t !== null; ) {
            var i = t;
            switch (OA(i),
            i.tag) {
            case 1:
                i = i.type.childContextTypes,
                i != null && Mg();
                break;
            case 3:
                $u(),
                Kt(Bi),
                Kt(ai),
                XA();
                break;
            case 5:
                JA(i);
                break;
            case 4:
                $u();
                break;
            case 13:
                Kt(sn);
                break;
            case 19:
                Kt(sn);
                break;
            case 10:
                HA(i.type._context);
                break;
            case 22:
            case 23:
                rw()
            }
            t = t.return
        }
    if (Wn = n,
    En = n = Yo(n.current, null),
    Kn = Gi = e,
    In = 0,
    xd = null,
    tw = p0 = xl = 0,
    Ei = Hf = null,
    Qa !== null) {
        for (e = 0; e < Qa.length; e++)
            if (t = Qa[e],
            i = t.interleaved,
            i !== null) {
                t.interleaved = null;
                var r = i.next
                  , s = t.pending;
                if (s !== null) {
                    var o = s.next;
                    s.next = r,
                    i.next = o
                }
                t.pending = i
            }
        Qa = null
    }
    return n
}
function MB(n, e) {
    do {
        var t = En;
        try {
            if (GA(),
            Km.current = Lg,
            Ig) {
                for (var i = un.memoizedState; i !== null; ) {
                    var r = i.queue;
                    r !== null && (r.pending = null),
                    i = i.next
                }
                Ig = !1
            }
            if (yl = 0,
            Vn = Rn = un = null,
            zf = !1,
            gd = 0,
            ew.current = null,
            t === null || t.return === null) {
                In = 1,
                xd = e,
                En = null;
                break
            }
            e: {
                var s = n
                  , o = t.return
                  , a = t
                  , l = e;
                if (e = Kn,
                a.flags |= 32768,
                l !== null && typeof l == "object" && typeof l.then == "function") {
                    var c = l
                      , d = a
                      , h = d.tag;
                    if (!(d.mode & 1) && (h === 0 || h === 11 || h === 15)) {
                        var p = d.alternate;
                        p ? (d.updateQueue = p.updateQueue,
                        d.memoizedState = p.memoizedState,
                        d.lanes = p.lanes) : (d.updateQueue = null,
                        d.memoizedState = null)
                    }
                    var m = SC(o);
                    if (m !== null) {
                        m.flags &= -257,
                        MC(m, o, a, s, e),
                        m.mode & 1 && wC(s, c, e),
                        e = m,
                        l = c;
                        var y = e.updateQueue;
                        if (y === null) {
                            var v = new Set;
                            v.add(l),
                            e.updateQueue = v
                        } else
                            y.add(l);
                        break e
                    } else {
                        if (!(e & 1)) {
                            wC(s, c, e),
                            sw();
                            break e
                        }
                        l = Error(Me(426))
                    }
                } else if (en && a.mode & 1) {
                    var x = SC(o);
                    if (x !== null) {
                        !(x.flags & 65536) && (x.flags |= 256),
                        MC(x, o, a, s, e),
                        UA(ec(l, a));
                        break e
                    }
                }
                s = l = ec(l, a),
                In !== 4 && (In = 2),
                Hf === null ? Hf = [s] : Hf.push(s),
                s = o;
                do {
                    switch (s.tag) {
                    case 3:
                        s.flags |= 65536,
                        e &= -e,
                        s.lanes |= e;
                        var _ = aB(s, l, e);
                        mC(s, _);
                        break e;
                    case 1:
                        a = l;
                        var A = s.type
                          , w = s.stateNode;
                        if (!(s.flags & 128) && (typeof A.getDerivedStateFromError == "function" || w !== null && typeof w.componentDidCatch == "function" && (Jo === null || !Jo.has(w)))) {
                            s.flags |= 65536,
                            e &= -e,
                            s.lanes |= e;
                            var M = lB(s, a, e);
                            mC(s, M);
                            break e
                        }
                    }
                    s = s.return
                } while (s !== null)
            }
            EB(t)
        } catch (C) {
            e = C,
            En === t && t !== null && (En = t = t.return);
            continue
        }
        break
    } while (1)
}
function bB() {
    var n = Dg.current;
    return Dg.current = Lg,
    n === null ? Lg : n
}
function sw() {
    (In === 0 || In === 3 || In === 2) && (In = 4),
    Wn === null || !(xl & 268435455) && !(p0 & 268435455) || Do(Wn, Kn)
}
function Ng(n, e) {
    var t = Lt;
    Lt |= 2;
    var i = bB();
    (Wn !== n || Kn !== e) && (Ds = null,
    al(n, e));
    do
        try {
            hO();
            break
        } catch (r) {
            MB(n, r)
        }
    while (1);
    if (GA(),
    Lt = t,
    Dg.current = i,
    En !== null)
        throw Error(Me(261));
    return Wn = null,
    Kn = 0,
    In
}
function hO() {
    for (; En !== null; )
        CB(En)
}
function pO() {
    for (; En !== null && !UF(); )
        CB(En)
}
function CB(n) {
    var e = PB(n.alternate, n, Gi);
    n.memoizedProps = n.pendingProps,
    e === null ? EB(n) : En = e,
    ew.current = null
}
function EB(n) {
    var e = n;
    do {
        var t = e.alternate;
        if (n = e.return,
        e.flags & 32768) {
            if (t = aO(t, e),
            t !== null) {
                t.flags &= 32767,
                En = t;
                return
            }
            if (n !== null)
                n.flags |= 32768,
                n.subtreeFlags = 0,
                n.deletions = null;
            else {
                In = 6,
                En = null;
                return
            }
        } else if (t = oO(t, e, Gi),
        t !== null) {
            En = t;
            return
        }
        if (e = e.sibling,
        e !== null) {
            En = e;
            return
        }
        En = e = n
    } while (e !== null);
    In === 0 && (In = 5)
}
function za(n, e, t) {
    var i = zt
      , r = _r.transition;
    try {
        _r.transition = null,
        zt = 1,
        mO(n, e, t, i)
    } finally {
        _r.transition = r,
        zt = i
    }
    return null
}
function mO(n, e, t, i) {
    do
        Wu();
    while (Fo !== null);
    if (Lt & 6)
        throw Error(Me(327));
    t = n.finishedWork;
    var r = n.finishedLanes;
    if (t === null)
        return null;
    if (n.finishedWork = null,
    n.finishedLanes = 0,
    t === n.current)
        throw Error(Me(177));
    n.callbackNode = null,
    n.callbackPriority = 0;
    var s = t.lanes | t.childLanes;
    if (KF(n, s),
    n === Wn && (En = Wn = null,
    Kn = 0),
    !(t.subtreeFlags & 2064) && !(t.flags & 2064) || Op || (Op = !0,
    BB(yg, function() {
        return Wu(),
        null
    })),
    s = (t.flags & 15990) !== 0,
    t.subtreeFlags & 15990 || s) {
        s = _r.transition,
        _r.transition = null;
        var o = zt;
        zt = 1;
        var a = Lt;
        Lt |= 4,
        ew.current = null,
        uO(n, t),
        AB(t, n),
        kN(p1),
        _g = !!h1,
        p1 = h1 = null,
        n.current = t,
        cO(t),
        zF(),
        Lt = a,
        zt = o,
        _r.transition = s
    } else
        n.current = t;
    if (Op && (Op = !1,
    Fo = n,
    Fg = r),
    s = n.pendingLanes,
    s === 0 && (Jo = null),
    VF(t.stateNode),
    Ii(n, An()),
    e !== null)
        for (i = n.onRecoverableError,
        t = 0; t < e.length; t++)
            r = e[t],
            i(r.value, {
                componentStack: r.stack,
                digest: r.digest
            });
    if (kg)
        throw kg = !1,
        n = D1,
        D1 = null,
        n;
    return Fg & 1 && n.tag !== 0 && Wu(),
    s = n.pendingLanes,
    s & 1 ? n === k1 ? Vf++ : (Vf = 0,
    k1 = n) : Vf = 0,
    da(),
    null
}
function Wu() {
    if (Fo !== null) {
        var n = o3(Fg)
          , e = _r.transition
          , t = zt;
        try {
            if (_r.transition = null,
            zt = 16 > n ? 16 : n,
            Fo === null)
                var i = !1;
            else {
                if (n = Fo,
                Fo = null,
                Fg = 0,
                Lt & 6)
                    throw Error(Me(331));
                var r = Lt;
                for (Lt |= 4,
                He = n.current; He !== null; ) {
                    var s = He
                      , o = s.child;
                    if (He.flags & 16) {
                        var a = s.deletions;
                        if (a !== null) {
                            for (var l = 0; l < a.length; l++) {
                                var c = a[l];
                                for (He = c; He !== null; ) {
                                    var d = He;
                                    switch (d.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Gf(8, d, s)
                                    }
                                    var h = d.child;
                                    if (h !== null)
                                        h.return = d,
                                        He = h;
                                    else
                                        for (; He !== null; ) {
                                            d = He;
                                            var p = d.sibling
                                              , m = d.return;
                                            if (yB(d),
                                            d === c) {
                                                He = null;
                                                break
                                            }
                                            if (p !== null) {
                                                p.return = m,
                                                He = p;
                                                break
                                            }
                                            He = m
                                        }
                                }
                            }
                            var y = s.alternate;
                            if (y !== null) {
                                var v = y.child;
                                if (v !== null) {
                                    y.child = null;
                                    do {
                                        var x = v.sibling;
                                        v.sibling = null,
                                        v = x
                                    } while (v !== null)
                                }
                            }
                            He = s
                        }
                    }
                    if (s.subtreeFlags & 2064 && o !== null)
                        o.return = s,
                        He = o;
                    else
                        e: for (; He !== null; ) {
                            if (s = He,
                            s.flags & 2048)
                                switch (s.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Gf(9, s, s.return)
                                }
                            var _ = s.sibling;
                            if (_ !== null) {
                                _.return = s.return,
                                He = _;
                                break e
                            }
                            He = s.return
                        }
                }
                var A = n.current;
                for (He = A; He !== null; ) {
                    o = He;
                    var w = o.child;
                    if (o.subtreeFlags & 2064 && w !== null)
                        w.return = o,
                        He = w;
                    else
                        e: for (o = A; He !== null; ) {
                            if (a = He,
                            a.flags & 2048)
                                try {
                                    switch (a.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        h0(9, a)
                                    }
                                } catch (C) {
                                    mn(a, a.return, C)
                                }
                            if (a === o) {
                                He = null;
                                break e
                            }
                            var M = a.sibling;
                            if (M !== null) {
                                M.return = a.return,
                                He = M;
                                break e
                            }
                            He = a.return
                        }
                }
                if (Lt = r,
                da(),
                ls && typeof ls.onPostCommitFiberRoot == "function")
                    try {
                        ls.onPostCommitFiberRoot(s0, n)
                    } catch {}
                i = !0
            }
            return i
        } finally {
            zt = t,
            _r.transition = e
        }
    }
    return !1
}
function NC(n, e, t) {
    e = ec(t, e),
    e = aB(n, e, 1),
    n = jo(n, e, 1),
    e = vi(),
    n !== null && (Yd(n, 1, e),
    Ii(n, e))
}
function mn(n, e, t) {
    if (n.tag === 3)
        NC(n, n, t);
    else
        for (; e !== null; ) {
            if (e.tag === 3) {
                NC(e, n, t);
                break
            } else if (e.tag === 1) {
                var i = e.stateNode;
                if (typeof e.type.getDerivedStateFromError == "function" || typeof i.componentDidCatch == "function" && (Jo === null || !Jo.has(i))) {
                    n = ec(t, n),
                    n = lB(e, n, 1),
                    e = jo(e, n, 1),
                    n = vi(),
                    e !== null && (Yd(e, 1, n),
                    Ii(e, n));
                    break
                }
            }
            e = e.return
        }
}
function gO(n, e, t) {
    var i = n.pingCache;
    i !== null && i.delete(e),
    e = vi(),
    n.pingedLanes |= n.suspendedLanes & t,
    Wn === n && (Kn & t) === t && (In === 4 || In === 3 && (Kn & 130023424) === Kn && 500 > An() - nw ? al(n, 0) : tw |= t),
    Ii(n, e)
}
function TB(n, e) {
    e === 0 && (n.mode & 1 ? (e = Tp,
    Tp <<= 1,
    !(Tp & 130023424) && (Tp = 4194304)) : e = 1);
    var t = vi();
    n = Qs(n, e),
    n !== null && (Yd(n, e, t),
    Ii(n, t))
}
function vO(n) {
    var e = n.memoizedState
      , t = 0;
    e !== null && (t = e.retryLane),
    TB(n, t)
}
function yO(n, e) {
    var t = 0;
    switch (n.tag) {
    case 13:
        var i = n.stateNode
          , r = n.memoizedState;
        r !== null && (t = r.retryLane);
        break;
    case 19:
        i = n.stateNode;
        break;
    default:
        throw Error(Me(314))
    }
    i !== null && i.delete(e),
    TB(n, t)
}
var PB;
PB = function(n, e, t) {
    if (n !== null)
        if (n.memoizedProps !== e.pendingProps || Bi.current)
            Pi = !0;
        else {
            if (!(n.lanes & t) && !(e.flags & 128))
                return Pi = !1,
                sO(n, e, t);
            Pi = !!(n.flags & 131072)
        }
    else
        Pi = !1,
        en && e.flags & 1048576 && I3(e, Eg, e.index);
    switch (e.lanes = 0,
    e.tag) {
    case 2:
        var i = e.type;
        Zm(n, e),
        n = e.pendingProps;
        var r = Qu(e, ai.current);
        Vu(e, t),
        r = KA(null, e, i, n, r, t);
        var s = QA();
        return e.flags |= 1,
        typeof r == "object" && r !== null && typeof r.render == "function" && r.$$typeof === void 0 ? (e.tag = 1,
        e.memoizedState = null,
        e.updateQueue = null,
        Ri(i) ? (s = !0,
        bg(e)) : s = !1,
        e.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null,
        WA(e),
        r.updater = f0,
        e.stateNode = r,
        r._reactInternals = e,
        S1(e, i, n, t),
        e = C1(null, e, i, !0, s, t)) : (e.tag = 0,
        en && s && NA(e),
        mi(null, e, r, t),
        e = e.child),
        e;
    case 16:
        i = e.elementType;
        e: {
            switch (Zm(n, e),
            n = e.pendingProps,
            r = i._init,
            i = r(i._payload),
            e.type = i,
            r = e.tag = _O(i),
            n = Lr(i, n),
            r) {
            case 0:
                e = b1(null, e, i, n, t);
                break e;
            case 1:
                e = EC(null, e, i, n, t);
                break e;
            case 11:
                e = bC(null, e, i, n, t);
                break e;
            case 14:
                e = CC(null, e, i, Lr(i.type, n), t);
                break e
            }
            throw Error(Me(306, i, ""))
        }
        return e;
    case 0:
        return i = e.type,
        r = e.pendingProps,
        r = e.elementType === i ? r : Lr(i, r),
        b1(n, e, i, r, t);
    case 1:
        return i = e.type,
        r = e.pendingProps,
        r = e.elementType === i ? r : Lr(i, r),
        EC(n, e, i, r, t);
    case 3:
        e: {
            if (dB(e),
            n === null)
                throw Error(Me(387));
            i = e.pendingProps,
            s = e.memoizedState,
            r = s.element,
            F3(n, e),
            Bg(e, i, null, t);
            var o = e.memoizedState;
            if (i = o.element,
            s.isDehydrated)
                if (s = {
                    element: i,
                    isDehydrated: !1,
                    cache: o.cache,
                    pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
                    transitions: o.transitions
                },
                e.updateQueue.baseState = s,
                e.memoizedState = s,
                e.flags & 256) {
                    r = ec(Error(Me(423)), e),
                    e = TC(n, e, i, t, r);
                    break e
                } else if (i !== r) {
                    r = ec(Error(Me(424)), e),
                    e = TC(n, e, i, t, r);
                    break e
                } else
                    for (Vi = Wo(e.stateNode.containerInfo.firstChild),
                    ji = e,
                    en = !0,
                    Fr = null,
                    t = z3(e, null, i, t),
                    e.child = t; t; )
                        t.flags = t.flags & -3 | 4096,
                        t = t.sibling;
            else {
                if (Zu(),
                i === r) {
                    e = Zs(n, e, t);
                    break e
                }
                mi(n, e, i, t)
            }
            e = e.child
        }
        return e;
    case 5:
        return G3(e),
        n === null && _1(e),
        i = e.type,
        r = e.pendingProps,
        s = n !== null ? n.memoizedProps : null,
        o = r.children,
        m1(i, r) ? o = null : s !== null && m1(i, s) && (e.flags |= 32),
        fB(n, e),
        mi(n, e, o, t),
        e.child;
    case 6:
        return n === null && _1(e),
        null;
    case 13:
        return hB(n, e, t);
    case 4:
        return jA(e, e.stateNode.containerInfo),
        i = e.pendingProps,
        n === null ? e.child = qu(e, null, i, t) : mi(n, e, i, t),
        e.child;
    case 11:
        return i = e.type,
        r = e.pendingProps,
        r = e.elementType === i ? r : Lr(i, r),
        bC(n, e, i, r, t);
    case 7:
        return mi(n, e, e.pendingProps, t),
        e.child;
    case 8:
        return mi(n, e, e.pendingProps.children, t),
        e.child;
    case 12:
        return mi(n, e, e.pendingProps.children, t),
        e.child;
    case 10:
        e: {
            if (i = e.type._context,
            r = e.pendingProps,
            s = e.memoizedProps,
            o = r.value,
            jt(Tg, i._currentValue),
            i._currentValue = o,
            s !== null)
                if (Wr(s.value, o)) {
                    if (s.children === r.children && !Bi.current) {
                        e = Zs(n, e, t);
                        break e
                    }
                } else
                    for (s = e.child,
                    s !== null && (s.return = e); s !== null; ) {
                        var a = s.dependencies;
                        if (a !== null) {
                            o = s.child;
                            for (var l = a.firstContext; l !== null; ) {
                                if (l.context === i) {
                                    if (s.tag === 1) {
                                        l = Ws(-1, t & -t),
                                        l.tag = 2;
                                        var c = s.updateQueue;
                                        if (c !== null) {
                                            c = c.shared;
                                            var d = c.pending;
                                            d === null ? l.next = l : (l.next = d.next,
                                            d.next = l),
                                            c.pending = l
                                        }
                                    }
                                    s.lanes |= t,
                                    l = s.alternate,
                                    l !== null && (l.lanes |= t),
                                    A1(s.return, t, e),
                                    a.lanes |= t;
                                    break
                                }
                                l = l.next
                            }
                        } else if (s.tag === 10)
                            o = s.type === e.type ? null : s.child;
                        else if (s.tag === 18) {
                            if (o = s.return,
                            o === null)
                                throw Error(Me(341));
                            o.lanes |= t,
                            a = o.alternate,
                            a !== null && (a.lanes |= t),
                            A1(o, t, e),
                            o = s.sibling
                        } else
                            o = s.child;
                        if (o !== null)
                            o.return = s;
                        else
                            for (o = s; o !== null; ) {
                                if (o === e) {
                                    o = null;
                                    break
                                }
                                if (s = o.sibling,
                                s !== null) {
                                    s.return = o.return,
                                    o = s;
                                    break
                                }
                                o = o.return
                            }
                        s = o
                    }
            mi(n, e, r.children, t),
            e = e.child
        }
        return e;
    case 9:
        return r = e.type,
        i = e.pendingProps.children,
        Vu(e, t),
        r = wr(r),
        i = i(r),
        e.flags |= 1,
        mi(n, e, i, t),
        e.child;
    case 14:
        return i = e.type,
        r = Lr(i, e.pendingProps),
        r = Lr(i.type, r),
        CC(n, e, i, r, t);
    case 15:
        return uB(n, e, e.type, e.pendingProps, t);
    case 17:
        return i = e.type,
        r = e.pendingProps,
        r = e.elementType === i ? r : Lr(i, r),
        Zm(n, e),
        e.tag = 1,
        Ri(i) ? (n = !0,
        bg(e)) : n = !1,
        Vu(e, t),
        O3(e, i, r),
        S1(e, i, r, t),
        C1(null, e, i, !0, n, t);
    case 19:
        return pB(n, e, t);
    case 22:
        return cB(n, e, t)
    }
    throw Error(Me(156, e.tag))
}
;
function BB(n, e) {
    return n3(n, e)
}
function xO(n, e, t, i) {
    this.tag = n,
    this.key = t,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.ref = null,
    this.pendingProps = e,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = i,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function xr(n, e, t, i) {
    return new xO(n,e,t,i)
}
function ow(n) {
    return n = n.prototype,
    !(!n || !n.isReactComponent)
}
function _O(n) {
    if (typeof n == "function")
        return ow(n) ? 1 : 0;
    if (n != null) {
        if (n = n.$$typeof,
        n === bA)
            return 11;
        if (n === CA)
            return 14
    }
    return 2
}
function Yo(n, e) {
    var t = n.alternate;
    return t === null ? (t = xr(n.tag, e, n.key, n.mode),
    t.elementType = n.elementType,
    t.type = n.type,
    t.stateNode = n.stateNode,
    t.alternate = n,
    n.alternate = t) : (t.pendingProps = e,
    t.type = n.type,
    t.flags = 0,
    t.subtreeFlags = 0,
    t.deletions = null),
    t.flags = n.flags & 14680064,
    t.childLanes = n.childLanes,
    t.lanes = n.lanes,
    t.child = n.child,
    t.memoizedProps = n.memoizedProps,
    t.memoizedState = n.memoizedState,
    t.updateQueue = n.updateQueue,
    e = n.dependencies,
    t.dependencies = e === null ? null : {
        lanes: e.lanes,
        firstContext: e.firstContext
    },
    t.sibling = n.sibling,
    t.index = n.index,
    t.ref = n.ref,
    t
}
function eg(n, e, t, i, r, s) {
    var o = 2;
    if (i = n,
    typeof n == "function")
        ow(n) && (o = 1);
    else if (typeof n == "string")
        o = 5;
    else
        e: switch (n) {
        case yu:
            return ll(t.children, r, s, e);
        case MA:
            o = 8,
            r |= 8;
            break;
        case Xx:
            return n = xr(12, t, e, r | 2),
            n.elementType = Xx,
            n.lanes = s,
            n;
        case Yx:
            return n = xr(13, t, e, r),
            n.elementType = Yx,
            n.lanes = s,
            n;
        case Kx:
            return n = xr(19, t, e, r),
            n.elementType = Kx,
            n.lanes = s,
            n;
        case UP:
            return m0(t, r, s, e);
        default:
            if (typeof n == "object" && n !== null)
                switch (n.$$typeof) {
                case NP:
                    o = 10;
                    break e;
                case OP:
                    o = 9;
                    break e;
                case bA:
                    o = 11;
                    break e;
                case CA:
                    o = 14;
                    break e;
                case Po:
                    o = 16,
                    i = null;
                    break e
                }
            throw Error(Me(130, n == null ? n : typeof n, ""))
        }
    return e = xr(o, t, e, r),
    e.elementType = n,
    e.type = i,
    e.lanes = s,
    e
}
function ll(n, e, t, i) {
    return n = xr(7, n, i, e),
    n.lanes = t,
    n
}
function m0(n, e, t, i) {
    return n = xr(22, n, i, e),
    n.elementType = UP,
    n.lanes = t,
    n.stateNode = {
        isHidden: !1
    },
    n
}
function Ry(n, e, t) {
    return n = xr(6, n, null, e),
    n.lanes = t,
    n
}
function Iy(n, e, t) {
    return e = xr(4, n.children !== null ? n.children : [], n.key, e),
    e.lanes = t,
    e.stateNode = {
        containerInfo: n.containerInfo,
        pendingChildren: null,
        implementation: n.implementation
    },
    e
}
function AO(n, e, t, i, r) {
    this.tag = e,
    this.containerInfo = n,
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.pendingContext = this.context = null,
    this.callbackPriority = 0,
    this.eventTimes = dy(0),
    this.expirationTimes = dy(-1),
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = dy(0),
    this.identifierPrefix = i,
    this.onRecoverableError = r,
    this.mutableSourceEagerHydrationData = null
}
function aw(n, e, t, i, r, s, o, a, l) {
    return n = new AO(n,e,t,a,l),
    e === 1 ? (e = 1,
    s === !0 && (e |= 8)) : e = 0,
    s = xr(3, null, null, e),
    n.current = s,
    s.stateNode = n,
    s.memoizedState = {
        element: i,
        isDehydrated: t,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    },
    WA(s),
    n
}
function wO(n, e, t) {
    var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: vu,
        key: i == null ? null : "" + i,
        children: n,
        containerInfo: e,
        implementation: t
    }
}
function RB(n) {
    if (!n)
        return $o;
    n = n._reactInternals;
    e: {
        if (Tl(n) !== n || n.tag !== 1)
            throw Error(Me(170));
        var e = n;
        do {
            switch (e.tag) {
            case 3:
                e = e.stateNode.context;
                break e;
            case 1:
                if (Ri(e.type)) {
                    e = e.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e
                }
            }
            e = e.return
        } while (e !== null);
        throw Error(Me(171))
    }
    if (n.tag === 1) {
        var t = n.type;
        if (Ri(t))
            return B3(n, t, e)
    }
    return e
}
function IB(n, e, t, i, r, s, o, a, l) {
    return n = aw(t, i, !0, n, r, s, o, a, l),
    n.context = RB(null),
    t = n.current,
    i = vi(),
    r = Xo(t),
    s = Ws(i, r),
    s.callback = e ?? null,
    jo(t, s, r),
    n.current.lanes = r,
    Yd(n, r, i),
    Ii(n, i),
    n
}
function g0(n, e, t, i) {
    var r = e.current
      , s = vi()
      , o = Xo(r);
    return t = RB(t),
    e.context === null ? e.context = t : e.pendingContext = t,
    e = Ws(s, o),
    e.payload = {
        element: n
    },
    i = i === void 0 ? null : i,
    i !== null && (e.callback = i),
    n = jo(r, e, o),
    n !== null && (Gr(n, r, o, s),
    Ym(n, r, o)),
    o
}
function Og(n) {
    if (n = n.current,
    !n.child)
        return null;
    switch (n.child.tag) {
    case 5:
        return n.child.stateNode;
    default:
        return n.child.stateNode
    }
}
function OC(n, e) {
    if (n = n.memoizedState,
    n !== null && n.dehydrated !== null) {
        var t = n.retryLane;
        n.retryLane = t !== 0 && t < e ? t : e
    }
}
function lw(n, e) {
    OC(n, e),
    (n = n.alternate) && OC(n, e)
}
function SO() {
    return null
}
var LB = typeof reportError == "function" ? reportError : function(n) {
    console.error(n)
}
;
function uw(n) {
    this._internalRoot = n
}
v0.prototype.render = uw.prototype.render = function(n) {
    var e = this._internalRoot;
    if (e === null)
        throw Error(Me(409));
    g0(n, e, null, null)
}
;
v0.prototype.unmount = uw.prototype.unmount = function() {
    var n = this._internalRoot;
    if (n !== null) {
        this._internalRoot = null;
        var e = n.containerInfo;
        _l(function() {
            g0(null, n, null, null)
        }),
        e[Ks] = null
    }
}
;
function v0(n) {
    this._internalRoot = n
}
v0.prototype.unstable_scheduleHydration = function(n) {
    if (n) {
        var e = u3();
        n = {
            blockedOn: null,
            target: n,
            priority: e
        };
        for (var t = 0; t < Lo.length && e !== 0 && e < Lo[t].priority; t++)
            ;
        Lo.splice(t, 0, n),
        t === 0 && f3(n)
    }
}
;
function cw(n) {
    return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11)
}
function y0(n) {
    return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11 && (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable "))
}
function UC() {}
function MO(n, e, t, i, r) {
    if (r) {
        if (typeof i == "function") {
            var s = i;
            i = function() {
                var c = Og(o);
                s.call(c)
            }
        }
        var o = IB(e, i, n, 0, null, !1, !1, "", UC);
        return n._reactRootContainer = o,
        n[Ks] = o.current,
        fd(n.nodeType === 8 ? n.parentNode : n),
        _l(),
        o
    }
    for (; r = n.lastChild; )
        n.removeChild(r);
    if (typeof i == "function") {
        var a = i;
        i = function() {
            var c = Og(l);
            a.call(c)
        }
    }
    var l = aw(n, 0, !1, null, null, !1, !1, "", UC);
    return n._reactRootContainer = l,
    n[Ks] = l.current,
    fd(n.nodeType === 8 ? n.parentNode : n),
    _l(function() {
        g0(e, l, t, i)
    }),
    l
}
function x0(n, e, t, i, r) {
    var s = t._reactRootContainer;
    if (s) {
        var o = s;
        if (typeof r == "function") {
            var a = r;
            r = function() {
                var l = Og(o);
                a.call(l)
            }
        }
        g0(e, o, n, r)
    } else
        o = MO(t, e, n, r, i);
    return Og(o)
}
a3 = function(n) {
    switch (n.tag) {
    case 3:
        var e = n.stateNode;
        if (e.current.memoizedState.isDehydrated) {
            var t = Bf(e.pendingLanes);
            t !== 0 && (PA(e, t | 1),
            Ii(e, An()),
            !(Lt & 6) && (tc = An() + 500,
            da()))
        }
        break;
    case 13:
        _l(function() {
            var i = Qs(n, 1);
            if (i !== null) {
                var r = vi();
                Gr(i, n, 1, r)
            }
        }),
        lw(n, 1)
    }
}
;
BA = function(n) {
    if (n.tag === 13) {
        var e = Qs(n, 134217728);
        if (e !== null) {
            var t = vi();
            Gr(e, n, 134217728, t)
        }
        lw(n, 134217728)
    }
}
;
l3 = function(n) {
    if (n.tag === 13) {
        var e = Xo(n)
          , t = Qs(n, e);
        if (t !== null) {
            var i = vi();
            Gr(t, n, e, i)
        }
        lw(n, e)
    }
}
;
u3 = function() {
    return zt
}
;
c3 = function(n, e) {
    var t = zt;
    try {
        return zt = n,
        e()
    } finally {
        zt = t
    }
}
;
s1 = function(n, e, t) {
    switch (e) {
    case "input":
        if (qx(n, t),
        e = t.name,
        t.type === "radio" && e != null) {
            for (t = n; t.parentNode; )
                t = t.parentNode;
            for (t = t.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'),
            e = 0; e < t.length; e++) {
                var i = t[e];
                if (i !== n && i.form === n.form) {
                    var r = u0(i);
                    if (!r)
                        throw Error(Me(90));
                    GP(i),
                    qx(i, r)
                }
            }
        }
        break;
    case "textarea":
        VP(n, t);
        break;
    case "select":
        e = t.value,
        e != null && Uu(n, !!t.multiple, e, !1)
    }
}
;
QP = iw;
ZP = _l;
var bO = {
    usingClientEntryPoint: !1,
    Events: [Qd, wu, u0, YP, KP, iw]
}
  , sf = {
    findFiberByHostInstance: Ka,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom"
}
  , CO = {
    bundleType: sf.bundleType,
    version: sf.version,
    rendererPackageName: sf.rendererPackageName,
    rendererConfig: sf.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: ro.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(n) {
        return n = e3(n),
        n === null ? null : n.stateNode
    },
    findFiberByHostInstance: sf.findFiberByHostInstance || SO,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Up = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Up.isDisabled && Up.supportsFiber)
        try {
            s0 = Up.inject(CO),
            ls = Up
        } catch {}
}
Zi.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = bO;
Zi.createPortal = function(n, e) {
    var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!cw(e))
        throw Error(Me(200));
    return wO(n, e, null, t)
}
;
Zi.createRoot = function(n, e) {
    if (!cw(n))
        throw Error(Me(299));
    var t = !1
      , i = ""
      , r = LB;
    return e != null && (e.unstable_strictMode === !0 && (t = !0),
    e.identifierPrefix !== void 0 && (i = e.identifierPrefix),
    e.onRecoverableError !== void 0 && (r = e.onRecoverableError)),
    e = aw(n, 1, !1, null, null, t, !1, i, r),
    n[Ks] = e.current,
    fd(n.nodeType === 8 ? n.parentNode : n),
    new uw(e)
}
;
Zi.findDOMNode = function(n) {
    if (n == null)
        return null;
    if (n.nodeType === 1)
        return n;
    var e = n._reactInternals;
    if (e === void 0)
        throw typeof n.render == "function" ? Error(Me(188)) : (n = Object.keys(n).join(","),
        Error(Me(268, n)));
    return n = e3(e),
    n = n === null ? null : n.stateNode,
    n
}
;
Zi.flushSync = function(n) {
    return _l(n)
}
;
Zi.hydrate = function(n, e, t) {
    if (!y0(e))
        throw Error(Me(200));
    return x0(null, n, e, !0, t)
}
;
Zi.hydrateRoot = function(n, e, t) {
    if (!cw(n))
        throw Error(Me(405));
    var i = t != null && t.hydratedSources || null
      , r = !1
      , s = ""
      , o = LB;
    if (t != null && (t.unstable_strictMode === !0 && (r = !0),
    t.identifierPrefix !== void 0 && (s = t.identifierPrefix),
    t.onRecoverableError !== void 0 && (o = t.onRecoverableError)),
    e = IB(e, null, n, 1, t ?? null, r, !1, s, o),
    n[Ks] = e.current,
    fd(n),
    i)
        for (n = 0; n < i.length; n++)
            t = i[n],
            r = t._getVersion,
            r = r(t._source),
            e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [t, r] : e.mutableSourceEagerHydrationData.push(t, r);
    return new v0(e)
}
;
Zi.render = function(n, e, t) {
    if (!y0(e))
        throw Error(Me(200));
    return x0(null, n, e, !1, t)
}
;
Zi.unmountComponentAtNode = function(n) {
    if (!y0(n))
        throw Error(Me(40));
    return n._reactRootContainer ? (_l(function() {
        x0(null, null, n, !1, function() {
            n._reactRootContainer = null,
            n[Ks] = null
        })
    }),
    !0) : !1
}
;
Zi.unstable_batchedUpdates = iw;
Zi.unstable_renderSubtreeIntoContainer = function(n, e, t, i) {
    if (!y0(t))
        throw Error(Me(200));
    if (n == null || n._reactInternals === void 0)
        throw Error(Me(38));
    return x0(n, e, t, !1, i)
}
;
Zi.version = "18.2.0-next-9e3b772b8-20220608";
(function(n) {
    function e() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)
            } catch (t) {
                console.error(t)
            }
    }
    e(),
    n.exports = Zi
}
)(SF);
var DB, zC = pg;
DB = Wx.createRoot = zC.createRoot,
Wx.hydrateRoot = zC.hydrateRoot;
/**
 * @remix-run/router v1.3.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _d() {
    return _d = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
        }
        return n
    }
    ,
    _d.apply(this, arguments)
}
var qa;
(function(n) {
    n.Pop = "POP",
    n.Push = "PUSH",
    n.Replace = "REPLACE"
}
)(qa || (qa = {}));
const GC = "popstate";
function EO(n) {
    n === void 0 && (n = {});
    function e(i, r) {
        let {pathname: s, search: o, hash: a} = i.location;
        return O1("", {
            pathname: s,
            search: o,
            hash: a
        }, r.state && r.state.usr || null, r.state && r.state.key || "default")
    }
    function t(i, r) {
        return typeof r == "string" ? r : Ug(r)
    }
    return PO(e, t, null, n)
}
function Ko(n, e) {
    if (n === !1 || n === null || typeof n > "u")
        throw new Error(e)
}
function TO() {
    return Math.random().toString(36).substr(2, 8)
}
function HC(n, e) {
    return {
        usr: n.state,
        key: n.key,
        idx: e
    }
}
function O1(n, e, t, i) {
    return t === void 0 && (t = null),
    _d({
        pathname: typeof n == "string" ? n : n.pathname,
        search: "",
        hash: ""
    }, typeof e == "string" ? _0(e) : e, {
        state: t,
        key: e && e.key || i || TO()
    })
}
function Ug(n) {
    let {pathname: e="/", search: t="", hash: i=""} = n;
    return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t),
    i && i !== "#" && (e += i.charAt(0) === "#" ? i : "#" + i),
    e
}
function _0(n) {
    let e = {};
    if (n) {
        let t = n.indexOf("#");
        t >= 0 && (e.hash = n.substr(t),
        n = n.substr(0, t));
        let i = n.indexOf("?");
        i >= 0 && (e.search = n.substr(i),
        n = n.substr(0, i)),
        n && (e.pathname = n)
    }
    return e
}
function PO(n, e, t, i) {
    i === void 0 && (i = {});
    let {window: r=document.defaultView, v5Compat: s=!1} = i
      , o = r.history
      , a = qa.Pop
      , l = null
      , c = d();
    c == null && (c = 0,
    o.replaceState(_d({}, o.state, {
        idx: c
    }), ""));
    function d() {
        return (o.state || {
            idx: null
        }).idx
    }
    function h() {
        a = qa.Pop;
        let x = d()
          , _ = x == null ? null : x - c;
        c = x,
        l && l({
            action: a,
            location: v.location,
            delta: _
        })
    }
    function p(x, _) {
        a = qa.Push;
        let A = O1(v.location, x, _);
        t && t(A, x),
        c = d() + 1;
        let w = HC(A, c)
          , M = v.createHref(A);
        try {
            o.pushState(w, "", M)
        } catch {
            r.location.assign(M)
        }
        s && l && l({
            action: a,
            location: v.location,
            delta: 1
        })
    }
    function m(x, _) {
        a = qa.Replace;
        let A = O1(v.location, x, _);
        t && t(A, x),
        c = d();
        let w = HC(A, c)
          , M = v.createHref(A);
        o.replaceState(w, "", M),
        s && l && l({
            action: a,
            location: v.location,
            delta: 0
        })
    }
    function y(x) {
        let _ = r.location.origin !== "null" ? r.location.origin : r.location.href
          , A = typeof x == "string" ? x : Ug(x);
        return Ko(_, "No window.location.(origin|href) available to create URL for href: " + A),
        new URL(A,_)
    }
    let v = {
        get action() {
            return a
        },
        get location() {
            return n(r, o)
        },
        listen(x) {
            if (l)
                throw new Error("A history only accepts one active listener");
            return r.addEventListener(GC, h),
            l = x,
            ()=>{
                r.removeEventListener(GC, h),
                l = null
            }
        },
        createHref(x) {
            return e(r, x)
        },
        createURL: y,
        encodeLocation(x) {
            let _ = y(x);
            return {
                pathname: _.pathname,
                search: _.search,
                hash: _.hash
            }
        },
        push: p,
        replace: m,
        go(x) {
            return o.go(x)
        }
    };
    return v
}
var VC;
(function(n) {
    n.data = "data",
    n.deferred = "deferred",
    n.redirect = "redirect",
    n.error = "error"
}
)(VC || (VC = {}));
function BO(n, e) {
    if (e === "/")
        return n;
    if (!n.toLowerCase().startsWith(e.toLowerCase()))
        return null;
    let t = e.endsWith("/") ? e.length - 1 : e.length
      , i = n.charAt(t);
    return i && i !== "/" ? null : n.slice(t) || "/"
}
function RO(n, e) {
    e === void 0 && (e = "/");
    let {pathname: t, search: i="", hash: r=""} = typeof n == "string" ? _0(n) : n;
    return {
        pathname: t ? t.startsWith("/") ? t : IO(t, e) : e,
        search: LO(i),
        hash: DO(r)
    }
}
function IO(n, e) {
    let t = e.replace(/\/+$/, "").split("/");
    return n.split("/").forEach(r=>{
        r === ".." ? t.length > 1 && t.pop() : r !== "." && t.push(r)
    }
    ),
    t.length > 1 ? t.join("/") : "/"
}
function Ly(n, e, t, i) {
    return "Cannot include a '" + n + "' character in a manually specified " + ("`to." + e + "` field [" + JSON.stringify(i) + "].  Please separate it out to the ") + ("`to." + t + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.'
}
function kB(n) {
    return n.filter((e,t)=>t === 0 || e.route.path && e.route.path.length > 0)
}
function FB(n, e, t, i) {
    i === void 0 && (i = !1);
    let r;
    typeof n == "string" ? r = _0(n) : (r = _d({}, n),
    Ko(!r.pathname || !r.pathname.includes("?"), Ly("?", "pathname", "search", r)),
    Ko(!r.pathname || !r.pathname.includes("#"), Ly("#", "pathname", "hash", r)),
    Ko(!r.search || !r.search.includes("#"), Ly("#", "search", "hash", r)));
    let s = n === "" || r.pathname === "", o = s ? "/" : r.pathname, a;
    if (i || o == null)
        a = t;
    else {
        let h = e.length - 1;
        if (o.startsWith("..")) {
            let p = o.split("/");
            for (; p[0] === ".."; )
                p.shift(),
                h -= 1;
            r.pathname = p.join("/")
        }
        a = h >= 0 ? e[h] : "/"
    }
    let l = RO(r, a)
      , c = o && o !== "/" && o.endsWith("/")
      , d = (s || o === ".") && t.endsWith("/");
    return !l.pathname.endsWith("/") && (c || d) && (l.pathname += "/"),
    l
}
const NB = n=>n.join("/").replace(/\/\/+/g, "/")
  , LO = n=>!n || n === "?" ? "" : n.startsWith("?") ? n : "?" + n
  , DO = n=>!n || n === "#" ? "" : n.startsWith("#") ? n : "#" + n
  , kO = ["post", "put", "patch", "delete"];
[...kO];
/**
 * React Router v6.8.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function FO(n, e) {
    return n === e && (n !== 0 || 1 / n === 1 / e) || n !== n && e !== e
}
const NO = typeof Object.is == "function" ? Object.is : FO
  , {useState: OO, useEffect: UO, useLayoutEffect: zO, useDebugValue: GO} = Vx;
function HO(n, e, t) {
    const i = e()
      , [{inst: r},s] = OO({
        inst: {
            value: i,
            getSnapshot: e
        }
    });
    return zO(()=>{
        r.value = i,
        r.getSnapshot = e,
        Dy(r) && s({
            inst: r
        })
    }
    , [n, i, e]),
    UO(()=>(Dy(r) && s({
        inst: r
    }),
    n(()=>{
        Dy(r) && s({
            inst: r
        })
    }
    )), [n]),
    GO(i),
    i
}
function Dy(n) {
    const e = n.getSnapshot
      , t = n.value;
    try {
        const i = e();
        return !NO(t, i)
    } catch {
        return !0
    }
}
function VO(n, e, t) {
    return e()
}
const WO = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"
  , jO = !WO
  , JO = jO ? VO : HO;
"useSyncExternalStore"in Vx && (n=>n.useSyncExternalStore)(Vx);
const fw = U.createContext(null)
  , dw = U.createContext(null)
  , OB = U.createContext({
    outlet: null,
    matches: []
});
function XO(n, e) {
    let {relative: t} = e === void 0 ? {} : e;
    A0() || Ko(!1);
    let {basename: i, navigator: r} = U.useContext(fw)
      , {hash: s, pathname: o, search: a} = UB(n, {
        relative: t
    })
      , l = o;
    return i !== "/" && (l = o === "/" ? i : NB([i, o])),
    r.createHref({
        pathname: l,
        search: a,
        hash: s
    })
}
function A0() {
    return U.useContext(dw) != null
}
function hw() {
    return A0() || Ko(!1),
    U.useContext(dw).location
}
function YO() {
    A0() || Ko(!1);
    let {basename: n, navigator: e} = U.useContext(fw)
      , {matches: t} = U.useContext(OB)
      , {pathname: i} = hw()
      , r = JSON.stringify(kB(t).map(a=>a.pathnameBase))
      , s = U.useRef(!1);
    return U.useEffect(()=>{
        s.current = !0
    }
    ),
    U.useCallback(function(a, l) {
        if (l === void 0 && (l = {}),
        !s.current)
            return;
        if (typeof a == "number") {
            e.go(a);
            return
        }
        let c = FB(a, JSON.parse(r), i, l.relative === "path");
        n !== "/" && (c.pathname = c.pathname === "/" ? n : NB([n, c.pathname])),
        (l.replace ? e.replace : e.push)(c, l.state, l)
    }, [n, e, r, i])
}
function UB(n, e) {
    let {relative: t} = e === void 0 ? {} : e
      , {matches: i} = U.useContext(OB)
      , {pathname: r} = hw()
      , s = JSON.stringify(kB(i).map(o=>o.pathnameBase));
    return U.useMemo(()=>FB(n, JSON.parse(s), r, t === "path"), [n, s, r, t])
}
var WC;
(function(n) {
    n.UseBlocker = "useBlocker",
    n.UseRevalidator = "useRevalidator"
}
)(WC || (WC = {}));
var jC;
(function(n) {
    n.UseLoaderData = "useLoaderData",
    n.UseActionData = "useActionData",
    n.UseRouteError = "useRouteError",
    n.UseNavigation = "useNavigation",
    n.UseRouteLoaderData = "useRouteLoaderData",
    n.UseMatches = "useMatches",
    n.UseRevalidator = "useRevalidator"
}
)(jC || (jC = {}));
function KO(n) {
    let {basename: e="/", children: t=null, location: i, navigationType: r=qa.Pop, navigator: s, static: o=!1} = n;
    A0() && Ko(!1);
    let a = e.replace(/^\/*/, "/")
      , l = U.useMemo(()=>({
        basename: a,
        navigator: s,
        static: o
    }), [a, s, o]);
    typeof i == "string" && (i = _0(i));
    let {pathname: c="/", search: d="", hash: h="", state: p=null, key: m="default"} = i
      , y = U.useMemo(()=>{
        let v = BO(c, a);
        return v == null ? null : {
            pathname: v,
            search: d,
            hash: h,
            state: p,
            key: m
        }
    }
    , [a, c, d, h, p, m]);
    return y == null ? null : U.createElement(fw.Provider, {
        value: l
    }, U.createElement(dw.Provider, {
        children: t,
        value: {
            location: y,
            navigationType: r
        }
    }))
}
var JC;
(function(n) {
    n[n.pending = 0] = "pending",
    n[n.success = 1] = "success",
    n[n.error = 2] = "error"
}
)(JC || (JC = {}));
new Promise(()=>{}
);
/**
 * React Router DOM v6.8.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function U1() {
    return U1 = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
        }
        return n
    }
    ,
    U1.apply(this, arguments)
}
function QO(n, e) {
    if (n == null)
        return {};
    var t = {}, i = Object.keys(n), r, s;
    for (s = 0; s < i.length; s++)
        r = i[s],
        !(e.indexOf(r) >= 0) && (t[r] = n[r]);
    return t
}
function ZO(n) {
    return !!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey)
}
function qO(n, e) {
    return n.button === 0 && (!e || e === "_self") && !ZO(n)
}
const $O = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"];
function e4(n) {
    let {basename: e, children: t, window: i} = n
      , r = U.useRef();
    r.current == null && (r.current = EO({
        window: i,
        v5Compat: !0
    }));
    let s = r.current
      , [o,a] = U.useState({
        action: s.action,
        location: s.location
    });
    return U.useLayoutEffect(()=>s.listen(a), [s]),
    U.createElement(KO, {
        basename: e,
        children: t,
        location: o.location,
        navigationType: o.action,
        navigator: s
    })
}
const t4 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"
  , n4 = U.forwardRef(function(e, t) {
    let {onClick: i, relative: r, reloadDocument: s, replace: o, state: a, target: l, to: c, preventScrollReset: d} = e, h = QO(e, $O), p, m = !1;
    if (t4 && typeof c == "string" && /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i.test(c)) {
        p = c;
        let _ = new URL(window.location.href)
          , A = c.startsWith("//") ? new URL(_.protocol + c) : new URL(c);
        A.origin === _.origin ? c = A.pathname + A.search + A.hash : m = !0
    }
    let y = XO(c, {
        relative: r
    })
      , v = i4(c, {
        replace: o,
        state: a,
        target: l,
        preventScrollReset: d,
        relative: r
    });
    function x(_) {
        i && i(_),
        _.defaultPrevented || v(_)
    }
    return U.createElement("a", U1({}, h, {
        href: p || y,
        onClick: m || s ? i : x,
        ref: t,
        target: l
    }))
});
var XC;
(function(n) {
    n.UseScrollRestoration = "useScrollRestoration",
    n.UseSubmitImpl = "useSubmitImpl",
    n.UseFetcher = "useFetcher"
}
)(XC || (XC = {}));
var YC;
(function(n) {
    n.UseFetchers = "useFetchers",
    n.UseScrollRestoration = "useScrollRestoration"
}
)(YC || (YC = {}));
function i4(n, e) {
    let {target: t, replace: i, state: r, preventScrollReset: s, relative: o} = e === void 0 ? {} : e
      , a = YO()
      , l = hw()
      , c = UB(n, {
        relative: o
    });
    return U.useCallback(d=>{
        if (qO(d, t)) {
            d.preventDefault();
            let h = i !== void 0 ? i : Ug(l) === Ug(c);
            a(n, {
                replace: h,
                state: r,
                preventScrollReset: s,
                relative: o
            })
        }
    }
    , [l, a, c, i, r, t, n, s, o])
}
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const w0 = "149"
  , Ga = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
}
  , Ha = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
}
  , zB = 0
  , z1 = 1
  , GB = 2
  , r4 = 3
  , HB = 0
  , S0 = 1
  , Wf = 2
  , $a = 3
  , hs = 0
  , Li = 1
  , Or = 2
  , s4 = 2
  , js = 0
  , ul = 1
  , G1 = 2
  , H1 = 3
  , V1 = 4
  , VB = 5
  , Xa = 100
  , WB = 101
  , jB = 102
  , W1 = 103
  , j1 = 104
  , JB = 200
  , XB = 201
  , YB = 202
  , KB = 203
  , pw = 204
  , mw = 205
  , QB = 206
  , ZB = 207
  , qB = 208
  , $B = 209
  , eR = 210
  , tR = 0
  , nR = 1
  , iR = 2
  , zg = 3
  , rR = 4
  , sR = 5
  , oR = 6
  , aR = 7
  , qd = 0
  , lR = 1
  , uR = 2
  , Hr = 0
  , cR = 1
  , fR = 2
  , dR = 3
  , gw = 4
  , hR = 5
  , M0 = 300
  , ea = 301
  , ta = 302
  , Ad = 303
  , wd = 304
  , _c = 306
  , na = 1e3
  , Xn = 1001
  , nc = 1002
  , gn = 1003
  , Sd = 1004
  , o4 = 1004
  , ju = 1005
  , a4 = 1005
  , on = 1006
  , b0 = 1007
  , l4 = 1007
  , ps = 1008
  , u4 = 1008
  , qs = 1009
  , pR = 1010
  , mR = 1011
  , vw = 1012
  , gR = 1013
  , No = 1014
  , zs = 1015
  , ic = 1016
  , vR = 1017
  , yR = 1018
  , cl = 1020
  , xR = 1021
  , Ti = 1023
  , _R = 1024
  , AR = 1025
  , Qo = 1026
  , Al = 1027
  , wR = 1028
  , SR = 1029
  , MR = 1030
  , bR = 1031
  , CR = 1033
  , tg = 33776
  , ng = 33777
  , ig = 33778
  , rg = 33779
  , J1 = 35840
  , X1 = 35841
  , Y1 = 35842
  , K1 = 35843
  , ER = 36196
  , Q1 = 37492
  , Z1 = 37496
  , q1 = 37808
  , $1 = 37809
  , e_ = 37810
  , t_ = 37811
  , n_ = 37812
  , i_ = 37813
  , r_ = 37814
  , s_ = 37815
  , o_ = 37816
  , a_ = 37817
  , l_ = 37818
  , u_ = 37819
  , c_ = 37820
  , f_ = 37821
  , sg = 36492
  , TR = 36283
  , d_ = 36284
  , h_ = 36285
  , p_ = 36286
  , PR = 2200
  , BR = 2201
  , RR = 2202
  , rc = 2300
  , wl = 2301
  , og = 2302
  , el = 2400
  , tl = 2401
  , Md = 2402
  , C0 = 2500
  , yw = 2501
  , c4 = 0
  , IR = 1
  , xw = 2
  , $s = 3e3
  , Tt = 3001
  , LR = 3200
  , DR = 3201
  , so = 0
  , kR = 1
  , f4 = ""
  , kr = "srgb"
  , sc = "srgb-linear"
  , d4 = 0
  , ag = 7680
  , h4 = 7681
  , p4 = 7682
  , m4 = 7683
  , g4 = 34055
  , v4 = 34056
  , y4 = 5386
  , x4 = 512
  , _4 = 513
  , A4 = 514
  , w4 = 515
  , S4 = 516
  , M4 = 517
  , b4 = 518
  , FR = 519
  , bd = 35044
  , fl = 35048
  , C4 = 35040
  , E4 = 35045
  , T4 = 35049
  , P4 = 35041
  , B4 = 35046
  , R4 = 35050
  , I4 = 35042
  , L4 = "100"
  , m_ = "300 es"
  , Gg = 1035;
class gs {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const i = this._listeners;
        i[e] === void 0 && (i[e] = []),
        i[e].indexOf(t) === -1 && i[e].push(t)
    }
    hasEventListener(e, t) {
        if (this._listeners === void 0)
            return !1;
        const i = this._listeners;
        return i[e] !== void 0 && i[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        if (this._listeners === void 0)
            return;
        const r = this._listeners[e];
        if (r !== void 0) {
            const s = r.indexOf(t);
            s !== -1 && r.splice(s, 1)
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0)
            return;
        const i = this._listeners[e.type];
        if (i !== void 0) {
            e.target = this;
            const r = i.slice(0);
            for (let s = 0, o = r.length; s < o; s++)
                r[s].call(this, e);
            e.target = null
        }
    }
}
const ri = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let KC = 1234567;
const dl = Math.PI / 180
  , Cd = 180 / Math.PI;
function Ji() {
    const n = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , t = Math.random() * 4294967295 | 0
      , i = Math.random() * 4294967295 | 0;
    return (ri[n & 255] + ri[n >> 8 & 255] + ri[n >> 16 & 255] + ri[n >> 24 & 255] + "-" + ri[e & 255] + ri[e >> 8 & 255] + "-" + ri[e >> 16 & 15 | 64] + ri[e >> 24 & 255] + "-" + ri[t & 63 | 128] + ri[t >> 8 & 255] + "-" + ri[t >> 16 & 255] + ri[t >> 24 & 255] + ri[i & 255] + ri[i >> 8 & 255] + ri[i >> 16 & 255] + ri[i >> 24 & 255]).toLowerCase()
}
function wn(n, e, t) {
    return Math.max(e, Math.min(t, n))
}
function _w(n, e) {
    return (n % e + e) % e
}
function D4(n, e, t, i, r) {
    return i + (n - e) * (r - i) / (t - e)
}
function k4(n, e, t) {
    return n !== e ? (t - n) / (e - n) : 0
}
function jf(n, e, t) {
    return (1 - t) * n + t * e
}
function F4(n, e, t, i) {
    return jf(n, e, 1 - Math.exp(-t * i))
}
function N4(n, e=1) {
    return e - Math.abs(_w(n, e * 2) - e)
}
function O4(n, e, t) {
    return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e),
    n * n * (3 - 2 * n))
}
function U4(n, e, t) {
    return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e),
    n * n * n * (n * (n * 6 - 15) + 10))
}
function z4(n, e) {
    return n + Math.floor(Math.random() * (e - n + 1))
}
function G4(n, e) {
    return n + Math.random() * (e - n)
}
function H4(n) {
    return n * (.5 - Math.random())
}
function V4(n) {
    n !== void 0 && (KC = n);
    let e = KC += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1),
    e ^= e + Math.imul(e ^ e >>> 7, e | 61),
    ((e ^ e >>> 14) >>> 0) / 4294967296
}
function W4(n) {
    return n * dl
}
function j4(n) {
    return n * Cd
}
function g_(n) {
    return (n & n - 1) === 0 && n !== 0
}
function NR(n) {
    return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2))
}
function Hg(n) {
    return Math.pow(2, Math.floor(Math.log(n) / Math.LN2))
}
function J4(n, e, t, i, r) {
    const s = Math.cos
      , o = Math.sin
      , a = s(t / 2)
      , l = o(t / 2)
      , c = s((e + i) / 2)
      , d = o((e + i) / 2)
      , h = s((e - i) / 2)
      , p = o((e - i) / 2)
      , m = s((i - e) / 2)
      , y = o((i - e) / 2);
    switch (r) {
    case "XYX":
        n.set(a * d, l * h, l * p, a * c);
        break;
    case "YZY":
        n.set(l * p, a * d, l * h, a * c);
        break;
    case "ZXZ":
        n.set(l * h, l * p, a * d, a * c);
        break;
    case "XZX":
        n.set(a * d, l * y, l * m, a * c);
        break;
    case "YXY":
        n.set(l * m, a * d, l * y, a * c);
        break;
    case "ZYZ":
        n.set(l * y, l * m, a * d, a * c);
        break;
    default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
    }
}
function Gs(n, e) {
    switch (e.constructor) {
    case Float32Array:
        return n;
    case Uint16Array:
        return n / 65535;
    case Uint8Array:
        return n / 255;
    case Int16Array:
        return Math.max(n / 32767, -1);
    case Int8Array:
        return Math.max(n / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function Vt(n, e) {
    switch (e.constructor) {
    case Float32Array:
        return n;
    case Uint16Array:
        return Math.round(n * 65535);
    case Uint8Array:
        return Math.round(n * 255);
    case Int16Array:
        return Math.round(n * 32767);
    case Int8Array:
        return Math.round(n * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
var Aw = Object.freeze({
    __proto__: null,
    DEG2RAD: dl,
    RAD2DEG: Cd,
    ceilPowerOfTwo: NR,
    clamp: wn,
    damp: F4,
    degToRad: W4,
    denormalize: Gs,
    euclideanModulo: _w,
    floorPowerOfTwo: Hg,
    generateUUID: Ji,
    inverseLerp: k4,
    isPowerOfTwo: g_,
    lerp: jf,
    mapLinear: D4,
    normalize: Vt,
    pingpong: N4,
    radToDeg: j4,
    randFloat: G4,
    randFloatSpread: H4,
    randInt: z4,
    seededRandom: V4,
    setQuaternionFromProperEuler: J4,
    smootherstep: U4,
    smoothstep: O4
});
class me {
    constructor(e=0, t=0) {
        me.prototype.isVector2 = !0,
        this.x = e,
        this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e,
        this.y = t,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x
          , i = this.y
          , r = e.elements;
        return this.x = r[0] * t + r[3] * i + r[6],
        this.y = r[1] * t + r[4] * i + r[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , i = this.y - e.y;
        return t * t + i * i
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this
    }
    rotateAround(e, t) {
        const i = Math.cos(t)
          , r = Math.sin(t)
          , s = this.x - e.x
          , o = this.y - e.y;
        return this.x = s * i - o * r + e.x,
        this.y = s * r + o * i + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
class gi {
    constructor() {
        gi.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
    }
    set(e, t, i, r, s, o, a, l, c) {
        const d = this.elements;
        return d[0] = e,
        d[1] = r,
        d[2] = a,
        d[3] = t,
        d[4] = s,
        d[5] = l,
        d[6] = i,
        d[7] = o,
        d[8] = c,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        const t = this.elements
          , i = e.elements;
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        i.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements
          , r = t.elements
          , s = this.elements
          , o = i[0]
          , a = i[3]
          , l = i[6]
          , c = i[1]
          , d = i[4]
          , h = i[7]
          , p = i[2]
          , m = i[5]
          , y = i[8]
          , v = r[0]
          , x = r[3]
          , _ = r[6]
          , A = r[1]
          , w = r[4]
          , M = r[7]
          , C = r[2]
          , P = r[5]
          , R = r[8];
        return s[0] = o * v + a * A + l * C,
        s[3] = o * x + a * w + l * P,
        s[6] = o * _ + a * M + l * R,
        s[1] = c * v + d * A + h * C,
        s[4] = c * x + d * w + h * P,
        s[7] = c * _ + d * M + h * R,
        s[2] = p * v + m * A + y * C,
        s[5] = p * x + m * w + y * P,
        s[8] = p * _ + m * M + y * R,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[3] *= e,
        t[6] *= e,
        t[1] *= e,
        t[4] *= e,
        t[7] *= e,
        t[2] *= e,
        t[5] *= e,
        t[8] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , d = e[8];
        return t * o * d - t * a * c - i * s * d + i * a * l + r * s * c - r * o * l
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , d = e[8]
          , h = d * o - a * c
          , p = a * l - d * s
          , m = c * s - o * l
          , y = t * h + i * p + r * m;
        if (y === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const v = 1 / y;
        return e[0] = h * v,
        e[1] = (r * c - d * i) * v,
        e[2] = (a * i - r * o) * v,
        e[3] = p * v,
        e[4] = (d * t - r * l) * v,
        e[5] = (r * s - a * t) * v,
        e[6] = m * v,
        e[7] = (i * l - c * t) * v,
        e[8] = (o * t - i * s) * v,
        this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0],
        e[1] = t[3],
        e[2] = t[6],
        e[3] = t[1],
        e[4] = t[4],
        e[5] = t[7],
        e[6] = t[2],
        e[7] = t[5],
        e[8] = t[8],
        this
    }
    setUvTransform(e, t, i, r, s, o, a) {
        const l = Math.cos(s)
          , c = Math.sin(s);
        return this.set(i * l, i * c, -i * (l * o + c * a) + o + e, -r * c, r * l, -r * (-c * o + l * a) + a + t, 0, 0, 1),
        this
    }
    scale(e, t) {
        return this.premultiply(ky.makeScale(e, t)),
        this
    }
    rotate(e) {
        return this.premultiply(ky.makeRotation(-e)),
        this
    }
    translate(e, t) {
        return this.premultiply(ky.makeTranslation(e, t)),
        this
    }
    makeTranslation(e, t) {
        return this.set(1, 0, e, 0, 1, t, 0, 0, 1),
        this
    }
    makeRotation(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, -i, 0, i, t, 0, 0, 0, 1),
        this
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
        this
    }
    equals(e) {
        const t = this.elements
          , i = e.elements;
        for (let r = 0; r < 9; r++)
            if (t[r] !== i[r])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let i = 0; i < 9; i++)
            this.elements[i] = e[i + t];
        return this
    }
    toArray(e=[], t=0) {
        const i = this.elements;
        return e[t] = i[0],
        e[t + 1] = i[1],
        e[t + 2] = i[2],
        e[t + 3] = i[3],
        e[t + 4] = i[4],
        e[t + 5] = i[5],
        e[t + 6] = i[6],
        e[t + 7] = i[7],
        e[t + 8] = i[8],
        e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const ky = new gi;
function OR(n) {
    for (let e = n.length - 1; e >= 0; --e)
        if (n[e] >= 65535)
            return !0;
    return !1
}
const X4 = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
};
function Pu(n, e) {
    return new X4[n](e)
}
function Ed(n) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", n)
}
function hl(n) {
    return n < .04045 ? n * .0773993808 : Math.pow(n * .9478672986 + .0521327014, 2.4)
}
function lg(n) {
    return n < .0031308 ? n * 12.92 : 1.055 * Math.pow(n, .41666) - .055
}
const Fy = {
    [kr]: {
        [sc]: hl
    },
    [sc]: {
        [kr]: lg
    }
}
  , si = {
    legacyMode: !0,
    get workingColorSpace() {
        return sc
    },
    set workingColorSpace(n) {
        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
    },
    convert: function(n, e, t) {
        if (this.legacyMode || e === t || !e || !t)
            return n;
        if (Fy[e] && Fy[e][t] !== void 0) {
            const i = Fy[e][t];
            return n.r = i(n.r),
            n.g = i(n.g),
            n.b = i(n.b),
            n
        }
        throw new Error("Unsupported color space conversion.")
    },
    fromWorkingColorSpace: function(n, e) {
        return this.convert(n, this.workingColorSpace, e)
    },
    toWorkingColorSpace: function(n, e) {
        return this.convert(n, e, this.workingColorSpace)
    }
}
  , UR = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , Bn = {
    r: 0,
    g: 0,
    b: 0
}
  , Br = {
    h: 0,
    s: 0,
    l: 0
}
  , zp = {
    h: 0,
    s: 0,
    l: 0
};
function Ny(n, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n
}
function Gp(n, e) {
    return e.r = n.r,
    e.g = n.g,
    e.b = n.b,
    e
}
class Ie {
    constructor(e, t, i) {
        return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        t === void 0 && i === void 0 ? this.set(e) : this.setRGB(e, t, i)
    }
    set(e) {
        return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e),
        this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, t=kr) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        si.toWorkingColorSpace(this, t),
        this
    }
    setRGB(e, t, i, r=si.workingColorSpace) {
        return this.r = e,
        this.g = t,
        this.b = i,
        si.toWorkingColorSpace(this, r),
        this
    }
    setHSL(e, t, i, r=si.workingColorSpace) {
        if (e = _w(e, 1),
        t = wn(t, 0, 1),
        i = wn(i, 0, 1),
        t === 0)
            this.r = this.g = this.b = i;
        else {
            const s = i <= .5 ? i * (1 + t) : i + t - i * t
              , o = 2 * i - s;
            this.r = Ny(o, s, e + 1 / 3),
            this.g = Ny(o, s, e),
            this.b = Ny(o, s, e - 1 / 3)
        }
        return si.toWorkingColorSpace(this, r),
        this
    }
    setStyle(e, t=kr) {
        function i(s) {
            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let r;
        if (r = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
            let s;
            const o = r[1]
              , a = r[2];
            switch (o) {
            case "rgb":
            case "rgba":
                if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return this.r = Math.min(255, parseInt(s[1], 10)) / 255,
                    this.g = Math.min(255, parseInt(s[2], 10)) / 255,
                    this.b = Math.min(255, parseInt(s[3], 10)) / 255,
                    si.toWorkingColorSpace(this, t),
                    i(s[4]),
                    this;
                if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return this.r = Math.min(100, parseInt(s[1], 10)) / 100,
                    this.g = Math.min(100, parseInt(s[2], 10)) / 100,
                    this.b = Math.min(100, parseInt(s[3], 10)) / 100,
                    si.toWorkingColorSpace(this, t),
                    i(s[4]),
                    this;
                break;
            case "hsl":
            case "hsla":
                if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) {
                    const l = parseFloat(s[1]) / 360
                      , c = parseFloat(s[2]) / 100
                      , d = parseFloat(s[3]) / 100;
                    return i(s[4]),
                    this.setHSL(l, c, d, t)
                }
                break
            }
        } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const s = r[1]
              , o = s.length;
            if (o === 3)
                return this.r = parseInt(s.charAt(0) + s.charAt(0), 16) / 255,
                this.g = parseInt(s.charAt(1) + s.charAt(1), 16) / 255,
                this.b = parseInt(s.charAt(2) + s.charAt(2), 16) / 255,
                si.toWorkingColorSpace(this, t),
                this;
            if (o === 6)
                return this.r = parseInt(s.charAt(0) + s.charAt(1), 16) / 255,
                this.g = parseInt(s.charAt(2) + s.charAt(3), 16) / 255,
                this.b = parseInt(s.charAt(4) + s.charAt(5), 16) / 255,
                si.toWorkingColorSpace(this, t),
                this
        }
        return e && e.length > 0 ? this.setColorName(e, t) : this
    }
    setColorName(e, t=kr) {
        const i = UR[e.toLowerCase()];
        return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = hl(e.r),
        this.g = hl(e.g),
        this.b = hl(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = lg(e.r),
        this.g = lg(e.g),
        this.b = lg(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=kr) {
        return si.fromWorkingColorSpace(Gp(this, Bn), e),
        wn(Bn.r * 255, 0, 255) << 16 ^ wn(Bn.g * 255, 0, 255) << 8 ^ wn(Bn.b * 255, 0, 255) << 0
    }
    getHexString(e=kr) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t=si.workingColorSpace) {
        si.fromWorkingColorSpace(Gp(this, Bn), t);
        const i = Bn.r
          , r = Bn.g
          , s = Bn.b
          , o = Math.max(i, r, s)
          , a = Math.min(i, r, s);
        let l, c;
        const d = (a + o) / 2;
        if (a === o)
            l = 0,
            c = 0;
        else {
            const h = o - a;
            switch (c = d <= .5 ? h / (o + a) : h / (2 - o - a),
            o) {
            case i:
                l = (r - s) / h + (r < s ? 6 : 0);
                break;
            case r:
                l = (s - i) / h + 2;
                break;
            case s:
                l = (i - r) / h + 4;
                break
            }
            l /= 6
        }
        return e.h = l,
        e.s = c,
        e.l = d,
        e
    }
    getRGB(e, t=si.workingColorSpace) {
        return si.fromWorkingColorSpace(Gp(this, Bn), t),
        e.r = Bn.r,
        e.g = Bn.g,
        e.b = Bn.b,
        e
    }
    getStyle(e=kr) {
        return si.fromWorkingColorSpace(Gp(this, Bn), e),
        e !== kr ? `color(${e} ${Bn.r} ${Bn.g} ${Bn.b})` : `rgb(${Bn.r * 255 | 0},${Bn.g * 255 | 0},${Bn.b * 255 | 0})`
    }
    offsetHSL(e, t, i) {
        return this.getHSL(Br),
        Br.h += e,
        Br.s += t,
        Br.l += i,
        this.setHSL(Br.h, Br.s, Br.l),
        this
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, t) {
        return this.r = e.r + t.r,
        this.g = e.g + t.g,
        this.b = e.b + t.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t,
        this.g += (e.g - this.g) * t,
        this.b += (e.b - this.b) * t,
        this
    }
    lerpColors(e, t, i) {
        return this.r = e.r + (t.r - e.r) * i,
        this.g = e.g + (t.g - e.g) * i,
        this.b = e.b + (t.b - e.b) * i,
        this
    }
    lerpHSL(e, t) {
        this.getHSL(Br),
        e.getHSL(zp);
        const i = jf(Br.h, zp.h, t)
          , r = jf(Br.s, zp.s, t)
          , s = jf(Br.l, zp.l, t);
        return this.setHSL(i, r, s),
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t=0) {
        return this.r = e[t],
        this.g = e[t + 1],
        this.b = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.r,
        e[t + 1] = this.g,
        e[t + 2] = this.b,
        e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t),
        this.g = e.getY(t),
        this.b = e.getZ(t),
        this
    }
    toJSON() {
        return this.getHex()
    }
    *[Symbol.iterator]() {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
Ie.NAMES = UR;
let Ql;
class ww {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
        let t;
        if (e instanceof HTMLCanvasElement)
            t = e;
        else {
            Ql === void 0 && (Ql = Ed("canvas")),
            Ql.width = e.width,
            Ql.height = e.height;
            const i = Ql.getContext("2d");
            e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height),
            t = Ql
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
        t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = Ed("canvas");
            t.width = e.width,
            t.height = e.height;
            const i = t.getContext("2d");
            i.drawImage(e, 0, 0, e.width, e.height);
            const r = i.getImageData(0, 0, e.width, e.height)
              , s = r.data;
            for (let o = 0; o < s.length; o++)
                s[o] = hl(s[o] / 255) * 255;
            return i.putImageData(r, 0, 0),
            t
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let i = 0; i < t.length; i++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(hl(t[i] / 255) * 255) : t[i] = hl(t[i]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
    }
}
class nl {
    constructor(e=null) {
        this.isSource = !0,
        this.uuid = Ji(),
        this.data = e,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0)
            return e.images[this.uuid];
        const i = {
            uuid: this.uuid,
            url: ""
        }
          , r = this.data;
        if (r !== null) {
            let s;
            if (Array.isArray(r)) {
                s = [];
                for (let o = 0, a = r.length; o < a; o++)
                    r[o].isDataTexture ? s.push(Oy(r[o].image)) : s.push(Oy(r[o]))
            } else
                s = Oy(r);
            i.url = s
        }
        return t || (e.images[this.uuid] = i),
        i
    }
}
function Oy(n) {
    return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? ww.getDataURL(n) : n.data ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
let Y4 = 0;
class tn extends gs {
    constructor(e=tn.DEFAULT_IMAGE, t=tn.DEFAULT_MAPPING, i=Xn, r=Xn, s=on, o=ps, a=Ti, l=qs, c=tn.DEFAULT_ANISOTROPY, d=$s) {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: Y4++
        }),
        this.uuid = Ji(),
        this.name = "",
        this.source = new nl(e),
        this.mipmaps = [],
        this.mapping = t,
        this.wrapS = i,
        this.wrapT = r,
        this.magFilter = s,
        this.minFilter = o,
        this.anisotropy = c,
        this.format = a,
        this.internalFormat = null,
        this.type = l,
        this.offset = new me(0,0),
        this.repeat = new me(1,1),
        this.center = new me(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new gi,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.encoding = d,
        this.userData = {},
        this.version = 0,
        this.onUpdate = null,
        this.isRenderTargetTexture = !1,
        this.needsPMREMUpdate = !1
    }
    get image() {
        return this.source.data
    }
    set image(e) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.encoding = e.encoding,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        const i = {
            metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (i.userData = this.userData),
        t || (e.textures[this.uuid] = i),
        i
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== M0)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case na:
                e.x = e.x - Math.floor(e.x);
                break;
            case Xn:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case nc:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case na:
                e.y = e.y - Math.floor(e.y);
                break;
            case Xn:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case nc:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
}
tn.DEFAULT_IMAGE = null;
tn.DEFAULT_MAPPING = M0;
tn.DEFAULT_ANISOTROPY = 1;
class Ut {
    constructor(e=0, t=0, i=0, r=1) {
        Ut.prototype.isVector4 = !0,
        this.x = e,
        this.y = t,
        this.z = i,
        this.w = r
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, i, r) {
        return this.x = e,
        this.y = t,
        this.z = i,
        this.w = r,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = this.w
          , o = e.elements;
        return this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s,
        this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s,
        this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s,
        this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / t,
        this.y = e.y / t,
        this.z = e.z / t),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, i, r, s;
        const l = e.elements
          , c = l[0]
          , d = l[4]
          , h = l[8]
          , p = l[1]
          , m = l[5]
          , y = l[9]
          , v = l[2]
          , x = l[6]
          , _ = l[10];
        if (Math.abs(d - p) < .01 && Math.abs(h - v) < .01 && Math.abs(y - x) < .01) {
            if (Math.abs(d + p) < .1 && Math.abs(h + v) < .1 && Math.abs(y + x) < .1 && Math.abs(c + m + _ - 3) < .1)
                return this.set(1, 0, 0, 0),
                this;
            t = Math.PI;
            const w = (c + 1) / 2
              , M = (m + 1) / 2
              , C = (_ + 1) / 2
              , P = (d + p) / 4
              , R = (h + v) / 4
              , E = (y + x) / 4;
            return w > M && w > C ? w < .01 ? (i = 0,
            r = .707106781,
            s = .707106781) : (i = Math.sqrt(w),
            r = P / i,
            s = R / i) : M > C ? M < .01 ? (i = .707106781,
            r = 0,
            s = .707106781) : (r = Math.sqrt(M),
            i = P / r,
            s = E / r) : C < .01 ? (i = .707106781,
            r = .707106781,
            s = 0) : (s = Math.sqrt(C),
            i = R / s,
            r = E / s),
            this.set(i, r, s, t),
            this
        }
        let A = Math.sqrt((x - y) * (x - y) + (h - v) * (h - v) + (p - d) * (p - d));
        return Math.abs(A) < .001 && (A = 1),
        this.x = (x - y) / A,
        this.y = (h - v) / A,
        this.z = (p - d) / A,
        this.w = Math.acos((c + m + _ - 1) / 2),
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this.w = Math.max(e.w, Math.min(t.w, this.w)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this.w = Math.max(e, Math.min(t, this.w)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this.w += (e.w - this.w) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this.z = e.z + (t.z - e.z) * i,
        this.w = e.w + (t.w - e.w) * i,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this.w = e.getW(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
class jr extends gs {
    constructor(e=1, t=1, i={}) {
        super(),
        this.isWebGLRenderTarget = !0,
        this.width = e,
        this.height = t,
        this.depth = 1,
        this.scissor = new Ut(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new Ut(0,0,e,t);
        const r = {
            width: e,
            height: t,
            depth: 1
        };
        this.texture = new tn(r,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding),
        this.texture.isRenderTargetTexture = !0,
        this.texture.flipY = !1,
        this.texture.generateMipmaps = i.generateMipmaps !== void 0 ? i.generateMipmaps : !1,
        this.texture.internalFormat = i.internalFormat !== void 0 ? i.internalFormat : null,
        this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : on,
        this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : !0,
        this.stencilBuffer = i.stencilBuffer !== void 0 ? i.stencilBuffer : !1,
        this.depthTexture = i.depthTexture !== void 0 ? i.depthTexture : null,
        this.samples = i.samples !== void 0 ? i.samples : 0
    }
    setSize(e, t, i=1) {
        (this.width !== e || this.height !== t || this.depth !== i) && (this.width = e,
        this.height = t,
        this.depth = i,
        this.texture.image.width = e,
        this.texture.image.height = t,
        this.texture.image.depth = i,
        this.dispose()),
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.viewport.copy(e.viewport),
        this.texture = e.texture.clone(),
        this.texture.isRenderTargetTexture = !0;
        const t = Object.assign({}, e.texture.image);
        return this.texture.source = new nl(t),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class E0 extends tn {
    constructor(e=null, t=1, i=1, r=1) {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i,
            depth: r
        },
        this.magFilter = gn,
        this.minFilter = gn,
        this.wrapR = Xn,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class K4 extends jr {
    constructor(e=1, t=1, i=1) {
        super(e, t),
        this.isWebGLArrayRenderTarget = !0,
        this.depth = i,
        this.texture = new E0(null,e,t,i),
        this.texture.isRenderTargetTexture = !0
    }
}
class Sw extends tn {
    constructor(e=null, t=1, i=1, r=1) {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i,
            depth: r
        },
        this.magFilter = gn,
        this.minFilter = gn,
        this.wrapR = Xn,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class Q4 extends jr {
    constructor(e=1, t=1, i=1) {
        super(e, t),
        this.isWebGL3DRenderTarget = !0,
        this.depth = i,
        this.texture = new Sw(null,e,t,i),
        this.texture.isRenderTargetTexture = !0
    }
}
class Z4 extends jr {
    constructor(e=1, t=1, i=1, r={}) {
        super(e, t, r),
        this.isWebGLMultipleRenderTargets = !0;
        const s = this.texture;
        this.texture = [];
        for (let o = 0; o < i; o++)
            this.texture[o] = s.clone(),
            this.texture[o].isRenderTargetTexture = !0
    }
    setSize(e, t, i=1) {
        if (this.width !== e || this.height !== t || this.depth !== i) {
            this.width = e,
            this.height = t,
            this.depth = i;
            for (let r = 0, s = this.texture.length; r < s; r++)
                this.texture[r].image.width = e,
                this.texture[r].image.height = t,
                this.texture[r].image.depth = i;
            this.dispose()
        }
        return this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t),
        this
    }
    copy(e) {
        this.dispose(),
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.viewport.set(0, 0, this.width, this.height),
        this.scissor.set(0, 0, this.width, this.height),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.texture.length = 0;
        for (let t = 0, i = e.texture.length; t < i; t++)
            this.texture[t] = e.texture[t].clone(),
            this.texture[t].isRenderTargetTexture = !0;
        return this
    }
}
class Qn {
    constructor(e=0, t=0, i=0, r=1) {
        this.isQuaternion = !0,
        this._x = e,
        this._y = t,
        this._z = i,
        this._w = r
    }
    static slerpFlat(e, t, i, r, s, o, a) {
        let l = i[r + 0]
          , c = i[r + 1]
          , d = i[r + 2]
          , h = i[r + 3];
        const p = s[o + 0]
          , m = s[o + 1]
          , y = s[o + 2]
          , v = s[o + 3];
        if (a === 0) {
            e[t + 0] = l,
            e[t + 1] = c,
            e[t + 2] = d,
            e[t + 3] = h;
            return
        }
        if (a === 1) {
            e[t + 0] = p,
            e[t + 1] = m,
            e[t + 2] = y,
            e[t + 3] = v;
            return
        }
        if (h !== v || l !== p || c !== m || d !== y) {
            let x = 1 - a;
            const _ = l * p + c * m + d * y + h * v
              , A = _ >= 0 ? 1 : -1
              , w = 1 - _ * _;
            if (w > Number.EPSILON) {
                const C = Math.sqrt(w)
                  , P = Math.atan2(C, _ * A);
                x = Math.sin(x * P) / C,
                a = Math.sin(a * P) / C
            }
            const M = a * A;
            if (l = l * x + p * M,
            c = c * x + m * M,
            d = d * x + y * M,
            h = h * x + v * M,
            x === 1 - a) {
                const C = 1 / Math.sqrt(l * l + c * c + d * d + h * h);
                l *= C,
                c *= C,
                d *= C,
                h *= C
            }
        }
        e[t] = l,
        e[t + 1] = c,
        e[t + 2] = d,
        e[t + 3] = h
    }
    static multiplyQuaternionsFlat(e, t, i, r, s, o) {
        const a = i[r]
          , l = i[r + 1]
          , c = i[r + 2]
          , d = i[r + 3]
          , h = s[o]
          , p = s[o + 1]
          , m = s[o + 2]
          , y = s[o + 3];
        return e[t] = a * y + d * h + l * m - c * p,
        e[t + 1] = l * y + d * p + c * h - a * m,
        e[t + 2] = c * y + d * m + a * p - l * h,
        e[t + 3] = d * y - a * h - l * p - c * m,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, t, i, r) {
        return this._x = e,
        this._y = t,
        this._z = i,
        this._w = r,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, t) {
        const i = e._x
          , r = e._y
          , s = e._z
          , o = e._order
          , a = Math.cos
          , l = Math.sin
          , c = a(i / 2)
          , d = a(r / 2)
          , h = a(s / 2)
          , p = l(i / 2)
          , m = l(r / 2)
          , y = l(s / 2);
        switch (o) {
        case "XYZ":
            this._x = p * d * h + c * m * y,
            this._y = c * m * h - p * d * y,
            this._z = c * d * y + p * m * h,
            this._w = c * d * h - p * m * y;
            break;
        case "YXZ":
            this._x = p * d * h + c * m * y,
            this._y = c * m * h - p * d * y,
            this._z = c * d * y - p * m * h,
            this._w = c * d * h + p * m * y;
            break;
        case "ZXY":
            this._x = p * d * h - c * m * y,
            this._y = c * m * h + p * d * y,
            this._z = c * d * y + p * m * h,
            this._w = c * d * h - p * m * y;
            break;
        case "ZYX":
            this._x = p * d * h - c * m * y,
            this._y = c * m * h + p * d * y,
            this._z = c * d * y - p * m * h,
            this._w = c * d * h + p * m * y;
            break;
        case "YZX":
            this._x = p * d * h + c * m * y,
            this._y = c * m * h + p * d * y,
            this._z = c * d * y - p * m * h,
            this._w = c * d * h - p * m * y;
            break;
        case "XZY":
            this._x = p * d * h - c * m * y,
            this._y = c * m * h - p * d * y,
            this._z = c * d * y + p * m * h,
            this._w = c * d * h + p * m * y;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return t !== !1 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, t) {
        const i = t / 2
          , r = Math.sin(i);
        return this._x = e.x * r,
        this._y = e.y * r,
        this._z = e.z * r,
        this._w = Math.cos(i),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        const t = e.elements
          , i = t[0]
          , r = t[4]
          , s = t[8]
          , o = t[1]
          , a = t[5]
          , l = t[9]
          , c = t[2]
          , d = t[6]
          , h = t[10]
          , p = i + a + h;
        if (p > 0) {
            const m = .5 / Math.sqrt(p + 1);
            this._w = .25 / m,
            this._x = (d - l) * m,
            this._y = (s - c) * m,
            this._z = (o - r) * m
        } else if (i > a && i > h) {
            const m = 2 * Math.sqrt(1 + i - a - h);
            this._w = (d - l) / m,
            this._x = .25 * m,
            this._y = (r + o) / m,
            this._z = (s + c) / m
        } else if (a > h) {
            const m = 2 * Math.sqrt(1 + a - i - h);
            this._w = (s - c) / m,
            this._x = (r + o) / m,
            this._y = .25 * m,
            this._z = (l + d) / m
        } else {
            const m = 2 * Math.sqrt(1 + h - i - a);
            this._w = (o - r) / m,
            this._x = (s + c) / m,
            this._y = (l + d) / m,
            this._z = .25 * m
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, t) {
        let i = e.dot(t) + 1;
        return i < Number.EPSILON ? (i = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = i) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = i)) : (this._x = e.y * t.z - e.z * t.y,
        this._y = e.z * t.x - e.x * t.z,
        this._z = e.x * t.y - e.y * t.x,
        this._w = i),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(wn(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const i = this.angleTo(e);
        if (i === 0)
            return this;
        const r = Math.min(1, t / i);
        return this.slerp(e, r),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const i = e._x
          , r = e._y
          , s = e._z
          , o = e._w
          , a = t._x
          , l = t._y
          , c = t._z
          , d = t._w;
        return this._x = i * d + o * a + r * c - s * l,
        this._y = r * d + o * l + s * a - i * c,
        this._z = s * d + o * c + i * l - r * a,
        this._w = o * d - i * a - r * l - s * c,
        this._onChangeCallback(),
        this
    }
    slerp(e, t) {
        if (t === 0)
            return this;
        if (t === 1)
            return this.copy(e);
        const i = this._x
          , r = this._y
          , s = this._z
          , o = this._w;
        let a = o * e._w + i * e._x + r * e._y + s * e._z;
        if (a < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        a = -a) : this.copy(e),
        a >= 1)
            return this._w = o,
            this._x = i,
            this._y = r,
            this._z = s,
            this;
        const l = 1 - a * a;
        if (l <= Number.EPSILON) {
            const m = 1 - t;
            return this._w = m * o + t * this._w,
            this._x = m * i + t * this._x,
            this._y = m * r + t * this._y,
            this._z = m * s + t * this._z,
            this.normalize(),
            this._onChangeCallback(),
            this
        }
        const c = Math.sqrt(l)
          , d = Math.atan2(c, a)
          , h = Math.sin((1 - t) * d) / c
          , p = Math.sin(t * d) / c;
        return this._w = o * h + this._w * p,
        this._x = i * h + this._x * p,
        this._y = r * h + this._y * p,
        this._z = s * h + this._z * p,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, t, i) {
        return this.copy(e).slerp(t, i)
    }
    random() {
        const e = Math.random()
          , t = Math.sqrt(1 - e)
          , i = Math.sqrt(e)
          , r = 2 * Math.PI * Math.random()
          , s = 2 * Math.PI * Math.random();
        return this.set(t * Math.cos(r), i * Math.sin(s), i * Math.cos(s), t * Math.sin(r))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t=0) {
        return this._x = e[t],
        this._y = e[t + 1],
        this._z = e[t + 2],
        this._w = e[t + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t),
        this._y = e.getY(t),
        this._z = e.getZ(t),
        this._w = e.getW(t),
        this
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class D {
    constructor(e=0, t=0, i=0) {
        D.prototype.isVector3 = !0,
        this.x = e,
        this.y = t,
        this.z = i
    }
    set(e, t, i) {
        return i === void 0 && (i = this.z),
        this.x = e,
        this.y = t,
        this.z = i,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this
    }
    applyEuler(e) {
        return this.applyQuaternion(QC.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(QC.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[3] * i + s[6] * r,
        this.y = s[1] * t + s[4] * i + s[7] * r,
        this.z = s[2] * t + s[5] * i + s[8] * r,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.elements
          , o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
        return this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o,
        this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o,
        this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o,
        this
    }
    applyQuaternion(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.x
          , o = e.y
          , a = e.z
          , l = e.w
          , c = l * t + o * r - a * i
          , d = l * i + a * t - s * r
          , h = l * r + s * i - o * t
          , p = -s * t - o * i - a * r;
        return this.x = c * l + p * -s + d * -a - h * -o,
        this.y = d * l + p * -o + h * -s - c * -a,
        this.z = h * l + p * -a + c * -o - d * -s,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[4] * i + s[8] * r,
        this.y = s[1] * t + s[5] * i + s[9] * r,
        this.z = s[2] * t + s[6] * i + s[10] * r,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this.z = e.z + (t.z - e.z) * i,
        this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z
          , o = t.x
          , a = t.y
          , l = t.z;
        return this.x = r * l - s * a,
        this.y = s * o - i * l,
        this.z = i * a - r * o,
        this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0)
            return this.set(0, 0, 0);
        const i = e.dot(this) / t;
        return this.copy(e).multiplyScalar(i)
    }
    projectOnPlane(e) {
        return Uy.copy(this).projectOnVector(e),
        this.sub(Uy)
    }
    reflect(e) {
        return this.sub(Uy.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(wn(i, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , i = this.y - e.y
          , r = this.z - e.z;
        return t * t + i * i + r * r
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, i) {
        const r = Math.sin(t) * e;
        return this.x = r * Math.sin(i),
        this.y = Math.cos(t) * e,
        this.z = r * Math.cos(i),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, i) {
        return this.x = e * Math.sin(t),
        this.y = i,
        this.z = e * Math.cos(t),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length()
          , i = this.setFromMatrixColumn(e, 1).length()
          , r = this.setFromMatrixColumn(e, 2).length();
        return this.x = t,
        this.y = i,
        this.z = r,
        this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const e = (Math.random() - .5) * 2
          , t = Math.random() * Math.PI * 2
          , i = Math.sqrt(1 - e ** 2);
        return this.x = i * Math.cos(t),
        this.y = i * Math.sin(t),
        this.z = e,
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const Uy = new D
  , QC = new Qn;
class ha {
    constructor(e=new D(1 / 0,1 / 0,1 / 0), t=new D(-1 / 0,-1 / 0,-1 / 0)) {
        this.isBox3 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromArray(e) {
        let t = 1 / 0
          , i = 1 / 0
          , r = 1 / 0
          , s = -1 / 0
          , o = -1 / 0
          , a = -1 / 0;
        for (let l = 0, c = e.length; l < c; l += 3) {
            const d = e[l]
              , h = e[l + 1]
              , p = e[l + 2];
            d < t && (t = d),
            h < i && (i = h),
            p < r && (r = p),
            d > s && (s = d),
            h > o && (o = h),
            p > a && (a = p)
        }
        return this.min.set(t, i, r),
        this.max.set(s, o, a),
        this
    }
    setFromBufferAttribute(e) {
        let t = 1 / 0
          , i = 1 / 0
          , r = 1 / 0
          , s = -1 / 0
          , o = -1 / 0
          , a = -1 / 0;
        for (let l = 0, c = e.count; l < c; l++) {
            const d = e.getX(l)
              , h = e.getY(l)
              , p = e.getZ(l);
            d < t && (t = d),
            h < i && (i = h),
            p < r && (r = p),
            d > s && (s = d),
            h > o && (o = h),
            p > a && (a = p)
        }
        return this.min.set(t, i, r),
        this.max.set(s, o, a),
        this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const i = Pa.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(i),
        this.max.copy(e).add(i),
        this
    }
    setFromObject(e, t=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, t=!1) {
        e.updateWorldMatrix(!1, !1);
        const i = e.geometry;
        if (i !== void 0)
            if (t && i.attributes != null && i.attributes.position !== void 0) {
                const s = i.attributes.position;
                for (let o = 0, a = s.count; o < a; o++)
                    Pa.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld),
                    this.expandByPoint(Pa)
            } else
                i.boundingBox === null && i.computeBoundingBox(),
                zy.copy(i.boundingBox),
                zy.applyMatrix4(e.matrixWorld),
                this.union(zy);
        const r = e.children;
        for (let s = 0, o = r.length; s < o; s++)
            this.expandByObject(r[s], t);
        return this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, Pa),
        Pa.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, i;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
        i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
        i = e.normal.x * this.min.x),
        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
        i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
        i += e.normal.y * this.min.y),
        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
        i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
        i += e.normal.z * this.min.z),
        t <= -e.constant && i >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(of),
        Hp.subVectors(this.max, of),
        Zl.subVectors(e.a, of),
        ql.subVectors(e.b, of),
        $l.subVectors(e.c, of),
        xo.subVectors(ql, Zl),
        _o.subVectors($l, ql),
        Ba.subVectors(Zl, $l);
        let t = [0, -xo.z, xo.y, 0, -_o.z, _o.y, 0, -Ba.z, Ba.y, xo.z, 0, -xo.x, _o.z, 0, -_o.x, Ba.z, 0, -Ba.x, -xo.y, xo.x, 0, -_o.y, _o.x, 0, -Ba.y, Ba.x, 0];
        return !Gy(t, Zl, ql, $l, Hp) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !Gy(t, Zl, ql, $l, Hp)) ? !1 : (Vp.crossVectors(xo, _o),
        t = [Vp.x, Vp.y, Vp.z],
        Gy(t, Zl, ql, $l, Hp))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return Pa.copy(e).clamp(this.min, this.max).sub(e).length()
    }
    getBoundingSphere(e) {
        return this.getCenter(e.center),
        e.radius = this.getSize(Pa).length() * .5,
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (Es[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Es[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Es[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Es[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Es[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Es[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Es[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Es[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Es),
        this)
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const Es = [new D, new D, new D, new D, new D, new D, new D, new D]
  , Pa = new D
  , zy = new ha
  , Zl = new D
  , ql = new D
  , $l = new D
  , xo = new D
  , _o = new D
  , Ba = new D
  , of = new D
  , Hp = new D
  , Vp = new D
  , Ra = new D;
function Gy(n, e, t, i, r) {
    for (let s = 0, o = n.length - 3; s <= o; s += 3) {
        Ra.fromArray(n, s);
        const a = r.x * Math.abs(Ra.x) + r.y * Math.abs(Ra.y) + r.z * Math.abs(Ra.z)
          , l = e.dot(Ra)
          , c = t.dot(Ra)
          , d = i.dot(Ra);
        if (Math.max(-Math.max(l, c, d), Math.min(l, c, d)) > a)
            return !1
    }
    return !0
}
const q4 = new ha
  , af = new D
  , Hy = new D;
class pa {
    constructor(e=new D, t=-1) {
        this.center = e,
        this.radius = t
    }
    set(e, t) {
        return this.center.copy(e),
        this.radius = t,
        this
    }
    setFromPoints(e, t) {
        const i = this.center;
        t !== void 0 ? i.copy(t) : q4.setFromPoints(e).getCenter(i);
        let r = 0;
        for (let s = 0, o = e.length; s < o; s++)
            r = Math.max(r, i.distanceToSquared(e[s]));
        return this.radius = Math.sqrt(r),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const i = this.center.distanceToSquared(e);
        return t.copy(e),
        i > this.radius * this.radius && (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
        t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        if (this.isEmpty())
            return this.center.copy(e),
            this.radius = 0,
            this;
        af.subVectors(e, this.center);
        const t = af.lengthSq();
        if (t > this.radius * this.radius) {
            const i = Math.sqrt(t)
              , r = (i - this.radius) * .5;
            this.center.addScaledVector(af, r / i),
            this.radius += r
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Hy.subVectors(e.center, this.center).setLength(e.radius),
        this.expandByPoint(af.copy(e.center).add(Hy)),
        this.expandByPoint(af.copy(e.center).sub(Hy))),
        this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const Ts = new D
  , Vy = new D
  , Wp = new D
  , Ao = new D
  , Wy = new D
  , jp = new D
  , jy = new D;
class $d {
    constructor(e=new D, t=new D(0,0,-1)) {
        this.origin = e,
        this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e),
        this.direction.copy(t),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, t) {
        return t.copy(this.direction).multiplyScalar(e).add(this.origin)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, Ts)),
        this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const i = t.dot(this.direction);
        return i < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(i).add(this.origin)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = Ts.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (Ts.copy(this.direction).multiplyScalar(t).add(this.origin),
        Ts.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, i, r) {
        Vy.copy(e).add(t).multiplyScalar(.5),
        Wp.copy(t).sub(e).normalize(),
        Ao.copy(this.origin).sub(Vy);
        const s = e.distanceTo(t) * .5
          , o = -this.direction.dot(Wp)
          , a = Ao.dot(this.direction)
          , l = -Ao.dot(Wp)
          , c = Ao.lengthSq()
          , d = Math.abs(1 - o * o);
        let h, p, m, y;
        if (d > 0)
            if (h = o * l - a,
            p = o * a - l,
            y = s * d,
            h >= 0)
                if (p >= -y)
                    if (p <= y) {
                        const v = 1 / d;
                        h *= v,
                        p *= v,
                        m = h * (h + o * p + 2 * a) + p * (o * h + p + 2 * l) + c
                    } else
                        p = s,
                        h = Math.max(0, -(o * p + a)),
                        m = -h * h + p * (p + 2 * l) + c;
                else
                    p = -s,
                    h = Math.max(0, -(o * p + a)),
                    m = -h * h + p * (p + 2 * l) + c;
            else
                p <= -y ? (h = Math.max(0, -(-o * s + a)),
                p = h > 0 ? -s : Math.min(Math.max(-s, -l), s),
                m = -h * h + p * (p + 2 * l) + c) : p <= y ? (h = 0,
                p = Math.min(Math.max(-s, -l), s),
                m = p * (p + 2 * l) + c) : (h = Math.max(0, -(o * s + a)),
                p = h > 0 ? s : Math.min(Math.max(-s, -l), s),
                m = -h * h + p * (p + 2 * l) + c);
        else
            p = o > 0 ? -s : s,
            h = Math.max(0, -(o * p + a)),
            m = -h * h + p * (p + 2 * l) + c;
        return i && i.copy(this.direction).multiplyScalar(h).add(this.origin),
        r && r.copy(Wp).multiplyScalar(p).add(Vy),
        m
    }
    intersectSphere(e, t) {
        Ts.subVectors(e.center, this.origin);
        const i = Ts.dot(this.direction)
          , r = Ts.dot(Ts) - i * i
          , s = e.radius * e.radius;
        if (r > s)
            return null;
        const o = Math.sqrt(s - r)
          , a = i - o
          , l = i + o;
        return a < 0 && l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0)
            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const i = -(this.origin.dot(e.normal) + e.constant) / t;
        return i >= 0 ? i : null
    }
    intersectPlane(e, t) {
        const i = this.distanceToPlane(e);
        return i === null ? null : this.at(i, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let i, r, s, o, a, l;
        const c = 1 / this.direction.x
          , d = 1 / this.direction.y
          , h = 1 / this.direction.z
          , p = this.origin;
        return c >= 0 ? (i = (e.min.x - p.x) * c,
        r = (e.max.x - p.x) * c) : (i = (e.max.x - p.x) * c,
        r = (e.min.x - p.x) * c),
        d >= 0 ? (s = (e.min.y - p.y) * d,
        o = (e.max.y - p.y) * d) : (s = (e.max.y - p.y) * d,
        o = (e.min.y - p.y) * d),
        i > o || s > r || ((s > i || isNaN(i)) && (i = s),
        (o < r || isNaN(r)) && (r = o),
        h >= 0 ? (a = (e.min.z - p.z) * h,
        l = (e.max.z - p.z) * h) : (a = (e.max.z - p.z) * h,
        l = (e.min.z - p.z) * h),
        i > l || a > r) || ((a > i || i !== i) && (i = a),
        (l < r || r !== r) && (r = l),
        r < 0) ? null : this.at(i >= 0 ? i : r, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, Ts) !== null
    }
    intersectTriangle(e, t, i, r, s) {
        Wy.subVectors(t, e),
        jp.subVectors(i, e),
        jy.crossVectors(Wy, jp);
        let o = this.direction.dot(jy), a;
        if (o > 0) {
            if (r)
                return null;
            a = 1
        } else if (o < 0)
            a = -1,
            o = -o;
        else
            return null;
        Ao.subVectors(this.origin, e);
        const l = a * this.direction.dot(jp.crossVectors(Ao, jp));
        if (l < 0)
            return null;
        const c = a * this.direction.dot(Wy.cross(Ao));
        if (c < 0 || l + c > o)
            return null;
        const d = -a * Ao.dot(jy);
        return d < 0 ? null : this.at(d / o, s)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class ot {
    constructor() {
        ot.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    }
    set(e, t, i, r, s, o, a, l, c, d, h, p, m, y, v, x) {
        const _ = this.elements;
        return _[0] = e,
        _[4] = t,
        _[8] = i,
        _[12] = r,
        _[1] = s,
        _[5] = o,
        _[9] = a,
        _[13] = l,
        _[2] = c,
        _[6] = d,
        _[10] = h,
        _[14] = p,
        _[3] = m,
        _[7] = y,
        _[11] = v,
        _[15] = x,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new ot().fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements
          , i = e.elements;
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        t[9] = i[9],
        t[10] = i[10],
        t[11] = i[11],
        t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        t[15] = i[15],
        this
    }
    copyPosition(e) {
        const t = this.elements
          , i = e.elements;
        return t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        i.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, t, i) {
        return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        const t = this.elements
          , i = e.elements
          , r = 1 / eu.setFromMatrixColumn(e, 0).length()
          , s = 1 / eu.setFromMatrixColumn(e, 1).length()
          , o = 1 / eu.setFromMatrixColumn(e, 2).length();
        return t[0] = i[0] * r,
        t[1] = i[1] * r,
        t[2] = i[2] * r,
        t[3] = 0,
        t[4] = i[4] * s,
        t[5] = i[5] * s,
        t[6] = i[6] * s,
        t[7] = 0,
        t[8] = i[8] * o,
        t[9] = i[9] * o,
        t[10] = i[10] * o,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        const t = this.elements
          , i = e.x
          , r = e.y
          , s = e.z
          , o = Math.cos(i)
          , a = Math.sin(i)
          , l = Math.cos(r)
          , c = Math.sin(r)
          , d = Math.cos(s)
          , h = Math.sin(s);
        if (e.order === "XYZ") {
            const p = o * d
              , m = o * h
              , y = a * d
              , v = a * h;
            t[0] = l * d,
            t[4] = -l * h,
            t[8] = c,
            t[1] = m + y * c,
            t[5] = p - v * c,
            t[9] = -a * l,
            t[2] = v - p * c,
            t[6] = y + m * c,
            t[10] = o * l
        } else if (e.order === "YXZ") {
            const p = l * d
              , m = l * h
              , y = c * d
              , v = c * h;
            t[0] = p + v * a,
            t[4] = y * a - m,
            t[8] = o * c,
            t[1] = o * h,
            t[5] = o * d,
            t[9] = -a,
            t[2] = m * a - y,
            t[6] = v + p * a,
            t[10] = o * l
        } else if (e.order === "ZXY") {
            const p = l * d
              , m = l * h
              , y = c * d
              , v = c * h;
            t[0] = p - v * a,
            t[4] = -o * h,
            t[8] = y + m * a,
            t[1] = m + y * a,
            t[5] = o * d,
            t[9] = v - p * a,
            t[2] = -o * c,
            t[6] = a,
            t[10] = o * l
        } else if (e.order === "ZYX") {
            const p = o * d
              , m = o * h
              , y = a * d
              , v = a * h;
            t[0] = l * d,
            t[4] = y * c - m,
            t[8] = p * c + v,
            t[1] = l * h,
            t[5] = v * c + p,
            t[9] = m * c - y,
            t[2] = -c,
            t[6] = a * l,
            t[10] = o * l
        } else if (e.order === "YZX") {
            const p = o * l
              , m = o * c
              , y = a * l
              , v = a * c;
            t[0] = l * d,
            t[4] = v - p * h,
            t[8] = y * h + m,
            t[1] = h,
            t[5] = o * d,
            t[9] = -a * d,
            t[2] = -c * d,
            t[6] = m * h + y,
            t[10] = p - v * h
        } else if (e.order === "XZY") {
            const p = o * l
              , m = o * c
              , y = a * l
              , v = a * c;
            t[0] = l * d,
            t[4] = -h,
            t[8] = c * d,
            t[1] = p * h + v,
            t[5] = o * d,
            t[9] = m * h - y,
            t[2] = y * h - m,
            t[6] = a * d,
            t[10] = v * h + p
        }
        return t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose($4, e, eU)
    }
    lookAt(e, t, i) {
        const r = this.elements;
        return Ui.subVectors(e, t),
        Ui.lengthSq() === 0 && (Ui.z = 1),
        Ui.normalize(),
        wo.crossVectors(i, Ui),
        wo.lengthSq() === 0 && (Math.abs(i.z) === 1 ? Ui.x += 1e-4 : Ui.z += 1e-4,
        Ui.normalize(),
        wo.crossVectors(i, Ui)),
        wo.normalize(),
        Jp.crossVectors(Ui, wo),
        r[0] = wo.x,
        r[4] = Jp.x,
        r[8] = Ui.x,
        r[1] = wo.y,
        r[5] = Jp.y,
        r[9] = Ui.y,
        r[2] = wo.z,
        r[6] = Jp.z,
        r[10] = Ui.z,
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements
          , r = t.elements
          , s = this.elements
          , o = i[0]
          , a = i[4]
          , l = i[8]
          , c = i[12]
          , d = i[1]
          , h = i[5]
          , p = i[9]
          , m = i[13]
          , y = i[2]
          , v = i[6]
          , x = i[10]
          , _ = i[14]
          , A = i[3]
          , w = i[7]
          , M = i[11]
          , C = i[15]
          , P = r[0]
          , R = r[4]
          , E = r[8]
          , B = r[12]
          , I = r[1]
          , z = r[5]
          , q = r[9]
          , W = r[13]
          , G = r[2]
          , K = r[6]
          , ne = r[10]
          , oe = r[14]
          , F = r[3]
          , V = r[7]
          , Y = r[11]
          , re = r[15];
        return s[0] = o * P + a * I + l * G + c * F,
        s[4] = o * R + a * z + l * K + c * V,
        s[8] = o * E + a * q + l * ne + c * Y,
        s[12] = o * B + a * W + l * oe + c * re,
        s[1] = d * P + h * I + p * G + m * F,
        s[5] = d * R + h * z + p * K + m * V,
        s[9] = d * E + h * q + p * ne + m * Y,
        s[13] = d * B + h * W + p * oe + m * re,
        s[2] = y * P + v * I + x * G + _ * F,
        s[6] = y * R + v * z + x * K + _ * V,
        s[10] = y * E + v * q + x * ne + _ * Y,
        s[14] = y * B + v * W + x * oe + _ * re,
        s[3] = A * P + w * I + M * G + C * F,
        s[7] = A * R + w * z + M * K + C * V,
        s[11] = A * E + w * q + M * ne + C * Y,
        s[15] = A * B + w * W + M * oe + C * re,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[4] *= e,
        t[8] *= e,
        t[12] *= e,
        t[1] *= e,
        t[5] *= e,
        t[9] *= e,
        t[13] *= e,
        t[2] *= e,
        t[6] *= e,
        t[10] *= e,
        t[14] *= e,
        t[3] *= e,
        t[7] *= e,
        t[11] *= e,
        t[15] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , i = e[4]
          , r = e[8]
          , s = e[12]
          , o = e[1]
          , a = e[5]
          , l = e[9]
          , c = e[13]
          , d = e[2]
          , h = e[6]
          , p = e[10]
          , m = e[14]
          , y = e[3]
          , v = e[7]
          , x = e[11]
          , _ = e[15];
        return y * (+s * l * h - r * c * h - s * a * p + i * c * p + r * a * m - i * l * m) + v * (+t * l * m - t * c * p + s * o * p - r * o * m + r * c * d - s * l * d) + x * (+t * c * h - t * a * m - s * o * h + i * o * m + s * a * d - i * c * d) + _ * (-r * a * d - t * l * h + t * a * p + r * o * h - i * o * p + i * l * d)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1],
        e[1] = e[4],
        e[4] = t,
        t = e[2],
        e[2] = e[8],
        e[8] = t,
        t = e[6],
        e[6] = e[9],
        e[9] = t,
        t = e[3],
        e[3] = e[12],
        e[12] = t,
        t = e[7],
        e[7] = e[13],
        e[13] = t,
        t = e[11],
        e[11] = e[14],
        e[14] = t,
        this
    }
    setPosition(e, t, i) {
        const r = this.elements;
        return e.isVector3 ? (r[12] = e.x,
        r[13] = e.y,
        r[14] = e.z) : (r[12] = e,
        r[13] = t,
        r[14] = i),
        this
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , d = e[8]
          , h = e[9]
          , p = e[10]
          , m = e[11]
          , y = e[12]
          , v = e[13]
          , x = e[14]
          , _ = e[15]
          , A = h * x * c - v * p * c + v * l * m - a * x * m - h * l * _ + a * p * _
          , w = y * p * c - d * x * c - y * l * m + o * x * m + d * l * _ - o * p * _
          , M = d * v * c - y * h * c + y * a * m - o * v * m - d * a * _ + o * h * _
          , C = y * h * l - d * v * l - y * a * p + o * v * p + d * a * x - o * h * x
          , P = t * A + i * w + r * M + s * C;
        if (P === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const R = 1 / P;
        return e[0] = A * R,
        e[1] = (v * p * s - h * x * s - v * r * m + i * x * m + h * r * _ - i * p * _) * R,
        e[2] = (a * x * s - v * l * s + v * r * c - i * x * c - a * r * _ + i * l * _) * R,
        e[3] = (h * l * s - a * p * s - h * r * c + i * p * c + a * r * m - i * l * m) * R,
        e[4] = w * R,
        e[5] = (d * x * s - y * p * s + y * r * m - t * x * m - d * r * _ + t * p * _) * R,
        e[6] = (y * l * s - o * x * s - y * r * c + t * x * c + o * r * _ - t * l * _) * R,
        e[7] = (o * p * s - d * l * s + d * r * c - t * p * c - o * r * m + t * l * m) * R,
        e[8] = M * R,
        e[9] = (y * h * s - d * v * s - y * i * m + t * v * m + d * i * _ - t * h * _) * R,
        e[10] = (o * v * s - y * a * s + y * i * c - t * v * c - o * i * _ + t * a * _) * R,
        e[11] = (d * a * s - o * h * s - d * i * c + t * h * c + o * i * m - t * a * m) * R,
        e[12] = C * R,
        e[13] = (d * v * r - y * h * r + y * i * p - t * v * p - d * i * x + t * h * x) * R,
        e[14] = (y * a * r - o * v * r - y * i * l + t * v * l + o * i * x - t * a * x) * R,
        e[15] = (o * h * r - d * a * r + d * i * l - t * h * l - o * i * p + t * a * p) * R,
        this
    }
    scale(e) {
        const t = this.elements
          , i = e.x
          , r = e.y
          , s = e.z;
        return t[0] *= i,
        t[4] *= r,
        t[8] *= s,
        t[1] *= i,
        t[5] *= r,
        t[9] *= s,
        t[2] *= i,
        t[6] *= r,
        t[10] *= s,
        t[3] *= i,
        t[7] *= r,
        t[11] *= s,
        this
    }
    getMaxScaleOnAxis() {
        const e = this.elements
          , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, i, r))
    }
    makeTranslation(e, t, i) {
        return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, t) {
        const i = Math.cos(t)
          , r = Math.sin(t)
          , s = 1 - i
          , o = e.x
          , a = e.y
          , l = e.z
          , c = s * o
          , d = s * a;
        return this.set(c * o + i, c * a - r * l, c * l + r * a, 0, c * a + r * l, d * a + i, d * l - r * o, 0, c * l - r * a, d * l + r * o, s * l * l + i, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, t, i) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, t, i, r, s, o) {
        return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, t, i) {
        const r = this.elements
          , s = t._x
          , o = t._y
          , a = t._z
          , l = t._w
          , c = s + s
          , d = o + o
          , h = a + a
          , p = s * c
          , m = s * d
          , y = s * h
          , v = o * d
          , x = o * h
          , _ = a * h
          , A = l * c
          , w = l * d
          , M = l * h
          , C = i.x
          , P = i.y
          , R = i.z;
        return r[0] = (1 - (v + _)) * C,
        r[1] = (m + M) * C,
        r[2] = (y - w) * C,
        r[3] = 0,
        r[4] = (m - M) * P,
        r[5] = (1 - (p + _)) * P,
        r[6] = (x + A) * P,
        r[7] = 0,
        r[8] = (y + w) * R,
        r[9] = (x - A) * R,
        r[10] = (1 - (p + v)) * R,
        r[11] = 0,
        r[12] = e.x,
        r[13] = e.y,
        r[14] = e.z,
        r[15] = 1,
        this
    }
    decompose(e, t, i) {
        const r = this.elements;
        let s = eu.set(r[0], r[1], r[2]).length();
        const o = eu.set(r[4], r[5], r[6]).length()
          , a = eu.set(r[8], r[9], r[10]).length();
        this.determinant() < 0 && (s = -s),
        e.x = r[12],
        e.y = r[13],
        e.z = r[14],
        Rr.copy(this);
        const c = 1 / s
          , d = 1 / o
          , h = 1 / a;
        return Rr.elements[0] *= c,
        Rr.elements[1] *= c,
        Rr.elements[2] *= c,
        Rr.elements[4] *= d,
        Rr.elements[5] *= d,
        Rr.elements[6] *= d,
        Rr.elements[8] *= h,
        Rr.elements[9] *= h,
        Rr.elements[10] *= h,
        t.setFromRotationMatrix(Rr),
        i.x = s,
        i.y = o,
        i.z = a,
        this
    }
    makePerspective(e, t, i, r, s, o) {
        const a = this.elements
          , l = 2 * s / (t - e)
          , c = 2 * s / (i - r)
          , d = (t + e) / (t - e)
          , h = (i + r) / (i - r)
          , p = -(o + s) / (o - s)
          , m = -2 * o * s / (o - s);
        return a[0] = l,
        a[4] = 0,
        a[8] = d,
        a[12] = 0,
        a[1] = 0,
        a[5] = c,
        a[9] = h,
        a[13] = 0,
        a[2] = 0,
        a[6] = 0,
        a[10] = p,
        a[14] = m,
        a[3] = 0,
        a[7] = 0,
        a[11] = -1,
        a[15] = 0,
        this
    }
    makeOrthographic(e, t, i, r, s, o) {
        const a = this.elements
          , l = 1 / (t - e)
          , c = 1 / (i - r)
          , d = 1 / (o - s)
          , h = (t + e) * l
          , p = (i + r) * c
          , m = (o + s) * d;
        return a[0] = 2 * l,
        a[4] = 0,
        a[8] = 0,
        a[12] = -h,
        a[1] = 0,
        a[5] = 2 * c,
        a[9] = 0,
        a[13] = -p,
        a[2] = 0,
        a[6] = 0,
        a[10] = -2 * d,
        a[14] = -m,
        a[3] = 0,
        a[7] = 0,
        a[11] = 0,
        a[15] = 1,
        this
    }
    equals(e) {
        const t = this.elements
          , i = e.elements;
        for (let r = 0; r < 16; r++)
            if (t[r] !== i[r])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let i = 0; i < 16; i++)
            this.elements[i] = e[i + t];
        return this
    }
    toArray(e=[], t=0) {
        const i = this.elements;
        return e[t] = i[0],
        e[t + 1] = i[1],
        e[t + 2] = i[2],
        e[t + 3] = i[3],
        e[t + 4] = i[4],
        e[t + 5] = i[5],
        e[t + 6] = i[6],
        e[t + 7] = i[7],
        e[t + 8] = i[8],
        e[t + 9] = i[9],
        e[t + 10] = i[10],
        e[t + 11] = i[11],
        e[t + 12] = i[12],
        e[t + 13] = i[13],
        e[t + 14] = i[14],
        e[t + 15] = i[15],
        e
    }
}
const eu = new D
  , Rr = new ot
  , $4 = new D(0,0,0)
  , eU = new D(1,1,1)
  , wo = new D
  , Jp = new D
  , Ui = new D
  , ZC = new ot
  , qC = new Qn;
class Pl {
    constructor(e=0, t=0, i=0, r=Pl.DEFAULT_ORDER) {
        this.isEuler = !0,
        this._x = e,
        this._y = t,
        this._z = i,
        this._order = r
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, t, i, r=this._order) {
        return this._x = e,
        this._y = t,
        this._z = i,
        this._order = r,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, t=this._order, i=!0) {
        const r = e.elements
          , s = r[0]
          , o = r[4]
          , a = r[8]
          , l = r[1]
          , c = r[5]
          , d = r[9]
          , h = r[2]
          , p = r[6]
          , m = r[10];
        switch (t) {
        case "XYZ":
            this._y = Math.asin(wn(a, -1, 1)),
            Math.abs(a) < .9999999 ? (this._x = Math.atan2(-d, m),
            this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(p, c),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-wn(d, -1, 1)),
            Math.abs(d) < .9999999 ? (this._y = Math.atan2(a, m),
            this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, s),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(wn(p, -1, 1)),
            Math.abs(p) < .9999999 ? (this._y = Math.atan2(-h, m),
            this._z = Math.atan2(-o, c)) : (this._y = 0,
            this._z = Math.atan2(l, s));
            break;
        case "ZYX":
            this._y = Math.asin(-wn(h, -1, 1)),
            Math.abs(h) < .9999999 ? (this._x = Math.atan2(p, m),
            this._z = Math.atan2(l, s)) : (this._x = 0,
            this._z = Math.atan2(-o, c));
            break;
        case "YZX":
            this._z = Math.asin(wn(l, -1, 1)),
            Math.abs(l) < .9999999 ? (this._x = Math.atan2(-d, c),
            this._y = Math.atan2(-h, s)) : (this._x = 0,
            this._y = Math.atan2(a, m));
            break;
        case "XZY":
            this._z = Math.asin(-wn(o, -1, 1)),
            Math.abs(o) < .9999999 ? (this._x = Math.atan2(p, c),
            this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-d, m),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t,
        i === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, t, i) {
        return ZC.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(ZC, t, i)
    }
    setFromVector3(e, t=this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return qC.setFromEuler(this),
        this.setFromQuaternion(qC, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
}
Pl.DEFAULT_ORDER = "XYZ";
let pl = class {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
  , tU = 0;
const $C = new D
  , tu = new Qn
  , Ps = new ot
  , Xp = new D
  , lf = new D
  , nU = new D
  , iU = new Qn
  , eE = new D(1,0,0)
  , tE = new D(0,1,0)
  , nE = new D(0,0,1)
  , rU = {
    type: "added"
}
  , iE = {
    type: "removed"
};
class Rt extends gs {
    constructor() {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: tU++
        }),
        this.uuid = Ji(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = Rt.DEFAULT_UP.clone();
        const e = new D
          , t = new Pl
          , i = new Qn
          , r = new D(1,1,1);
        function s() {
            i.setFromEuler(t, !1)
        }
        function o() {
            t.setFromQuaternion(i, void 0, !1)
        }
        t._onChange(s),
        i._onChange(o),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            modelViewMatrix: {
                value: new ot
            },
            normalMatrix: {
                value: new gi
            }
        }),
        this.matrix = new ot,
        this.matrixWorld = new ot,
        this.matrixAutoUpdate = Rt.DEFAULT_MATRIX_AUTO_UPDATE,
        this.matrixWorldNeedsUpdate = !1,
        this.matrixWorldAutoUpdate = Rt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
        this.layers = new pl,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {}
    }
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return tu.setFromAxisAngle(e, t),
        this.quaternion.multiply(tu),
        this
    }
    rotateOnWorldAxis(e, t) {
        return tu.setFromAxisAngle(e, t),
        this.quaternion.premultiply(tu),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(eE, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(tE, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(nE, e)
    }
    translateOnAxis(e, t) {
        return $C.copy(e).applyQuaternion(this.quaternion),
        this.position.add($C.multiplyScalar(t)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(eE, e)
    }
    translateY(e) {
        return this.translateOnAxis(tE, e)
    }
    translateZ(e) {
        return this.translateOnAxis(nE, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(Ps.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, i) {
        e.isVector3 ? Xp.copy(e) : Xp.set(e, t, i);
        const r = this.parent;
        this.updateWorldMatrix(!0, !1),
        lf.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? Ps.lookAt(lf, Xp, this.up) : Ps.lookAt(Xp, lf, this.up),
        this.quaternion.setFromRotationMatrix(Ps),
        r && (Ps.extractRotation(r.matrixWorld),
        tu.setFromRotationMatrix(Ps),
        this.quaternion.premultiply(tu.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
                this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(rU)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++)
                this.remove(arguments[i]);
            return this
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null,
        this.children.splice(t, 1),
        e.dispatchEvent(iE)),
        this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this),
        this
    }
    clear() {
        for (let e = 0; e < this.children.length; e++) {
            const t = this.children[e];
            t.parent = null,
            t.dispatchEvent(iE)
        }
        return this.children.length = 0,
        this
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        Ps.copy(this.matrixWorld).invert(),
        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
        Ps.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(Ps),
        this.add(e),
        e.updateWorldMatrix(!1, !0),
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t)
            return this;
        for (let i = 0, r = this.children.length; i < r; i++) {
            const o = this.children[i].getObjectByProperty(e, t);
            if (o !== void 0)
                return o
        }
    }
    getObjectsByProperty(e, t) {
        let i = [];
        this[e] === t && i.push(this);
        for (let r = 0, s = this.children.length; r < s; r++) {
            const o = this.children[r].getObjectsByProperty(e, t);
            o.length > 0 && (i = i.concat(o))
        }
        return i
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(lf, e, nU),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(lf, iU, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++)
            t[i].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1)
            return;
        e(this);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++)
            t[i].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t),
        t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e)
        }
    }
    updateWorldMatrix(e, t) {
        const i = this.parent;
        if (e === !0 && i !== null && i.matrixWorldAutoUpdate === !0 && i.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        t === !0) {
            const r = this.children;
            for (let s = 0, o = r.length; s < o; s++) {
                const a = r[s];
                a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0)
            }
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string"
          , i = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        i.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const r = {};
        r.uuid = this.uuid,
        r.type = this.type,
        this.name !== "" && (r.name = this.name),
        this.castShadow === !0 && (r.castShadow = !0),
        this.receiveShadow === !0 && (r.receiveShadow = !0),
        this.visible === !1 && (r.visible = !1),
        this.frustumCulled === !1 && (r.frustumCulled = !1),
        this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (r.userData = this.userData),
        r.layers = this.layers.mask,
        r.matrix = this.matrix.toArray(),
        this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
        this.isInstancedMesh && (r.type = "InstancedMesh",
        r.count = this.count,
        r.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON()));
        function s(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)),
            l.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            r.geometry = s(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const l = a.shapes;
                if (Array.isArray(l))
                    for (let c = 0, d = l.length; c < d; c++) {
                        const h = l[c];
                        s(e.shapes, h)
                    }
                else
                    s(e.shapes, l)
            }
        }
        if (this.isSkinnedMesh && (r.bindMode = this.bindMode,
        r.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (s(e.skeletons, this.skeleton),
        r.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                const a = [];
                for (let l = 0, c = this.material.length; l < c; l++)
                    a.push(s(e.materials, this.material[l]));
                r.material = a
            } else
                r.material = s(e.materials, this.material);
        if (this.children.length > 0) {
            r.children = [];
            for (let a = 0; a < this.children.length; a++)
                r.children.push(this.children[a].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            r.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const l = this.animations[a];
                r.animations.push(s(e.animations, l))
            }
        }
        if (t) {
            const a = o(e.geometries)
              , l = o(e.materials)
              , c = o(e.textures)
              , d = o(e.images)
              , h = o(e.shapes)
              , p = o(e.skeletons)
              , m = o(e.animations)
              , y = o(e.nodes);
            a.length > 0 && (i.geometries = a),
            l.length > 0 && (i.materials = l),
            c.length > 0 && (i.textures = c),
            d.length > 0 && (i.images = d),
            h.length > 0 && (i.shapes = h),
            p.length > 0 && (i.skeletons = p),
            m.length > 0 && (i.animations = m),
            y.length > 0 && (i.nodes = y)
        }
        return i.object = r,
        i;
        function o(a) {
            const l = [];
            for (const c in a) {
                const d = a[c];
                delete d.metadata,
                l.push(d)
            }
            return l
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        t === !0)
            for (let i = 0; i < e.children.length; i++) {
                const r = e.children[i];
                this.add(r.clone())
            }
        return this
    }
}
Rt.DEFAULT_UP = new D(0,1,0);
Rt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Rt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Ir = new D
  , Bs = new D
  , Jy = new D
  , Rs = new D
  , nu = new D
  , iu = new D
  , rE = new D
  , Xy = new D
  , Yy = new D
  , Ky = new D;
class yr {
    constructor(e=new D, t=new D, i=new D) {
        this.a = e,
        this.b = t,
        this.c = i
    }
    static getNormal(e, t, i, r) {
        r.subVectors(i, t),
        Ir.subVectors(e, t),
        r.cross(Ir);
        const s = r.lengthSq();
        return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0)
    }
    static getBarycoord(e, t, i, r, s) {
        Ir.subVectors(r, t),
        Bs.subVectors(i, t),
        Jy.subVectors(e, t);
        const o = Ir.dot(Ir)
          , a = Ir.dot(Bs)
          , l = Ir.dot(Jy)
          , c = Bs.dot(Bs)
          , d = Bs.dot(Jy)
          , h = o * c - a * a;
        if (h === 0)
            return s.set(-2, -1, -1);
        const p = 1 / h
          , m = (c * l - a * d) * p
          , y = (o * d - a * l) * p;
        return s.set(1 - m - y, y, m)
    }
    static containsPoint(e, t, i, r) {
        return this.getBarycoord(e, t, i, r, Rs),
        Rs.x >= 0 && Rs.y >= 0 && Rs.x + Rs.y <= 1
    }
    static getUV(e, t, i, r, s, o, a, l) {
        return this.getBarycoord(e, t, i, r, Rs),
        l.set(0, 0),
        l.addScaledVector(s, Rs.x),
        l.addScaledVector(o, Rs.y),
        l.addScaledVector(a, Rs.z),
        l
    }
    static isFrontFacing(e, t, i, r) {
        return Ir.subVectors(i, t),
        Bs.subVectors(e, t),
        Ir.cross(Bs).dot(r) < 0
    }
    set(e, t, i) {
        return this.a.copy(e),
        this.b.copy(t),
        this.c.copy(i),
        this
    }
    setFromPointsAndIndices(e, t, i, r) {
        return this.a.copy(e[t]),
        this.b.copy(e[i]),
        this.c.copy(e[r]),
        this
    }
    setFromAttributeAndIndices(e, t, i, r) {
        return this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, i),
        this.c.fromBufferAttribute(e, r),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return Ir.subVectors(this.c, this.b),
        Bs.subVectors(this.a, this.b),
        Ir.cross(Bs).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return yr.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return yr.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getUV(e, t, i, r, s) {
        return yr.getUV(e, this.a, this.b, this.c, t, i, r, s)
    }
    containsPoint(e) {
        return yr.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return yr.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const i = this.a
          , r = this.b
          , s = this.c;
        let o, a;
        nu.subVectors(r, i),
        iu.subVectors(s, i),
        Xy.subVectors(e, i);
        const l = nu.dot(Xy)
          , c = iu.dot(Xy);
        if (l <= 0 && c <= 0)
            return t.copy(i);
        Yy.subVectors(e, r);
        const d = nu.dot(Yy)
          , h = iu.dot(Yy);
        if (d >= 0 && h <= d)
            return t.copy(r);
        const p = l * h - d * c;
        if (p <= 0 && l >= 0 && d <= 0)
            return o = l / (l - d),
            t.copy(i).addScaledVector(nu, o);
        Ky.subVectors(e, s);
        const m = nu.dot(Ky)
          , y = iu.dot(Ky);
        if (y >= 0 && m <= y)
            return t.copy(s);
        const v = m * c - l * y;
        if (v <= 0 && c >= 0 && y <= 0)
            return a = c / (c - y),
            t.copy(i).addScaledVector(iu, a);
        const x = d * y - m * h;
        if (x <= 0 && h - d >= 0 && m - y >= 0)
            return rE.subVectors(s, r),
            a = (h - d) / (h - d + (m - y)),
            t.copy(r).addScaledVector(rE, a);
        const _ = 1 / (x + v + p);
        return o = v * _,
        a = p * _,
        t.copy(i).addScaledVector(nu, o).addScaledVector(iu, a)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
let sU = 0;
class Tn extends gs {
    constructor() {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: sU++
        }),
        this.uuid = Ji(),
        this.name = "",
        this.type = "Material",
        this.blending = ul,
        this.side = hs,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.blendSrc = pw,
        this.blendDst = mw,
        this.blendEquation = Xa,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.depthFunc = zg,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = FR,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = ag,
        this.stencilZFail = ag,
        this.stencilZPass = ag,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.forceSinglePass = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const i = e[t];
                if (i === void 0) {
                    console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                    continue
                }
                const r = this[t];
                if (r === void 0) {
                    console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.");
                    continue
                }
                r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[t] = i
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        const i = {
            metadata: {
                version: 4.5,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        i.uuid = this.uuid,
        i.type = this.type,
        this.name !== "" && (i.name = this.name),
        this.color && this.color.isColor && (i.color = this.color.getHex()),
        this.roughness !== void 0 && (i.roughness = this.roughness),
        this.metalness !== void 0 && (i.metalness = this.metalness),
        this.sheen !== void 0 && (i.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
        this.emissiveIntensity && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (i.shininess = this.shininess),
        this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.iridescence !== void 0 && (i.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid,
        i.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid,
        i.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid,
        i.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid,
        i.normalMapType = this.normalMapType,
        i.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid,
        i.displacementScale = this.displacementScale,
        i.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid,
        this.combine !== void 0 && (i.combine = this.combine)),
        this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (i.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (i.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (i.size = this.size),
        this.shadowSide !== null && (i.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation),
        this.blending !== ul && (i.blending = this.blending),
        this.side !== hs && (i.side = this.side),
        this.vertexColors && (i.vertexColors = !0),
        this.opacity < 1 && (i.opacity = this.opacity),
        this.transparent === !0 && (i.transparent = this.transparent),
        i.depthFunc = this.depthFunc,
        i.depthTest = this.depthTest,
        i.depthWrite = this.depthWrite,
        i.colorWrite = this.colorWrite,
        i.stencilWrite = this.stencilWrite,
        i.stencilWriteMask = this.stencilWriteMask,
        i.stencilFunc = this.stencilFunc,
        i.stencilRef = this.stencilRef,
        i.stencilFuncMask = this.stencilFuncMask,
        i.stencilFail = this.stencilFail,
        i.stencilZFail = this.stencilZFail,
        i.stencilZPass = this.stencilZPass,
        this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation),
        this.polygonOffset === !0 && (i.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth),
        this.dashSize !== void 0 && (i.dashSize = this.dashSize),
        this.gapSize !== void 0 && (i.gapSize = this.gapSize),
        this.scale !== void 0 && (i.scale = this.scale),
        this.dithering === !0 && (i.dithering = !0),
        this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
        this.alphaToCoverage === !0 && (i.alphaToCoverage = this.alphaToCoverage),
        this.premultipliedAlpha === !0 && (i.premultipliedAlpha = this.premultipliedAlpha),
        this.forceSinglePass === !0 && (i.forceSinglePass = this.forceSinglePass),
        this.wireframe === !0 && (i.wireframe = this.wireframe),
        this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (i.flatShading = this.flatShading),
        this.visible === !1 && (i.visible = !1),
        this.toneMapped === !1 && (i.toneMapped = !1),
        this.fog === !1 && (i.fog = !1),
        Object.keys(this.userData).length > 0 && (i.userData = this.userData);
        function r(s) {
            const o = [];
            for (const a in s) {
                const l = s[a];
                delete l.metadata,
                o.push(l)
            }
            return o
        }
        if (t) {
            const s = r(e.textures)
              , o = r(e.images);
            s.length > 0 && (i.textures = s),
            o.length > 0 && (i.images = o)
        }
        return i
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let i = null;
        if (t !== null) {
            const r = t.length;
            i = new Array(r);
            for (let s = 0; s !== r; ++s)
                i[s] = t[s].clone()
        }
        return this.clippingPlanes = i,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.forceSinglePass = e.forceSinglePass,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
}
class Wi extends Tn {
    constructor(e) {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new Ie(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = qd,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
const bn = new D
  , Yp = new me;
class Nt {
    constructor(e, t, i=!1) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.normalized = i,
        this.usage = bd,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this
    }
    copyAt(e, t, i) {
        e *= this.itemSize,
        i *= t.itemSize;
        for (let r = 0, s = this.itemSize; r < s; r++)
            this.array[e + r] = t.array[i + r];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, i = this.count; t < i; t++)
                Yp.fromBufferAttribute(this, t),
                Yp.applyMatrix3(e),
                this.setXY(t, Yp.x, Yp.y);
        else if (this.itemSize === 3)
            for (let t = 0, i = this.count; t < i; t++)
                bn.fromBufferAttribute(this, t),
                bn.applyMatrix3(e),
                this.setXYZ(t, bn.x, bn.y, bn.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, i = this.count; t < i; t++)
            bn.fromBufferAttribute(this, t),
            bn.applyMatrix4(e),
            this.setXYZ(t, bn.x, bn.y, bn.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++)
            bn.fromBufferAttribute(this, t),
            bn.applyNormalMatrix(e),
            this.setXYZ(t, bn.x, bn.y, bn.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++)
            bn.fromBufferAttribute(this, t),
            bn.transformDirection(e),
            this.setXYZ(t, bn.x, bn.y, bn.z);
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = Gs(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = Vt(t, this.array)),
        this.array[e * this.itemSize] = t,
        this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = Gs(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = Vt(t, this.array)),
        this.array[e * this.itemSize + 1] = t,
        this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = Gs(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = Vt(t, this.array)),
        this.array[e * this.itemSize + 2] = t,
        this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = Gs(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = Vt(t, this.array)),
        this.array[e * this.itemSize + 3] = t,
        this
    }
    setXY(e, t, i) {
        return e *= this.itemSize,
        this.normalized && (t = Vt(t, this.array),
        i = Vt(i, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this
    }
    setXYZ(e, t, i, r) {
        return e *= this.itemSize,
        this.normalized && (t = Vt(t, this.array),
        i = Vt(i, this.array),
        r = Vt(r, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this.array[e + 2] = r,
        this
    }
    setXYZW(e, t, i, r, s) {
        return e *= this.itemSize,
        this.normalized && (t = Vt(t, this.array),
        i = Vt(i, this.array),
        r = Vt(r, this.array),
        s = Vt(s, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this.array[e + 2] = r,
        this.array[e + 3] = s,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name),
        this.usage !== bd && (e.usage = this.usage),
        (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange),
        e
    }
    copyColorsArray() {
        console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")
    }
    copyVector2sArray() {
        console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")
    }
    copyVector3sArray() {
        console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")
    }
    copyVector4sArray() {
        console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")
    }
}
class oU extends Nt {
    constructor(e, t, i) {
        super(new Int8Array(e), t, i)
    }
}
class aU extends Nt {
    constructor(e, t, i) {
        super(new Uint8Array(e), t, i)
    }
}
class lU extends Nt {
    constructor(e, t, i) {
        super(new Uint8ClampedArray(e), t, i)
    }
}
class uU extends Nt {
    constructor(e, t, i) {
        super(new Int16Array(e), t, i)
    }
}
class Mw extends Nt {
    constructor(e, t, i) {
        super(new Uint16Array(e), t, i)
    }
}
class cU extends Nt {
    constructor(e, t, i) {
        super(new Int32Array(e), t, i)
    }
}
class bw extends Nt {
    constructor(e, t, i) {
        super(new Uint32Array(e), t, i)
    }
}
class fU extends Nt {
    constructor(e, t, i) {
        super(new Uint16Array(e), t, i),
        this.isFloat16BufferAttribute = !0
    }
}
class je extends Nt {
    constructor(e, t, i) {
        super(new Float32Array(e), t, i)
    }
}
class dU extends Nt {
    constructor(e, t, i) {
        super(new Float64Array(e), t, i)
    }
}
let hU = 0;
const dr = new ot
  , Qy = new Rt
  , ru = new D
  , zi = new ha
  , uf = new ha
  , Hn = new D;
class ft extends gs {
    constructor() {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: hU++
        }),
        this.uuid = Ji(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (OR(e) ? bw : Mw)(e,1) : this.index = e,
        this
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, i=0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: i
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e,
        this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e),
        t.needsUpdate = !0);
        const i = this.attributes.normal;
        if (i !== void 0) {
            const s = new gi().getNormalMatrix(e);
            i.applyNormalMatrix(s),
            i.needsUpdate = !0
        }
        const r = this.attributes.tangent;
        return r !== void 0 && (r.transformDirection(e),
        r.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return dr.makeRotationFromQuaternion(e),
        this.applyMatrix4(dr),
        this
    }
    rotateX(e) {
        return dr.makeRotationX(e),
        this.applyMatrix4(dr),
        this
    }
    rotateY(e) {
        return dr.makeRotationY(e),
        this.applyMatrix4(dr),
        this
    }
    rotateZ(e) {
        return dr.makeRotationZ(e),
        this.applyMatrix4(dr),
        this
    }
    translate(e, t, i) {
        return dr.makeTranslation(e, t, i),
        this.applyMatrix4(dr),
        this
    }
    scale(e, t, i) {
        return dr.makeScale(e, t, i),
        this.applyMatrix4(dr),
        this
    }
    lookAt(e) {
        return Qy.lookAt(e),
        Qy.updateMatrix(),
        this.applyMatrix4(Qy.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(ru).negate(),
        this.translate(ru.x, ru.y, ru.z),
        this
    }
    setFromPoints(e) {
        const t = [];
        for (let i = 0, r = e.length; i < r; i++) {
            const s = e[i];
            t.push(s.x, s.y, s.z || 0)
        }
        return this.setAttribute("position", new je(t,3)),
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new ha);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingBox.set(new D(-1 / 0,-1 / 0,-1 / 0), new D(1 / 0,1 / 0,1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e),
            t)
                for (let i = 0, r = t.length; i < r; i++) {
                    const s = t[i];
                    zi.setFromBufferAttribute(s),
                    this.morphTargetsRelative ? (Hn.addVectors(this.boundingBox.min, zi.min),
                    this.boundingBox.expandByPoint(Hn),
                    Hn.addVectors(this.boundingBox.max, zi.max),
                    this.boundingBox.expandByPoint(Hn)) : (this.boundingBox.expandByPoint(zi.min),
                    this.boundingBox.expandByPoint(zi.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new pa);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingSphere.set(new D, 1 / 0);
            return
        }
        if (e) {
            const i = this.boundingSphere.center;
            if (zi.setFromBufferAttribute(e),
            t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s];
                    uf.setFromBufferAttribute(a),
                    this.morphTargetsRelative ? (Hn.addVectors(zi.min, uf.min),
                    zi.expandByPoint(Hn),
                    Hn.addVectors(zi.max, uf.max),
                    zi.expandByPoint(Hn)) : (zi.expandByPoint(uf.min),
                    zi.expandByPoint(uf.max))
                }
            zi.getCenter(i);
            let r = 0;
            for (let s = 0, o = e.count; s < o; s++)
                Hn.fromBufferAttribute(e, s),
                r = Math.max(r, i.distanceToSquared(Hn));
            if (t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s]
                      , l = this.morphTargetsRelative;
                    for (let c = 0, d = a.count; c < d; c++)
                        Hn.fromBufferAttribute(a, c),
                        l && (ru.fromBufferAttribute(e, c),
                        Hn.add(ru)),
                        r = Math.max(r, i.distanceToSquared(Hn))
                }
            this.boundingSphere.radius = Math.sqrt(r),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index
          , t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const i = e.array
          , r = t.position.array
          , s = t.normal.array
          , o = t.uv.array
          , a = r.length / 3;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Nt(new Float32Array(4 * a),4));
        const l = this.getAttribute("tangent").array
          , c = []
          , d = [];
        for (let I = 0; I < a; I++)
            c[I] = new D,
            d[I] = new D;
        const h = new D
          , p = new D
          , m = new D
          , y = new me
          , v = new me
          , x = new me
          , _ = new D
          , A = new D;
        function w(I, z, q) {
            h.fromArray(r, I * 3),
            p.fromArray(r, z * 3),
            m.fromArray(r, q * 3),
            y.fromArray(o, I * 2),
            v.fromArray(o, z * 2),
            x.fromArray(o, q * 2),
            p.sub(h),
            m.sub(h),
            v.sub(y),
            x.sub(y);
            const W = 1 / (v.x * x.y - x.x * v.y);
            isFinite(W) && (_.copy(p).multiplyScalar(x.y).addScaledVector(m, -v.y).multiplyScalar(W),
            A.copy(m).multiplyScalar(v.x).addScaledVector(p, -x.x).multiplyScalar(W),
            c[I].add(_),
            c[z].add(_),
            c[q].add(_),
            d[I].add(A),
            d[z].add(A),
            d[q].add(A))
        }
        let M = this.groups;
        M.length === 0 && (M = [{
            start: 0,
            count: i.length
        }]);
        for (let I = 0, z = M.length; I < z; ++I) {
            const q = M[I]
              , W = q.start
              , G = q.count;
            for (let K = W, ne = W + G; K < ne; K += 3)
                w(i[K + 0], i[K + 1], i[K + 2])
        }
        const C = new D
          , P = new D
          , R = new D
          , E = new D;
        function B(I) {
            R.fromArray(s, I * 3),
            E.copy(R);
            const z = c[I];
            C.copy(z),
            C.sub(R.multiplyScalar(R.dot(z))).normalize(),
            P.crossVectors(E, z);
            const W = P.dot(d[I]) < 0 ? -1 : 1;
            l[I * 4] = C.x,
            l[I * 4 + 1] = C.y,
            l[I * 4 + 2] = C.z,
            l[I * 4 + 3] = W
        }
        for (let I = 0, z = M.length; I < z; ++I) {
            const q = M[I]
              , W = q.start
              , G = q.count;
            for (let K = W, ne = W + G; K < ne; K += 3)
                B(i[K + 0]),
                B(i[K + 1]),
                B(i[K + 2])
        }
    }
    computeVertexNormals() {
        const e = this.index
          , t = this.getAttribute("position");
        if (t !== void 0) {
            let i = this.getAttribute("normal");
            if (i === void 0)
                i = new Nt(new Float32Array(t.count * 3),3),
                this.setAttribute("normal", i);
            else
                for (let p = 0, m = i.count; p < m; p++)
                    i.setXYZ(p, 0, 0, 0);
            const r = new D
              , s = new D
              , o = new D
              , a = new D
              , l = new D
              , c = new D
              , d = new D
              , h = new D;
            if (e)
                for (let p = 0, m = e.count; p < m; p += 3) {
                    const y = e.getX(p + 0)
                      , v = e.getX(p + 1)
                      , x = e.getX(p + 2);
                    r.fromBufferAttribute(t, y),
                    s.fromBufferAttribute(t, v),
                    o.fromBufferAttribute(t, x),
                    d.subVectors(o, s),
                    h.subVectors(r, s),
                    d.cross(h),
                    a.fromBufferAttribute(i, y),
                    l.fromBufferAttribute(i, v),
                    c.fromBufferAttribute(i, x),
                    a.add(d),
                    l.add(d),
                    c.add(d),
                    i.setXYZ(y, a.x, a.y, a.z),
                    i.setXYZ(v, l.x, l.y, l.z),
                    i.setXYZ(x, c.x, c.y, c.z)
                }
            else
                for (let p = 0, m = t.count; p < m; p += 3)
                    r.fromBufferAttribute(t, p + 0),
                    s.fromBufferAttribute(t, p + 1),
                    o.fromBufferAttribute(t, p + 2),
                    d.subVectors(o, s),
                    h.subVectors(r, s),
                    d.cross(h),
                    i.setXYZ(p + 0, d.x, d.y, d.z),
                    i.setXYZ(p + 1, d.x, d.y, d.z),
                    i.setXYZ(p + 2, d.x, d.y, d.z);
            this.normalizeNormals(),
            i.needsUpdate = !0
        }
    }
    merge() {
        return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."),
        this
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, i = e.count; t < i; t++)
            Hn.fromBufferAttribute(e, t),
            Hn.normalize(),
            e.setXYZ(t, Hn.x, Hn.y, Hn.z)
    }
    toNonIndexed() {
        function e(a, l) {
            const c = a.array
              , d = a.itemSize
              , h = a.normalized
              , p = new c.constructor(l.length * d);
            let m = 0
              , y = 0;
            for (let v = 0, x = l.length; v < x; v++) {
                a.isInterleavedBufferAttribute ? m = l[v] * a.data.stride + a.offset : m = l[v] * d;
                for (let _ = 0; _ < d; _++)
                    p[y++] = c[m++]
            }
            return new Nt(p,d,h)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const t = new ft
          , i = this.index.array
          , r = this.attributes;
        for (const a in r) {
            const l = r[a]
              , c = e(l, i);
            t.setAttribute(a, c)
        }
        const s = this.morphAttributes;
        for (const a in s) {
            const l = []
              , c = s[a];
            for (let d = 0, h = c.length; d < h; d++) {
                const p = c[d]
                  , m = e(p, i);
                l.push(m)
            }
            t.morphAttributes[a] = l
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let a = 0, l = o.length; a < l; a++) {
            const c = o[a];
            t.addGroup(c.start, c.count, c.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.5,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0) {
            const l = this.parameters;
            for (const c in l)
                l[c] !== void 0 && (e[c] = l[c]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const i = this.attributes;
        for (const l in i) {
            const c = i[l];
            e.data.attributes[l] = c.toJSON(e.data)
        }
        const r = {};
        let s = !1;
        for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l]
              , d = [];
            for (let h = 0, p = c.length; h < p; h++) {
                const m = c[h];
                d.push(m.toJSON(e.data))
            }
            d.length > 0 && (r[l] = d,
            s = !0)
        }
        s && (e.data.morphAttributes = r,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return a !== null && (e.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius
        }),
        e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const i = e.index;
        i !== null && this.setIndex(i.clone(t));
        const r = e.attributes;
        for (const c in r) {
            const d = r[c];
            this.setAttribute(c, d.clone(t))
        }
        const s = e.morphAttributes;
        for (const c in s) {
            const d = []
              , h = s[c];
            for (let p = 0, m = h.length; p < m; p++)
                d.push(h[p].clone(t));
            this.morphAttributes[c] = d
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const o = e.groups;
        for (let c = 0, d = o.length; c < d; c++) {
            const h = o[c];
            this.addGroup(h.start, h.count, h.materialIndex)
        }
        const a = e.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const l = e.boundingSphere;
        return l !== null && (this.boundingSphere = l.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        e.parameters !== void 0 && (this.parameters = Object.assign({}, e.parameters)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const sE = new ot
  , su = new $d
  , Zy = new pa
  , cf = new D
  , ff = new D
  , df = new D
  , qy = new D
  , Kp = new D
  , Qp = new me
  , Zp = new me
  , qp = new me
  , $y = new D
  , $p = new D;
class Ln extends Rt {
    constructor(e=new ft, t=new Wi) {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const i = this.geometry
          , r = i.attributes.position
          , s = i.morphAttributes.position
          , o = i.morphTargetsRelative;
        t.fromBufferAttribute(r, e);
        const a = this.morphTargetInfluences;
        if (s && a) {
            Kp.set(0, 0, 0);
            for (let l = 0, c = s.length; l < c; l++) {
                const d = a[l]
                  , h = s[l];
                d !== 0 && (qy.fromBufferAttribute(h, e),
                o ? Kp.addScaledVector(qy, d) : Kp.addScaledVector(qy.sub(t), d))
            }
            t.add(Kp)
        }
        return this.isSkinnedMesh && this.boneTransform(e, t),
        t
    }
    raycast(e, t) {
        const i = this.geometry
          , r = this.material
          , s = this.matrixWorld;
        if (r === void 0 || (i.boundingSphere === null && i.computeBoundingSphere(),
        Zy.copy(i.boundingSphere),
        Zy.applyMatrix4(s),
        e.ray.intersectsSphere(Zy) === !1) || (sE.copy(s).invert(),
        su.copy(e.ray).applyMatrix4(sE),
        i.boundingBox !== null && su.intersectsBox(i.boundingBox) === !1))
            return;
        let o;
        const a = i.index
          , l = i.attributes.position
          , c = i.attributes.uv
          , d = i.attributes.uv2
          , h = i.groups
          , p = i.drawRange;
        if (a !== null)
            if (Array.isArray(r))
                for (let m = 0, y = h.length; m < y; m++) {
                    const v = h[m]
                      , x = r[v.materialIndex]
                      , _ = Math.max(v.start, p.start)
                      , A = Math.min(a.count, Math.min(v.start + v.count, p.start + p.count));
                    for (let w = _, M = A; w < M; w += 3) {
                        const C = a.getX(w)
                          , P = a.getX(w + 1)
                          , R = a.getX(w + 2);
                        o = em(this, x, e, su, c, d, C, P, R),
                        o && (o.faceIndex = Math.floor(w / 3),
                        o.face.materialIndex = v.materialIndex,
                        t.push(o))
                    }
                }
            else {
                const m = Math.max(0, p.start)
                  , y = Math.min(a.count, p.start + p.count);
                for (let v = m, x = y; v < x; v += 3) {
                    const _ = a.getX(v)
                      , A = a.getX(v + 1)
                      , w = a.getX(v + 2);
                    o = em(this, r, e, su, c, d, _, A, w),
                    o && (o.faceIndex = Math.floor(v / 3),
                    t.push(o))
                }
            }
        else if (l !== void 0)
            if (Array.isArray(r))
                for (let m = 0, y = h.length; m < y; m++) {
                    const v = h[m]
                      , x = r[v.materialIndex]
                      , _ = Math.max(v.start, p.start)
                      , A = Math.min(l.count, Math.min(v.start + v.count, p.start + p.count));
                    for (let w = _, M = A; w < M; w += 3) {
                        const C = w
                          , P = w + 1
                          , R = w + 2;
                        o = em(this, x, e, su, c, d, C, P, R),
                        o && (o.faceIndex = Math.floor(w / 3),
                        o.face.materialIndex = v.materialIndex,
                        t.push(o))
                    }
                }
            else {
                const m = Math.max(0, p.start)
                  , y = Math.min(l.count, p.start + p.count);
                for (let v = m, x = y; v < x; v += 3) {
                    const _ = v
                      , A = v + 1
                      , w = v + 2;
                    o = em(this, r, e, su, c, d, _, A, w),
                    o && (o.faceIndex = Math.floor(v / 3),
                    t.push(o))
                }
            }
    }
}
function pU(n, e, t, i, r, s, o, a) {
    let l;
    if (e.side === Li ? l = i.intersectTriangle(o, s, r, !0, a) : l = i.intersectTriangle(r, s, o, e.side === hs, a),
    l === null)
        return null;
    $p.copy(a),
    $p.applyMatrix4(n.matrixWorld);
    const c = t.ray.origin.distanceTo($p);
    return c < t.near || c > t.far ? null : {
        distance: c,
        point: $p.clone(),
        object: n
    }
}
function em(n, e, t, i, r, s, o, a, l) {
    n.getVertexPosition(o, cf),
    n.getVertexPosition(a, ff),
    n.getVertexPosition(l, df);
    const c = pU(n, e, t, i, cf, ff, df, $y);
    if (c) {
        r && (Qp.fromBufferAttribute(r, o),
        Zp.fromBufferAttribute(r, a),
        qp.fromBufferAttribute(r, l),
        c.uv = yr.getUV($y, cf, ff, df, Qp, Zp, qp, new me)),
        s && (Qp.fromBufferAttribute(s, o),
        Zp.fromBufferAttribute(s, a),
        qp.fromBufferAttribute(s, l),
        c.uv2 = yr.getUV($y, cf, ff, df, Qp, Zp, qp, new me));
        const d = {
            a: o,
            b: a,
            c: l,
            normal: new D,
            materialIndex: 0
        };
        yr.getNormal(cf, ff, df, d.normal),
        c.face = d
    }
    return c
}
class ma extends ft {
    constructor(e=1, t=1, i=1, r=1, s=1, o=1) {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: r,
            heightSegments: s,
            depthSegments: o
        };
        const a = this;
        r = Math.floor(r),
        s = Math.floor(s),
        o = Math.floor(o);
        const l = []
          , c = []
          , d = []
          , h = [];
        let p = 0
          , m = 0;
        y("z", "y", "x", -1, -1, i, t, e, o, s, 0),
        y("z", "y", "x", 1, -1, i, t, -e, o, s, 1),
        y("x", "z", "y", 1, 1, e, i, t, r, o, 2),
        y("x", "z", "y", 1, -1, e, i, -t, r, o, 3),
        y("x", "y", "z", 1, -1, e, t, i, r, s, 4),
        y("x", "y", "z", -1, -1, e, t, -i, r, s, 5),
        this.setIndex(l),
        this.setAttribute("position", new je(c,3)),
        this.setAttribute("normal", new je(d,3)),
        this.setAttribute("uv", new je(h,2));
        function y(v, x, _, A, w, M, C, P, R, E, B) {
            const I = M / R
              , z = C / E
              , q = M / 2
              , W = C / 2
              , G = P / 2
              , K = R + 1
              , ne = E + 1;
            let oe = 0
              , F = 0;
            const V = new D;
            for (let Y = 0; Y < ne; Y++) {
                const re = Y * z - W;
                for (let j = 0; j < K; j++) {
                    const ie = j * I - q;
                    V[v] = ie * A,
                    V[x] = re * w,
                    V[_] = G,
                    c.push(V.x, V.y, V.z),
                    V[v] = 0,
                    V[x] = 0,
                    V[_] = P > 0 ? 1 : -1,
                    d.push(V.x, V.y, V.z),
                    h.push(j / R),
                    h.push(1 - Y / E),
                    oe += 1
                }
            }
            for (let Y = 0; Y < E; Y++)
                for (let re = 0; re < R; re++) {
                    const j = p + re + K * Y
                      , ie = p + re + K * (Y + 1)
                      , ye = p + (re + 1) + K * (Y + 1)
                      , _e = p + (re + 1) + K * Y;
                    l.push(j, ie, _e),
                    l.push(ie, ye, _e),
                    F += 6
                }
            a.addGroup(m, F, B),
            m += F,
            p += oe
        }
    }
    static fromJSON(e) {
        return new ma(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
    }
}
function oc(n) {
    const e = {};
    for (const t in n) {
        e[t] = {};
        for (const i in n[t]) {
            const r = n[t][i];
            r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[t][i] = r.clone() : Array.isArray(r) ? e[t][i] = r.slice() : e[t][i] = r
        }
    }
    return e
}
function hi(n) {
    const e = {};
    for (let t = 0; t < n.length; t++) {
        const i = oc(n[t]);
        for (const r in i)
            e[r] = i[r]
    }
    return e
}
function mU(n) {
    const e = [];
    for (let t = 0; t < n.length; t++)
        e.push(n[t].clone());
    return e
}
function zR(n) {
    return n.getRenderTarget() === null && n.outputEncoding === Tt ? kr : sc
}
const GR = {
    clone: oc,
    merge: hi
};
var gU = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
  , vU = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ms extends Tn {
    constructor(e) {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = gU,
        this.fragmentShader = vU,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = oc(e.uniforms),
        this.uniformsGroups = mU(e.uniformsGroups),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.fog = e.fog,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion,
        t.uniforms = {};
        for (const r in this.uniforms) {
            const o = this.uniforms[r].value;
            o && o.isTexture ? t.uniforms[r] = {
                type: "t",
                value: o.toJSON(e).uuid
            } : o && o.isColor ? t.uniforms[r] = {
                type: "c",
                value: o.getHex()
            } : o && o.isVector2 ? t.uniforms[r] = {
                type: "v2",
                value: o.toArray()
            } : o && o.isVector3 ? t.uniforms[r] = {
                type: "v3",
                value: o.toArray()
            } : o && o.isVector4 ? t.uniforms[r] = {
                type: "v4",
                value: o.toArray()
            } : o && o.isMatrix3 ? t.uniforms[r] = {
                type: "m3",
                value: o.toArray()
            } : o && o.isMatrix4 ? t.uniforms[r] = {
                type: "m4",
                value: o.toArray()
            } : t.uniforms[r] = {
                value: o
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader;
        const i = {};
        for (const r in this.extensions)
            this.extensions[r] === !0 && (i[r] = !0);
        return Object.keys(i).length > 0 && (t.extensions = i),
        t
    }
}
class eh extends Rt {
    constructor() {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new ot,
        this.projectionMatrix = new ot,
        this.projectionMatrixInverse = new ot
    }
    copy(e, t) {
        return super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(-t[8], -t[9], -t[10]).normalize()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Wt extends eh {
    constructor(e=50, t=1, i=.1, r=2e3) {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = i,
        this.far = r,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = Cd * 2 * Math.atan(t),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(dl * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return Cd * 2 * Math.atan(Math.tan(dl * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    setViewOffset(e, t, i, r, s, o) {
        this.aspect = e / t,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = i,
        this.view.offsetY = r,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(dl * .5 * this.fov) / this.zoom
          , i = 2 * t
          , r = this.aspect * i
          , s = -.5 * r;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth
              , c = o.fullHeight;
            s += o.offsetX * r / l,
            t -= o.offsetY * i / c,
            r *= o.width / l,
            i *= o.height / c
        }
        const a = this.filmOffset;
        a !== 0 && (s += e * a / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(s, s + r, t, t - i, e, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov,
        t.object.zoom = this.zoom,
        t.object.near = this.near,
        t.object.far = this.far,
        t.object.focus = this.focus,
        t.object.aspect = this.aspect,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t.object.filmGauge = this.filmGauge,
        t.object.filmOffset = this.filmOffset,
        t
    }
}
const ou = -90
  , au = 1;
class Cw extends Rt {
    constructor(e, t, i) {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = i;
        const r = new Wt(ou,au,e,t);
        r.layers = this.layers,
        r.up.set(0, 1, 0),
        r.lookAt(1, 0, 0),
        this.add(r);
        const s = new Wt(ou,au,e,t);
        s.layers = this.layers,
        s.up.set(0, 1, 0),
        s.lookAt(-1, 0, 0),
        this.add(s);
        const o = new Wt(ou,au,e,t);
        o.layers = this.layers,
        o.up.set(0, 0, -1),
        o.lookAt(0, 1, 0),
        this.add(o);
        const a = new Wt(ou,au,e,t);
        a.layers = this.layers,
        a.up.set(0, 0, 1),
        a.lookAt(0, -1, 0),
        this.add(a);
        const l = new Wt(ou,au,e,t);
        l.layers = this.layers,
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, 1),
        this.add(l);
        const c = new Wt(ou,au,e,t);
        c.layers = this.layers,
        c.up.set(0, 1, 0),
        c.lookAt(0, 0, -1),
        this.add(c)
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const i = this.renderTarget
          , [r,s,o,a,l,c] = this.children
          , d = e.getRenderTarget()
          , h = e.toneMapping
          , p = e.xr.enabled;
        e.toneMapping = Hr,
        e.xr.enabled = !1;
        const m = i.texture.generateMipmaps;
        i.texture.generateMipmaps = !1,
        e.setRenderTarget(i, 0),
        e.render(t, r),
        e.setRenderTarget(i, 1),
        e.render(t, s),
        e.setRenderTarget(i, 2),
        e.render(t, o),
        e.setRenderTarget(i, 3),
        e.render(t, a),
        e.setRenderTarget(i, 4),
        e.render(t, l),
        i.texture.generateMipmaps = m,
        e.setRenderTarget(i, 5),
        e.render(t, c),
        e.setRenderTarget(d),
        e.toneMapping = h,
        e.xr.enabled = p,
        i.texture.needsPMREMUpdate = !0
    }
}
class th extends tn {
    constructor(e, t, i, r, s, o, a, l, c, d) {
        e = e !== void 0 ? e : [],
        t = t !== void 0 ? t : ea,
        super(e, t, i, r, s, o, a, l, c, d),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class Ew extends jr {
    constructor(e=1, t={}) {
        super(e, e, t),
        this.isWebGLCubeRenderTarget = !0;
        const i = {
            width: e,
            height: e,
            depth: 1
        }
          , r = [i, i, i, i, i, i];
        this.texture = new th(r,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),
        this.texture.isRenderTargetTexture = !0,
        this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1,
        this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : on
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type,
        this.texture.encoding = t.encoding,
        this.texture.generateMipmaps = t.generateMipmaps,
        this.texture.minFilter = t.minFilter,
        this.texture.magFilter = t.magFilter;
        const i = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }
          , r = new ma(5,5,5)
          , s = new ms({
            name: "CubemapFromEquirect",
            uniforms: oc(i.uniforms),
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            side: Li,
            blending: js
        });
        s.uniforms.tEquirect.value = t;
        const o = new Ln(r,s)
          , a = t.minFilter;
        return t.minFilter === ps && (t.minFilter = on),
        new Cw(1,10,this).update(e, o),
        t.minFilter = a,
        o.geometry.dispose(),
        o.material.dispose(),
        this
    }
    clear(e, t, i, r) {
        const s = e.getRenderTarget();
        for (let o = 0; o < 6; o++)
            e.setRenderTarget(this, o),
            e.clear(t, i, r);
        e.setRenderTarget(s)
    }
}
const ex = new D
  , yU = new D
  , xU = new gi;
class Ro {
    constructor(e=new D(1,0,0), t=0) {
        this.isPlane = !0,
        this.normal = e,
        this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e),
        this.constant = t,
        this
    }
    setComponents(e, t, i, r) {
        return this.normal.set(e, t, i),
        this.constant = r,
        this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e),
        this.constant = -t.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, t, i) {
        const r = ex.subVectors(i, t).cross(yU.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(r, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
    }
    intersectLine(e, t) {
        const i = e.delta(ex)
          , r = this.normal.dot(i);
        if (r === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const s = -(e.start.dot(this.normal) + this.constant) / r;
        return s < 0 || s > 1 ? null : t.copy(i).multiplyScalar(s).add(e.start)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start)
          , i = this.distanceToPoint(e.end);
        return t < 0 && i > 0 || i < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const i = t || xU.getNormalMatrix(e)
          , r = this.coplanarPoint(ex).applyMatrix4(e)
          , s = this.normal.applyMatrix3(i).normalize();
        return this.constant = -r.dot(s),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const lu = new pa
  , tm = new D;
class T0 {
    constructor(e=new Ro, t=new Ro, i=new Ro, r=new Ro, s=new Ro, o=new Ro) {
        this.planes = [e, t, i, r, s, o]
    }
    set(e, t, i, r, s, o) {
        const a = this.planes;
        return a[0].copy(e),
        a[1].copy(t),
        a[2].copy(i),
        a[3].copy(r),
        a[4].copy(s),
        a[5].copy(o),
        this
    }
    copy(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++)
            t[i].copy(e.planes[i]);
        return this
    }
    setFromProjectionMatrix(e) {
        const t = this.planes
          , i = e.elements
          , r = i[0]
          , s = i[1]
          , o = i[2]
          , a = i[3]
          , l = i[4]
          , c = i[5]
          , d = i[6]
          , h = i[7]
          , p = i[8]
          , m = i[9]
          , y = i[10]
          , v = i[11]
          , x = i[12]
          , _ = i[13]
          , A = i[14]
          , w = i[15];
        return t[0].setComponents(a - r, h - l, v - p, w - x).normalize(),
        t[1].setComponents(a + r, h + l, v + p, w + x).normalize(),
        t[2].setComponents(a + s, h + c, v + m, w + _).normalize(),
        t[3].setComponents(a - s, h - c, v - m, w - _).normalize(),
        t[4].setComponents(a - o, h - d, v - y, w - A).normalize(),
        t[5].setComponents(a + o, h + d, v + y, w + A).normalize(),
        this
    }
    intersectsObject(e) {
        const t = e.geometry;
        return t.boundingSphere === null && t.computeBoundingSphere(),
        lu.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
        this.intersectsSphere(lu)
    }
    intersectsSprite(e) {
        return lu.center.set(0, 0, 0),
        lu.radius = .7071067811865476,
        lu.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(lu)
    }
    intersectsSphere(e) {
        const t = this.planes
          , i = e.center
          , r = -e.radius;
        for (let s = 0; s < 6; s++)
            if (t[s].distanceToPoint(i) < r)
                return !1;
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++) {
            const r = t[i];
            if (tm.x = r.normal.x > 0 ? e.max.x : e.min.x,
            tm.y = r.normal.y > 0 ? e.max.y : e.min.y,
            tm.z = r.normal.z > 0 ? e.max.z : e.min.z,
            r.distanceToPoint(tm) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++)
            if (t[i].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
function HR() {
    let n = null
      , e = !1
      , t = null
      , i = null;
    function r(s, o) {
        t(s, o),
        i = n.requestAnimationFrame(r)
    }
    return {
        start: function() {
            e !== !0 && t !== null && (i = n.requestAnimationFrame(r),
            e = !0)
        },
        stop: function() {
            n.cancelAnimationFrame(i),
            e = !1
        },
        setAnimationLoop: function(s) {
            t = s
        },
        setContext: function(s) {
            n = s
        }
    }
}
function _U(n, e) {
    const t = e.isWebGL2
      , i = new WeakMap;
    function r(c, d) {
        const h = c.array
          , p = c.usage
          , m = n.createBuffer();
        n.bindBuffer(d, m),
        n.bufferData(d, h, p),
        c.onUploadCallback();
        let y;
        if (h instanceof Float32Array)
            y = 5126;
        else if (h instanceof Uint16Array)
            if (c.isFloat16BufferAttribute)
                if (t)
                    y = 5131;
                else
                    throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
            else
                y = 5123;
        else if (h instanceof Int16Array)
            y = 5122;
        else if (h instanceof Uint32Array)
            y = 5125;
        else if (h instanceof Int32Array)
            y = 5124;
        else if (h instanceof Int8Array)
            y = 5120;
        else if (h instanceof Uint8Array)
            y = 5121;
        else if (h instanceof Uint8ClampedArray)
            y = 5121;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + h);
        return {
            buffer: m,
            type: y,
            bytesPerElement: h.BYTES_PER_ELEMENT,
            version: c.version
        }
    }
    function s(c, d, h) {
        const p = d.array
          , m = d.updateRange;
        n.bindBuffer(h, c),
        m.count === -1 ? n.bufferSubData(h, 0, p) : (t ? n.bufferSubData(h, m.offset * p.BYTES_PER_ELEMENT, p, m.offset, m.count) : n.bufferSubData(h, m.offset * p.BYTES_PER_ELEMENT, p.subarray(m.offset, m.offset + m.count)),
        m.count = -1),
        d.onUploadCallback()
    }
    function o(c) {
        return c.isInterleavedBufferAttribute && (c = c.data),
        i.get(c)
    }
    function a(c) {
        c.isInterleavedBufferAttribute && (c = c.data);
        const d = i.get(c);
        d && (n.deleteBuffer(d.buffer),
        i.delete(c))
    }
    function l(c, d) {
        if (c.isGLBufferAttribute) {
            const p = i.get(c);
            (!p || p.version < c.version) && i.set(c, {
                buffer: c.buffer,
                type: c.type,
                bytesPerElement: c.elementSize,
                version: c.version
            });
            return
        }
        c.isInterleavedBufferAttribute && (c = c.data);
        const h = i.get(c);
        h === void 0 ? i.set(c, r(c, d)) : h.version < c.version && (s(h.buffer, c, d),
        h.version = c.version)
    }
    return {
        get: o,
        remove: a,
        update: l
    }
}
class Ac extends ft {
    constructor(e=1, t=1, i=1, r=1) {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: r
        };
        const s = e / 2
          , o = t / 2
          , a = Math.floor(i)
          , l = Math.floor(r)
          , c = a + 1
          , d = l + 1
          , h = e / a
          , p = t / l
          , m = []
          , y = []
          , v = []
          , x = [];
        for (let _ = 0; _ < d; _++) {
            const A = _ * p - o;
            for (let w = 0; w < c; w++) {
                const M = w * h - s;
                y.push(M, -A, 0),
                v.push(0, 0, 1),
                x.push(w / a),
                x.push(1 - _ / l)
            }
        }
        for (let _ = 0; _ < l; _++)
            for (let A = 0; A < a; A++) {
                const w = A + c * _
                  , M = A + c * (_ + 1)
                  , C = A + 1 + c * (_ + 1)
                  , P = A + 1 + c * _;
                m.push(w, M, P),
                m.push(M, C, P)
            }
        this.setIndex(m),
        this.setAttribute("position", new je(y,3)),
        this.setAttribute("normal", new je(v,3)),
        this.setAttribute("uv", new je(x,2))
    }
    static fromJSON(e) {
        return new Ac(e.width,e.height,e.widthSegments,e.heightSegments)
    }
}
var AU = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`
  , wU = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , SU = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`
  , MU = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`
  , bU = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`
  , CU = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`
  , EU = "vec3 transformed = vec3( position );"
  , TU = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`
  , PU = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`
  , BU = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`
  , RU = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`
  , IU = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`
  , LU = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`
  , DU = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`
  , kU = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`
  , FU = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`
  , NU = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`
  , OU = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`
  , UU = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`
  , zU = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`
  , GU = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`
  , HU = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`
  , VU = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`
  , WU = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`
  , jU = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`
  , JU = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`
  , XU = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
  , YU = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`
  , KU = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`
  , QU = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`
  , ZU = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`
  , qU = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`
  , $U = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`
  , ez = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`
  , tz = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`
  , nz = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`
  , iz = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`
  , rz = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`
  , sz = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`
  , oz = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`
  , az = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`
  , lz = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`
  , uz = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`
  , cz = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`
  , fz = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`
  , dz = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`
  , hz = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`
  , pz = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`
  , mz = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`
  , gz = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`
  , vz = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`
  , yz = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`
  , xz = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`
  , _z = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`
  , Az = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , wz = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`
  , Sz = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`
  , Mz = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`
  , bz = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`
  , Cz = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`
  , Ez = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , Tz = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`
  , Pz = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`
  , Bz = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`
  , Rz = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`
  , Iz = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`
  , Lz = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`
  , Dz = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`
  , kz = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`
  , Fz = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , Nz = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , Oz = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`
  , Uz = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`
  , zz = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`
  , Gz = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`
  , Hz = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`
  , Vz = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`
  , Wz = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`
  , jz = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`
  , Jz = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`
  , Xz = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`
  , Yz = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`
  , Kz = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`
  , Qz = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`
  , Zz = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`
  , qz = `#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`
  , $z = `#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`
  , e5 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`
  , t5 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`
  , n5 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`
  , i5 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`
  , r5 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`
  , s5 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`
  , o5 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`
  , a5 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`
  , l5 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`
  , u5 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`
  , c5 = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`
  , f5 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`
  , d5 = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`
  , h5 = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`
  , p5 = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`
  , m5 = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`
  , g5 = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`
  , v5 = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`
  , y5 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const x5 = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`
  , _5 = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , A5 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , w5 = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , S5 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , M5 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , b5 = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`
  , C5 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`
  , E5 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`
  , T5 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`
  , P5 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`
  , B5 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , R5 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , I5 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , L5 = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`
  , D5 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , k5 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , F5 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , N5 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`
  , O5 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , U5 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`
  , z5 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`
  , G5 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , H5 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , V5 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`
  , W5 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , j5 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , J5 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , X5 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`
  , Y5 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , K5 = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , Q5 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`
  , Z5 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , q5 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`
  , vt = {
    alphamap_fragment: AU,
    alphamap_pars_fragment: wU,
    alphatest_fragment: SU,
    alphatest_pars_fragment: MU,
    aomap_fragment: bU,
    aomap_pars_fragment: CU,
    begin_vertex: EU,
    beginnormal_vertex: TU,
    bsdfs: PU,
    iridescence_fragment: BU,
    bumpmap_pars_fragment: RU,
    clipping_planes_fragment: IU,
    clipping_planes_pars_fragment: LU,
    clipping_planes_pars_vertex: DU,
    clipping_planes_vertex: kU,
    color_fragment: FU,
    color_pars_fragment: NU,
    color_pars_vertex: OU,
    color_vertex: UU,
    common: zU,
    cube_uv_reflection_fragment: GU,
    defaultnormal_vertex: HU,
    displacementmap_pars_vertex: VU,
    displacementmap_vertex: WU,
    emissivemap_fragment: jU,
    emissivemap_pars_fragment: JU,
    encodings_fragment: XU,
    encodings_pars_fragment: YU,
    envmap_fragment: KU,
    envmap_common_pars_fragment: QU,
    envmap_pars_fragment: ZU,
    envmap_pars_vertex: qU,
    envmap_physical_pars_fragment: cz,
    envmap_vertex: $U,
    fog_vertex: ez,
    fog_pars_vertex: tz,
    fog_fragment: nz,
    fog_pars_fragment: iz,
    gradientmap_pars_fragment: rz,
    lightmap_fragment: sz,
    lightmap_pars_fragment: oz,
    lights_lambert_fragment: az,
    lights_lambert_pars_fragment: lz,
    lights_pars_begin: uz,
    lights_toon_fragment: fz,
    lights_toon_pars_fragment: dz,
    lights_phong_fragment: hz,
    lights_phong_pars_fragment: pz,
    lights_physical_fragment: mz,
    lights_physical_pars_fragment: gz,
    lights_fragment_begin: vz,
    lights_fragment_maps: yz,
    lights_fragment_end: xz,
    logdepthbuf_fragment: _z,
    logdepthbuf_pars_fragment: Az,
    logdepthbuf_pars_vertex: wz,
    logdepthbuf_vertex: Sz,
    map_fragment: Mz,
    map_pars_fragment: bz,
    map_particle_fragment: Cz,
    map_particle_pars_fragment: Ez,
    metalnessmap_fragment: Tz,
    metalnessmap_pars_fragment: Pz,
    morphcolor_vertex: Bz,
    morphnormal_vertex: Rz,
    morphtarget_pars_vertex: Iz,
    morphtarget_vertex: Lz,
    normal_fragment_begin: Dz,
    normal_fragment_maps: kz,
    normal_pars_fragment: Fz,
    normal_pars_vertex: Nz,
    normal_vertex: Oz,
    normalmap_pars_fragment: Uz,
    clearcoat_normal_fragment_begin: zz,
    clearcoat_normal_fragment_maps: Gz,
    clearcoat_pars_fragment: Hz,
    iridescence_pars_fragment: Vz,
    output_fragment: Wz,
    packing: jz,
    premultiplied_alpha_fragment: Jz,
    project_vertex: Xz,
    dithering_fragment: Yz,
    dithering_pars_fragment: Kz,
    roughnessmap_fragment: Qz,
    roughnessmap_pars_fragment: Zz,
    shadowmap_pars_fragment: qz,
    shadowmap_pars_vertex: $z,
    shadowmap_vertex: e5,
    shadowmask_pars_fragment: t5,
    skinbase_vertex: n5,
    skinning_pars_vertex: i5,
    skinning_vertex: r5,
    skinnormal_vertex: s5,
    specularmap_fragment: o5,
    specularmap_pars_fragment: a5,
    tonemapping_fragment: l5,
    tonemapping_pars_fragment: u5,
    transmission_fragment: c5,
    transmission_pars_fragment: f5,
    uv_pars_fragment: d5,
    uv_pars_vertex: h5,
    uv_vertex: p5,
    uv2_pars_fragment: m5,
    uv2_pars_vertex: g5,
    uv2_vertex: v5,
    worldpos_vertex: y5,
    background_vert: x5,
    background_frag: _5,
    backgroundCube_vert: A5,
    backgroundCube_frag: w5,
    cube_vert: S5,
    cube_frag: M5,
    depth_vert: b5,
    depth_frag: C5,
    distanceRGBA_vert: E5,
    distanceRGBA_frag: T5,
    equirect_vert: P5,
    equirect_frag: B5,
    linedashed_vert: R5,
    linedashed_frag: I5,
    meshbasic_vert: L5,
    meshbasic_frag: D5,
    meshlambert_vert: k5,
    meshlambert_frag: F5,
    meshmatcap_vert: N5,
    meshmatcap_frag: O5,
    meshnormal_vert: U5,
    meshnormal_frag: z5,
    meshphong_vert: G5,
    meshphong_frag: H5,
    meshphysical_vert: V5,
    meshphysical_frag: W5,
    meshtoon_vert: j5,
    meshtoon_frag: J5,
    points_vert: X5,
    points_frag: Y5,
    shadow_vert: K5,
    shadow_frag: Q5,
    sprite_vert: Z5,
    sprite_frag: q5
}
  , Re = {
    common: {
        diffuse: {
            value: new Ie(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        uvTransform: {
            value: new gi
        },
        uv2Transform: {
            value: new gi
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalScale: {
            value: new me(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new Ie(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotLightMap: {
            value: []
        },
        spotShadowMap: {
            value: []
        },
        spotLightMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new Ie(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new gi
        }
    },
    sprite: {
        diffuse: {
            value: new Ie(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new me(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new gi
        }
    }
}
  , Nr = {
    basic: {
        uniforms: hi([Re.common, Re.specularmap, Re.envmap, Re.aomap, Re.lightmap, Re.fog]),
        vertexShader: vt.meshbasic_vert,
        fragmentShader: vt.meshbasic_frag
    },
    lambert: {
        uniforms: hi([Re.common, Re.specularmap, Re.envmap, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.fog, Re.lights, {
            emissive: {
                value: new Ie(0)
            }
        }]),
        vertexShader: vt.meshlambert_vert,
        fragmentShader: vt.meshlambert_frag
    },
    phong: {
        uniforms: hi([Re.common, Re.specularmap, Re.envmap, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.fog, Re.lights, {
            emissive: {
                value: new Ie(0)
            },
            specular: {
                value: new Ie(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: vt.meshphong_vert,
        fragmentShader: vt.meshphong_frag
    },
    standard: {
        uniforms: hi([Re.common, Re.envmap, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.roughnessmap, Re.metalnessmap, Re.fog, Re.lights, {
            emissive: {
                value: new Ie(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: vt.meshphysical_vert,
        fragmentShader: vt.meshphysical_frag
    },
    toon: {
        uniforms: hi([Re.common, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.gradientmap, Re.fog, Re.lights, {
            emissive: {
                value: new Ie(0)
            }
        }]),
        vertexShader: vt.meshtoon_vert,
        fragmentShader: vt.meshtoon_frag
    },
    matcap: {
        uniforms: hi([Re.common, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: vt.meshmatcap_vert,
        fragmentShader: vt.meshmatcap_frag
    },
    points: {
        uniforms: hi([Re.points, Re.fog]),
        vertexShader: vt.points_vert,
        fragmentShader: vt.points_frag
    },
    dashed: {
        uniforms: hi([Re.common, Re.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: vt.linedashed_vert,
        fragmentShader: vt.linedashed_frag
    },
    depth: {
        uniforms: hi([Re.common, Re.displacementmap]),
        vertexShader: vt.depth_vert,
        fragmentShader: vt.depth_frag
    },
    normal: {
        uniforms: hi([Re.common, Re.bumpmap, Re.normalmap, Re.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: vt.meshnormal_vert,
        fragmentShader: vt.meshnormal_frag
    },
    sprite: {
        uniforms: hi([Re.sprite, Re.fog]),
        vertexShader: vt.sprite_vert,
        fragmentShader: vt.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new gi
            },
            t2D: {
                value: null
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: vt.background_vert,
        fragmentShader: vt.background_frag
    },
    backgroundCube: {
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            backgroundBlurriness: {
                value: 0
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: vt.backgroundCube_vert,
        fragmentShader: vt.backgroundCube_frag
    },
    cube: {
        uniforms: {
            tCube: {
                value: null
            },
            tFlip: {
                value: -1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: vt.cube_vert,
        fragmentShader: vt.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: vt.equirect_vert,
        fragmentShader: vt.equirect_frag
    },
    distanceRGBA: {
        uniforms: hi([Re.common, Re.displacementmap, {
            referencePosition: {
                value: new D
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: vt.distanceRGBA_vert,
        fragmentShader: vt.distanceRGBA_frag
    },
    shadow: {
        uniforms: hi([Re.lights, Re.fog, {
            color: {
                value: new Ie(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: vt.shadow_vert,
        fragmentShader: vt.shadow_frag
    }
};
Nr.physical = {
    uniforms: hi([Nr.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatNormalScale: {
            value: new me(1,1)
        },
        clearcoatNormalMap: {
            value: null
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new Ie(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionSamplerSize: {
            value: new me
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new Ie(0)
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularColor: {
            value: new Ie(1,1,1)
        },
        specularColorMap: {
            value: null
        }
    }]),
    vertexShader: vt.meshphysical_vert,
    fragmentShader: vt.meshphysical_frag
};
const nm = {
    r: 0,
    b: 0,
    g: 0
};
function $5(n, e, t, i, r, s, o) {
    const a = new Ie(0);
    let l = s === !0 ? 0 : 1, c, d, h = null, p = 0, m = null;
    function y(x, _) {
        let A = !1
          , w = _.isScene === !0 ? _.background : null;
        w && w.isTexture && (w = (_.backgroundBlurriness > 0 ? t : e).get(w));
        const M = n.xr
          , C = M.getSession && M.getSession();
        C && C.environmentBlendMode === "additive" && (w = null),
        w === null ? v(a, l) : w && w.isColor && (v(w, 1),
        A = !0),
        (n.autoClear || A) && n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil),
        w && (w.isCubeTexture || w.mapping === _c) ? (d === void 0 && (d = new Ln(new ma(1,1,1),new ms({
            name: "BackgroundCubeMaterial",
            uniforms: oc(Nr.backgroundCube.uniforms),
            vertexShader: Nr.backgroundCube.vertexShader,
            fragmentShader: Nr.backgroundCube.fragmentShader,
            side: Li,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        d.geometry.deleteAttribute("normal"),
        d.geometry.deleteAttribute("uv"),
        d.onBeforeRender = function(P, R, E) {
            this.matrixWorld.copyPosition(E.matrixWorld)
        }
        ,
        Object.defineProperty(d.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }),
        r.update(d)),
        d.material.uniforms.envMap.value = w,
        d.material.uniforms.flipEnvMap.value = w.isCubeTexture && w.isRenderTargetTexture === !1 ? -1 : 1,
        d.material.uniforms.backgroundBlurriness.value = _.backgroundBlurriness,
        d.material.uniforms.backgroundIntensity.value = _.backgroundIntensity,
        d.material.toneMapped = w.encoding !== Tt,
        (h !== w || p !== w.version || m !== n.toneMapping) && (d.material.needsUpdate = !0,
        h = w,
        p = w.version,
        m = n.toneMapping),
        d.layers.enableAll(),
        x.unshift(d, d.geometry, d.material, 0, 0, null)) : w && w.isTexture && (c === void 0 && (c = new Ln(new Ac(2,2),new ms({
            name: "BackgroundMaterial",
            uniforms: oc(Nr.background.uniforms),
            vertexShader: Nr.background.vertexShader,
            fragmentShader: Nr.background.fragmentShader,
            side: hs,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        c.geometry.deleteAttribute("normal"),
        Object.defineProperty(c.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }),
        r.update(c)),
        c.material.uniforms.t2D.value = w,
        c.material.uniforms.backgroundIntensity.value = _.backgroundIntensity,
        c.material.toneMapped = w.encoding !== Tt,
        w.matrixAutoUpdate === !0 && w.updateMatrix(),
        c.material.uniforms.uvTransform.value.copy(w.matrix),
        (h !== w || p !== w.version || m !== n.toneMapping) && (c.material.needsUpdate = !0,
        h = w,
        p = w.version,
        m = n.toneMapping),
        c.layers.enableAll(),
        x.unshift(c, c.geometry, c.material, 0, 0, null))
    }
    function v(x, _) {
        x.getRGB(nm, zR(n)),
        i.buffers.color.setClear(nm.r, nm.g, nm.b, _, o)
    }
    return {
        getClearColor: function() {
            return a
        },
        setClearColor: function(x, _=1) {
            a.set(x),
            l = _,
            v(a, l)
        },
        getClearAlpha: function() {
            return l
        },
        setClearAlpha: function(x) {
            l = x,
            v(a, l)
        },
        render: y
    }
}
function eG(n, e, t, i) {
    const r = n.getParameter(34921)
      , s = i.isWebGL2 ? null : e.get("OES_vertex_array_object")
      , o = i.isWebGL2 || s !== null
      , a = {}
      , l = x(null);
    let c = l
      , d = !1;
    function h(G, K, ne, oe, F) {
        let V = !1;
        if (o) {
            const Y = v(oe, ne, K);
            c !== Y && (c = Y,
            m(c.object)),
            V = _(G, oe, ne, F),
            V && A(G, oe, ne, F)
        } else {
            const Y = K.wireframe === !0;
            (c.geometry !== oe.id || c.program !== ne.id || c.wireframe !== Y) && (c.geometry = oe.id,
            c.program = ne.id,
            c.wireframe = Y,
            V = !0)
        }
        F !== null && t.update(F, 34963),
        (V || d) && (d = !1,
        E(G, K, ne, oe),
        F !== null && n.bindBuffer(34963, t.get(F).buffer))
    }
    function p() {
        return i.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES()
    }
    function m(G) {
        return i.isWebGL2 ? n.bindVertexArray(G) : s.bindVertexArrayOES(G)
    }
    function y(G) {
        return i.isWebGL2 ? n.deleteVertexArray(G) : s.deleteVertexArrayOES(G)
    }
    function v(G, K, ne) {
        const oe = ne.wireframe === !0;
        let F = a[G.id];
        F === void 0 && (F = {},
        a[G.id] = F);
        let V = F[K.id];
        V === void 0 && (V = {},
        F[K.id] = V);
        let Y = V[oe];
        return Y === void 0 && (Y = x(p()),
        V[oe] = Y),
        Y
    }
    function x(G) {
        const K = []
          , ne = []
          , oe = [];
        for (let F = 0; F < r; F++)
            K[F] = 0,
            ne[F] = 0,
            oe[F] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: K,
            enabledAttributes: ne,
            attributeDivisors: oe,
            object: G,
            attributes: {},
            index: null
        }
    }
    function _(G, K, ne, oe) {
        const F = c.attributes
          , V = K.attributes;
        let Y = 0;
        const re = ne.getAttributes();
        for (const j in re)
            if (re[j].location >= 0) {
                const ye = F[j];
                let _e = V[j];
                if (_e === void 0 && (j === "instanceMatrix" && G.instanceMatrix && (_e = G.instanceMatrix),
                j === "instanceColor" && G.instanceColor && (_e = G.instanceColor)),
                ye === void 0 || ye.attribute !== _e || _e && ye.data !== _e.data)
                    return !0;
                Y++
            }
        return c.attributesNum !== Y || c.index !== oe
    }
    function A(G, K, ne, oe) {
        const F = {}
          , V = K.attributes;
        let Y = 0;
        const re = ne.getAttributes();
        for (const j in re)
            if (re[j].location >= 0) {
                let ye = V[j];
                ye === void 0 && (j === "instanceMatrix" && G.instanceMatrix && (ye = G.instanceMatrix),
                j === "instanceColor" && G.instanceColor && (ye = G.instanceColor));
                const _e = {};
                _e.attribute = ye,
                ye && ye.data && (_e.data = ye.data),
                F[j] = _e,
                Y++
            }
        c.attributes = F,
        c.attributesNum = Y,
        c.index = oe
    }
    function w() {
        const G = c.newAttributes;
        for (let K = 0, ne = G.length; K < ne; K++)
            G[K] = 0
    }
    function M(G) {
        C(G, 0)
    }
    function C(G, K) {
        const ne = c.newAttributes
          , oe = c.enabledAttributes
          , F = c.attributeDivisors;
        ne[G] = 1,
        oe[G] === 0 && (n.enableVertexAttribArray(G),
        oe[G] = 1),
        F[G] !== K && ((i.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](G, K),
        F[G] = K)
    }
    function P() {
        const G = c.newAttributes
          , K = c.enabledAttributes;
        for (let ne = 0, oe = K.length; ne < oe; ne++)
            K[ne] !== G[ne] && (n.disableVertexAttribArray(ne),
            K[ne] = 0)
    }
    function R(G, K, ne, oe, F, V) {
        i.isWebGL2 === !0 && (ne === 5124 || ne === 5125) ? n.vertexAttribIPointer(G, K, ne, F, V) : n.vertexAttribPointer(G, K, ne, oe, F, V)
    }
    function E(G, K, ne, oe) {
        if (i.isWebGL2 === !1 && (G.isInstancedMesh || oe.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
            return;
        w();
        const F = oe.attributes
          , V = ne.getAttributes()
          , Y = K.defaultAttributeValues;
        for (const re in V) {
            const j = V[re];
            if (j.location >= 0) {
                let ie = F[re];
                if (ie === void 0 && (re === "instanceMatrix" && G.instanceMatrix && (ie = G.instanceMatrix),
                re === "instanceColor" && G.instanceColor && (ie = G.instanceColor)),
                ie !== void 0) {
                    const ye = ie.normalized
                      , _e = ie.itemSize
                      , $ = t.get(ie);
                    if ($ === void 0)
                        continue;
                    const Ne = $.buffer
                      , Oe = $.type
                      , Ve = $.bytesPerElement;
                    if (ie.isInterleavedBufferAttribute) {
                        const we = ie.data
                          , Le = we.stride
                          , de = ie.offset;
                        if (we.isInstancedInterleavedBuffer) {
                            for (let ae = 0; ae < j.locationSize; ae++)
                                C(j.location + ae, we.meshPerAttribute);
                            G.isInstancedMesh !== !0 && oe._maxInstanceCount === void 0 && (oe._maxInstanceCount = we.meshPerAttribute * we.count)
                        } else
                            for (let ae = 0; ae < j.locationSize; ae++)
                                M(j.location + ae);
                        n.bindBuffer(34962, Ne);
                        for (let ae = 0; ae < j.locationSize; ae++)
                            R(j.location + ae, _e / j.locationSize, Oe, ye, Le * Ve, (de + _e / j.locationSize * ae) * Ve)
                    } else {
                        if (ie.isInstancedBufferAttribute) {
                            for (let we = 0; we < j.locationSize; we++)
                                C(j.location + we, ie.meshPerAttribute);
                            G.isInstancedMesh !== !0 && oe._maxInstanceCount === void 0 && (oe._maxInstanceCount = ie.meshPerAttribute * ie.count)
                        } else
                            for (let we = 0; we < j.locationSize; we++)
                                M(j.location + we);
                        n.bindBuffer(34962, Ne);
                        for (let we = 0; we < j.locationSize; we++)
                            R(j.location + we, _e / j.locationSize, Oe, ye, _e * Ve, _e / j.locationSize * we * Ve)
                    }
                } else if (Y !== void 0) {
                    const ye = Y[re];
                    if (ye !== void 0)
                        switch (ye.length) {
                        case 2:
                            n.vertexAttrib2fv(j.location, ye);
                            break;
                        case 3:
                            n.vertexAttrib3fv(j.location, ye);
                            break;
                        case 4:
                            n.vertexAttrib4fv(j.location, ye);
                            break;
                        default:
                            n.vertexAttrib1fv(j.location, ye)
                        }
                }
            }
        }
        P()
    }
    function B() {
        q();
        for (const G in a) {
            const K = a[G];
            for (const ne in K) {
                const oe = K[ne];
                for (const F in oe)
                    y(oe[F].object),
                    delete oe[F];
                delete K[ne]
            }
            delete a[G]
        }
    }
    function I(G) {
        if (a[G.id] === void 0)
            return;
        const K = a[G.id];
        for (const ne in K) {
            const oe = K[ne];
            for (const F in oe)
                y(oe[F].object),
                delete oe[F];
            delete K[ne]
        }
        delete a[G.id]
    }
    function z(G) {
        for (const K in a) {
            const ne = a[K];
            if (ne[G.id] === void 0)
                continue;
            const oe = ne[G.id];
            for (const F in oe)
                y(oe[F].object),
                delete oe[F];
            delete ne[G.id]
        }
    }
    function q() {
        W(),
        d = !0,
        c !== l && (c = l,
        m(c.object))
    }
    function W() {
        l.geometry = null,
        l.program = null,
        l.wireframe = !1
    }
    return {
        setup: h,
        reset: q,
        resetDefaultState: W,
        dispose: B,
        releaseStatesOfGeometry: I,
        releaseStatesOfProgram: z,
        initAttributes: w,
        enableAttribute: M,
        disableUnusedAttributes: P
    }
}
function tG(n, e, t, i) {
    const r = i.isWebGL2;
    let s;
    function o(c) {
        s = c
    }
    function a(c, d) {
        n.drawArrays(s, c, d),
        t.update(d, s, 1)
    }
    function l(c, d, h) {
        if (h === 0)
            return;
        let p, m;
        if (r)
            p = n,
            m = "drawArraysInstanced";
        else if (p = e.get("ANGLE_instanced_arrays"),
        m = "drawArraysInstancedANGLE",
        p === null) {
            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        p[m](s, c, d, h),
        t.update(d, s, h)
    }
    this.setMode = o,
    this.render = a,
    this.renderInstances = l
}
function nG(n, e, t) {
    let i;
    function r() {
        if (i !== void 0)
            return i;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const R = e.get("EXT_texture_filter_anisotropic");
            i = n.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            i = 0;
        return i
    }
    function s(R) {
        if (R === "highp") {
            if (n.getShaderPrecisionFormat(35633, 36338).precision > 0 && n.getShaderPrecisionFormat(35632, 36338).precision > 0)
                return "highp";
            R = "mediump"
        }
        return R === "mediump" && n.getShaderPrecisionFormat(35633, 36337).precision > 0 && n.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
    }
    const o = typeof WebGL2RenderingContext < "u" && n instanceof WebGL2RenderingContext;
    let a = t.precision !== void 0 ? t.precision : "highp";
    const l = s(a);
    l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."),
    a = l);
    const c = o || e.has("WEBGL_draw_buffers")
      , d = t.logarithmicDepthBuffer === !0
      , h = n.getParameter(34930)
      , p = n.getParameter(35660)
      , m = n.getParameter(3379)
      , y = n.getParameter(34076)
      , v = n.getParameter(34921)
      , x = n.getParameter(36347)
      , _ = n.getParameter(36348)
      , A = n.getParameter(36349)
      , w = p > 0
      , M = o || e.has("OES_texture_float")
      , C = w && M
      , P = o ? n.getParameter(36183) : 0;
    return {
        isWebGL2: o,
        drawBuffers: c,
        getMaxAnisotropy: r,
        getMaxPrecision: s,
        precision: a,
        logarithmicDepthBuffer: d,
        maxTextures: h,
        maxVertexTextures: p,
        maxTextureSize: m,
        maxCubemapSize: y,
        maxAttributes: v,
        maxVertexUniforms: x,
        maxVaryings: _,
        maxFragmentUniforms: A,
        vertexTextures: w,
        floatFragmentTextures: M,
        floatVertexTextures: C,
        maxSamples: P
    }
}
function iG(n) {
    const e = this;
    let t = null
      , i = 0
      , r = !1
      , s = !1;
    const o = new Ro
      , a = new gi
      , l = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = l,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(h, p) {
        const m = h.length !== 0 || p || i !== 0 || r;
        return r = p,
        i = h.length,
        m
    }
    ,
    this.beginShadows = function() {
        s = !0,
        d(null)
    }
    ,
    this.endShadows = function() {
        s = !1
    }
    ,
    this.setGlobalState = function(h, p) {
        t = d(h, p, 0)
    }
    ,
    this.setState = function(h, p, m) {
        const y = h.clippingPlanes
          , v = h.clipIntersection
          , x = h.clipShadows
          , _ = n.get(h);
        if (!r || y === null || y.length === 0 || s && !x)
            s ? d(null) : c();
        else {
            const A = s ? 0 : i
              , w = A * 4;
            let M = _.clippingState || null;
            l.value = M,
            M = d(y, p, w, m);
            for (let C = 0; C !== w; ++C)
                M[C] = t[C];
            _.clippingState = M,
            this.numIntersection = v ? this.numPlanes : 0,
            this.numPlanes += A
        }
    }
    ;
    function c() {
        l.value !== t && (l.value = t,
        l.needsUpdate = i > 0),
        e.numPlanes = i,
        e.numIntersection = 0
    }
    function d(h, p, m, y) {
        const v = h !== null ? h.length : 0;
        let x = null;
        if (v !== 0) {
            if (x = l.value,
            y !== !0 || x === null) {
                const _ = m + v * 4
                  , A = p.matrixWorldInverse;
                a.getNormalMatrix(A),
                (x === null || x.length < _) && (x = new Float32Array(_));
                for (let w = 0, M = m; w !== v; ++w,
                M += 4)
                    o.copy(h[w]).applyMatrix4(A, a),
                    o.normal.toArray(x, M),
                    x[M + 3] = o.constant
            }
            l.value = x,
            l.needsUpdate = !0
        }
        return e.numPlanes = v,
        e.numIntersection = 0,
        x
    }
}
function rG(n) {
    let e = new WeakMap;
    function t(o, a) {
        return a === Ad ? o.mapping = ea : a === wd && (o.mapping = ta),
        o
    }
    function i(o) {
        if (o && o.isTexture && o.isRenderTargetTexture === !1) {
            const a = o.mapping;
            if (a === Ad || a === wd)
                if (e.has(o)) {
                    const l = e.get(o).texture;
                    return t(l, o.mapping)
                } else {
                    const l = o.image;
                    if (l && l.height > 0) {
                        const c = new Ew(l.height / 2);
                        return c.fromEquirectangularTexture(n, o),
                        e.set(o, c),
                        o.addEventListener("dispose", r),
                        t(c.texture, o.mapping)
                    } else
                        return null
                }
        }
        return o
    }
    function r(o) {
        const a = o.target;
        a.removeEventListener("dispose", r);
        const l = e.get(a);
        l !== void 0 && (e.delete(a),
        l.dispose())
    }
    function s() {
        e = new WeakMap
    }
    return {
        get: i,
        dispose: s
    }
}
class Vr extends eh {
    constructor(e=-1, t=1, i=1, r=-1, s=.1, o=2e3) {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = i,
        this.bottom = r,
        this.near = s,
        this.far = o,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, t, i, r, s, o) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = i,
        this.view.offsetY = r,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom)
          , t = (this.top - this.bottom) / (2 * this.zoom)
          , i = (this.right + this.left) / 2
          , r = (this.top + this.bottom) / 2;
        let s = i - e
          , o = i + e
          , a = r + t
          , l = r - t;
        if (this.view !== null && this.view.enabled) {
            const c = (this.right - this.left) / this.view.fullWidth / this.zoom
              , d = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            s += c * this.view.offsetX,
            o = s + c * this.view.width,
            a -= d * this.view.offsetY,
            l = a - d * this.view.height
        }
        this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom,
        t.object.left = this.left,
        t.object.right = this.right,
        t.object.top = this.top,
        t.object.bottom = this.bottom,
        t.object.near = this.near,
        t.object.far = this.far,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t
    }
}
const Bu = 4
  , oE = [.125, .215, .35, .446, .526, .582]
  , Ya = 20
  , tx = new Vr
  , aE = new Ie;
let nx = null;
const Va = (1 + Math.sqrt(5)) / 2
  , uu = 1 / Va
  , lE = [new D(1,1,1), new D(-1,1,1), new D(1,1,-1), new D(-1,1,-1), new D(0,Va,uu), new D(0,Va,-uu), new D(uu,0,Va), new D(-uu,0,Va), new D(Va,uu,0), new D(-Va,uu,0)];
class v_ {
    constructor(e) {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t=0, i=.1, r=100) {
        nx = this._renderer.getRenderTarget(),
        this._setSize(256);
        const s = this._allocateTargets();
        return s.depthBuffer = !0,
        this._sceneToCubeUV(e, i, r, s),
        t > 0 && this._blur(s, 0, 0, t),
        this._applyPMREM(s),
        this._cleanup(s),
        s
    }
    fromEquirectangular(e, t=null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t=null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = fE(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = cE(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(nx),
        e.scissorTest = !1,
        im(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === ea || e.mapping === ta ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        nx = this._renderer.getRenderTarget();
        const i = t || this._allocateTargets();
        return this._textureToCubeUV(e, i),
        this._applyPMREM(i),
        this._cleanup(i),
        i
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112)
          , t = 4 * this._cubeSize
          , i = {
            magFilter: on,
            minFilter: on,
            generateMipmaps: !1,
            type: ic,
            format: Ti,
            encoding: $s,
            depthBuffer: !1
        }
          , r = uE(e, t, i);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = uE(e, t, i);
            const {_lodMax: s} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = sG(s)),
            this._blurMaterial = oG(s, e, t)
        }
        return r
    }
    _compileMaterial(e) {
        const t = new Ln(this._lodPlanes[0],e);
        this._renderer.compile(t, tx)
    }
    _sceneToCubeUV(e, t, i, r) {
        const a = new Wt(90,1,t,i)
          , l = [1, -1, 1, 1, 1, 1]
          , c = [1, 1, 1, -1, -1, -1]
          , d = this._renderer
          , h = d.autoClear
          , p = d.toneMapping;
        d.getClearColor(aE),
        d.toneMapping = Hr,
        d.autoClear = !1;
        const m = new Wi({
            name: "PMREM.Background",
            side: Li,
            depthWrite: !1,
            depthTest: !1
        })
          , y = new Ln(new ma,m);
        let v = !1;
        const x = e.background;
        x ? x.isColor && (m.color.copy(x),
        e.background = null,
        v = !0) : (m.color.copy(aE),
        v = !0);
        for (let _ = 0; _ < 6; _++) {
            const A = _ % 3;
            A === 0 ? (a.up.set(0, l[_], 0),
            a.lookAt(c[_], 0, 0)) : A === 1 ? (a.up.set(0, 0, l[_]),
            a.lookAt(0, c[_], 0)) : (a.up.set(0, l[_], 0),
            a.lookAt(0, 0, c[_]));
            const w = this._cubeSize;
            im(r, A * w, _ > 2 ? w : 0, w, w),
            d.setRenderTarget(r),
            v && d.render(y, a),
            d.render(e, a)
        }
        y.geometry.dispose(),
        y.material.dispose(),
        d.toneMapping = p,
        d.autoClear = h,
        e.background = x
    }
    _textureToCubeUV(e, t) {
        const i = this._renderer
          , r = e.mapping === ea || e.mapping === ta;
        r ? (this._cubemapMaterial === null && (this._cubemapMaterial = fE()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = cE());
        const s = r ? this._cubemapMaterial : this._equirectMaterial
          , o = new Ln(this._lodPlanes[0],s)
          , a = s.uniforms;
        a.envMap.value = e;
        const l = this._cubeSize;
        im(t, 0, 0, 3 * l, 2 * l),
        i.setRenderTarget(t),
        i.render(o, tx)
    }
    _applyPMREM(e) {
        const t = this._renderer
          , i = t.autoClear;
        t.autoClear = !1;
        for (let r = 1; r < this._lodPlanes.length; r++) {
            const s = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1])
              , o = lE[(r - 1) % lE.length];
            this._blur(e, r - 1, r, s, o)
        }
        t.autoClear = i
    }
    _blur(e, t, i, r, s) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(e, o, t, i, r, "latitudinal", s),
        this._halfBlur(o, e, i, i, r, "longitudinal", s)
    }
    _halfBlur(e, t, i, r, s, o, a) {
        const l = this._renderer
          , c = this._blurMaterial;
        o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const d = 3
          , h = new Ln(this._lodPlanes[r],c)
          , p = c.uniforms
          , m = this._sizeLods[i] - 1
          , y = isFinite(s) ? Math.PI / (2 * m) : 2 * Math.PI / (2 * Ya - 1)
          , v = s / y
          , x = isFinite(s) ? 1 + Math.floor(d * v) : Ya;
        x > Ya && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${x} samples when the maximum is set to ${Ya}`);
        const _ = [];
        let A = 0;
        for (let R = 0; R < Ya; ++R) {
            const E = R / v
              , B = Math.exp(-E * E / 2);
            _.push(B),
            R === 0 ? A += B : R < x && (A += 2 * B)
        }
        for (let R = 0; R < _.length; R++)
            _[R] = _[R] / A;
        p.envMap.value = e.texture,
        p.samples.value = x,
        p.weights.value = _,
        p.latitudinal.value = o === "latitudinal",
        a && (p.poleAxis.value = a);
        const {_lodMax: w} = this;
        p.dTheta.value = y,
        p.mipInt.value = w - i;
        const M = this._sizeLods[r]
          , C = 3 * M * (r > w - Bu ? r - w + Bu : 0)
          , P = 4 * (this._cubeSize - M);
        im(t, C, P, 3 * M, 2 * M),
        l.setRenderTarget(t),
        l.render(h, tx)
    }
}
function sG(n) {
    const e = []
      , t = []
      , i = [];
    let r = n;
    const s = n - Bu + 1 + oE.length;
    for (let o = 0; o < s; o++) {
        const a = Math.pow(2, r);
        t.push(a);
        let l = 1 / a;
        o > n - Bu ? l = oE[o - n + Bu - 1] : o === 0 && (l = 0),
        i.push(l);
        const c = 1 / (a - 2)
          , d = -c
          , h = 1 + c
          , p = [d, d, h, d, h, h, d, d, h, h, d, h]
          , m = 6
          , y = 6
          , v = 3
          , x = 2
          , _ = 1
          , A = new Float32Array(v * y * m)
          , w = new Float32Array(x * y * m)
          , M = new Float32Array(_ * y * m);
        for (let P = 0; P < m; P++) {
            const R = P % 3 * 2 / 3 - 1
              , E = P > 2 ? 0 : -1
              , B = [R, E, 0, R + 2 / 3, E, 0, R + 2 / 3, E + 1, 0, R, E, 0, R + 2 / 3, E + 1, 0, R, E + 1, 0];
            A.set(B, v * y * P),
            w.set(p, x * y * P);
            const I = [P, P, P, P, P, P];
            M.set(I, _ * y * P)
        }
        const C = new ft;
        C.setAttribute("position", new Nt(A,v)),
        C.setAttribute("uv", new Nt(w,x)),
        C.setAttribute("faceIndex", new Nt(M,_)),
        e.push(C),
        r > Bu && r--
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: i
    }
}
function uE(n, e, t) {
    const i = new jr(n,e,t);
    return i.texture.mapping = _c,
    i.texture.name = "PMREM.cubeUv",
    i.scissorTest = !0,
    i
}
function im(n, e, t, i, r) {
    n.viewport.set(e, t, i, r),
    n.scissor.set(e, t, i, r)
}
function oG(n, e, t) {
    const i = new Float32Array(Ya)
      , r = new D(0,1,0);
    return new ms({
        name: "SphericalGaussianBlur",
        defines: {
            n: Ya,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${n}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: i
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: r
            }
        },
        vertexShader: Tw(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: js,
        depthTest: !1,
        depthWrite: !1
    })
}
function cE() {
    return new ms({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: Tw(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: js,
        depthTest: !1,
        depthWrite: !1
    })
}
function fE() {
    return new ms({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: Tw(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: js,
        depthTest: !1,
        depthWrite: !1
    })
}
function Tw() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function aG(n) {
    let e = new WeakMap
      , t = null;
    function i(a) {
        if (a && a.isTexture) {
            const l = a.mapping
              , c = l === Ad || l === wd
              , d = l === ea || l === ta;
            if (c || d)
                if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
                    a.needsPMREMUpdate = !1;
                    let h = e.get(a);
                    return t === null && (t = new v_(n)),
                    h = c ? t.fromEquirectangular(a, h) : t.fromCubemap(a, h),
                    e.set(a, h),
                    h.texture
                } else {
                    if (e.has(a))
                        return e.get(a).texture;
                    {
                        const h = a.image;
                        if (c && h && h.height > 0 || d && h && r(h)) {
                            t === null && (t = new v_(n));
                            const p = c ? t.fromEquirectangular(a) : t.fromCubemap(a);
                            return e.set(a, p),
                            a.addEventListener("dispose", s),
                            p.texture
                        } else
                            return null
                    }
                }
        }
        return a
    }
    function r(a) {
        let l = 0;
        const c = 6;
        for (let d = 0; d < c; d++)
            a[d] !== void 0 && l++;
        return l === c
    }
    function s(a) {
        const l = a.target;
        l.removeEventListener("dispose", s);
        const c = e.get(l);
        c !== void 0 && (e.delete(l),
        c.dispose())
    }
    function o() {
        e = new WeakMap,
        t !== null && (t.dispose(),
        t = null)
    }
    return {
        get: i,
        dispose: o
    }
}
function lG(n) {
    const e = {};
    function t(i) {
        if (e[i] !== void 0)
            return e[i];
        let r;
        switch (i) {
        case "WEBGL_depth_texture":
            r = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            r = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            r = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            r = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            r = n.getExtension(i)
        }
        return e[i] = r,
        r
    }
    return {
        has: function(i) {
            return t(i) !== null
        },
        init: function(i) {
            i.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"),
            t("OES_texture_float"),
            t("OES_texture_half_float"),
            t("OES_texture_half_float_linear"),
            t("OES_standard_derivatives"),
            t("OES_element_index_uint"),
            t("OES_vertex_array_object"),
            t("ANGLE_instanced_arrays")),
            t("OES_texture_float_linear"),
            t("EXT_color_buffer_half_float"),
            t("WEBGL_multisampled_render_to_texture")
        },
        get: function(i) {
            const r = t(i);
            return r === null && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."),
            r
        }
    }
}
function uG(n, e, t, i) {
    const r = {}
      , s = new WeakMap;
    function o(h) {
        const p = h.target;
        p.index !== null && e.remove(p.index);
        for (const y in p.attributes)
            e.remove(p.attributes[y]);
        p.removeEventListener("dispose", o),
        delete r[p.id];
        const m = s.get(p);
        m && (e.remove(m),
        s.delete(p)),
        i.releaseStatesOfGeometry(p),
        p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount,
        t.memory.geometries--
    }
    function a(h, p) {
        return r[p.id] === !0 || (p.addEventListener("dispose", o),
        r[p.id] = !0,
        t.memory.geometries++),
        p
    }
    function l(h) {
        const p = h.attributes;
        for (const y in p)
            e.update(p[y], 34962);
        const m = h.morphAttributes;
        for (const y in m) {
            const v = m[y];
            for (let x = 0, _ = v.length; x < _; x++)
                e.update(v[x], 34962)
        }
    }
    function c(h) {
        const p = []
          , m = h.index
          , y = h.attributes.position;
        let v = 0;
        if (m !== null) {
            const A = m.array;
            v = m.version;
            for (let w = 0, M = A.length; w < M; w += 3) {
                const C = A[w + 0]
                  , P = A[w + 1]
                  , R = A[w + 2];
                p.push(C, P, P, R, R, C)
            }
        } else {
            const A = y.array;
            v = y.version;
            for (let w = 0, M = A.length / 3 - 1; w < M; w += 3) {
                const C = w + 0
                  , P = w + 1
                  , R = w + 2;
                p.push(C, P, P, R, R, C)
            }
        }
        const x = new (OR(p) ? bw : Mw)(p,1);
        x.version = v;
        const _ = s.get(h);
        _ && e.remove(_),
        s.set(h, x)
    }
    function d(h) {
        const p = s.get(h);
        if (p) {
            const m = h.index;
            m !== null && p.version < m.version && c(h)
        } else
            c(h);
        return s.get(h)
    }
    return {
        get: a,
        update: l,
        getWireframeAttribute: d
    }
}
function cG(n, e, t, i) {
    const r = i.isWebGL2;
    let s;
    function o(p) {
        s = p
    }
    let a, l;
    function c(p) {
        a = p.type,
        l = p.bytesPerElement
    }
    function d(p, m) {
        n.drawElements(s, m, a, p * l),
        t.update(m, s, 1)
    }
    function h(p, m, y) {
        if (y === 0)
            return;
        let v, x;
        if (r)
            v = n,
            x = "drawElementsInstanced";
        else if (v = e.get("ANGLE_instanced_arrays"),
        x = "drawElementsInstancedANGLE",
        v === null) {
            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        v[x](s, m, a, p * l, y),
        t.update(m, s, y)
    }
    this.setMode = o,
    this.setIndex = c,
    this.render = d,
    this.renderInstances = h
}
function fG(n) {
    const e = {
        geometries: 0,
        textures: 0
    }
      , t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function i(s, o, a) {
        switch (t.calls++,
        o) {
        case 4:
            t.triangles += a * (s / 3);
            break;
        case 1:
            t.lines += a * (s / 2);
            break;
        case 3:
            t.lines += a * (s - 1);
            break;
        case 2:
            t.lines += a * s;
            break;
        case 0:
            t.points += a * s;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", o);
            break
        }
    }
    function r() {
        t.frame++,
        t.calls = 0,
        t.triangles = 0,
        t.points = 0,
        t.lines = 0
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: r,
        update: i
    }
}
function dG(n, e) {
    return n[0] - e[0]
}
function hG(n, e) {
    return Math.abs(e[1]) - Math.abs(n[1])
}
function pG(n, e, t) {
    const i = {}
      , r = new Float32Array(8)
      , s = new WeakMap
      , o = new Ut
      , a = [];
    for (let c = 0; c < 8; c++)
        a[c] = [c, 0];
    function l(c, d, h, p) {
        const m = c.morphTargetInfluences;
        if (e.isWebGL2 === !0) {
            const v = d.morphAttributes.position || d.morphAttributes.normal || d.morphAttributes.color
              , x = v !== void 0 ? v.length : 0;
            let _ = s.get(d);
            if (_ === void 0 || _.count !== x) {
                let ne = function() {
                    G.dispose(),
                    s.delete(d),
                    d.removeEventListener("dispose", ne)
                };
                var y = ne;
                _ !== void 0 && _.texture.dispose();
                const M = d.morphAttributes.position !== void 0
                  , C = d.morphAttributes.normal !== void 0
                  , P = d.morphAttributes.color !== void 0
                  , R = d.morphAttributes.position || []
                  , E = d.morphAttributes.normal || []
                  , B = d.morphAttributes.color || [];
                let I = 0;
                M === !0 && (I = 1),
                C === !0 && (I = 2),
                P === !0 && (I = 3);
                let z = d.attributes.position.count * I
                  , q = 1;
                z > e.maxTextureSize && (q = Math.ceil(z / e.maxTextureSize),
                z = e.maxTextureSize);
                const W = new Float32Array(z * q * 4 * x)
                  , G = new E0(W,z,q,x);
                G.type = zs,
                G.needsUpdate = !0;
                const K = I * 4;
                for (let oe = 0; oe < x; oe++) {
                    const F = R[oe]
                      , V = E[oe]
                      , Y = B[oe]
                      , re = z * q * 4 * oe;
                    for (let j = 0; j < F.count; j++) {
                        const ie = j * K;
                        M === !0 && (o.fromBufferAttribute(F, j),
                        W[re + ie + 0] = o.x,
                        W[re + ie + 1] = o.y,
                        W[re + ie + 2] = o.z,
                        W[re + ie + 3] = 0),
                        C === !0 && (o.fromBufferAttribute(V, j),
                        W[re + ie + 4] = o.x,
                        W[re + ie + 5] = o.y,
                        W[re + ie + 6] = o.z,
                        W[re + ie + 7] = 0),
                        P === !0 && (o.fromBufferAttribute(Y, j),
                        W[re + ie + 8] = o.x,
                        W[re + ie + 9] = o.y,
                        W[re + ie + 10] = o.z,
                        W[re + ie + 11] = Y.itemSize === 4 ? o.w : 1)
                    }
                }
                _ = {
                    count: x,
                    texture: G,
                    size: new me(z,q)
                },
                s.set(d, _),
                d.addEventListener("dispose", ne)
            }
            let A = 0;
            for (let M = 0; M < m.length; M++)
                A += m[M];
            const w = d.morphTargetsRelative ? 1 : 1 - A;
            p.getUniforms().setValue(n, "morphTargetBaseInfluence", w),
            p.getUniforms().setValue(n, "morphTargetInfluences", m),
            p.getUniforms().setValue(n, "morphTargetsTexture", _.texture, t),
            p.getUniforms().setValue(n, "morphTargetsTextureSize", _.size)
        } else {
            const v = m === void 0 ? 0 : m.length;
            let x = i[d.id];
            if (x === void 0 || x.length !== v) {
                x = [];
                for (let C = 0; C < v; C++)
                    x[C] = [C, 0];
                i[d.id] = x
            }
            for (let C = 0; C < v; C++) {
                const P = x[C];
                P[0] = C,
                P[1] = m[C]
            }
            x.sort(hG);
            for (let C = 0; C < 8; C++)
                C < v && x[C][1] ? (a[C][0] = x[C][0],
                a[C][1] = x[C][1]) : (a[C][0] = Number.MAX_SAFE_INTEGER,
                a[C][1] = 0);
            a.sort(dG);
            const _ = d.morphAttributes.position
              , A = d.morphAttributes.normal;
            let w = 0;
            for (let C = 0; C < 8; C++) {
                const P = a[C]
                  , R = P[0]
                  , E = P[1];
                R !== Number.MAX_SAFE_INTEGER && E ? (_ && d.getAttribute("morphTarget" + C) !== _[R] && d.setAttribute("morphTarget" + C, _[R]),
                A && d.getAttribute("morphNormal" + C) !== A[R] && d.setAttribute("morphNormal" + C, A[R]),
                r[C] = E,
                w += E) : (_ && d.hasAttribute("morphTarget" + C) === !0 && d.deleteAttribute("morphTarget" + C),
                A && d.hasAttribute("morphNormal" + C) === !0 && d.deleteAttribute("morphNormal" + C),
                r[C] = 0)
            }
            const M = d.morphTargetsRelative ? 1 : 1 - w;
            p.getUniforms().setValue(n, "morphTargetBaseInfluence", M),
            p.getUniforms().setValue(n, "morphTargetInfluences", r)
        }
    }
    return {
        update: l
    }
}
function mG(n, e, t, i) {
    let r = new WeakMap;
    function s(l) {
        const c = i.render.frame
          , d = l.geometry
          , h = e.get(l, d);
        return r.get(h) !== c && (e.update(h),
        r.set(h, c)),
        l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a),
        t.update(l.instanceMatrix, 34962),
        l.instanceColor !== null && t.update(l.instanceColor, 34962)),
        h
    }
    function o() {
        r = new WeakMap
    }
    function a(l) {
        const c = l.target;
        c.removeEventListener("dispose", a),
        t.remove(c.instanceMatrix),
        c.instanceColor !== null && t.remove(c.instanceColor)
    }
    return {
        update: s,
        dispose: o
    }
}
const VR = new tn
  , WR = new E0
  , jR = new Sw
  , JR = new th
  , dE = []
  , hE = []
  , pE = new Float32Array(16)
  , mE = new Float32Array(9)
  , gE = new Float32Array(4);
function wc(n, e, t) {
    const i = n[0];
    if (i <= 0 || i > 0)
        return n;
    const r = e * t;
    let s = dE[r];
    if (s === void 0 && (s = new Float32Array(r),
    dE[r] = s),
    e !== 0) {
        i.toArray(s, 0);
        for (let o = 1, a = 0; o !== e; ++o)
            a += t,
            n[o].toArray(s, a)
    }
    return s
}
function Dn(n, e) {
    if (n.length !== e.length)
        return !1;
    for (let t = 0, i = n.length; t < i; t++)
        if (n[t] !== e[t])
            return !1;
    return !0
}
function kn(n, e) {
    for (let t = 0, i = e.length; t < i; t++)
        n[t] = e[t]
}
function P0(n, e) {
    let t = hE[e];
    t === void 0 && (t = new Int32Array(e),
    hE[e] = t);
    for (let i = 0; i !== e; ++i)
        t[i] = n.allocateTextureUnit();
    return t
}
function gG(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1f(this.addr, e),
    t[0] = e)
}
function vG(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Dn(t, e))
            return;
        n.uniform2fv(this.addr, e),
        kn(t, e)
    }
}
function yG(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else if (e.r !== void 0)
        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b),
        t[0] = e.r,
        t[1] = e.g,
        t[2] = e.b);
    else {
        if (Dn(t, e))
            return;
        n.uniform3fv(this.addr, e),
        kn(t, e)
    }
}
function xG(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Dn(t, e))
            return;
        n.uniform4fv(this.addr, e),
        kn(t, e)
    }
}
function _G(n, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (Dn(t, e))
            return;
        n.uniformMatrix2fv(this.addr, !1, e),
        kn(t, e)
    } else {
        if (Dn(t, i))
            return;
        gE.set(i),
        n.uniformMatrix2fv(this.addr, !1, gE),
        kn(t, i)
    }
}
function AG(n, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (Dn(t, e))
            return;
        n.uniformMatrix3fv(this.addr, !1, e),
        kn(t, e)
    } else {
        if (Dn(t, i))
            return;
        mE.set(i),
        n.uniformMatrix3fv(this.addr, !1, mE),
        kn(t, i)
    }
}
function wG(n, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (Dn(t, e))
            return;
        n.uniformMatrix4fv(this.addr, !1, e),
        kn(t, e)
    } else {
        if (Dn(t, i))
            return;
        pE.set(i),
        n.uniformMatrix4fv(this.addr, !1, pE),
        kn(t, i)
    }
}
function SG(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1i(this.addr, e),
    t[0] = e)
}
function MG(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Dn(t, e))
            return;
        n.uniform2iv(this.addr, e),
        kn(t, e)
    }
}
function bG(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (Dn(t, e))
            return;
        n.uniform3iv(this.addr, e),
        kn(t, e)
    }
}
function CG(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Dn(t, e))
            return;
        n.uniform4iv(this.addr, e),
        kn(t, e)
    }
}
function EG(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1ui(this.addr, e),
    t[0] = e)
}
function TG(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Dn(t, e))
            return;
        n.uniform2uiv(this.addr, e),
        kn(t, e)
    }
}
function PG(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (Dn(t, e))
            return;
        n.uniform3uiv(this.addr, e),
        kn(t, e)
    }
}
function BG(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Dn(t, e))
            return;
        n.uniform4uiv(this.addr, e),
        kn(t, e)
    }
}
function RG(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTexture2D(e || VR, r)
}
function IG(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTexture3D(e || jR, r)
}
function LG(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTextureCube(e || JR, r)
}
function DG(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTexture2DArray(e || WR, r)
}
function kG(n) {
    switch (n) {
    case 5126:
        return gG;
    case 35664:
        return vG;
    case 35665:
        return yG;
    case 35666:
        return xG;
    case 35674:
        return _G;
    case 35675:
        return AG;
    case 35676:
        return wG;
    case 5124:
    case 35670:
        return SG;
    case 35667:
    case 35671:
        return MG;
    case 35668:
    case 35672:
        return bG;
    case 35669:
    case 35673:
        return CG;
    case 5125:
        return EG;
    case 36294:
        return TG;
    case 36295:
        return PG;
    case 36296:
        return BG;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return RG;
    case 35679:
    case 36299:
    case 36307:
        return IG;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return LG;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return DG
    }
}
function FG(n, e) {
    n.uniform1fv(this.addr, e)
}
function NG(n, e) {
    const t = wc(e, this.size, 2);
    n.uniform2fv(this.addr, t)
}
function OG(n, e) {
    const t = wc(e, this.size, 3);
    n.uniform3fv(this.addr, t)
}
function UG(n, e) {
    const t = wc(e, this.size, 4);
    n.uniform4fv(this.addr, t)
}
function zG(n, e) {
    const t = wc(e, this.size, 4);
    n.uniformMatrix2fv(this.addr, !1, t)
}
function GG(n, e) {
    const t = wc(e, this.size, 9);
    n.uniformMatrix3fv(this.addr, !1, t)
}
function HG(n, e) {
    const t = wc(e, this.size, 16);
    n.uniformMatrix4fv(this.addr, !1, t)
}
function VG(n, e) {
    n.uniform1iv(this.addr, e)
}
function WG(n, e) {
    n.uniform2iv(this.addr, e)
}
function jG(n, e) {
    n.uniform3iv(this.addr, e)
}
function JG(n, e) {
    n.uniform4iv(this.addr, e)
}
function XG(n, e) {
    n.uniform1uiv(this.addr, e)
}
function YG(n, e) {
    n.uniform2uiv(this.addr, e)
}
function KG(n, e) {
    n.uniform3uiv(this.addr, e)
}
function QG(n, e) {
    n.uniform4uiv(this.addr, e)
}
function ZG(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = P0(t, r);
    Dn(i, s) || (n.uniform1iv(this.addr, s),
    kn(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture2D(e[o] || VR, s[o])
}
function qG(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = P0(t, r);
    Dn(i, s) || (n.uniform1iv(this.addr, s),
    kn(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture3D(e[o] || jR, s[o])
}
function $G(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = P0(t, r);
    Dn(i, s) || (n.uniform1iv(this.addr, s),
    kn(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTextureCube(e[o] || JR, s[o])
}
function e9(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = P0(t, r);
    Dn(i, s) || (n.uniform1iv(this.addr, s),
    kn(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture2DArray(e[o] || WR, s[o])
}
function t9(n) {
    switch (n) {
    case 5126:
        return FG;
    case 35664:
        return NG;
    case 35665:
        return OG;
    case 35666:
        return UG;
    case 35674:
        return zG;
    case 35675:
        return GG;
    case 35676:
        return HG;
    case 5124:
    case 35670:
        return VG;
    case 35667:
    case 35671:
        return WG;
    case 35668:
    case 35672:
        return jG;
    case 35669:
    case 35673:
        return JG;
    case 5125:
        return XG;
    case 36294:
        return YG;
    case 36295:
        return KG;
    case 36296:
        return QG;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return ZG;
    case 35679:
    case 36299:
    case 36307:
        return qG;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return $G;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return e9
    }
}
class n9 {
    constructor(e, t, i) {
        this.id = e,
        this.addr = i,
        this.cache = [],
        this.setValue = kG(t.type)
    }
}
class i9 {
    constructor(e, t, i) {
        this.id = e,
        this.addr = i,
        this.cache = [],
        this.size = t.size,
        this.setValue = t9(t.type)
    }
}
class r9 {
    constructor(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    setValue(e, t, i) {
        const r = this.seq;
        for (let s = 0, o = r.length; s !== o; ++s) {
            const a = r[s];
            a.setValue(e, t[a.id], i)
        }
    }
}
const ix = /(\w+)(\])?(\[|\.)?/g;
function vE(n, e) {
    n.seq.push(e),
    n.map[e.id] = e
}
function s9(n, e, t) {
    const i = n.name
      , r = i.length;
    for (ix.lastIndex = 0; ; ) {
        const s = ix.exec(i)
          , o = ix.lastIndex;
        let a = s[1];
        const l = s[2] === "]"
          , c = s[3];
        if (l && (a = a | 0),
        c === void 0 || c === "[" && o + 2 === r) {
            vE(t, c === void 0 ? new n9(a,n,e) : new i9(a,n,e));
            break
        } else {
            let h = t.map[a];
            h === void 0 && (h = new r9(a),
            vE(t, h)),
            t = h
        }
    }
}
class ug {
    constructor(e, t) {
        this.seq = [],
        this.map = {};
        const i = e.getProgramParameter(t, 35718);
        for (let r = 0; r < i; ++r) {
            const s = e.getActiveUniform(t, r)
              , o = e.getUniformLocation(t, s.name);
            s9(s, o, this)
        }
    }
    setValue(e, t, i, r) {
        const s = this.map[t];
        s !== void 0 && s.setValue(e, i, r)
    }
    setOptional(e, t, i) {
        const r = t[i];
        r !== void 0 && this.setValue(e, i, r)
    }
    static upload(e, t, i, r) {
        for (let s = 0, o = t.length; s !== o; ++s) {
            const a = t[s]
              , l = i[a.id];
            l.needsUpdate !== !1 && a.setValue(e, l.value, r)
        }
    }
    static seqWithValue(e, t) {
        const i = [];
        for (let r = 0, s = e.length; r !== s; ++r) {
            const o = e[r];
            o.id in t && i.push(o)
        }
        return i
    }
}
function yE(n, e, t) {
    const i = n.createShader(e);
    return n.shaderSource(i, t),
    n.compileShader(i),
    i
}
let o9 = 0;
function a9(n, e) {
    const t = n.split(`
`)
      , i = []
      , r = Math.max(e - 6, 0)
      , s = Math.min(e + 6, t.length);
    for (let o = r; o < s; o++) {
        const a = o + 1;
        i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`)
    }
    return i.join(`
`)
}
function l9(n) {
    switch (n) {
    case $s:
        return ["Linear", "( value )"];
    case Tt:
        return ["sRGB", "( value )"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported encoding:", n),
        ["Linear", "( value )"]
    }
}
function xE(n, e, t) {
    const i = n.getShaderParameter(e, 35713)
      , r = n.getShaderInfoLog(e).trim();
    if (i && r === "")
        return "";
    const s = /ERROR: 0:(\d+)/.exec(r);
    if (s) {
        const o = parseInt(s[1]);
        return t.toUpperCase() + `

` + r + `

` + a9(n.getShaderSource(e), o)
    } else
        return r
}
function u9(n, e) {
    const t = l9(e);
    return "vec4 " + n + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }"
}
function c9(n, e) {
    let t;
    switch (e) {
    case cR:
        t = "Linear";
        break;
    case fR:
        t = "Reinhard";
        break;
    case dR:
        t = "OptimizedCineon";
        break;
    case gw:
        t = "ACESFilmic";
        break;
    case hR:
        t = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        t = "Linear"
    }
    return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}
function f9(n) {
    return [n.extensionDerivatives || n.envMapCubeUVHeight || n.bumpMap || n.tangentSpaceNormalMap || n.clearcoatNormalMap || n.flatShading || n.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (n.extensionFragDepth || n.logarithmicDepthBuffer) && n.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", n.extensionDrawBuffers && n.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (n.extensionShaderTextureLOD || n.envMap || n.transmission) && n.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(If).join(`
`)
}
function d9(n) {
    const e = [];
    for (const t in n) {
        const i = n[t];
        i !== !1 && e.push("#define " + t + " " + i)
    }
    return e.join(`
`)
}
function h9(n, e) {
    const t = {}
      , i = n.getProgramParameter(e, 35721);
    for (let r = 0; r < i; r++) {
        const s = n.getActiveAttrib(e, r)
          , o = s.name;
        let a = 1;
        s.type === 35674 && (a = 2),
        s.type === 35675 && (a = 3),
        s.type === 35676 && (a = 4),
        t[o] = {
            type: s.type,
            location: n.getAttribLocation(e, o),
            locationSize: a
        }
    }
    return t
}
function If(n) {
    return n !== ""
}
function _E(n, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function AE(n, e) {
    return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const p9 = /^[ \t]*#include +<([\w\d./]+)>/gm;
function y_(n) {
    return n.replace(p9, m9)
}
function m9(n, e) {
    const t = vt[e];
    if (t === void 0)
        throw new Error("Can not resolve #include <" + e + ">");
    return y_(t)
}
const g9 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function wE(n) {
    return n.replace(g9, v9)
}
function v9(n, e, t, i) {
    let r = "";
    for (let s = parseInt(e); s < parseInt(t); s++)
        r += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
    return r
}
function SE(n) {
    let e = "precision " + n.precision + ` float;
precision ` + n.precision + " int;";
    return n.precision === "highp" ? e += `
#define HIGH_PRECISION` : n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (e += `
#define LOW_PRECISION`),
    e
}
function y9(n) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return n.shadowMapType === S0 ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === Wf ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === $a && (e = "SHADOWMAP_TYPE_VSM"),
    e
}
function x9(n) {
    let e = "ENVMAP_TYPE_CUBE";
    if (n.envMap)
        switch (n.envMapMode) {
        case ea:
        case ta:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case _c:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return e
}
function _9(n) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (n.envMap)
        switch (n.envMapMode) {
        case ta:
            e = "ENVMAP_MODE_REFRACTION";
            break
        }
    return e
}
function A9(n) {
    let e = "ENVMAP_BLENDING_NONE";
    if (n.envMap)
        switch (n.combine) {
        case qd:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case lR:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case uR:
            e = "ENVMAP_BLENDING_ADD";
            break
        }
    return e
}
function w9(n) {
    const e = n.envMapCubeUVHeight;
    if (e === null)
        return null;
    const t = Math.log2(e) - 2
      , i = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: i,
        maxMip: t
    }
}
function S9(n, e, t, i) {
    const r = n.getContext()
      , s = t.defines;
    let o = t.vertexShader
      , a = t.fragmentShader;
    const l = y9(t)
      , c = x9(t)
      , d = _9(t)
      , h = A9(t)
      , p = w9(t)
      , m = t.isWebGL2 ? "" : f9(t)
      , y = d9(s)
      , v = r.createProgram();
    let x, _, A = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (x = [y].filter(If).join(`
`),
    x.length > 0 && (x += `
`),
    _ = [m, y].filter(If).join(`
`),
    _.length > 0 && (_ += `
`)) : (x = [SE(t), "#define SHADER_NAME " + t.shaderName, y, t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + d : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.displacementMap && t.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(If).join(`
`),
    _ = [m, SE(t), "#define SHADER_NAME " + t.shaderName, y, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + d : "", t.envMap ? "#define " + h : "", p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "", p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "", p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== Hr ? "#define TONE_MAPPING" : "", t.toneMapping !== Hr ? vt.tonemapping_pars_fragment : "", t.toneMapping !== Hr ? c9("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", vt.encodings_pars_fragment, u9("linearToOutputTexel", t.outputEncoding), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(If).join(`
`)),
    o = y_(o),
    o = _E(o, t),
    o = AE(o, t),
    a = y_(a),
    a = _E(a, t),
    a = AE(a, t),
    o = wE(o),
    a = wE(a),
    t.isWebGL2 && t.isRawShaderMaterial !== !0 && (A = `#version 300 es
`,
    x = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + x,
    _ = ["#define varying in", t.glslVersion === m_ ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === m_ ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + _);
    const w = A + x + o
      , M = A + _ + a
      , C = yE(r, 35633, w)
      , P = yE(r, 35632, M);
    if (r.attachShader(v, C),
    r.attachShader(v, P),
    t.index0AttributeName !== void 0 ? r.bindAttribLocation(v, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(v, 0, "position"),
    r.linkProgram(v),
    n.debug.checkShaderErrors) {
        const B = r.getProgramInfoLog(v).trim()
          , I = r.getShaderInfoLog(C).trim()
          , z = r.getShaderInfoLog(P).trim();
        let q = !0
          , W = !0;
        if (r.getProgramParameter(v, 35714) === !1) {
            q = !1;
            const G = xE(r, C, "vertex")
              , K = xE(r, P, "fragment");
            console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(v, 35715) + `

Program Info Log: ` + B + `
` + G + `
` + K)
        } else
            B !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", B) : (I === "" || z === "") && (W = !1);
        W && (this.diagnostics = {
            runnable: q,
            programLog: B,
            vertexShader: {
                log: I,
                prefix: x
            },
            fragmentShader: {
                log: z,
                prefix: _
            }
        })
    }
    r.deleteShader(C),
    r.deleteShader(P);
    let R;
    this.getUniforms = function() {
        return R === void 0 && (R = new ug(r,v)),
        R
    }
    ;
    let E;
    return this.getAttributes = function() {
        return E === void 0 && (E = h9(r, v)),
        E
    }
    ,
    this.destroy = function() {
        i.releaseStatesOfProgram(this),
        r.deleteProgram(v),
        this.program = void 0
    }
    ,
    this.name = t.shaderName,
    this.id = o9++,
    this.cacheKey = e,
    this.usedTimes = 1,
    this.program = v,
    this.vertexShader = C,
    this.fragmentShader = P,
    this
}
let M9 = 0;
class b9 {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e) {
        const t = e.vertexShader
          , i = e.fragmentShader
          , r = this._getShaderStage(t)
          , s = this._getShaderStage(i)
          , o = this._getShaderCacheForMaterial(e);
        return o.has(r) === !1 && (o.add(r),
        r.usedTimes++),
        o.has(s) === !1 && (o.add(s),
        s.usedTimes++),
        this
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const i of t)
            i.usedTimes--,
            i.usedTimes === 0 && this.shaderCache.delete(i.code);
        return this.materialCache.delete(e),
        this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let i = t.get(e);
        return i === void 0 && (i = new Set,
        t.set(e, i)),
        i
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let i = t.get(e);
        return i === void 0 && (i = new C9(e),
        t.set(e, i)),
        i
    }
}
class C9 {
    constructor(e) {
        this.id = M9++,
        this.code = e,
        this.usedTimes = 0
    }
}
function E9(n, e, t, i, r, s, o) {
    const a = new pl
      , l = new b9
      , c = []
      , d = r.isWebGL2
      , h = r.logarithmicDepthBuffer
      , p = r.vertexTextures;
    let m = r.precision;
    const y = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function v(E, B, I, z, q) {
        const W = z.fog
          , G = q.geometry
          , K = E.isMeshStandardMaterial ? z.environment : null
          , ne = (E.isMeshStandardMaterial ? t : e).get(E.envMap || K)
          , oe = ne && ne.mapping === _c ? ne.image.height : null
          , F = y[E.type];
        E.precision !== null && (m = r.getMaxPrecision(E.precision),
        m !== E.precision && console.warn("THREE.WebGLProgram.getParameters:", E.precision, "not supported, using", m, "instead."));
        const V = G.morphAttributes.position || G.morphAttributes.normal || G.morphAttributes.color
          , Y = V !== void 0 ? V.length : 0;
        let re = 0;
        G.morphAttributes.position !== void 0 && (re = 1),
        G.morphAttributes.normal !== void 0 && (re = 2),
        G.morphAttributes.color !== void 0 && (re = 3);
        let j, ie, ye, _e;
        if (F) {
            const Le = Nr[F];
            j = Le.vertexShader,
            ie = Le.fragmentShader
        } else
            j = E.vertexShader,
            ie = E.fragmentShader,
            l.update(E),
            ye = l.getVertexShaderID(E),
            _e = l.getFragmentShaderID(E);
        const $ = n.getRenderTarget()
          , Ne = E.alphaTest > 0
          , Oe = E.clearcoat > 0
          , Ve = E.iridescence > 0;
        return {
            isWebGL2: d,
            shaderID: F,
            shaderName: E.type,
            vertexShader: j,
            fragmentShader: ie,
            defines: E.defines,
            customVertexShaderID: ye,
            customFragmentShaderID: _e,
            isRawShaderMaterial: E.isRawShaderMaterial === !0,
            glslVersion: E.glslVersion,
            precision: m,
            instancing: q.isInstancedMesh === !0,
            instancingColor: q.isInstancedMesh === !0 && q.instanceColor !== null,
            supportsVertexTextures: p,
            outputEncoding: $ === null ? n.outputEncoding : $.isXRRenderTarget === !0 ? $.texture.encoding : $s,
            map: !!E.map,
            matcap: !!E.matcap,
            envMap: !!ne,
            envMapMode: ne && ne.mapping,
            envMapCubeUVHeight: oe,
            lightMap: !!E.lightMap,
            aoMap: !!E.aoMap,
            emissiveMap: !!E.emissiveMap,
            bumpMap: !!E.bumpMap,
            normalMap: !!E.normalMap,
            objectSpaceNormalMap: E.normalMapType === kR,
            tangentSpaceNormalMap: E.normalMapType === so,
            decodeVideoTexture: !!E.map && E.map.isVideoTexture === !0 && E.map.encoding === Tt,
            clearcoat: Oe,
            clearcoatMap: Oe && !!E.clearcoatMap,
            clearcoatRoughnessMap: Oe && !!E.clearcoatRoughnessMap,
            clearcoatNormalMap: Oe && !!E.clearcoatNormalMap,
            iridescence: Ve,
            iridescenceMap: Ve && !!E.iridescenceMap,
            iridescenceThicknessMap: Ve && !!E.iridescenceThicknessMap,
            displacementMap: !!E.displacementMap,
            roughnessMap: !!E.roughnessMap,
            metalnessMap: !!E.metalnessMap,
            specularMap: !!E.specularMap,
            specularIntensityMap: !!E.specularIntensityMap,
            specularColorMap: !!E.specularColorMap,
            opaque: E.transparent === !1 && E.blending === ul,
            alphaMap: !!E.alphaMap,
            alphaTest: Ne,
            gradientMap: !!E.gradientMap,
            sheen: E.sheen > 0,
            sheenColorMap: !!E.sheenColorMap,
            sheenRoughnessMap: !!E.sheenRoughnessMap,
            transmission: E.transmission > 0,
            transmissionMap: !!E.transmissionMap,
            thicknessMap: !!E.thicknessMap,
            combine: E.combine,
            vertexTangents: !!E.normalMap && !!G.attributes.tangent,
            vertexColors: E.vertexColors,
            vertexAlphas: E.vertexColors === !0 && !!G.attributes.color && G.attributes.color.itemSize === 4,
            vertexUvs: !!E.map || !!E.bumpMap || !!E.normalMap || !!E.specularMap || !!E.alphaMap || !!E.emissiveMap || !!E.roughnessMap || !!E.metalnessMap || !!E.clearcoatMap || !!E.clearcoatRoughnessMap || !!E.clearcoatNormalMap || !!E.iridescenceMap || !!E.iridescenceThicknessMap || !!E.displacementMap || !!E.transmissionMap || !!E.thicknessMap || !!E.specularIntensityMap || !!E.specularColorMap || !!E.sheenColorMap || !!E.sheenRoughnessMap,
            uvsVertexOnly: !(E.map || E.bumpMap || E.normalMap || E.specularMap || E.alphaMap || E.emissiveMap || E.roughnessMap || E.metalnessMap || E.clearcoatNormalMap || E.iridescenceMap || E.iridescenceThicknessMap || E.transmission > 0 || E.transmissionMap || E.thicknessMap || E.specularIntensityMap || E.specularColorMap || E.sheen > 0 || E.sheenColorMap || E.sheenRoughnessMap) && !!E.displacementMap,
            fog: !!W,
            useFog: E.fog === !0,
            fogExp2: W && W.isFogExp2,
            flatShading: !!E.flatShading,
            sizeAttenuation: E.sizeAttenuation,
            logarithmicDepthBuffer: h,
            skinning: q.isSkinnedMesh === !0,
            morphTargets: G.morphAttributes.position !== void 0,
            morphNormals: G.morphAttributes.normal !== void 0,
            morphColors: G.morphAttributes.color !== void 0,
            morphTargetsCount: Y,
            morphTextureStride: re,
            numDirLights: B.directional.length,
            numPointLights: B.point.length,
            numSpotLights: B.spot.length,
            numSpotLightMaps: B.spotLightMap.length,
            numRectAreaLights: B.rectArea.length,
            numHemiLights: B.hemi.length,
            numDirLightShadows: B.directionalShadowMap.length,
            numPointLightShadows: B.pointShadowMap.length,
            numSpotLightShadows: B.spotShadowMap.length,
            numSpotLightShadowsWithMaps: B.numSpotLightShadowsWithMaps,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: E.dithering,
            shadowMapEnabled: n.shadowMap.enabled && I.length > 0,
            shadowMapType: n.shadowMap.type,
            toneMapping: E.toneMapped ? n.toneMapping : Hr,
            physicallyCorrectLights: n.physicallyCorrectLights,
            premultipliedAlpha: E.premultipliedAlpha,
            doubleSided: E.side === Or,
            flipSided: E.side === Li,
            useDepthPacking: !!E.depthPacking,
            depthPacking: E.depthPacking || 0,
            index0AttributeName: E.index0AttributeName,
            extensionDerivatives: E.extensions && E.extensions.derivatives,
            extensionFragDepth: E.extensions && E.extensions.fragDepth,
            extensionDrawBuffers: E.extensions && E.extensions.drawBuffers,
            extensionShaderTextureLOD: E.extensions && E.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: d || i.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: d || i.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: d || i.has("EXT_shader_texture_lod"),
            customProgramCacheKey: E.customProgramCacheKey()
        }
    }
    function x(E) {
        const B = [];
        if (E.shaderID ? B.push(E.shaderID) : (B.push(E.customVertexShaderID),
        B.push(E.customFragmentShaderID)),
        E.defines !== void 0)
            for (const I in E.defines)
                B.push(I),
                B.push(E.defines[I]);
        return E.isRawShaderMaterial === !1 && (_(B, E),
        A(B, E),
        B.push(n.outputEncoding)),
        B.push(E.customProgramCacheKey),
        B.join()
    }
    function _(E, B) {
        E.push(B.precision),
        E.push(B.outputEncoding),
        E.push(B.envMapMode),
        E.push(B.envMapCubeUVHeight),
        E.push(B.combine),
        E.push(B.vertexUvs),
        E.push(B.fogExp2),
        E.push(B.sizeAttenuation),
        E.push(B.morphTargetsCount),
        E.push(B.morphAttributeCount),
        E.push(B.numDirLights),
        E.push(B.numPointLights),
        E.push(B.numSpotLights),
        E.push(B.numSpotLightMaps),
        E.push(B.numHemiLights),
        E.push(B.numRectAreaLights),
        E.push(B.numDirLightShadows),
        E.push(B.numPointLightShadows),
        E.push(B.numSpotLightShadows),
        E.push(B.numSpotLightShadowsWithMaps),
        E.push(B.shadowMapType),
        E.push(B.toneMapping),
        E.push(B.numClippingPlanes),
        E.push(B.numClipIntersection),
        E.push(B.depthPacking)
    }
    function A(E, B) {
        a.disableAll(),
        B.isWebGL2 && a.enable(0),
        B.supportsVertexTextures && a.enable(1),
        B.instancing && a.enable(2),
        B.instancingColor && a.enable(3),
        B.map && a.enable(4),
        B.matcap && a.enable(5),
        B.envMap && a.enable(6),
        B.lightMap && a.enable(7),
        B.aoMap && a.enable(8),
        B.emissiveMap && a.enable(9),
        B.bumpMap && a.enable(10),
        B.normalMap && a.enable(11),
        B.objectSpaceNormalMap && a.enable(12),
        B.tangentSpaceNormalMap && a.enable(13),
        B.clearcoat && a.enable(14),
        B.clearcoatMap && a.enable(15),
        B.clearcoatRoughnessMap && a.enable(16),
        B.clearcoatNormalMap && a.enable(17),
        B.iridescence && a.enable(18),
        B.iridescenceMap && a.enable(19),
        B.iridescenceThicknessMap && a.enable(20),
        B.displacementMap && a.enable(21),
        B.specularMap && a.enable(22),
        B.roughnessMap && a.enable(23),
        B.metalnessMap && a.enable(24),
        B.gradientMap && a.enable(25),
        B.alphaMap && a.enable(26),
        B.alphaTest && a.enable(27),
        B.vertexColors && a.enable(28),
        B.vertexAlphas && a.enable(29),
        B.vertexUvs && a.enable(30),
        B.vertexTangents && a.enable(31),
        B.uvsVertexOnly && a.enable(32),
        E.push(a.mask),
        a.disableAll(),
        B.fog && a.enable(0),
        B.useFog && a.enable(1),
        B.flatShading && a.enable(2),
        B.logarithmicDepthBuffer && a.enable(3),
        B.skinning && a.enable(4),
        B.morphTargets && a.enable(5),
        B.morphNormals && a.enable(6),
        B.morphColors && a.enable(7),
        B.premultipliedAlpha && a.enable(8),
        B.shadowMapEnabled && a.enable(9),
        B.physicallyCorrectLights && a.enable(10),
        B.doubleSided && a.enable(11),
        B.flipSided && a.enable(12),
        B.useDepthPacking && a.enable(13),
        B.dithering && a.enable(14),
        B.specularIntensityMap && a.enable(15),
        B.specularColorMap && a.enable(16),
        B.transmission && a.enable(17),
        B.transmissionMap && a.enable(18),
        B.thicknessMap && a.enable(19),
        B.sheen && a.enable(20),
        B.sheenColorMap && a.enable(21),
        B.sheenRoughnessMap && a.enable(22),
        B.decodeVideoTexture && a.enable(23),
        B.opaque && a.enable(24),
        E.push(a.mask)
    }
    function w(E) {
        const B = y[E.type];
        let I;
        if (B) {
            const z = Nr[B];
            I = GR.clone(z.uniforms)
        } else
            I = E.uniforms;
        return I
    }
    function M(E, B) {
        let I;
        for (let z = 0, q = c.length; z < q; z++) {
            const W = c[z];
            if (W.cacheKey === B) {
                I = W,
                ++I.usedTimes;
                break
            }
        }
        return I === void 0 && (I = new S9(n,B,E,s),
        c.push(I)),
        I
    }
    function C(E) {
        if (--E.usedTimes === 0) {
            const B = c.indexOf(E);
            c[B] = c[c.length - 1],
            c.pop(),
            E.destroy()
        }
    }
    function P(E) {
        l.remove(E)
    }
    function R() {
        l.dispose()
    }
    return {
        getParameters: v,
        getProgramCacheKey: x,
        getUniforms: w,
        acquireProgram: M,
        releaseProgram: C,
        releaseShaderCache: P,
        programs: c,
        dispose: R
    }
}
function T9() {
    let n = new WeakMap;
    function e(s) {
        let o = n.get(s);
        return o === void 0 && (o = {},
        n.set(s, o)),
        o
    }
    function t(s) {
        n.delete(s)
    }
    function i(s, o, a) {
        n.get(s)[o] = a
    }
    function r() {
        n = new WeakMap
    }
    return {
        get: e,
        remove: t,
        update: i,
        dispose: r
    }
}
function P9(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id
}
function ME(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id
}
function bE() {
    const n = [];
    let e = 0;
    const t = []
      , i = []
      , r = [];
    function s() {
        e = 0,
        t.length = 0,
        i.length = 0,
        r.length = 0
    }
    function o(h, p, m, y, v, x) {
        let _ = n[e];
        return _ === void 0 ? (_ = {
            id: h.id,
            object: h,
            geometry: p,
            material: m,
            groupOrder: y,
            renderOrder: h.renderOrder,
            z: v,
            group: x
        },
        n[e] = _) : (_.id = h.id,
        _.object = h,
        _.geometry = p,
        _.material = m,
        _.groupOrder = y,
        _.renderOrder = h.renderOrder,
        _.z = v,
        _.group = x),
        e++,
        _
    }
    function a(h, p, m, y, v, x) {
        const _ = o(h, p, m, y, v, x);
        m.transmission > 0 ? i.push(_) : m.transparent === !0 ? r.push(_) : t.push(_)
    }
    function l(h, p, m, y, v, x) {
        const _ = o(h, p, m, y, v, x);
        m.transmission > 0 ? i.unshift(_) : m.transparent === !0 ? r.unshift(_) : t.unshift(_)
    }
    function c(h, p) {
        t.length > 1 && t.sort(h || P9),
        i.length > 1 && i.sort(p || ME),
        r.length > 1 && r.sort(p || ME)
    }
    function d() {
        for (let h = e, p = n.length; h < p; h++) {
            const m = n[h];
            if (m.id === null)
                break;
            m.id = null,
            m.object = null,
            m.geometry = null,
            m.material = null,
            m.group = null
        }
    }
    return {
        opaque: t,
        transmissive: i,
        transparent: r,
        init: s,
        push: a,
        unshift: l,
        finish: d,
        sort: c
    }
}
function B9() {
    let n = new WeakMap;
    function e(i, r) {
        const s = n.get(i);
        let o;
        return s === void 0 ? (o = new bE,
        n.set(i, [o])) : r >= s.length ? (o = new bE,
        s.push(o)) : o = s[r],
        o
    }
    function t() {
        n = new WeakMap
    }
    return {
        get: e,
        dispose: t
    }
}
function R9() {
    const n = {};
    return {
        get: function(e) {
            if (n[e.id] !== void 0)
                return n[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    direction: new D,
                    color: new Ie
                };
                break;
            case "SpotLight":
                t = {
                    position: new D,
                    direction: new D,
                    color: new Ie,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                t = {
                    position: new D,
                    color: new Ie,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                t = {
                    direction: new D,
                    skyColor: new Ie,
                    groundColor: new Ie
                };
                break;
            case "RectAreaLight":
                t = {
                    color: new Ie,
                    position: new D,
                    halfWidth: new D,
                    halfHeight: new D
                };
                break
            }
            return n[e.id] = t,
            t
        }
    }
}
function I9() {
    const n = {};
    return {
        get: function(e) {
            if (n[e.id] !== void 0)
                return n[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new me
                };
                break;
            case "SpotLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new me
                };
                break;
            case "PointLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new me,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return n[e.id] = t,
            t
        }
    }
}
let L9 = 0;
function D9(n, e) {
    return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0)
}
function k9(n, e) {
    const t = new R9
      , i = I9()
      , r = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0
    };
    for (let d = 0; d < 9; d++)
        r.probe.push(new D);
    const s = new D
      , o = new ot
      , a = new ot;
    function l(d, h) {
        let p = 0
          , m = 0
          , y = 0;
        for (let z = 0; z < 9; z++)
            r.probe[z].set(0, 0, 0);
        let v = 0
          , x = 0
          , _ = 0
          , A = 0
          , w = 0
          , M = 0
          , C = 0
          , P = 0
          , R = 0
          , E = 0;
        d.sort(D9);
        const B = h !== !0 ? Math.PI : 1;
        for (let z = 0, q = d.length; z < q; z++) {
            const W = d[z]
              , G = W.color
              , K = W.intensity
              , ne = W.distance
              , oe = W.shadow && W.shadow.map ? W.shadow.map.texture : null;
            if (W.isAmbientLight)
                p += G.r * K * B,
                m += G.g * K * B,
                y += G.b * K * B;
            else if (W.isLightProbe)
                for (let F = 0; F < 9; F++)
                    r.probe[F].addScaledVector(W.sh.coefficients[F], K);
            else if (W.isDirectionalLight) {
                const F = t.get(W);
                if (F.color.copy(W.color).multiplyScalar(W.intensity * B),
                W.castShadow) {
                    const V = W.shadow
                      , Y = i.get(W);
                    Y.shadowBias = V.bias,
                    Y.shadowNormalBias = V.normalBias,
                    Y.shadowRadius = V.radius,
                    Y.shadowMapSize = V.mapSize,
                    r.directionalShadow[v] = Y,
                    r.directionalShadowMap[v] = oe,
                    r.directionalShadowMatrix[v] = W.shadow.matrix,
                    M++
                }
                r.directional[v] = F,
                v++
            } else if (W.isSpotLight) {
                const F = t.get(W);
                F.position.setFromMatrixPosition(W.matrixWorld),
                F.color.copy(G).multiplyScalar(K * B),
                F.distance = ne,
                F.coneCos = Math.cos(W.angle),
                F.penumbraCos = Math.cos(W.angle * (1 - W.penumbra)),
                F.decay = W.decay,
                r.spot[_] = F;
                const V = W.shadow;
                if (W.map && (r.spotLightMap[R] = W.map,
                R++,
                V.updateMatrices(W),
                W.castShadow && E++),
                r.spotLightMatrix[_] = V.matrix,
                W.castShadow) {
                    const Y = i.get(W);
                    Y.shadowBias = V.bias,
                    Y.shadowNormalBias = V.normalBias,
                    Y.shadowRadius = V.radius,
                    Y.shadowMapSize = V.mapSize,
                    r.spotShadow[_] = Y,
                    r.spotShadowMap[_] = oe,
                    P++
                }
                _++
            } else if (W.isRectAreaLight) {
                const F = t.get(W);
                F.color.copy(G).multiplyScalar(K),
                F.halfWidth.set(W.width * .5, 0, 0),
                F.halfHeight.set(0, W.height * .5, 0),
                r.rectArea[A] = F,
                A++
            } else if (W.isPointLight) {
                const F = t.get(W);
                if (F.color.copy(W.color).multiplyScalar(W.intensity * B),
                F.distance = W.distance,
                F.decay = W.decay,
                W.castShadow) {
                    const V = W.shadow
                      , Y = i.get(W);
                    Y.shadowBias = V.bias,
                    Y.shadowNormalBias = V.normalBias,
                    Y.shadowRadius = V.radius,
                    Y.shadowMapSize = V.mapSize,
                    Y.shadowCameraNear = V.camera.near,
                    Y.shadowCameraFar = V.camera.far,
                    r.pointShadow[x] = Y,
                    r.pointShadowMap[x] = oe,
                    r.pointShadowMatrix[x] = W.shadow.matrix,
                    C++
                }
                r.point[x] = F,
                x++
            } else if (W.isHemisphereLight) {
                const F = t.get(W);
                F.skyColor.copy(W.color).multiplyScalar(K * B),
                F.groundColor.copy(W.groundColor).multiplyScalar(K * B),
                r.hemi[w] = F,
                w++
            }
        }
        A > 0 && (e.isWebGL2 || n.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = Re.LTC_FLOAT_1,
        r.rectAreaLTC2 = Re.LTC_FLOAT_2) : n.has("OES_texture_half_float_linear") === !0 ? (r.rectAreaLTC1 = Re.LTC_HALF_1,
        r.rectAreaLTC2 = Re.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
        r.ambient[0] = p,
        r.ambient[1] = m,
        r.ambient[2] = y;
        const I = r.hash;
        (I.directionalLength !== v || I.pointLength !== x || I.spotLength !== _ || I.rectAreaLength !== A || I.hemiLength !== w || I.numDirectionalShadows !== M || I.numPointShadows !== C || I.numSpotShadows !== P || I.numSpotMaps !== R) && (r.directional.length = v,
        r.spot.length = _,
        r.rectArea.length = A,
        r.point.length = x,
        r.hemi.length = w,
        r.directionalShadow.length = M,
        r.directionalShadowMap.length = M,
        r.pointShadow.length = C,
        r.pointShadowMap.length = C,
        r.spotShadow.length = P,
        r.spotShadowMap.length = P,
        r.directionalShadowMatrix.length = M,
        r.pointShadowMatrix.length = C,
        r.spotLightMatrix.length = P + R - E,
        r.spotLightMap.length = R,
        r.numSpotLightShadowsWithMaps = E,
        I.directionalLength = v,
        I.pointLength = x,
        I.spotLength = _,
        I.rectAreaLength = A,
        I.hemiLength = w,
        I.numDirectionalShadows = M,
        I.numPointShadows = C,
        I.numSpotShadows = P,
        I.numSpotMaps = R,
        r.version = L9++)
    }
    function c(d, h) {
        let p = 0
          , m = 0
          , y = 0
          , v = 0
          , x = 0;
        const _ = h.matrixWorldInverse;
        for (let A = 0, w = d.length; A < w; A++) {
            const M = d[A];
            if (M.isDirectionalLight) {
                const C = r.directional[p];
                C.direction.setFromMatrixPosition(M.matrixWorld),
                s.setFromMatrixPosition(M.target.matrixWorld),
                C.direction.sub(s),
                C.direction.transformDirection(_),
                p++
            } else if (M.isSpotLight) {
                const C = r.spot[y];
                C.position.setFromMatrixPosition(M.matrixWorld),
                C.position.applyMatrix4(_),
                C.direction.setFromMatrixPosition(M.matrixWorld),
                s.setFromMatrixPosition(M.target.matrixWorld),
                C.direction.sub(s),
                C.direction.transformDirection(_),
                y++
            } else if (M.isRectAreaLight) {
                const C = r.rectArea[v];
                C.position.setFromMatrixPosition(M.matrixWorld),
                C.position.applyMatrix4(_),
                a.identity(),
                o.copy(M.matrixWorld),
                o.premultiply(_),
                a.extractRotation(o),
                C.halfWidth.set(M.width * .5, 0, 0),
                C.halfHeight.set(0, M.height * .5, 0),
                C.halfWidth.applyMatrix4(a),
                C.halfHeight.applyMatrix4(a),
                v++
            } else if (M.isPointLight) {
                const C = r.point[m];
                C.position.setFromMatrixPosition(M.matrixWorld),
                C.position.applyMatrix4(_),
                m++
            } else if (M.isHemisphereLight) {
                const C = r.hemi[x];
                C.direction.setFromMatrixPosition(M.matrixWorld),
                C.direction.transformDirection(_),
                x++
            }
        }
    }
    return {
        setup: l,
        setupView: c,
        state: r
    }
}
function CE(n, e) {
    const t = new k9(n,e)
      , i = []
      , r = [];
    function s() {
        i.length = 0,
        r.length = 0
    }
    function o(h) {
        i.push(h)
    }
    function a(h) {
        r.push(h)
    }
    function l(h) {
        t.setup(i, h)
    }
    function c(h) {
        t.setupView(i, h)
    }
    return {
        init: s,
        state: {
            lightsArray: i,
            shadowsArray: r,
            lights: t
        },
        setupLights: l,
        setupLightsView: c,
        pushLight: o,
        pushShadow: a
    }
}
function F9(n, e) {
    let t = new WeakMap;
    function i(s, o=0) {
        const a = t.get(s);
        let l;
        return a === void 0 ? (l = new CE(n,e),
        t.set(s, [l])) : o >= a.length ? (l = new CE(n,e),
        a.push(l)) : l = a[o],
        l
    }
    function r() {
        t = new WeakMap
    }
    return {
        get: i,
        dispose: r
    }
}
class Pw extends Tn {
    constructor(e) {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = LR,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
}
class Bw extends Tn {
    constructor(e) {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.referencePosition = new D,
        this.nearDistance = 1,
        this.farDistance = 1e3,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.referencePosition.copy(e.referencePosition),
        this.nearDistance = e.nearDistance,
        this.farDistance = e.farDistance,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
}
const N9 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
  , O9 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function U9(n, e, t) {
    let i = new T0;
    const r = new me
      , s = new me
      , o = new Ut
      , a = new Pw({
        depthPacking: DR
    })
      , l = new Bw
      , c = {}
      , d = t.maxTextureSize
      , h = {
        [hs]: Li,
        [Li]: hs,
        [Or]: Or
    }
      , p = new ms({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new me
            },
            radius: {
                value: 4
            }
        },
        vertexShader: N9,
        fragmentShader: O9
    })
      , m = p.clone();
    m.defines.HORIZONTAL_PASS = 1;
    const y = new ft;
    y.setAttribute("position", new Nt(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    const v = new Ln(y,p)
      , x = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = S0,
    this.render = function(M, C, P) {
        if (x.enabled === !1 || x.autoUpdate === !1 && x.needsUpdate === !1 || M.length === 0)
            return;
        const R = n.getRenderTarget()
          , E = n.getActiveCubeFace()
          , B = n.getActiveMipmapLevel()
          , I = n.state;
        I.setBlending(js),
        I.buffers.color.setClear(1, 1, 1, 1),
        I.buffers.depth.setTest(!0),
        I.setScissorTest(!1);
        for (let z = 0, q = M.length; z < q; z++) {
            const W = M[z]
              , G = W.shadow;
            if (G === void 0) {
                console.warn("THREE.WebGLShadowMap:", W, "has no shadow.");
                continue
            }
            if (G.autoUpdate === !1 && G.needsUpdate === !1)
                continue;
            r.copy(G.mapSize);
            const K = G.getFrameExtents();
            if (r.multiply(K),
            s.copy(G.mapSize),
            (r.x > d || r.y > d) && (r.x > d && (s.x = Math.floor(d / K.x),
            r.x = s.x * K.x,
            G.mapSize.x = s.x),
            r.y > d && (s.y = Math.floor(d / K.y),
            r.y = s.y * K.y,
            G.mapSize.y = s.y)),
            G.map === null) {
                const oe = this.type !== $a ? {
                    minFilter: gn,
                    magFilter: gn
                } : {};
                G.map = new jr(r.x,r.y,oe),
                G.map.texture.name = W.name + ".shadowMap",
                G.camera.updateProjectionMatrix()
            }
            n.setRenderTarget(G.map),
            n.clear();
            const ne = G.getViewportCount();
            for (let oe = 0; oe < ne; oe++) {
                const F = G.getViewport(oe);
                o.set(s.x * F.x, s.y * F.y, s.x * F.z, s.y * F.w),
                I.viewport(o),
                G.updateMatrices(W, oe),
                i = G.getFrustum(),
                w(C, P, G.camera, W, this.type)
            }
            G.isPointLightShadow !== !0 && this.type === $a && _(G, P),
            G.needsUpdate = !1
        }
        x.needsUpdate = !1,
        n.setRenderTarget(R, E, B)
    }
    ;
    function _(M, C) {
        const P = e.update(v);
        p.defines.VSM_SAMPLES !== M.blurSamples && (p.defines.VSM_SAMPLES = M.blurSamples,
        m.defines.VSM_SAMPLES = M.blurSamples,
        p.needsUpdate = !0,
        m.needsUpdate = !0),
        M.mapPass === null && (M.mapPass = new jr(r.x,r.y)),
        p.uniforms.shadow_pass.value = M.map.texture,
        p.uniforms.resolution.value = M.mapSize,
        p.uniforms.radius.value = M.radius,
        n.setRenderTarget(M.mapPass),
        n.clear(),
        n.renderBufferDirect(C, null, P, p, v, null),
        m.uniforms.shadow_pass.value = M.mapPass.texture,
        m.uniforms.resolution.value = M.mapSize,
        m.uniforms.radius.value = M.radius,
        n.setRenderTarget(M.map),
        n.clear(),
        n.renderBufferDirect(C, null, P, m, v, null)
    }
    function A(M, C, P, R, E, B) {
        let I = null;
        const z = P.isPointLight === !0 ? M.customDistanceMaterial : M.customDepthMaterial;
        if (z !== void 0)
            I = z;
        else if (I = P.isPointLight === !0 ? l : a,
        n.localClippingEnabled && C.clipShadows === !0 && Array.isArray(C.clippingPlanes) && C.clippingPlanes.length !== 0 || C.displacementMap && C.displacementScale !== 0 || C.alphaMap && C.alphaTest > 0 || C.map && C.alphaTest > 0) {
            const q = I.uuid
              , W = C.uuid;
            let G = c[q];
            G === void 0 && (G = {},
            c[q] = G);
            let K = G[W];
            K === void 0 && (K = I.clone(),
            G[W] = K),
            I = K
        }
        return I.visible = C.visible,
        I.wireframe = C.wireframe,
        B === $a ? I.side = C.shadowSide !== null ? C.shadowSide : C.side : I.side = C.shadowSide !== null ? C.shadowSide : h[C.side],
        I.alphaMap = C.alphaMap,
        I.alphaTest = C.alphaTest,
        I.map = C.map,
        I.clipShadows = C.clipShadows,
        I.clippingPlanes = C.clippingPlanes,
        I.clipIntersection = C.clipIntersection,
        I.displacementMap = C.displacementMap,
        I.displacementScale = C.displacementScale,
        I.displacementBias = C.displacementBias,
        I.wireframeLinewidth = C.wireframeLinewidth,
        I.linewidth = C.linewidth,
        P.isPointLight === !0 && I.isMeshDistanceMaterial === !0 && (I.referencePosition.setFromMatrixPosition(P.matrixWorld),
        I.nearDistance = R,
        I.farDistance = E),
        I
    }
    function w(M, C, P, R, E) {
        if (M.visible === !1)
            return;
        if (M.layers.test(C.layers) && (M.isMesh || M.isLine || M.isPoints) && (M.castShadow || M.receiveShadow && E === $a) && (!M.frustumCulled || i.intersectsObject(M))) {
            M.modelViewMatrix.multiplyMatrices(P.matrixWorldInverse, M.matrixWorld);
            const z = e.update(M)
              , q = M.material;
            if (Array.isArray(q)) {
                const W = z.groups;
                for (let G = 0, K = W.length; G < K; G++) {
                    const ne = W[G]
                      , oe = q[ne.materialIndex];
                    if (oe && oe.visible) {
                        const F = A(M, oe, R, P.near, P.far, E);
                        n.renderBufferDirect(P, null, z, F, M, ne)
                    }
                }
            } else if (q.visible) {
                const W = A(M, q, R, P.near, P.far, E);
                n.renderBufferDirect(P, null, z, W, M, null)
            }
        }
        const I = M.children;
        for (let z = 0, q = I.length; z < q; z++)
            w(I[z], C, P, R, E)
    }
}
function z9(n, e, t) {
    const i = t.isWebGL2;
    function r() {
        let X = !1;
        const ce = new Ut;
        let xe = null;
        const Ue = new Ut(0,0,0,0);
        return {
            setMask: function(Ze) {
                xe !== Ze && !X && (n.colorMask(Ze, Ze, Ze, Ze),
                xe = Ze)
            },
            setLocked: function(Ze) {
                X = Ze
            },
            setClear: function(Ze, It, yn, Nn, Kr) {
                Kr === !0 && (Ze *= Nn,
                It *= Nn,
                yn *= Nn),
                ce.set(Ze, It, yn, Nn),
                Ue.equals(ce) === !1 && (n.clearColor(Ze, It, yn, Nn),
                Ue.copy(ce))
            },
            reset: function() {
                X = !1,
                xe = null,
                Ue.set(-1, 0, 0, 0)
            }
        }
    }
    function s() {
        let X = !1
          , ce = null
          , xe = null
          , Ue = null;
        return {
            setTest: function(Ze) {
                Ze ? Ne(2929) : Oe(2929)
            },
            setMask: function(Ze) {
                ce !== Ze && !X && (n.depthMask(Ze),
                ce = Ze)
            },
            setFunc: function(Ze) {
                if (xe !== Ze) {
                    switch (Ze) {
                    case tR:
                        n.depthFunc(512);
                        break;
                    case nR:
                        n.depthFunc(519);
                        break;
                    case iR:
                        n.depthFunc(513);
                        break;
                    case zg:
                        n.depthFunc(515);
                        break;
                    case rR:
                        n.depthFunc(514);
                        break;
                    case sR:
                        n.depthFunc(518);
                        break;
                    case oR:
                        n.depthFunc(516);
                        break;
                    case aR:
                        n.depthFunc(517);
                        break;
                    default:
                        n.depthFunc(515)
                    }
                    xe = Ze
                }
            },
            setLocked: function(Ze) {
                X = Ze
            },
            setClear: function(Ze) {
                Ue !== Ze && (n.clearDepth(Ze),
                Ue = Ze)
            },
            reset: function() {
                X = !1,
                ce = null,
                xe = null,
                Ue = null
            }
        }
    }
    function o() {
        let X = !1
          , ce = null
          , xe = null
          , Ue = null
          , Ze = null
          , It = null
          , yn = null
          , Nn = null
          , Kr = null;
        return {
            setTest: function(Gt) {
                X || (Gt ? Ne(2960) : Oe(2960))
            },
            setMask: function(Gt) {
                ce !== Gt && !X && (n.stencilMask(Gt),
                ce = Gt)
            },
            setFunc: function(Gt, er, wi) {
                (xe !== Gt || Ue !== er || Ze !== wi) && (n.stencilFunc(Gt, er, wi),
                xe = Gt,
                Ue = er,
                Ze = wi)
            },
            setOp: function(Gt, er, wi) {
                (It !== Gt || yn !== er || Nn !== wi) && (n.stencilOp(Gt, er, wi),
                It = Gt,
                yn = er,
                Nn = wi)
            },
            setLocked: function(Gt) {
                X = Gt
            },
            setClear: function(Gt) {
                Kr !== Gt && (n.clearStencil(Gt),
                Kr = Gt)
            },
            reset: function() {
                X = !1,
                ce = null,
                xe = null,
                Ue = null,
                Ze = null,
                It = null,
                yn = null,
                Nn = null,
                Kr = null
            }
        }
    }
    const a = new r
      , l = new s
      , c = new o
      , d = new WeakMap
      , h = new WeakMap;
    let p = {}
      , m = {}
      , y = new WeakMap
      , v = []
      , x = null
      , _ = !1
      , A = null
      , w = null
      , M = null
      , C = null
      , P = null
      , R = null
      , E = null
      , B = !1
      , I = null
      , z = null
      , q = null
      , W = null
      , G = null;
    const K = n.getParameter(35661);
    let ne = !1
      , oe = 0;
    const F = n.getParameter(7938);
    F.indexOf("WebGL") !== -1 ? (oe = parseFloat(/^WebGL (\d)/.exec(F)[1]),
    ne = oe >= 1) : F.indexOf("OpenGL ES") !== -1 && (oe = parseFloat(/^OpenGL ES (\d)/.exec(F)[1]),
    ne = oe >= 2);
    let V = null
      , Y = {};
    const re = n.getParameter(3088)
      , j = n.getParameter(2978)
      , ie = new Ut().fromArray(re)
      , ye = new Ut().fromArray(j);
    function _e(X, ce, xe) {
        const Ue = new Uint8Array(4)
          , Ze = n.createTexture();
        n.bindTexture(X, Ze),
        n.texParameteri(X, 10241, 9728),
        n.texParameteri(X, 10240, 9728);
        for (let It = 0; It < xe; It++)
            n.texImage2D(ce + It, 0, 6408, 1, 1, 0, 6408, 5121, Ue);
        return Ze
    }
    const $ = {};
    $[3553] = _e(3553, 3553, 1),
    $[34067] = _e(34067, 34069, 6),
    a.setClear(0, 0, 0, 1),
    l.setClear(1),
    c.setClear(0),
    Ne(2929),
    l.setFunc(zg),
    Be(!1),
    $e(z1),
    Ne(2884),
    be(js);
    function Ne(X) {
        p[X] !== !0 && (n.enable(X),
        p[X] = !0)
    }
    function Oe(X) {
        p[X] !== !1 && (n.disable(X),
        p[X] = !1)
    }
    function Ve(X, ce) {
        return m[X] !== ce ? (n.bindFramebuffer(X, ce),
        m[X] = ce,
        i && (X === 36009 && (m[36160] = ce),
        X === 36160 && (m[36009] = ce)),
        !0) : !1
    }
    function we(X, ce) {
        let xe = v
          , Ue = !1;
        if (X)
            if (xe = y.get(ce),
            xe === void 0 && (xe = [],
            y.set(ce, xe)),
            X.isWebGLMultipleRenderTargets) {
                const Ze = X.texture;
                if (xe.length !== Ze.length || xe[0] !== 36064) {
                    for (let It = 0, yn = Ze.length; It < yn; It++)
                        xe[It] = 36064 + It;
                    xe.length = Ze.length,
                    Ue = !0
                }
            } else
                xe[0] !== 36064 && (xe[0] = 36064,
                Ue = !0);
        else
            xe[0] !== 1029 && (xe[0] = 1029,
            Ue = !0);
        Ue && (t.isWebGL2 ? n.drawBuffers(xe) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(xe))
    }
    function Le(X) {
        return x !== X ? (n.useProgram(X),
        x = X,
        !0) : !1
    }
    const de = {
        [Xa]: 32774,
        [WB]: 32778,
        [jB]: 32779
    };
    if (i)
        de[W1] = 32775,
        de[j1] = 32776;
    else {
        const X = e.get("EXT_blend_minmax");
        X !== null && (de[W1] = X.MIN_EXT,
        de[j1] = X.MAX_EXT)
    }
    const ae = {
        [JB]: 0,
        [XB]: 1,
        [YB]: 768,
        [pw]: 770,
        [eR]: 776,
        [qB]: 774,
        [QB]: 772,
        [KB]: 769,
        [mw]: 771,
        [$B]: 775,
        [ZB]: 773
    };
    function be(X, ce, xe, Ue, Ze, It, yn, Nn) {
        if (X === js) {
            _ === !0 && (Oe(3042),
            _ = !1);
            return
        }
        if (_ === !1 && (Ne(3042),
        _ = !0),
        X !== VB) {
            if (X !== A || Nn !== B) {
                if ((w !== Xa || P !== Xa) && (n.blendEquation(32774),
                w = Xa,
                P = Xa),
                Nn)
                    switch (X) {
                    case ul:
                        n.blendFuncSeparate(1, 771, 1, 771);
                        break;
                    case G1:
                        n.blendFunc(1, 1);
                        break;
                    case H1:
                        n.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case V1:
                        n.blendFuncSeparate(0, 768, 0, 770);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", X);
                        break
                    }
                else
                    switch (X) {
                    case ul:
                        n.blendFuncSeparate(770, 771, 1, 771);
                        break;
                    case G1:
                        n.blendFunc(770, 1);
                        break;
                    case H1:
                        n.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case V1:
                        n.blendFunc(0, 768);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", X);
                        break
                    }
                M = null,
                C = null,
                R = null,
                E = null,
                A = X,
                B = Nn
            }
            return
        }
        Ze = Ze || ce,
        It = It || xe,
        yn = yn || Ue,
        (ce !== w || Ze !== P) && (n.blendEquationSeparate(de[ce], de[Ze]),
        w = ce,
        P = Ze),
        (xe !== M || Ue !== C || It !== R || yn !== E) && (n.blendFuncSeparate(ae[xe], ae[Ue], ae[It], ae[yn]),
        M = xe,
        C = Ue,
        R = It,
        E = yn),
        A = X,
        B = !1
    }
    function Ge(X, ce) {
        X.side === Or ? Oe(2884) : Ne(2884);
        let xe = X.side === Li;
        ce && (xe = !xe),
        Be(xe),
        X.blending === ul && X.transparent === !1 ? be(js) : be(X.blending, X.blendEquation, X.blendSrc, X.blendDst, X.blendEquationAlpha, X.blendSrcAlpha, X.blendDstAlpha, X.premultipliedAlpha),
        l.setFunc(X.depthFunc),
        l.setTest(X.depthTest),
        l.setMask(X.depthWrite),
        a.setMask(X.colorWrite);
        const Ue = X.stencilWrite;
        c.setTest(Ue),
        Ue && (c.setMask(X.stencilWriteMask),
        c.setFunc(X.stencilFunc, X.stencilRef, X.stencilFuncMask),
        c.setOp(X.stencilFail, X.stencilZFail, X.stencilZPass)),
        Je(X.polygonOffset, X.polygonOffsetFactor, X.polygonOffsetUnits),
        X.alphaToCoverage === !0 ? Ne(32926) : Oe(32926)
    }
    function Be(X) {
        I !== X && (X ? n.frontFace(2304) : n.frontFace(2305),
        I = X)
    }
    function $e(X) {
        X !== zB ? (Ne(2884),
        X !== z && (X === z1 ? n.cullFace(1029) : X === GB ? n.cullFace(1028) : n.cullFace(1032))) : Oe(2884),
        z = X
    }
    function Ye(X) {
        X !== q && (ne && n.lineWidth(X),
        q = X)
    }
    function Je(X, ce, xe) {
        X ? (Ne(32823),
        (W !== ce || G !== xe) && (n.polygonOffset(ce, xe),
        W = ce,
        G = xe)) : Oe(32823)
    }
    function At(X) {
        X ? Ne(3089) : Oe(3089)
    }
    function Ct(X) {
        X === void 0 && (X = 33984 + K - 1),
        V !== X && (n.activeTexture(X),
        V = X)
    }
    function O(X, ce, xe) {
        xe === void 0 && (V === null ? xe = 33984 + K - 1 : xe = V);
        let Ue = Y[xe];
        Ue === void 0 && (Ue = {
            type: void 0,
            texture: void 0
        },
        Y[xe] = Ue),
        (Ue.type !== X || Ue.texture !== ce) && (V !== xe && (n.activeTexture(xe),
        V = xe),
        n.bindTexture(X, ce || $[X]),
        Ue.type = X,
        Ue.texture = ce)
    }
    function L() {
        const X = Y[V];
        X !== void 0 && X.type !== void 0 && (n.bindTexture(X.type, null),
        X.type = void 0,
        X.texture = void 0)
    }
    function se() {
        try {
            n.compressedTexImage2D.apply(n, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function Se() {
        try {
            n.compressedTexImage3D.apply(n, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function Ce() {
        try {
            n.texSubImage2D.apply(n, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function Pe() {
        try {
            n.texSubImage3D.apply(n, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function rt() {
        try {
            n.compressedTexSubImage2D.apply(n, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function De() {
        try {
            n.compressedTexSubImage3D.apply(n, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function ge() {
        try {
            n.texStorage2D.apply(n, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function Ke() {
        try {
            n.texStorage3D.apply(n, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function H() {
        try {
            n.texImage2D.apply(n, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function le() {
        try {
            n.texImage3D.apply(n, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function Ae(X) {
        ie.equals(X) === !1 && (n.scissor(X.x, X.y, X.z, X.w),
        ie.copy(X))
    }
    function Te(X) {
        ye.equals(X) === !1 && (n.viewport(X.x, X.y, X.z, X.w),
        ye.copy(X))
    }
    function tt(X, ce) {
        let xe = h.get(ce);
        xe === void 0 && (xe = new WeakMap,
        h.set(ce, xe));
        let Ue = xe.get(X);
        Ue === void 0 && (Ue = n.getUniformBlockIndex(ce, X.name),
        xe.set(X, Ue))
    }
    function _t(X, ce) {
        const Ue = h.get(ce).get(X);
        d.get(ce) !== Ue && (n.uniformBlockBinding(ce, Ue, X.__bindingPointIndex),
        d.set(ce, Ue))
    }
    function Jt() {
        n.disable(3042),
        n.disable(2884),
        n.disable(2929),
        n.disable(32823),
        n.disable(3089),
        n.disable(2960),
        n.disable(32926),
        n.blendEquation(32774),
        n.blendFunc(1, 0),
        n.blendFuncSeparate(1, 0, 1, 0),
        n.colorMask(!0, !0, !0, !0),
        n.clearColor(0, 0, 0, 0),
        n.depthMask(!0),
        n.depthFunc(513),
        n.clearDepth(1),
        n.stencilMask(4294967295),
        n.stencilFunc(519, 0, 4294967295),
        n.stencilOp(7680, 7680, 7680),
        n.clearStencil(0),
        n.cullFace(1029),
        n.frontFace(2305),
        n.polygonOffset(0, 0),
        n.activeTexture(33984),
        n.bindFramebuffer(36160, null),
        i === !0 && (n.bindFramebuffer(36009, null),
        n.bindFramebuffer(36008, null)),
        n.useProgram(null),
        n.lineWidth(1),
        n.scissor(0, 0, n.canvas.width, n.canvas.height),
        n.viewport(0, 0, n.canvas.width, n.canvas.height),
        p = {},
        V = null,
        Y = {},
        m = {},
        y = new WeakMap,
        v = [],
        x = null,
        _ = !1,
        A = null,
        w = null,
        M = null,
        C = null,
        P = null,
        R = null,
        E = null,
        B = !1,
        I = null,
        z = null,
        q = null,
        W = null,
        G = null,
        ie.set(0, 0, n.canvas.width, n.canvas.height),
        ye.set(0, 0, n.canvas.width, n.canvas.height),
        a.reset(),
        l.reset(),
        c.reset()
    }
    return {
        buffers: {
            color: a,
            depth: l,
            stencil: c
        },
        enable: Ne,
        disable: Oe,
        bindFramebuffer: Ve,
        drawBuffers: we,
        useProgram: Le,
        setBlending: be,
        setMaterial: Ge,
        setFlipSided: Be,
        setCullFace: $e,
        setLineWidth: Ye,
        setPolygonOffset: Je,
        setScissorTest: At,
        activeTexture: Ct,
        bindTexture: O,
        unbindTexture: L,
        compressedTexImage2D: se,
        compressedTexImage3D: Se,
        texImage2D: H,
        texImage3D: le,
        updateUBOMapping: tt,
        uniformBlockBinding: _t,
        texStorage2D: ge,
        texStorage3D: Ke,
        texSubImage2D: Ce,
        texSubImage3D: Pe,
        compressedTexSubImage2D: rt,
        compressedTexSubImage3D: De,
        scissor: Ae,
        viewport: Te,
        reset: Jt
    }
}
function G9(n, e, t, i, r, s, o) {
    const a = r.isWebGL2
      , l = r.maxTextures
      , c = r.maxCubemapSize
      , d = r.maxTextureSize
      , h = r.maxSamples
      , p = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
      , m = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
      , y = new WeakMap;
    let v;
    const x = new WeakMap;
    let _ = !1;
    try {
        _ = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
    } catch {}
    function A(O, L) {
        return _ ? new OffscreenCanvas(O,L) : Ed("canvas")
    }
    function w(O, L, se, Se) {
        let Ce = 1;
        if ((O.width > Se || O.height > Se) && (Ce = Se / Math.max(O.width, O.height)),
        Ce < 1 || L === !0)
            if (typeof HTMLImageElement < "u" && O instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && O instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && O instanceof ImageBitmap) {
                const Pe = L ? Hg : Math.floor
                  , rt = Pe(Ce * O.width)
                  , De = Pe(Ce * O.height);
                v === void 0 && (v = A(rt, De));
                const ge = se ? A(rt, De) : v;
                return ge.width = rt,
                ge.height = De,
                ge.getContext("2d").drawImage(O, 0, 0, rt, De),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + O.width + "x" + O.height + ") to (" + rt + "x" + De + ")."),
                ge
            } else
                return "data"in O && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + O.width + "x" + O.height + ")."),
                O;
        return O
    }
    function M(O) {
        return g_(O.width) && g_(O.height)
    }
    function C(O) {
        return a ? !1 : O.wrapS !== Xn || O.wrapT !== Xn || O.minFilter !== gn && O.minFilter !== on
    }
    function P(O, L) {
        return O.generateMipmaps && L && O.minFilter !== gn && O.minFilter !== on
    }
    function R(O) {
        n.generateMipmap(O)
    }
    function E(O, L, se, Se, Ce=!1) {
        if (a === !1)
            return L;
        if (O !== null) {
            if (n[O] !== void 0)
                return n[O];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + O + "'")
        }
        let Pe = L;
        return L === 6403 && (se === 5126 && (Pe = 33326),
        se === 5131 && (Pe = 33325),
        se === 5121 && (Pe = 33321)),
        L === 33319 && (se === 5126 && (Pe = 33328),
        se === 5131 && (Pe = 33327),
        se === 5121 && (Pe = 33323)),
        L === 6408 && (se === 5126 && (Pe = 34836),
        se === 5131 && (Pe = 34842),
        se === 5121 && (Pe = Se === Tt && Ce === !1 ? 35907 : 32856),
        se === 32819 && (Pe = 32854),
        se === 32820 && (Pe = 32855)),
        (Pe === 33325 || Pe === 33326 || Pe === 33327 || Pe === 33328 || Pe === 34842 || Pe === 34836) && e.get("EXT_color_buffer_float"),
        Pe
    }
    function B(O, L, se) {
        return P(O, se) === !0 || O.isFramebufferTexture && O.minFilter !== gn && O.minFilter !== on ? Math.log2(Math.max(L.width, L.height)) + 1 : O.mipmaps !== void 0 && O.mipmaps.length > 0 ? O.mipmaps.length : O.isCompressedTexture && Array.isArray(O.image) ? L.mipmaps.length : 1
    }
    function I(O) {
        return O === gn || O === Sd || O === ju ? 9728 : 9729
    }
    function z(O) {
        const L = O.target;
        L.removeEventListener("dispose", z),
        W(L),
        L.isVideoTexture && y.delete(L)
    }
    function q(O) {
        const L = O.target;
        L.removeEventListener("dispose", q),
        K(L)
    }
    function W(O) {
        const L = i.get(O);
        if (L.__webglInit === void 0)
            return;
        const se = O.source
          , Se = x.get(se);
        if (Se) {
            const Ce = Se[L.__cacheKey];
            Ce.usedTimes--,
            Ce.usedTimes === 0 && G(O),
            Object.keys(Se).length === 0 && x.delete(se)
        }
        i.remove(O)
    }
    function G(O) {
        const L = i.get(O);
        n.deleteTexture(L.__webglTexture);
        const se = O.source
          , Se = x.get(se);
        delete Se[L.__cacheKey],
        o.memory.textures--
    }
    function K(O) {
        const L = O.texture
          , se = i.get(O)
          , Se = i.get(L);
        if (Se.__webglTexture !== void 0 && (n.deleteTexture(Se.__webglTexture),
        o.memory.textures--),
        O.depthTexture && O.depthTexture.dispose(),
        O.isWebGLCubeRenderTarget)
            for (let Ce = 0; Ce < 6; Ce++)
                n.deleteFramebuffer(se.__webglFramebuffer[Ce]),
                se.__webglDepthbuffer && n.deleteRenderbuffer(se.__webglDepthbuffer[Ce]);
        else {
            if (n.deleteFramebuffer(se.__webglFramebuffer),
            se.__webglDepthbuffer && n.deleteRenderbuffer(se.__webglDepthbuffer),
            se.__webglMultisampledFramebuffer && n.deleteFramebuffer(se.__webglMultisampledFramebuffer),
            se.__webglColorRenderbuffer)
                for (let Ce = 0; Ce < se.__webglColorRenderbuffer.length; Ce++)
                    se.__webglColorRenderbuffer[Ce] && n.deleteRenderbuffer(se.__webglColorRenderbuffer[Ce]);
            se.__webglDepthRenderbuffer && n.deleteRenderbuffer(se.__webglDepthRenderbuffer)
        }
        if (O.isWebGLMultipleRenderTargets)
            for (let Ce = 0, Pe = L.length; Ce < Pe; Ce++) {
                const rt = i.get(L[Ce]);
                rt.__webglTexture && (n.deleteTexture(rt.__webglTexture),
                o.memory.textures--),
                i.remove(L[Ce])
            }
        i.remove(L),
        i.remove(O)
    }
    let ne = 0;
    function oe() {
        ne = 0
    }
    function F() {
        const O = ne;
        return O >= l && console.warn("THREE.WebGLTextures: Trying to use " + O + " texture units while this GPU supports only " + l),
        ne += 1,
        O
    }
    function V(O) {
        const L = [];
        return L.push(O.wrapS),
        L.push(O.wrapT),
        L.push(O.wrapR || 0),
        L.push(O.magFilter),
        L.push(O.minFilter),
        L.push(O.anisotropy),
        L.push(O.internalFormat),
        L.push(O.format),
        L.push(O.type),
        L.push(O.generateMipmaps),
        L.push(O.premultiplyAlpha),
        L.push(O.flipY),
        L.push(O.unpackAlignment),
        L.push(O.encoding),
        L.join()
    }
    function Y(O, L) {
        const se = i.get(O);
        if (O.isVideoTexture && At(O),
        O.isRenderTargetTexture === !1 && O.version > 0 && se.__version !== O.version) {
            const Se = O.image;
            if (Se === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (Se.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                Oe(se, O, L);
                return
            }
        }
        t.bindTexture(3553, se.__webglTexture, 33984 + L)
    }
    function re(O, L) {
        const se = i.get(O);
        if (O.version > 0 && se.__version !== O.version) {
            Oe(se, O, L);
            return
        }
        t.bindTexture(35866, se.__webglTexture, 33984 + L)
    }
    function j(O, L) {
        const se = i.get(O);
        if (O.version > 0 && se.__version !== O.version) {
            Oe(se, O, L);
            return
        }
        t.bindTexture(32879, se.__webglTexture, 33984 + L)
    }
    function ie(O, L) {
        const se = i.get(O);
        if (O.version > 0 && se.__version !== O.version) {
            Ve(se, O, L);
            return
        }
        t.bindTexture(34067, se.__webglTexture, 33984 + L)
    }
    const ye = {
        [na]: 10497,
        [Xn]: 33071,
        [nc]: 33648
    }
      , _e = {
        [gn]: 9728,
        [Sd]: 9984,
        [ju]: 9986,
        [on]: 9729,
        [b0]: 9985,
        [ps]: 9987
    };
    function $(O, L, se) {
        if (se ? (n.texParameteri(O, 10242, ye[L.wrapS]),
        n.texParameteri(O, 10243, ye[L.wrapT]),
        (O === 32879 || O === 35866) && n.texParameteri(O, 32882, ye[L.wrapR]),
        n.texParameteri(O, 10240, _e[L.magFilter]),
        n.texParameteri(O, 10241, _e[L.minFilter])) : (n.texParameteri(O, 10242, 33071),
        n.texParameteri(O, 10243, 33071),
        (O === 32879 || O === 35866) && n.texParameteri(O, 32882, 33071),
        (L.wrapS !== Xn || L.wrapT !== Xn) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
        n.texParameteri(O, 10240, I(L.magFilter)),
        n.texParameteri(O, 10241, I(L.minFilter)),
        L.minFilter !== gn && L.minFilter !== on && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
        e.has("EXT_texture_filter_anisotropic") === !0) {
            const Se = e.get("EXT_texture_filter_anisotropic");
            if (L.magFilter === gn || L.minFilter !== ju && L.minFilter !== ps || L.type === zs && e.has("OES_texture_float_linear") === !1 || a === !1 && L.type === ic && e.has("OES_texture_half_float_linear") === !1)
                return;
            (L.anisotropy > 1 || i.get(L).__currentAnisotropy) && (n.texParameterf(O, Se.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(L.anisotropy, r.getMaxAnisotropy())),
            i.get(L).__currentAnisotropy = L.anisotropy)
        }
    }
    function Ne(O, L) {
        let se = !1;
        O.__webglInit === void 0 && (O.__webglInit = !0,
        L.addEventListener("dispose", z));
        const Se = L.source;
        let Ce = x.get(Se);
        Ce === void 0 && (Ce = {},
        x.set(Se, Ce));
        const Pe = V(L);
        if (Pe !== O.__cacheKey) {
            Ce[Pe] === void 0 && (Ce[Pe] = {
                texture: n.createTexture(),
                usedTimes: 0
            },
            o.memory.textures++,
            se = !0),
            Ce[Pe].usedTimes++;
            const rt = Ce[O.__cacheKey];
            rt !== void 0 && (Ce[O.__cacheKey].usedTimes--,
            rt.usedTimes === 0 && G(L)),
            O.__cacheKey = Pe,
            O.__webglTexture = Ce[Pe].texture
        }
        return se
    }
    function Oe(O, L, se) {
        let Se = 3553;
        (L.isDataArrayTexture || L.isCompressedArrayTexture) && (Se = 35866),
        L.isData3DTexture && (Se = 32879);
        const Ce = Ne(O, L)
          , Pe = L.source;
        t.bindTexture(Se, O.__webglTexture, 33984 + se);
        const rt = i.get(Pe);
        if (Pe.version !== rt.__version || Ce === !0) {
            t.activeTexture(33984 + se),
            n.pixelStorei(37440, L.flipY),
            n.pixelStorei(37441, L.premultiplyAlpha),
            n.pixelStorei(3317, L.unpackAlignment),
            n.pixelStorei(37443, 0);
            const De = C(L) && M(L.image) === !1;
            let ge = w(L.image, De, !1, d);
            ge = Ct(L, ge);
            const Ke = M(ge) || a
              , H = s.convert(L.format, L.encoding);
            let le = s.convert(L.type)
              , Ae = E(L.internalFormat, H, le, L.encoding, L.isVideoTexture);
            $(Se, L, Ke);
            let Te;
            const tt = L.mipmaps
              , _t = a && L.isVideoTexture !== !0
              , Jt = rt.__version === void 0 || Ce === !0
              , X = B(L, ge, Ke);
            if (L.isDepthTexture)
                Ae = 6402,
                a ? L.type === zs ? Ae = 36012 : L.type === No ? Ae = 33190 : L.type === cl ? Ae = 35056 : Ae = 33189 : L.type === zs && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                L.format === Qo && Ae === 6402 && L.type !== vw && L.type !== No && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                L.type = No,
                le = s.convert(L.type)),
                L.format === Al && Ae === 6402 && (Ae = 34041,
                L.type !== cl && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                L.type = cl,
                le = s.convert(L.type))),
                Jt && (_t ? t.texStorage2D(3553, 1, Ae, ge.width, ge.height) : t.texImage2D(3553, 0, Ae, ge.width, ge.height, 0, H, le, null));
            else if (L.isDataTexture)
                if (tt.length > 0 && Ke) {
                    _t && Jt && t.texStorage2D(3553, X, Ae, tt[0].width, tt[0].height);
                    for (let ce = 0, xe = tt.length; ce < xe; ce++)
                        Te = tt[ce],
                        _t ? t.texSubImage2D(3553, ce, 0, 0, Te.width, Te.height, H, le, Te.data) : t.texImage2D(3553, ce, Ae, Te.width, Te.height, 0, H, le, Te.data);
                    L.generateMipmaps = !1
                } else
                    _t ? (Jt && t.texStorage2D(3553, X, Ae, ge.width, ge.height),
                    t.texSubImage2D(3553, 0, 0, 0, ge.width, ge.height, H, le, ge.data)) : t.texImage2D(3553, 0, Ae, ge.width, ge.height, 0, H, le, ge.data);
            else if (L.isCompressedTexture)
                if (L.isCompressedArrayTexture) {
                    _t && Jt && t.texStorage3D(35866, X, Ae, tt[0].width, tt[0].height, ge.depth);
                    for (let ce = 0, xe = tt.length; ce < xe; ce++)
                        Te = tt[ce],
                        L.format !== Ti ? H !== null ? _t ? t.compressedTexSubImage3D(35866, ce, 0, 0, 0, Te.width, Te.height, ge.depth, H, Te.data, 0, 0) : t.compressedTexImage3D(35866, ce, Ae, Te.width, Te.height, ge.depth, 0, Te.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : _t ? t.texSubImage3D(35866, ce, 0, 0, 0, Te.width, Te.height, ge.depth, H, le, Te.data) : t.texImage3D(35866, ce, Ae, Te.width, Te.height, ge.depth, 0, H, le, Te.data)
                } else {
                    _t && Jt && t.texStorage2D(3553, X, Ae, tt[0].width, tt[0].height);
                    for (let ce = 0, xe = tt.length; ce < xe; ce++)
                        Te = tt[ce],
                        L.format !== Ti ? H !== null ? _t ? t.compressedTexSubImage2D(3553, ce, 0, 0, Te.width, Te.height, H, Te.data) : t.compressedTexImage2D(3553, ce, Ae, Te.width, Te.height, 0, Te.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : _t ? t.texSubImage2D(3553, ce, 0, 0, Te.width, Te.height, H, le, Te.data) : t.texImage2D(3553, ce, Ae, Te.width, Te.height, 0, H, le, Te.data)
                }
            else if (L.isDataArrayTexture)
                _t ? (Jt && t.texStorage3D(35866, X, Ae, ge.width, ge.height, ge.depth),
                t.texSubImage3D(35866, 0, 0, 0, 0, ge.width, ge.height, ge.depth, H, le, ge.data)) : t.texImage3D(35866, 0, Ae, ge.width, ge.height, ge.depth, 0, H, le, ge.data);
            else if (L.isData3DTexture)
                _t ? (Jt && t.texStorage3D(32879, X, Ae, ge.width, ge.height, ge.depth),
                t.texSubImage3D(32879, 0, 0, 0, 0, ge.width, ge.height, ge.depth, H, le, ge.data)) : t.texImage3D(32879, 0, Ae, ge.width, ge.height, ge.depth, 0, H, le, ge.data);
            else if (L.isFramebufferTexture) {
                if (Jt)
                    if (_t)
                        t.texStorage2D(3553, X, Ae, ge.width, ge.height);
                    else {
                        let ce = ge.width
                          , xe = ge.height;
                        for (let Ue = 0; Ue < X; Ue++)
                            t.texImage2D(3553, Ue, Ae, ce, xe, 0, H, le, null),
                            ce >>= 1,
                            xe >>= 1
                    }
            } else if (tt.length > 0 && Ke) {
                _t && Jt && t.texStorage2D(3553, X, Ae, tt[0].width, tt[0].height);
                for (let ce = 0, xe = tt.length; ce < xe; ce++)
                    Te = tt[ce],
                    _t ? t.texSubImage2D(3553, ce, 0, 0, H, le, Te) : t.texImage2D(3553, ce, Ae, H, le, Te);
                L.generateMipmaps = !1
            } else
                _t ? (Jt && t.texStorage2D(3553, X, Ae, ge.width, ge.height),
                t.texSubImage2D(3553, 0, 0, 0, H, le, ge)) : t.texImage2D(3553, 0, Ae, H, le, ge);
            P(L, Ke) && R(Se),
            rt.__version = Pe.version,
            L.onUpdate && L.onUpdate(L)
        }
        O.__version = L.version
    }
    function Ve(O, L, se) {
        if (L.image.length !== 6)
            return;
        const Se = Ne(O, L)
          , Ce = L.source;
        t.bindTexture(34067, O.__webglTexture, 33984 + se);
        const Pe = i.get(Ce);
        if (Ce.version !== Pe.__version || Se === !0) {
            t.activeTexture(33984 + se),
            n.pixelStorei(37440, L.flipY),
            n.pixelStorei(37441, L.premultiplyAlpha),
            n.pixelStorei(3317, L.unpackAlignment),
            n.pixelStorei(37443, 0);
            const rt = L.isCompressedTexture || L.image[0].isCompressedTexture
              , De = L.image[0] && L.image[0].isDataTexture
              , ge = [];
            for (let ce = 0; ce < 6; ce++)
                !rt && !De ? ge[ce] = w(L.image[ce], !1, !0, c) : ge[ce] = De ? L.image[ce].image : L.image[ce],
                ge[ce] = Ct(L, ge[ce]);
            const Ke = ge[0]
              , H = M(Ke) || a
              , le = s.convert(L.format, L.encoding)
              , Ae = s.convert(L.type)
              , Te = E(L.internalFormat, le, Ae, L.encoding)
              , tt = a && L.isVideoTexture !== !0
              , _t = Pe.__version === void 0 || Se === !0;
            let Jt = B(L, Ke, H);
            $(34067, L, H);
            let X;
            if (rt) {
                tt && _t && t.texStorage2D(34067, Jt, Te, Ke.width, Ke.height);
                for (let ce = 0; ce < 6; ce++) {
                    X = ge[ce].mipmaps;
                    for (let xe = 0; xe < X.length; xe++) {
                        const Ue = X[xe];
                        L.format !== Ti ? le !== null ? tt ? t.compressedTexSubImage2D(34069 + ce, xe, 0, 0, Ue.width, Ue.height, le, Ue.data) : t.compressedTexImage2D(34069 + ce, xe, Te, Ue.width, Ue.height, 0, Ue.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : tt ? t.texSubImage2D(34069 + ce, xe, 0, 0, Ue.width, Ue.height, le, Ae, Ue.data) : t.texImage2D(34069 + ce, xe, Te, Ue.width, Ue.height, 0, le, Ae, Ue.data)
                    }
                }
            } else {
                X = L.mipmaps,
                tt && _t && (X.length > 0 && Jt++,
                t.texStorage2D(34067, Jt, Te, ge[0].width, ge[0].height));
                for (let ce = 0; ce < 6; ce++)
                    if (De) {
                        tt ? t.texSubImage2D(34069 + ce, 0, 0, 0, ge[ce].width, ge[ce].height, le, Ae, ge[ce].data) : t.texImage2D(34069 + ce, 0, Te, ge[ce].width, ge[ce].height, 0, le, Ae, ge[ce].data);
                        for (let xe = 0; xe < X.length; xe++) {
                            const Ze = X[xe].image[ce].image;
                            tt ? t.texSubImage2D(34069 + ce, xe + 1, 0, 0, Ze.width, Ze.height, le, Ae, Ze.data) : t.texImage2D(34069 + ce, xe + 1, Te, Ze.width, Ze.height, 0, le, Ae, Ze.data)
                        }
                    } else {
                        tt ? t.texSubImage2D(34069 + ce, 0, 0, 0, le, Ae, ge[ce]) : t.texImage2D(34069 + ce, 0, Te, le, Ae, ge[ce]);
                        for (let xe = 0; xe < X.length; xe++) {
                            const Ue = X[xe];
                            tt ? t.texSubImage2D(34069 + ce, xe + 1, 0, 0, le, Ae, Ue.image[ce]) : t.texImage2D(34069 + ce, xe + 1, Te, le, Ae, Ue.image[ce])
                        }
                    }
            }
            P(L, H) && R(34067),
            Pe.__version = Ce.version,
            L.onUpdate && L.onUpdate(L)
        }
        O.__version = L.version
    }
    function we(O, L, se, Se, Ce) {
        const Pe = s.convert(se.format, se.encoding)
          , rt = s.convert(se.type)
          , De = E(se.internalFormat, Pe, rt, se.encoding);
        i.get(L).__hasExternalTextures || (Ce === 32879 || Ce === 35866 ? t.texImage3D(Ce, 0, De, L.width, L.height, L.depth, 0, Pe, rt, null) : t.texImage2D(Ce, 0, De, L.width, L.height, 0, Pe, rt, null)),
        t.bindFramebuffer(36160, O),
        Je(L) ? p.framebufferTexture2DMultisampleEXT(36160, Se, Ce, i.get(se).__webglTexture, 0, Ye(L)) : (Ce === 3553 || Ce >= 34069 && Ce <= 34074) && n.framebufferTexture2D(36160, Se, Ce, i.get(se).__webglTexture, 0),
        t.bindFramebuffer(36160, null)
    }
    function Le(O, L, se) {
        if (n.bindRenderbuffer(36161, O),
        L.depthBuffer && !L.stencilBuffer) {
            let Se = 33189;
            if (se || Je(L)) {
                const Ce = L.depthTexture;
                Ce && Ce.isDepthTexture && (Ce.type === zs ? Se = 36012 : Ce.type === No && (Se = 33190));
                const Pe = Ye(L);
                Je(L) ? p.renderbufferStorageMultisampleEXT(36161, Pe, Se, L.width, L.height) : n.renderbufferStorageMultisample(36161, Pe, Se, L.width, L.height)
            } else
                n.renderbufferStorage(36161, Se, L.width, L.height);
            n.framebufferRenderbuffer(36160, 36096, 36161, O)
        } else if (L.depthBuffer && L.stencilBuffer) {
            const Se = Ye(L);
            se && Je(L) === !1 ? n.renderbufferStorageMultisample(36161, Se, 35056, L.width, L.height) : Je(L) ? p.renderbufferStorageMultisampleEXT(36161, Se, 35056, L.width, L.height) : n.renderbufferStorage(36161, 34041, L.width, L.height),
            n.framebufferRenderbuffer(36160, 33306, 36161, O)
        } else {
            const Se = L.isWebGLMultipleRenderTargets === !0 ? L.texture : [L.texture];
            for (let Ce = 0; Ce < Se.length; Ce++) {
                const Pe = Se[Ce]
                  , rt = s.convert(Pe.format, Pe.encoding)
                  , De = s.convert(Pe.type)
                  , ge = E(Pe.internalFormat, rt, De, Pe.encoding)
                  , Ke = Ye(L);
                se && Je(L) === !1 ? n.renderbufferStorageMultisample(36161, Ke, ge, L.width, L.height) : Je(L) ? p.renderbufferStorageMultisampleEXT(36161, Ke, ge, L.width, L.height) : n.renderbufferStorage(36161, ge, L.width, L.height)
            }
        }
        n.bindRenderbuffer(36161, null)
    }
    function de(O, L) {
        if (L && L.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(36160, O),
        !(L.depthTexture && L.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!i.get(L.depthTexture).__webglTexture || L.depthTexture.image.width !== L.width || L.depthTexture.image.height !== L.height) && (L.depthTexture.image.width = L.width,
        L.depthTexture.image.height = L.height,
        L.depthTexture.needsUpdate = !0),
        Y(L.depthTexture, 0);
        const Se = i.get(L.depthTexture).__webglTexture
          , Ce = Ye(L);
        if (L.depthTexture.format === Qo)
            Je(L) ? p.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, Se, 0, Ce) : n.framebufferTexture2D(36160, 36096, 3553, Se, 0);
        else if (L.depthTexture.format === Al)
            Je(L) ? p.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, Se, 0, Ce) : n.framebufferTexture2D(36160, 33306, 3553, Se, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function ae(O) {
        const L = i.get(O)
          , se = O.isWebGLCubeRenderTarget === !0;
        if (O.depthTexture && !L.__autoAllocateDepthBuffer) {
            if (se)
                throw new Error("target.depthTexture not supported in Cube render targets");
            de(L.__webglFramebuffer, O)
        } else if (se) {
            L.__webglDepthbuffer = [];
            for (let Se = 0; Se < 6; Se++)
                t.bindFramebuffer(36160, L.__webglFramebuffer[Se]),
                L.__webglDepthbuffer[Se] = n.createRenderbuffer(),
                Le(L.__webglDepthbuffer[Se], O, !1)
        } else
            t.bindFramebuffer(36160, L.__webglFramebuffer),
            L.__webglDepthbuffer = n.createRenderbuffer(),
            Le(L.__webglDepthbuffer, O, !1);
        t.bindFramebuffer(36160, null)
    }
    function be(O, L, se) {
        const Se = i.get(O);
        L !== void 0 && we(Se.__webglFramebuffer, O, O.texture, 36064, 3553),
        se !== void 0 && ae(O)
    }
    function Ge(O) {
        const L = O.texture
          , se = i.get(O)
          , Se = i.get(L);
        O.addEventListener("dispose", q),
        O.isWebGLMultipleRenderTargets !== !0 && (Se.__webglTexture === void 0 && (Se.__webglTexture = n.createTexture()),
        Se.__version = L.version,
        o.memory.textures++);
        const Ce = O.isWebGLCubeRenderTarget === !0
          , Pe = O.isWebGLMultipleRenderTargets === !0
          , rt = M(O) || a;
        if (Ce) {
            se.__webglFramebuffer = [];
            for (let De = 0; De < 6; De++)
                se.__webglFramebuffer[De] = n.createFramebuffer()
        } else {
            if (se.__webglFramebuffer = n.createFramebuffer(),
            Pe)
                if (r.drawBuffers) {
                    const De = O.texture;
                    for (let ge = 0, Ke = De.length; ge < Ke; ge++) {
                        const H = i.get(De[ge]);
                        H.__webglTexture === void 0 && (H.__webglTexture = n.createTexture(),
                        o.memory.textures++)
                    }
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
            if (a && O.samples > 0 && Je(O) === !1) {
                const De = Pe ? L : [L];
                se.__webglMultisampledFramebuffer = n.createFramebuffer(),
                se.__webglColorRenderbuffer = [],
                t.bindFramebuffer(36160, se.__webglMultisampledFramebuffer);
                for (let ge = 0; ge < De.length; ge++) {
                    const Ke = De[ge];
                    se.__webglColorRenderbuffer[ge] = n.createRenderbuffer(),
                    n.bindRenderbuffer(36161, se.__webglColorRenderbuffer[ge]);
                    const H = s.convert(Ke.format, Ke.encoding)
                      , le = s.convert(Ke.type)
                      , Ae = E(Ke.internalFormat, H, le, Ke.encoding, O.isXRRenderTarget === !0)
                      , Te = Ye(O);
                    n.renderbufferStorageMultisample(36161, Te, Ae, O.width, O.height),
                    n.framebufferRenderbuffer(36160, 36064 + ge, 36161, se.__webglColorRenderbuffer[ge])
                }
                n.bindRenderbuffer(36161, null),
                O.depthBuffer && (se.__webglDepthRenderbuffer = n.createRenderbuffer(),
                Le(se.__webglDepthRenderbuffer, O, !0)),
                t.bindFramebuffer(36160, null)
            }
        }
        if (Ce) {
            t.bindTexture(34067, Se.__webglTexture),
            $(34067, L, rt);
            for (let De = 0; De < 6; De++)
                we(se.__webglFramebuffer[De], O, L, 36064, 34069 + De);
            P(L, rt) && R(34067),
            t.unbindTexture()
        } else if (Pe) {
            const De = O.texture;
            for (let ge = 0, Ke = De.length; ge < Ke; ge++) {
                const H = De[ge]
                  , le = i.get(H);
                t.bindTexture(3553, le.__webglTexture),
                $(3553, H, rt),
                we(se.__webglFramebuffer, O, H, 36064 + ge, 3553),
                P(H, rt) && R(3553)
            }
            t.unbindTexture()
        } else {
            let De = 3553;
            (O.isWebGL3DRenderTarget || O.isWebGLArrayRenderTarget) && (a ? De = O.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),
            t.bindTexture(De, Se.__webglTexture),
            $(De, L, rt),
            we(se.__webglFramebuffer, O, L, 36064, De),
            P(L, rt) && R(De),
            t.unbindTexture()
        }
        O.depthBuffer && ae(O)
    }
    function Be(O) {
        const L = M(O) || a
          , se = O.isWebGLMultipleRenderTargets === !0 ? O.texture : [O.texture];
        for (let Se = 0, Ce = se.length; Se < Ce; Se++) {
            const Pe = se[Se];
            if (P(Pe, L)) {
                const rt = O.isWebGLCubeRenderTarget ? 34067 : 3553
                  , De = i.get(Pe).__webglTexture;
                t.bindTexture(rt, De),
                R(rt),
                t.unbindTexture()
            }
        }
    }
    function $e(O) {
        if (a && O.samples > 0 && Je(O) === !1) {
            const L = O.isWebGLMultipleRenderTargets ? O.texture : [O.texture]
              , se = O.width
              , Se = O.height;
            let Ce = 16384;
            const Pe = []
              , rt = O.stencilBuffer ? 33306 : 36096
              , De = i.get(O)
              , ge = O.isWebGLMultipleRenderTargets === !0;
            if (ge)
                for (let Ke = 0; Ke < L.length; Ke++)
                    t.bindFramebuffer(36160, De.__webglMultisampledFramebuffer),
                    n.framebufferRenderbuffer(36160, 36064 + Ke, 36161, null),
                    t.bindFramebuffer(36160, De.__webglFramebuffer),
                    n.framebufferTexture2D(36009, 36064 + Ke, 3553, null, 0);
            t.bindFramebuffer(36008, De.__webglMultisampledFramebuffer),
            t.bindFramebuffer(36009, De.__webglFramebuffer);
            for (let Ke = 0; Ke < L.length; Ke++) {
                Pe.push(36064 + Ke),
                O.depthBuffer && Pe.push(rt);
                const H = De.__ignoreDepthValues !== void 0 ? De.__ignoreDepthValues : !1;
                if (H === !1 && (O.depthBuffer && (Ce |= 256),
                O.stencilBuffer && (Ce |= 1024)),
                ge && n.framebufferRenderbuffer(36008, 36064, 36161, De.__webglColorRenderbuffer[Ke]),
                H === !0 && (n.invalidateFramebuffer(36008, [rt]),
                n.invalidateFramebuffer(36009, [rt])),
                ge) {
                    const le = i.get(L[Ke]).__webglTexture;
                    n.framebufferTexture2D(36009, 36064, 3553, le, 0)
                }
                n.blitFramebuffer(0, 0, se, Se, 0, 0, se, Se, Ce, 9728),
                m && n.invalidateFramebuffer(36008, Pe)
            }
            if (t.bindFramebuffer(36008, null),
            t.bindFramebuffer(36009, null),
            ge)
                for (let Ke = 0; Ke < L.length; Ke++) {
                    t.bindFramebuffer(36160, De.__webglMultisampledFramebuffer),
                    n.framebufferRenderbuffer(36160, 36064 + Ke, 36161, De.__webglColorRenderbuffer[Ke]);
                    const H = i.get(L[Ke]).__webglTexture;
                    t.bindFramebuffer(36160, De.__webglFramebuffer),
                    n.framebufferTexture2D(36009, 36064 + Ke, 3553, H, 0)
                }
            t.bindFramebuffer(36009, De.__webglMultisampledFramebuffer)
        }
    }
    function Ye(O) {
        return Math.min(h, O.samples)
    }
    function Je(O) {
        const L = i.get(O);
        return a && O.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && L.__useRenderToTexture !== !1
    }
    function At(O) {
        const L = o.render.frame;
        y.get(O) !== L && (y.set(O, L),
        O.update())
    }
    function Ct(O, L) {
        const se = O.encoding
          , Se = O.format
          , Ce = O.type;
        return O.isCompressedTexture === !0 || O.isVideoTexture === !0 || O.format === Gg || se !== $s && (se === Tt ? a === !1 ? e.has("EXT_sRGB") === !0 && Se === Ti ? (O.format = Gg,
        O.minFilter = on,
        O.generateMipmaps = !1) : L = ww.sRGBToLinear(L) : (Se !== Ti || Ce !== qs) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", se)),
        L
    }
    this.allocateTextureUnit = F,
    this.resetTextureUnits = oe,
    this.setTexture2D = Y,
    this.setTexture2DArray = re,
    this.setTexture3D = j,
    this.setTextureCube = ie,
    this.rebindTextures = be,
    this.setupRenderTarget = Ge,
    this.updateRenderTargetMipmap = Be,
    this.updateMultisampleRenderTarget = $e,
    this.setupDepthRenderbuffer = ae,
    this.setupFrameBufferTexture = we,
    this.useMultisampledRTT = Je
}
function XR(n, e, t) {
    const i = t.isWebGL2;
    function r(s, o=null) {
        let a;
        if (s === qs)
            return 5121;
        if (s === vR)
            return 32819;
        if (s === yR)
            return 32820;
        if (s === pR)
            return 5120;
        if (s === mR)
            return 5122;
        if (s === vw)
            return 5123;
        if (s === gR)
            return 5124;
        if (s === No)
            return 5125;
        if (s === zs)
            return 5126;
        if (s === ic)
            return i ? 5131 : (a = e.get("OES_texture_half_float"),
            a !== null ? a.HALF_FLOAT_OES : null);
        if (s === xR)
            return 6406;
        if (s === Ti)
            return 6408;
        if (s === _R)
            return 6409;
        if (s === AR)
            return 6410;
        if (s === Qo)
            return 6402;
        if (s === Al)
            return 34041;
        if (s === Gg)
            return a = e.get("EXT_sRGB"),
            a !== null ? a.SRGB_ALPHA_EXT : null;
        if (s === wR)
            return 6403;
        if (s === SR)
            return 36244;
        if (s === MR)
            return 33319;
        if (s === bR)
            return 33320;
        if (s === CR)
            return 36249;
        if (s === tg || s === ng || s === ig || s === rg)
            if (o === Tt)
                if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                a !== null) {
                    if (s === tg)
                        return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (s === ng)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (s === ig)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (s === rg)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (a = e.get("WEBGL_compressed_texture_s3tc"),
            a !== null) {
                if (s === tg)
                    return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (s === ng)
                    return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (s === ig)
                    return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (s === rg)
                    return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (s === J1 || s === X1 || s === Y1 || s === K1)
            if (a = e.get("WEBGL_compressed_texture_pvrtc"),
            a !== null) {
                if (s === J1)
                    return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (s === X1)
                    return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (s === Y1)
                    return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (s === K1)
                    return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (s === ER)
            return a = e.get("WEBGL_compressed_texture_etc1"),
            a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
        if (s === Q1 || s === Z1)
            if (a = e.get("WEBGL_compressed_texture_etc"),
            a !== null) {
                if (s === Q1)
                    return o === Tt ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                if (s === Z1)
                    return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (s === q1 || s === $1 || s === e_ || s === t_ || s === n_ || s === i_ || s === r_ || s === s_ || s === o_ || s === a_ || s === l_ || s === u_ || s === c_ || s === f_)
            if (a = e.get("WEBGL_compressed_texture_astc"),
            a !== null) {
                if (s === q1)
                    return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (s === $1)
                    return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (s === e_)
                    return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (s === t_)
                    return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (s === n_)
                    return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (s === i_)
                    return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (s === r_)
                    return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (s === s_)
                    return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (s === o_)
                    return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (s === a_)
                    return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (s === l_)
                    return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (s === u_)
                    return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (s === c_)
                    return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (s === f_)
                    return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (s === sg)
            if (a = e.get("EXT_texture_compression_bptc"),
            a !== null) {
                if (s === sg)
                    return o === Tt ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT
            } else
                return null;
        if (s === TR || s === d_ || s === h_ || s === p_)
            if (a = e.get("EXT_texture_compression_rgtc"),
            a !== null) {
                if (s === sg)
                    return a.COMPRESSED_RED_RGTC1_EXT;
                if (s === d_)
                    return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (s === h_)
                    return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (s === p_)
                    return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else
                return null;
        return s === cl ? i ? 34042 : (a = e.get("WEBGL_depth_texture"),
        a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : n[s] !== void 0 ? n[s] : null
    }
    return {
        convert: r
    }
}
class YR extends Wt {
    constructor(e=[]) {
        super(),
        this.isArrayCamera = !0,
        this.cameras = e
    }
}
class Hs extends Rt {
    constructor() {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const H9 = {
    type: "move"
};
class rx {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new Hs,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new Hs,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new D,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new D),
        this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new Hs,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new D,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new D),
        this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this
    }
    connect(e) {
        if (e && e.hand) {
            const t = this._hand;
            if (t)
                for (const i of e.hand.values())
                    this._getHandJoint(t, i)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }),
        this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
    }
    update(e, t, i) {
        let r = null
          , s = null
          , o = null;
        const a = this._targetRay
          , l = this._grip
          , c = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
            if (c && e.hand) {
                o = !0;
                for (const v of e.hand.values()) {
                    const x = t.getJointPose(v, i)
                      , _ = this._getHandJoint(c, v);
                    x !== null && (_.matrix.fromArray(x.transform.matrix),
                    _.matrix.decompose(_.position, _.rotation, _.scale),
                    _.jointRadius = x.radius),
                    _.visible = x !== null
                }
                const d = c.joints["index-finger-tip"]
                  , h = c.joints["thumb-tip"]
                  , p = d.position.distanceTo(h.position)
                  , m = .02
                  , y = .005;
                c.inputState.pinching && p > m + y ? (c.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !c.inputState.pinching && p <= m - y && (c.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, i),
                s !== null && (l.matrix.fromArray(s.transform.matrix),
                l.matrix.decompose(l.position, l.rotation, l.scale),
                s.linearVelocity ? (l.hasLinearVelocity = !0,
                l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1,
                s.angularVelocity ? (l.hasAngularVelocity = !0,
                l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
            a !== null && (r = t.getPose(e.targetRaySpace, i),
            r === null && s !== null && (r = s),
            r !== null && (a.matrix.fromArray(r.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            r.linearVelocity ? (a.hasLinearVelocity = !0,
            a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1,
            r.angularVelocity ? (a.hasAngularVelocity = !0,
            a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1,
            this.dispatchEvent(H9)))
        }
        return a !== null && (a.visible = r !== null),
        l !== null && (l.visible = s !== null),
        c !== null && (c.visible = o !== null),
        this
    }
    _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
            const i = new Hs;
            i.matrixAutoUpdate = !1,
            i.visible = !1,
            e.joints[t.jointName] = i,
            e.add(i)
        }
        return e.joints[t.jointName]
    }
}
class KR extends tn {
    constructor(e, t, i, r, s, o, a, l, c, d) {
        if (d = d !== void 0 ? d : Qo,
        d !== Qo && d !== Al)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        i === void 0 && d === Qo && (i = No),
        i === void 0 && d === Al && (i = cl),
        super(null, r, s, o, a, l, d, i, c),
        this.isDepthTexture = !0,
        this.image = {
            width: e,
            height: t
        },
        this.magFilter = a !== void 0 ? a : gn,
        this.minFilter = l !== void 0 ? l : gn,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
}
class V9 extends gs {
    constructor(e, t) {
        super();
        const i = this;
        let r = null
          , s = 1
          , o = null
          , a = "local-floor"
          , l = 1
          , c = null
          , d = null
          , h = null
          , p = null
          , m = null
          , y = null;
        const v = t.getContextAttributes();
        let x = null
          , _ = null;
        const A = []
          , w = []
          , M = new Set
          , C = new Map
          , P = new Wt;
        P.layers.enable(1),
        P.viewport = new Ut;
        const R = new Wt;
        R.layers.enable(2),
        R.viewport = new Ut;
        const E = [P, R]
          , B = new YR;
        B.layers.enable(1),
        B.layers.enable(2);
        let I = null
          , z = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(j) {
            let ie = A[j];
            return ie === void 0 && (ie = new rx,
            A[j] = ie),
            ie.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(j) {
            let ie = A[j];
            return ie === void 0 && (ie = new rx,
            A[j] = ie),
            ie.getGripSpace()
        }
        ,
        this.getHand = function(j) {
            let ie = A[j];
            return ie === void 0 && (ie = new rx,
            A[j] = ie),
            ie.getHandSpace()
        }
        ;
        function q(j) {
            const ie = w.indexOf(j.inputSource);
            if (ie === -1)
                return;
            const ye = A[ie];
            ye !== void 0 && ye.dispatchEvent({
                type: j.type,
                data: j.inputSource
            })
        }
        function W() {
            r.removeEventListener("select", q),
            r.removeEventListener("selectstart", q),
            r.removeEventListener("selectend", q),
            r.removeEventListener("squeeze", q),
            r.removeEventListener("squeezestart", q),
            r.removeEventListener("squeezeend", q),
            r.removeEventListener("end", W),
            r.removeEventListener("inputsourceschange", G);
            for (let j = 0; j < A.length; j++) {
                const ie = w[j];
                ie !== null && (w[j] = null,
                A[j].disconnect(ie))
            }
            I = null,
            z = null,
            e.setRenderTarget(x),
            m = null,
            p = null,
            h = null,
            r = null,
            _ = null,
            re.stop(),
            i.isPresenting = !1,
            i.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(j) {
            s = j,
            i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(j) {
            a = j,
            i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return c || o
        }
        ,
        this.setReferenceSpace = function(j) {
            c = j
        }
        ,
        this.getBaseLayer = function() {
            return p !== null ? p : m
        }
        ,
        this.getBinding = function() {
            return h
        }
        ,
        this.getFrame = function() {
            return y
        }
        ,
        this.getSession = function() {
            return r
        }
        ,
        this.setSession = async function(j) {
            if (r = j,
            r !== null) {
                if (x = e.getRenderTarget(),
                r.addEventListener("select", q),
                r.addEventListener("selectstart", q),
                r.addEventListener("selectend", q),
                r.addEventListener("squeeze", q),
                r.addEventListener("squeezestart", q),
                r.addEventListener("squeezeend", q),
                r.addEventListener("end", W),
                r.addEventListener("inputsourceschange", G),
                v.xrCompatible !== !0 && await t.makeXRCompatible(),
                r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
                    const ie = {
                        antialias: r.renderState.layers === void 0 ? v.antialias : !0,
                        alpha: v.alpha,
                        depth: v.depth,
                        stencil: v.stencil,
                        framebufferScaleFactor: s
                    };
                    m = new XRWebGLLayer(r,t,ie),
                    r.updateRenderState({
                        baseLayer: m
                    }),
                    _ = new jr(m.framebufferWidth,m.framebufferHeight,{
                        format: Ti,
                        type: qs,
                        encoding: e.outputEncoding,
                        stencilBuffer: v.stencil
                    })
                } else {
                    let ie = null
                      , ye = null
                      , _e = null;
                    v.depth && (_e = v.stencil ? 35056 : 33190,
                    ie = v.stencil ? Al : Qo,
                    ye = v.stencil ? cl : No);
                    const $ = {
                        colorFormat: 32856,
                        depthFormat: _e,
                        scaleFactor: s
                    };
                    h = new XRWebGLBinding(r,t),
                    p = h.createProjectionLayer($),
                    r.updateRenderState({
                        layers: [p]
                    }),
                    _ = new jr(p.textureWidth,p.textureHeight,{
                        format: Ti,
                        type: qs,
                        depthTexture: new KR(p.textureWidth,p.textureHeight,ye,void 0,void 0,void 0,void 0,void 0,void 0,ie),
                        stencilBuffer: v.stencil,
                        encoding: e.outputEncoding,
                        samples: v.antialias ? 4 : 0
                    });
                    const Ne = e.properties.get(_);
                    Ne.__ignoreDepthValues = p.ignoreDepthValues
                }
                _.isXRRenderTarget = !0,
                this.setFoveation(l),
                c = null,
                o = await r.requestReferenceSpace(a),
                re.setContext(r),
                re.start(),
                i.isPresenting = !0,
                i.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ;
        function G(j) {
            for (let ie = 0; ie < j.removed.length; ie++) {
                const ye = j.removed[ie]
                  , _e = w.indexOf(ye);
                _e >= 0 && (w[_e] = null,
                A[_e].disconnect(ye))
            }
            for (let ie = 0; ie < j.added.length; ie++) {
                const ye = j.added[ie];
                let _e = w.indexOf(ye);
                if (_e === -1) {
                    for (let Ne = 0; Ne < A.length; Ne++)
                        if (Ne >= w.length) {
                            w.push(ye),
                            _e = Ne;
                            break
                        } else if (w[Ne] === null) {
                            w[Ne] = ye,
                            _e = Ne;
                            break
                        }
                    if (_e === -1)
                        break
                }
                const $ = A[_e];
                $ && $.connect(ye)
            }
        }
        const K = new D
          , ne = new D;
        function oe(j, ie, ye) {
            K.setFromMatrixPosition(ie.matrixWorld),
            ne.setFromMatrixPosition(ye.matrixWorld);
            const _e = K.distanceTo(ne)
              , $ = ie.projectionMatrix.elements
              , Ne = ye.projectionMatrix.elements
              , Oe = $[14] / ($[10] - 1)
              , Ve = $[14] / ($[10] + 1)
              , we = ($[9] + 1) / $[5]
              , Le = ($[9] - 1) / $[5]
              , de = ($[8] - 1) / $[0]
              , ae = (Ne[8] + 1) / Ne[0]
              , be = Oe * de
              , Ge = Oe * ae
              , Be = _e / (-de + ae)
              , $e = Be * -de;
            ie.matrixWorld.decompose(j.position, j.quaternion, j.scale),
            j.translateX($e),
            j.translateZ(Be),
            j.matrixWorld.compose(j.position, j.quaternion, j.scale),
            j.matrixWorldInverse.copy(j.matrixWorld).invert();
            const Ye = Oe + Be
              , Je = Ve + Be
              , At = be - $e
              , Ct = Ge + (_e - $e)
              , O = we * Ve / Je * Ye
              , L = Le * Ve / Je * Ye;
            j.projectionMatrix.makePerspective(At, Ct, O, L, Ye, Je)
        }
        function F(j, ie) {
            ie === null ? j.matrixWorld.copy(j.matrix) : j.matrixWorld.multiplyMatrices(ie.matrixWorld, j.matrix),
            j.matrixWorldInverse.copy(j.matrixWorld).invert()
        }
        this.updateCamera = function(j) {
            if (r === null)
                return;
            B.near = R.near = P.near = j.near,
            B.far = R.far = P.far = j.far,
            (I !== B.near || z !== B.far) && (r.updateRenderState({
                depthNear: B.near,
                depthFar: B.far
            }),
            I = B.near,
            z = B.far);
            const ie = j.parent
              , ye = B.cameras;
            F(B, ie);
            for (let $ = 0; $ < ye.length; $++)
                F(ye[$], ie);
            B.matrixWorld.decompose(B.position, B.quaternion, B.scale),
            j.matrix.copy(B.matrix),
            j.matrix.decompose(j.position, j.quaternion, j.scale);
            const _e = j.children;
            for (let $ = 0, Ne = _e.length; $ < Ne; $++)
                _e[$].updateMatrixWorld(!0);
            ye.length === 2 ? oe(B, P, R) : B.projectionMatrix.copy(P.projectionMatrix)
        }
        ,
        this.getCamera = function() {
            return B
        }
        ,
        this.getFoveation = function() {
            if (!(p === null && m === null))
                return l
        }
        ,
        this.setFoveation = function(j) {
            l = j,
            p !== null && (p.fixedFoveation = j),
            m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = j)
        }
        ,
        this.getPlanes = function() {
            return M
        }
        ;
        let V = null;
        function Y(j, ie) {
            if (d = ie.getViewerPose(c || o),
            y = ie,
            d !== null) {
                const ye = d.views;
                m !== null && (e.setRenderTargetFramebuffer(_, m.framebuffer),
                e.setRenderTarget(_));
                let _e = !1;
                ye.length !== B.cameras.length && (B.cameras.length = 0,
                _e = !0);
                for (let $ = 0; $ < ye.length; $++) {
                    const Ne = ye[$];
                    let Oe = null;
                    if (m !== null)
                        Oe = m.getViewport(Ne);
                    else {
                        const we = h.getViewSubImage(p, Ne);
                        Oe = we.viewport,
                        $ === 0 && (e.setRenderTargetTextures(_, we.colorTexture, p.ignoreDepthValues ? void 0 : we.depthStencilTexture),
                        e.setRenderTarget(_))
                    }
                    let Ve = E[$];
                    Ve === void 0 && (Ve = new Wt,
                    Ve.layers.enable($),
                    Ve.viewport = new Ut,
                    E[$] = Ve),
                    Ve.matrix.fromArray(Ne.transform.matrix),
                    Ve.projectionMatrix.fromArray(Ne.projectionMatrix),
                    Ve.viewport.set(Oe.x, Oe.y, Oe.width, Oe.height),
                    $ === 0 && B.matrix.copy(Ve.matrix),
                    _e === !0 && B.cameras.push(Ve)
                }
            }
            for (let ye = 0; ye < A.length; ye++) {
                const _e = w[ye]
                  , $ = A[ye];
                _e !== null && $ !== void 0 && $.update(_e, ie, c || o)
            }
            if (V && V(j, ie),
            ie.detectedPlanes) {
                i.dispatchEvent({
                    type: "planesdetected",
                    data: ie.detectedPlanes
                });
                let ye = null;
                for (const _e of M)
                    ie.detectedPlanes.has(_e) || (ye === null && (ye = []),
                    ye.push(_e));
                if (ye !== null)
                    for (const _e of ye)
                        M.delete(_e),
                        C.delete(_e),
                        i.dispatchEvent({
                            type: "planeremoved",
                            data: _e
                        });
                for (const _e of ie.detectedPlanes)
                    if (!M.has(_e))
                        M.add(_e),
                        C.set(_e, ie.lastChangedTime),
                        i.dispatchEvent({
                            type: "planeadded",
                            data: _e
                        });
                    else {
                        const $ = C.get(_e);
                        _e.lastChangedTime > $ && (C.set(_e, _e.lastChangedTime),
                        i.dispatchEvent({
                            type: "planechanged",
                            data: _e
                        }))
                    }
            }
            y = null
        }
        const re = new HR;
        re.setAnimationLoop(Y),
        this.setAnimationLoop = function(j) {
            V = j
        }
        ,
        this.dispose = function() {}
    }
}
function W9(n, e) {
    function t(v, x) {
        x.color.getRGB(v.fogColor.value, zR(n)),
        x.isFog ? (v.fogNear.value = x.near,
        v.fogFar.value = x.far) : x.isFogExp2 && (v.fogDensity.value = x.density)
    }
    function i(v, x, _, A, w) {
        x.isMeshBasicMaterial || x.isMeshLambertMaterial ? r(v, x) : x.isMeshToonMaterial ? (r(v, x),
        d(v, x)) : x.isMeshPhongMaterial ? (r(v, x),
        c(v, x)) : x.isMeshStandardMaterial ? (r(v, x),
        h(v, x),
        x.isMeshPhysicalMaterial && p(v, x, w)) : x.isMeshMatcapMaterial ? (r(v, x),
        m(v, x)) : x.isMeshDepthMaterial ? r(v, x) : x.isMeshDistanceMaterial ? (r(v, x),
        y(v, x)) : x.isMeshNormalMaterial ? r(v, x) : x.isLineBasicMaterial ? (s(v, x),
        x.isLineDashedMaterial && o(v, x)) : x.isPointsMaterial ? a(v, x, _, A) : x.isSpriteMaterial ? l(v, x) : x.isShadowMaterial ? (v.color.value.copy(x.color),
        v.opacity.value = x.opacity) : x.isShaderMaterial && (x.uniformsNeedUpdate = !1)
    }
    function r(v, x) {
        v.opacity.value = x.opacity,
        x.color && v.diffuse.value.copy(x.color),
        x.emissive && v.emissive.value.copy(x.emissive).multiplyScalar(x.emissiveIntensity),
        x.map && (v.map.value = x.map),
        x.alphaMap && (v.alphaMap.value = x.alphaMap),
        x.bumpMap && (v.bumpMap.value = x.bumpMap,
        v.bumpScale.value = x.bumpScale,
        x.side === Li && (v.bumpScale.value *= -1)),
        x.displacementMap && (v.displacementMap.value = x.displacementMap,
        v.displacementScale.value = x.displacementScale,
        v.displacementBias.value = x.displacementBias),
        x.emissiveMap && (v.emissiveMap.value = x.emissiveMap),
        x.normalMap && (v.normalMap.value = x.normalMap,
        v.normalScale.value.copy(x.normalScale),
        x.side === Li && v.normalScale.value.negate()),
        x.specularMap && (v.specularMap.value = x.specularMap),
        x.alphaTest > 0 && (v.alphaTest.value = x.alphaTest);
        const _ = e.get(x).envMap;
        if (_ && (v.envMap.value = _,
        v.flipEnvMap.value = _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1,
        v.reflectivity.value = x.reflectivity,
        v.ior.value = x.ior,
        v.refractionRatio.value = x.refractionRatio),
        x.lightMap) {
            v.lightMap.value = x.lightMap;
            const M = n.physicallyCorrectLights !== !0 ? Math.PI : 1;
            v.lightMapIntensity.value = x.lightMapIntensity * M
        }
        x.aoMap && (v.aoMap.value = x.aoMap,
        v.aoMapIntensity.value = x.aoMapIntensity);
        let A;
        x.map ? A = x.map : x.specularMap ? A = x.specularMap : x.displacementMap ? A = x.displacementMap : x.normalMap ? A = x.normalMap : x.bumpMap ? A = x.bumpMap : x.roughnessMap ? A = x.roughnessMap : x.metalnessMap ? A = x.metalnessMap : x.alphaMap ? A = x.alphaMap : x.emissiveMap ? A = x.emissiveMap : x.clearcoatMap ? A = x.clearcoatMap : x.clearcoatNormalMap ? A = x.clearcoatNormalMap : x.clearcoatRoughnessMap ? A = x.clearcoatRoughnessMap : x.iridescenceMap ? A = x.iridescenceMap : x.iridescenceThicknessMap ? A = x.iridescenceThicknessMap : x.specularIntensityMap ? A = x.specularIntensityMap : x.specularColorMap ? A = x.specularColorMap : x.transmissionMap ? A = x.transmissionMap : x.thicknessMap ? A = x.thicknessMap : x.sheenColorMap ? A = x.sheenColorMap : x.sheenRoughnessMap && (A = x.sheenRoughnessMap),
        A !== void 0 && (A.isWebGLRenderTarget && (A = A.texture),
        A.matrixAutoUpdate === !0 && A.updateMatrix(),
        v.uvTransform.value.copy(A.matrix));
        let w;
        x.aoMap ? w = x.aoMap : x.lightMap && (w = x.lightMap),
        w !== void 0 && (w.isWebGLRenderTarget && (w = w.texture),
        w.matrixAutoUpdate === !0 && w.updateMatrix(),
        v.uv2Transform.value.copy(w.matrix))
    }
    function s(v, x) {
        v.diffuse.value.copy(x.color),
        v.opacity.value = x.opacity
    }
    function o(v, x) {
        v.dashSize.value = x.dashSize,
        v.totalSize.value = x.dashSize + x.gapSize,
        v.scale.value = x.scale
    }
    function a(v, x, _, A) {
        v.diffuse.value.copy(x.color),
        v.opacity.value = x.opacity,
        v.size.value = x.size * _,
        v.scale.value = A * .5,
        x.map && (v.map.value = x.map),
        x.alphaMap && (v.alphaMap.value = x.alphaMap),
        x.alphaTest > 0 && (v.alphaTest.value = x.alphaTest);
        let w;
        x.map ? w = x.map : x.alphaMap && (w = x.alphaMap),
        w !== void 0 && (w.matrixAutoUpdate === !0 && w.updateMatrix(),
        v.uvTransform.value.copy(w.matrix))
    }
    function l(v, x) {
        v.diffuse.value.copy(x.color),
        v.opacity.value = x.opacity,
        v.rotation.value = x.rotation,
        x.map && (v.map.value = x.map),
        x.alphaMap && (v.alphaMap.value = x.alphaMap),
        x.alphaTest > 0 && (v.alphaTest.value = x.alphaTest);
        let _;
        x.map ? _ = x.map : x.alphaMap && (_ = x.alphaMap),
        _ !== void 0 && (_.matrixAutoUpdate === !0 && _.updateMatrix(),
        v.uvTransform.value.copy(_.matrix))
    }
    function c(v, x) {
        v.specular.value.copy(x.specular),
        v.shininess.value = Math.max(x.shininess, 1e-4)
    }
    function d(v, x) {
        x.gradientMap && (v.gradientMap.value = x.gradientMap)
    }
    function h(v, x) {
        v.roughness.value = x.roughness,
        v.metalness.value = x.metalness,
        x.roughnessMap && (v.roughnessMap.value = x.roughnessMap),
        x.metalnessMap && (v.metalnessMap.value = x.metalnessMap),
        e.get(x).envMap && (v.envMapIntensity.value = x.envMapIntensity)
    }
    function p(v, x, _) {
        v.ior.value = x.ior,
        x.sheen > 0 && (v.sheenColor.value.copy(x.sheenColor).multiplyScalar(x.sheen),
        v.sheenRoughness.value = x.sheenRoughness,
        x.sheenColorMap && (v.sheenColorMap.value = x.sheenColorMap),
        x.sheenRoughnessMap && (v.sheenRoughnessMap.value = x.sheenRoughnessMap)),
        x.clearcoat > 0 && (v.clearcoat.value = x.clearcoat,
        v.clearcoatRoughness.value = x.clearcoatRoughness,
        x.clearcoatMap && (v.clearcoatMap.value = x.clearcoatMap),
        x.clearcoatRoughnessMap && (v.clearcoatRoughnessMap.value = x.clearcoatRoughnessMap),
        x.clearcoatNormalMap && (v.clearcoatNormalScale.value.copy(x.clearcoatNormalScale),
        v.clearcoatNormalMap.value = x.clearcoatNormalMap,
        x.side === Li && v.clearcoatNormalScale.value.negate())),
        x.iridescence > 0 && (v.iridescence.value = x.iridescence,
        v.iridescenceIOR.value = x.iridescenceIOR,
        v.iridescenceThicknessMinimum.value = x.iridescenceThicknessRange[0],
        v.iridescenceThicknessMaximum.value = x.iridescenceThicknessRange[1],
        x.iridescenceMap && (v.iridescenceMap.value = x.iridescenceMap),
        x.iridescenceThicknessMap && (v.iridescenceThicknessMap.value = x.iridescenceThicknessMap)),
        x.transmission > 0 && (v.transmission.value = x.transmission,
        v.transmissionSamplerMap.value = _.texture,
        v.transmissionSamplerSize.value.set(_.width, _.height),
        x.transmissionMap && (v.transmissionMap.value = x.transmissionMap),
        v.thickness.value = x.thickness,
        x.thicknessMap && (v.thicknessMap.value = x.thicknessMap),
        v.attenuationDistance.value = x.attenuationDistance,
        v.attenuationColor.value.copy(x.attenuationColor)),
        v.specularIntensity.value = x.specularIntensity,
        v.specularColor.value.copy(x.specularColor),
        x.specularIntensityMap && (v.specularIntensityMap.value = x.specularIntensityMap),
        x.specularColorMap && (v.specularColorMap.value = x.specularColorMap)
    }
    function m(v, x) {
        x.matcap && (v.matcap.value = x.matcap)
    }
    function y(v, x) {
        v.referencePosition.value.copy(x.referencePosition),
        v.nearDistance.value = x.nearDistance,
        v.farDistance.value = x.farDistance
    }
    return {
        refreshFogUniforms: t,
        refreshMaterialUniforms: i
    }
}
function j9(n, e, t, i) {
    let r = {}
      , s = {}
      , o = [];
    const a = t.isWebGL2 ? n.getParameter(35375) : 0;
    function l(A, w) {
        const M = w.program;
        i.uniformBlockBinding(A, M)
    }
    function c(A, w) {
        let M = r[A.id];
        M === void 0 && (y(A),
        M = d(A),
        r[A.id] = M,
        A.addEventListener("dispose", x));
        const C = w.program;
        i.updateUBOMapping(A, C);
        const P = e.render.frame;
        s[A.id] !== P && (p(A),
        s[A.id] = P)
    }
    function d(A) {
        const w = h();
        A.__bindingPointIndex = w;
        const M = n.createBuffer()
          , C = A.__size
          , P = A.usage;
        return n.bindBuffer(35345, M),
        n.bufferData(35345, C, P),
        n.bindBuffer(35345, null),
        n.bindBufferBase(35345, w, M),
        M
    }
    function h() {
        for (let A = 0; A < a; A++)
            if (o.indexOf(A) === -1)
                return o.push(A),
                A;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
        0
    }
    function p(A) {
        const w = r[A.id]
          , M = A.uniforms
          , C = A.__cache;
        n.bindBuffer(35345, w);
        for (let P = 0, R = M.length; P < R; P++) {
            const E = M[P];
            if (m(E, P, C) === !0) {
                const B = E.__offset
                  , I = Array.isArray(E.value) ? E.value : [E.value];
                let z = 0;
                for (let q = 0; q < I.length; q++) {
                    const W = I[q]
                      , G = v(W);
                    typeof W == "number" ? (E.__data[0] = W,
                    n.bufferSubData(35345, B + z, E.__data)) : W.isMatrix3 ? (E.__data[0] = W.elements[0],
                    E.__data[1] = W.elements[1],
                    E.__data[2] = W.elements[2],
                    E.__data[3] = W.elements[0],
                    E.__data[4] = W.elements[3],
                    E.__data[5] = W.elements[4],
                    E.__data[6] = W.elements[5],
                    E.__data[7] = W.elements[0],
                    E.__data[8] = W.elements[6],
                    E.__data[9] = W.elements[7],
                    E.__data[10] = W.elements[8],
                    E.__data[11] = W.elements[0]) : (W.toArray(E.__data, z),
                    z += G.storage / Float32Array.BYTES_PER_ELEMENT)
                }
                n.bufferSubData(35345, B, E.__data)
            }
        }
        n.bindBuffer(35345, null)
    }
    function m(A, w, M) {
        const C = A.value;
        if (M[w] === void 0) {
            if (typeof C == "number")
                M[w] = C;
            else {
                const P = Array.isArray(C) ? C : [C]
                  , R = [];
                for (let E = 0; E < P.length; E++)
                    R.push(P[E].clone());
                M[w] = R
            }
            return !0
        } else if (typeof C == "number") {
            if (M[w] !== C)
                return M[w] = C,
                !0
        } else {
            const P = Array.isArray(M[w]) ? M[w] : [M[w]]
              , R = Array.isArray(C) ? C : [C];
            for (let E = 0; E < P.length; E++) {
                const B = P[E];
                if (B.equals(R[E]) === !1)
                    return B.copy(R[E]),
                    !0
            }
        }
        return !1
    }
    function y(A) {
        const w = A.uniforms;
        let M = 0;
        const C = 16;
        let P = 0;
        for (let R = 0, E = w.length; R < E; R++) {
            const B = w[R]
              , I = {
                boundary: 0,
                storage: 0
            }
              , z = Array.isArray(B.value) ? B.value : [B.value];
            for (let q = 0, W = z.length; q < W; q++) {
                const G = z[q]
                  , K = v(G);
                I.boundary += K.boundary,
                I.storage += K.storage
            }
            if (B.__data = new Float32Array(I.storage / Float32Array.BYTES_PER_ELEMENT),
            B.__offset = M,
            R > 0) {
                P = M % C;
                const q = C - P;
                P !== 0 && q - I.boundary < 0 && (M += C - P,
                B.__offset = M)
            }
            M += I.storage
        }
        return P = M % C,
        P > 0 && (M += C - P),
        A.__size = M,
        A.__cache = {},
        this
    }
    function v(A) {
        const w = {
            boundary: 0,
            storage: 0
        };
        return typeof A == "number" ? (w.boundary = 4,
        w.storage = 4) : A.isVector2 ? (w.boundary = 8,
        w.storage = 8) : A.isVector3 || A.isColor ? (w.boundary = 16,
        w.storage = 12) : A.isVector4 ? (w.boundary = 16,
        w.storage = 16) : A.isMatrix3 ? (w.boundary = 48,
        w.storage = 48) : A.isMatrix4 ? (w.boundary = 64,
        w.storage = 64) : A.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", A),
        w
    }
    function x(A) {
        const w = A.target;
        w.removeEventListener("dispose", x);
        const M = o.indexOf(w.__bindingPointIndex);
        o.splice(M, 1),
        n.deleteBuffer(r[w.id]),
        delete r[w.id],
        delete s[w.id]
    }
    function _() {
        for (const A in r)
            n.deleteBuffer(r[A]);
        o = [],
        r = {},
        s = {}
    }
    return {
        bind: l,
        update: c,
        dispose: _
    }
}
function J9() {
    const n = Ed("canvas");
    return n.style.display = "block",
    n
}
function Rw(n={}) {
    this.isWebGLRenderer = !0;
    const e = n.canvas !== void 0 ? n.canvas : J9()
      , t = n.context !== void 0 ? n.context : null
      , i = n.depth !== void 0 ? n.depth : !0
      , r = n.stencil !== void 0 ? n.stencil : !0
      , s = n.antialias !== void 0 ? n.antialias : !1
      , o = n.premultipliedAlpha !== void 0 ? n.premultipliedAlpha : !0
      , a = n.preserveDrawingBuffer !== void 0 ? n.preserveDrawingBuffer : !1
      , l = n.powerPreference !== void 0 ? n.powerPreference : "default"
      , c = n.failIfMajorPerformanceCaveat !== void 0 ? n.failIfMajorPerformanceCaveat : !1;
    let d;
    t !== null ? d = t.getContextAttributes().alpha : d = n.alpha !== void 0 ? n.alpha : !1;
    let h = null
      , p = null;
    const m = []
      , y = [];
    this.domElement = e,
    this.debug = {
        checkShaderErrors: !0
    },
    this.autoClear = !0,
    this.autoClearColor = !0,
    this.autoClearDepth = !0,
    this.autoClearStencil = !0,
    this.sortObjects = !0,
    this.clippingPlanes = [],
    this.localClippingEnabled = !1,
    this.outputEncoding = $s,
    this.physicallyCorrectLights = !1,
    this.toneMapping = Hr,
    this.toneMappingExposure = 1;
    const v = this;
    let x = !1
      , _ = 0
      , A = 0
      , w = null
      , M = -1
      , C = null;
    const P = new Ut
      , R = new Ut;
    let E = null
      , B = e.width
      , I = e.height
      , z = 1
      , q = null
      , W = null;
    const G = new Ut(0,0,B,I)
      , K = new Ut(0,0,B,I);
    let ne = !1;
    const oe = new T0;
    let F = !1
      , V = !1
      , Y = null;
    const re = new ot
      , j = new me
      , ie = new D
      , ye = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0
    };
    function _e() {
        return w === null ? z : 1
    }
    let $ = t;
    function Ne(k, ee) {
        for (let pe = 0; pe < k.length; pe++) {
            const Z = k[pe]
              , ve = e.getContext(Z, ee);
            if (ve !== null)
                return ve
        }
        return null
    }
    try {
        const k = {
            alpha: !0,
            depth: i,
            stencil: r,
            antialias: s,
            premultipliedAlpha: o,
            preserveDrawingBuffer: a,
            powerPreference: l,
            failIfMajorPerformanceCaveat: c
        };
        if ("setAttribute"in e && e.setAttribute("data-engine", `three.js r${w0}`),
        e.addEventListener("webglcontextlost", Ae, !1),
        e.addEventListener("webglcontextrestored", Te, !1),
        e.addEventListener("webglcontextcreationerror", tt, !1),
        $ === null) {
            const ee = ["webgl2", "webgl", "experimental-webgl"];
            if (v.isWebGL1Renderer === !0 && ee.shift(),
            $ = Ne(ee, k),
            $ === null)
                throw Ne(ee) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
        }
        $.getShaderPrecisionFormat === void 0 && ($.getShaderPrecisionFormat = function() {
            return {
                rangeMin: 1,
                rangeMax: 1,
                precision: 1
            }
        }
        )
    } catch (k) {
        throw console.error("THREE.WebGLRenderer: " + k.message),
        k
    }
    let Oe, Ve, we, Le, de, ae, be, Ge, Be, $e, Ye, Je, At, Ct, O, L, se, Se, Ce, Pe, rt, De, ge, Ke;
    function H() {
        Oe = new lG($),
        Ve = new nG($,Oe,n),
        Oe.init(Ve),
        De = new XR($,Oe,Ve),
        we = new z9($,Oe,Ve),
        Le = new fG,
        de = new T9,
        ae = new G9($,Oe,we,de,Ve,De,Le),
        be = new rG(v),
        Ge = new aG(v),
        Be = new _U($,Ve),
        ge = new eG($,Oe,Be,Ve),
        $e = new uG($,Be,Le,ge),
        Ye = new mG($,$e,Be,Le),
        Ce = new pG($,Ve,ae),
        L = new iG(de),
        Je = new E9(v,be,Ge,Oe,Ve,ge,L),
        At = new W9(v,de),
        Ct = new B9,
        O = new F9(Oe,Ve),
        Se = new $5(v,be,Ge,we,Ye,d,o),
        se = new U9(v,Ye,Ve),
        Ke = new j9($,Le,Ve,we),
        Pe = new tG($,Oe,Le,Ve),
        rt = new cG($,Oe,Le,Ve),
        Le.programs = Je.programs,
        v.capabilities = Ve,
        v.extensions = Oe,
        v.properties = de,
        v.renderLists = Ct,
        v.shadowMap = se,
        v.state = we,
        v.info = Le
    }
    H();
    const le = new V9(v,$);
    this.xr = le,
    this.getContext = function() {
        return $
    }
    ,
    this.getContextAttributes = function() {
        return $.getContextAttributes()
    }
    ,
    this.forceContextLoss = function() {
        const k = Oe.get("WEBGL_lose_context");
        k && k.loseContext()
    }
    ,
    this.forceContextRestore = function() {
        const k = Oe.get("WEBGL_lose_context");
        k && k.restoreContext()
    }
    ,
    this.getPixelRatio = function() {
        return z
    }
    ,
    this.setPixelRatio = function(k) {
        k !== void 0 && (z = k,
        this.setSize(B, I, !1))
    }
    ,
    this.getSize = function(k) {
        return k.set(B, I)
    }
    ,
    this.setSize = function(k, ee, pe) {
        if (le.isPresenting) {
            console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
            return
        }
        B = k,
        I = ee,
        e.width = Math.floor(k * z),
        e.height = Math.floor(ee * z),
        pe !== !1 && (e.style.width = k + "px",
        e.style.height = ee + "px"),
        this.setViewport(0, 0, k, ee)
    }
    ,
    this.getDrawingBufferSize = function(k) {
        return k.set(B * z, I * z).floor()
    }
    ,
    this.setDrawingBufferSize = function(k, ee, pe) {
        B = k,
        I = ee,
        z = pe,
        e.width = Math.floor(k * pe),
        e.height = Math.floor(ee * pe),
        this.setViewport(0, 0, k, ee)
    }
    ,
    this.getCurrentViewport = function(k) {
        return k.copy(P)
    }
    ,
    this.getViewport = function(k) {
        return k.copy(G)
    }
    ,
    this.setViewport = function(k, ee, pe, Z) {
        k.isVector4 ? G.set(k.x, k.y, k.z, k.w) : G.set(k, ee, pe, Z),
        we.viewport(P.copy(G).multiplyScalar(z).floor())
    }
    ,
    this.getScissor = function(k) {
        return k.copy(K)
    }
    ,
    this.setScissor = function(k, ee, pe, Z) {
        k.isVector4 ? K.set(k.x, k.y, k.z, k.w) : K.set(k, ee, pe, Z),
        we.scissor(R.copy(K).multiplyScalar(z).floor())
    }
    ,
    this.getScissorTest = function() {
        return ne
    }
    ,
    this.setScissorTest = function(k) {
        we.setScissorTest(ne = k)
    }
    ,
    this.setOpaqueSort = function(k) {
        q = k
    }
    ,
    this.setTransparentSort = function(k) {
        W = k
    }
    ,
    this.getClearColor = function(k) {
        return k.copy(Se.getClearColor())
    }
    ,
    this.setClearColor = function() {
        Se.setClearColor.apply(Se, arguments)
    }
    ,
    this.getClearAlpha = function() {
        return Se.getClearAlpha()
    }
    ,
    this.setClearAlpha = function() {
        Se.setClearAlpha.apply(Se, arguments)
    }
    ,
    this.clear = function(k=!0, ee=!0, pe=!0) {
        let Z = 0;
        k && (Z |= 16384),
        ee && (Z |= 256),
        pe && (Z |= 1024),
        $.clear(Z)
    }
    ,
    this.clearColor = function() {
        this.clear(!0, !1, !1)
    }
    ,
    this.clearDepth = function() {
        this.clear(!1, !0, !1)
    }
    ,
    this.clearStencil = function() {
        this.clear(!1, !1, !0)
    }
    ,
    this.dispose = function() {
        e.removeEventListener("webglcontextlost", Ae, !1),
        e.removeEventListener("webglcontextrestored", Te, !1),
        e.removeEventListener("webglcontextcreationerror", tt, !1),
        Ct.dispose(),
        O.dispose(),
        de.dispose(),
        be.dispose(),
        Ge.dispose(),
        Ye.dispose(),
        ge.dispose(),
        Ke.dispose(),
        Je.dispose(),
        le.dispose(),
        le.removeEventListener("sessionstart", Ue),
        le.removeEventListener("sessionend", Ze),
        Y && (Y.dispose(),
        Y = null),
        It.stop()
    }
    ;
    function Ae(k) {
        k.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        x = !0
    }
    function Te() {
        console.log("THREE.WebGLRenderer: Context Restored."),
        x = !1;
        const k = Le.autoReset
          , ee = se.enabled
          , pe = se.autoUpdate
          , Z = se.needsUpdate
          , ve = se.type;
        H(),
        Le.autoReset = k,
        se.enabled = ee,
        se.autoUpdate = pe,
        se.needsUpdate = Z,
        se.type = ve
    }
    function tt(k) {
        console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", k.statusMessage)
    }
    function _t(k) {
        const ee = k.target;
        ee.removeEventListener("dispose", _t),
        Jt(ee)
    }
    function Jt(k) {
        X(k),
        de.remove(k)
    }
    function X(k) {
        const ee = de.get(k).programs;
        ee !== void 0 && (ee.forEach(function(pe) {
            Je.releaseProgram(pe)
        }),
        k.isShaderMaterial && Je.releaseShaderCache(k))
    }
    this.renderBufferDirect = function(k, ee, pe, Z, ve, et) {
        ee === null && (ee = ye);
        const at = ve.isMesh && ve.matrixWorld.determinant() < 0
          , pt = nv(k, ee, pe, Z, ve);
        we.setMaterial(Z, at);
        let yt = pe.index
          , Et = 1;
        Z.wireframe === !0 && (yt = $e.getWireframeAttribute(pe),
        Et = 2);
        const St = pe.drawRange
          , Mt = pe.attributes.position;
        let fn = St.start * Et
          , ui = (St.start + St.count) * Et;
        et !== null && (fn = Math.max(fn, et.start * Et),
        ui = Math.min(ui, (et.start + et.count) * Et)),
        yt !== null ? (fn = Math.max(fn, 0),
        ui = Math.min(ui, yt.count)) : Mt != null && (fn = Math.max(fn, 0),
        ui = Math.min(ui, Mt.count));
        const br = ui - fn;
        if (br < 0 || br === 1 / 0)
            return;
        ge.setup(ve, Z, pt, pe, yt);
        let vs, Zt = Pe;
        if (yt !== null && (vs = Be.get(yt),
        Zt = rt,
        Zt.setIndex(vs)),
        ve.isMesh)
            Z.wireframe === !0 ? (we.setLineWidth(Z.wireframeLinewidth * _e()),
            Zt.setMode(1)) : Zt.setMode(4);
        else if (ve.isLine) {
            let mt = Z.linewidth;
            mt === void 0 && (mt = 1),
            we.setLineWidth(mt * _e()),
            ve.isLineSegments ? Zt.setMode(1) : ve.isLineLoop ? Zt.setMode(2) : Zt.setMode(3)
        } else
            ve.isPoints ? Zt.setMode(0) : ve.isSprite && Zt.setMode(4);
        if (ve.isInstancedMesh)
            Zt.renderInstances(fn, br, ve.count);
        else if (pe.isInstancedBufferGeometry) {
            const mt = pe._maxInstanceCount !== void 0 ? pe._maxInstanceCount : 1 / 0
              , xa = Math.min(pe.instanceCount, mt);
            Zt.renderInstances(fn, br, xa)
        } else
            Zt.render(fn, br)
    }
    ,
    this.compile = function(k, ee) {
        function pe(Z, ve, et) {
            Z.transparent === !0 && Z.side === Or && Z.forceSinglePass === !1 ? (Z.side = Li,
            Z.needsUpdate = !0,
            wi(Z, ve, et),
            Z.side = hs,
            Z.needsUpdate = !0,
            wi(Z, ve, et),
            Z.side = Or) : wi(Z, ve, et)
        }
        p = O.get(k),
        p.init(),
        y.push(p),
        k.traverseVisible(function(Z) {
            Z.isLight && Z.layers.test(ee.layers) && (p.pushLight(Z),
            Z.castShadow && p.pushShadow(Z))
        }),
        p.setupLights(v.physicallyCorrectLights),
        k.traverse(function(Z) {
            const ve = Z.material;
            if (ve)
                if (Array.isArray(ve))
                    for (let et = 0; et < ve.length; et++) {
                        const at = ve[et];
                        pe(at, k, Z)
                    }
                else
                    pe(ve, k, Z)
        }),
        y.pop(),
        p = null
    }
    ;
    let ce = null;
    function xe(k) {
        ce && ce(k)
    }
    function Ue() {
        It.stop()
    }
    function Ze() {
        It.start()
    }
    const It = new HR;
    It.setAnimationLoop(xe),
    typeof self < "u" && It.setContext(self),
    this.setAnimationLoop = function(k) {
        ce = k,
        le.setAnimationLoop(k),
        k === null ? It.stop() : It.start()
    }
    ,
    le.addEventListener("sessionstart", Ue),
    le.addEventListener("sessionend", Ze),
    this.render = function(k, ee) {
        if (ee !== void 0 && ee.isCamera !== !0) {
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            return
        }
        if (x === !0)
            return;
        k.matrixWorldAutoUpdate === !0 && k.updateMatrixWorld(),
        ee.parent === null && ee.matrixWorldAutoUpdate === !0 && ee.updateMatrixWorld(),
        le.enabled === !0 && le.isPresenting === !0 && (le.cameraAutoUpdate === !0 && le.updateCamera(ee),
        ee = le.getCamera()),
        k.isScene === !0 && k.onBeforeRender(v, k, ee, w),
        p = O.get(k, y.length),
        p.init(),
        y.push(p),
        re.multiplyMatrices(ee.projectionMatrix, ee.matrixWorldInverse),
        oe.setFromProjectionMatrix(re),
        V = this.localClippingEnabled,
        F = L.init(this.clippingPlanes, V),
        h = Ct.get(k, m.length),
        h.init(),
        m.push(h),
        yn(k, ee, 0, v.sortObjects),
        h.finish(),
        v.sortObjects === !0 && h.sort(q, W),
        F === !0 && L.beginShadows();
        const pe = p.state.shadowsArray;
        if (se.render(pe, k, ee),
        F === !0 && L.endShadows(),
        this.info.autoReset === !0 && this.info.reset(),
        Se.render(h, k),
        p.setupLights(v.physicallyCorrectLights),
        ee.isArrayCamera) {
            const Z = ee.cameras;
            for (let ve = 0, et = Z.length; ve < et; ve++) {
                const at = Z[ve];
                Nn(h, k, at, at.viewport)
            }
        } else
            Nn(h, k, ee);
        w !== null && (ae.updateMultisampleRenderTarget(w),
        ae.updateRenderTargetMipmap(w)),
        k.isScene === !0 && k.onAfterRender(v, k, ee),
        ge.resetDefaultState(),
        M = -1,
        C = null,
        y.pop(),
        y.length > 0 ? p = y[y.length - 1] : p = null,
        m.pop(),
        m.length > 0 ? h = m[m.length - 1] : h = null
    }
    ;
    function yn(k, ee, pe, Z) {
        if (k.visible === !1)
            return;
        if (k.layers.test(ee.layers)) {
            if (k.isGroup)
                pe = k.renderOrder;
            else if (k.isLOD)
                k.autoUpdate === !0 && k.update(ee);
            else if (k.isLight)
                p.pushLight(k),
                k.castShadow && p.pushShadow(k);
            else if (k.isSprite) {
                if (!k.frustumCulled || oe.intersectsSprite(k)) {
                    Z && ie.setFromMatrixPosition(k.matrixWorld).applyMatrix4(re);
                    const at = Ye.update(k)
                      , pt = k.material;
                    pt.visible && h.push(k, at, pt, pe, ie.z, null)
                }
            } else if ((k.isMesh || k.isLine || k.isPoints) && (k.isSkinnedMesh && k.skeleton.frame !== Le.render.frame && (k.skeleton.update(),
            k.skeleton.frame = Le.render.frame),
            !k.frustumCulled || oe.intersectsObject(k))) {
                Z && ie.setFromMatrixPosition(k.matrixWorld).applyMatrix4(re);
                const at = Ye.update(k)
                  , pt = k.material;
                if (Array.isArray(pt)) {
                    const yt = at.groups;
                    for (let Et = 0, St = yt.length; Et < St; Et++) {
                        const Mt = yt[Et]
                          , fn = pt[Mt.materialIndex];
                        fn && fn.visible && h.push(k, at, fn, pe, ie.z, Mt)
                    }
                } else
                    pt.visible && h.push(k, at, pt, pe, ie.z, null)
            }
        }
        const et = k.children;
        for (let at = 0, pt = et.length; at < pt; at++)
            yn(et[at], ee, pe, Z)
    }
    function Nn(k, ee, pe, Z) {
        const ve = k.opaque
          , et = k.transmissive
          , at = k.transparent;
        p.setupLightsView(pe),
        F === !0 && L.setGlobalState(v.clippingPlanes, pe),
        et.length > 0 && Kr(ve, ee, pe),
        Z && we.viewport(P.copy(Z)),
        ve.length > 0 && Gt(ve, ee, pe),
        et.length > 0 && Gt(et, ee, pe),
        at.length > 0 && Gt(at, ee, pe),
        we.buffers.depth.setTest(!0),
        we.buffers.depth.setMask(!0),
        we.buffers.color.setMask(!0),
        we.setPolygonOffset(!1)
    }
    function Kr(k, ee, pe) {
        const Z = Ve.isWebGL2;
        Y === null && (Y = new jr(1,1,{
            generateMipmaps: !0,
            type: Oe.has("EXT_color_buffer_half_float") ? ic : qs,
            minFilter: ps,
            samples: Z && s === !0 ? 4 : 0
        })),
        v.getDrawingBufferSize(j),
        Z ? Y.setSize(j.x, j.y) : Y.setSize(Hg(j.x), Hg(j.y));
        const ve = v.getRenderTarget();
        v.setRenderTarget(Y),
        v.clear();
        const et = v.toneMapping;
        v.toneMapping = Hr,
        Gt(k, ee, pe),
        v.toneMapping = et,
        ae.updateMultisampleRenderTarget(Y),
        ae.updateRenderTargetMipmap(Y),
        v.setRenderTarget(ve)
    }
    function Gt(k, ee, pe) {
        const Z = ee.isScene === !0 ? ee.overrideMaterial : null;
        for (let ve = 0, et = k.length; ve < et; ve++) {
            const at = k[ve]
              , pt = at.object
              , yt = at.geometry
              , Et = Z === null ? at.material : Z
              , St = at.group;
            pt.layers.test(pe.layers) && er(pt, ee, pe, yt, Et, St)
        }
    }
    function er(k, ee, pe, Z, ve, et) {
        k.onBeforeRender(v, ee, pe, Z, ve, et),
        k.modelViewMatrix.multiplyMatrices(pe.matrixWorldInverse, k.matrixWorld),
        k.normalMatrix.getNormalMatrix(k.modelViewMatrix),
        ve.onBeforeRender(v, ee, pe, Z, k, et),
        ve.transparent === !0 && ve.side === Or && ve.forceSinglePass === !1 ? (ve.side = Li,
        ve.needsUpdate = !0,
        v.renderBufferDirect(pe, ee, Z, ve, k, et),
        ve.side = hs,
        ve.needsUpdate = !0,
        v.renderBufferDirect(pe, ee, Z, ve, k, et),
        ve.side = Or) : v.renderBufferDirect(pe, ee, Z, ve, k, et),
        k.onAfterRender(v, ee, pe, Z, ve, et)
    }
    function wi(k, ee, pe) {
        ee.isScene !== !0 && (ee = ye);
        const Z = de.get(k)
          , ve = p.state.lights
          , et = p.state.shadowsArray
          , at = ve.state.version
          , pt = Je.getParameters(k, ve.state, et, ee, pe)
          , yt = Je.getProgramCacheKey(pt);
        let Et = Z.programs;
        Z.environment = k.isMeshStandardMaterial ? ee.environment : null,
        Z.fog = ee.fog,
        Z.envMap = (k.isMeshStandardMaterial ? Ge : be).get(k.envMap || Z.environment),
        Et === void 0 && (k.addEventListener("dispose", _t),
        Et = new Map,
        Z.programs = Et);
        let St = Et.get(yt);
        if (St !== void 0) {
            if (Z.currentProgram === St && Z.lightsStateVersion === at)
                return Eh(k, pt),
                St
        } else
            pt.uniforms = Je.getUniforms(k),
            k.onBuild(pe, pt, v),
            k.onBeforeCompile(pt, v),
            St = Je.acquireProgram(pt, yt),
            Et.set(yt, St),
            Z.uniforms = pt.uniforms;
        const Mt = Z.uniforms;
        (!k.isShaderMaterial && !k.isRawShaderMaterial || k.clipping === !0) && (Mt.clippingPlanes = L.uniform),
        Eh(k, pt),
        Z.needsLights = Rc(k),
        Z.lightsStateVersion = at,
        Z.needsLights && (Mt.ambientLightColor.value = ve.state.ambient,
        Mt.lightProbe.value = ve.state.probe,
        Mt.directionalLights.value = ve.state.directional,
        Mt.directionalLightShadows.value = ve.state.directionalShadow,
        Mt.spotLights.value = ve.state.spot,
        Mt.spotLightShadows.value = ve.state.spotShadow,
        Mt.rectAreaLights.value = ve.state.rectArea,
        Mt.ltc_1.value = ve.state.rectAreaLTC1,
        Mt.ltc_2.value = ve.state.rectAreaLTC2,
        Mt.pointLights.value = ve.state.point,
        Mt.pointLightShadows.value = ve.state.pointShadow,
        Mt.hemisphereLights.value = ve.state.hemi,
        Mt.directionalShadowMap.value = ve.state.directionalShadowMap,
        Mt.directionalShadowMatrix.value = ve.state.directionalShadowMatrix,
        Mt.spotShadowMap.value = ve.state.spotShadowMap,
        Mt.spotLightMatrix.value = ve.state.spotLightMatrix,
        Mt.spotLightMap.value = ve.state.spotLightMap,
        Mt.pointShadowMap.value = ve.state.pointShadowMap,
        Mt.pointShadowMatrix.value = ve.state.pointShadowMatrix);
        const fn = St.getUniforms()
          , ui = ug.seqWithValue(fn.seq, Mt);
        return Z.currentProgram = St,
        Z.uniformsList = ui,
        St
    }
    function Eh(k, ee) {
        const pe = de.get(k);
        pe.outputEncoding = ee.outputEncoding,
        pe.instancing = ee.instancing,
        pe.skinning = ee.skinning,
        pe.morphTargets = ee.morphTargets,
        pe.morphNormals = ee.morphNormals,
        pe.morphColors = ee.morphColors,
        pe.morphTargetsCount = ee.morphTargetsCount,
        pe.numClippingPlanes = ee.numClippingPlanes,
        pe.numIntersection = ee.numClipIntersection,
        pe.vertexAlphas = ee.vertexAlphas,
        pe.vertexTangents = ee.vertexTangents,
        pe.toneMapping = ee.toneMapping
    }
    function nv(k, ee, pe, Z, ve) {
        ee.isScene !== !0 && (ee = ye),
        ae.resetTextureUnits();
        const et = ee.fog
          , at = Z.isMeshStandardMaterial ? ee.environment : null
          , pt = w === null ? v.outputEncoding : w.isXRRenderTarget === !0 ? w.texture.encoding : $s
          , yt = (Z.isMeshStandardMaterial ? Ge : be).get(Z.envMap || at)
          , Et = Z.vertexColors === !0 && !!pe.attributes.color && pe.attributes.color.itemSize === 4
          , St = !!Z.normalMap && !!pe.attributes.tangent
          , Mt = !!pe.morphAttributes.position
          , fn = !!pe.morphAttributes.normal
          , ui = !!pe.morphAttributes.color
          , br = Z.toneMapped ? v.toneMapping : Hr
          , vs = pe.morphAttributes.position || pe.morphAttributes.normal || pe.morphAttributes.color
          , Zt = vs !== void 0 ? vs.length : 0
          , mt = de.get(Z)
          , xa = p.state.lights;
        if (F === !0 && (V === !0 || k !== C)) {
            const Ot = k === C && Z.id === M;
            L.setState(Z, k, Ot)
        }
        let dn = !1;
        Z.version === mt.__version ? (mt.needsLights && mt.lightsStateVersion !== xa.state.version || mt.outputEncoding !== pt || ve.isInstancedMesh && mt.instancing === !1 || !ve.isInstancedMesh && mt.instancing === !0 || ve.isSkinnedMesh && mt.skinning === !1 || !ve.isSkinnedMesh && mt.skinning === !0 || mt.envMap !== yt || Z.fog === !0 && mt.fog !== et || mt.numClippingPlanes !== void 0 && (mt.numClippingPlanes !== L.numPlanes || mt.numIntersection !== L.numIntersection) || mt.vertexAlphas !== Et || mt.vertexTangents !== St || mt.morphTargets !== Mt || mt.morphNormals !== fn || mt.morphColors !== ui || mt.toneMapping !== br || Ve.isWebGL2 === !0 && mt.morphTargetsCount !== Zt) && (dn = !0) : (dn = !0,
        mt.__version = Z.version);
        let ys = mt.currentProgram;
        dn === !0 && (ys = wi(Z, ee, ve));
        let Fl = !1
          , tr = !1
          , nr = !1;
        const dt = ys.getUniforms()
          , Pt = mt.uniforms;
        if (we.useProgram(ys.program) && (Fl = !0,
        tr = !0,
        nr = !0),
        Z.id !== M && (M = Z.id,
        tr = !0),
        Fl || C !== k) {
            if (dt.setValue($, "projectionMatrix", k.projectionMatrix),
            Ve.logarithmicDepthBuffer && dt.setValue($, "logDepthBufFC", 2 / (Math.log(k.far + 1) / Math.LN2)),
            C !== k && (C = k,
            tr = !0,
            nr = !0),
            Z.isShaderMaterial || Z.isMeshPhongMaterial || Z.isMeshToonMaterial || Z.isMeshStandardMaterial || Z.envMap) {
                const Ot = dt.map.cameraPosition;
                Ot !== void 0 && Ot.setValue($, ie.setFromMatrixPosition(k.matrixWorld))
            }
            (Z.isMeshPhongMaterial || Z.isMeshToonMaterial || Z.isMeshLambertMaterial || Z.isMeshBasicMaterial || Z.isMeshStandardMaterial || Z.isShaderMaterial) && dt.setValue($, "isOrthographic", k.isOrthographicCamera === !0),
            (Z.isMeshPhongMaterial || Z.isMeshToonMaterial || Z.isMeshLambertMaterial || Z.isMeshBasicMaterial || Z.isMeshStandardMaterial || Z.isShaderMaterial || Z.isShadowMaterial || ve.isSkinnedMesh) && dt.setValue($, "viewMatrix", k.matrixWorldInverse)
        }
        if (ve.isSkinnedMesh) {
            dt.setOptional($, ve, "bindMatrix"),
            dt.setOptional($, ve, "bindMatrixInverse");
            const Ot = ve.skeleton;
            Ot && (Ve.floatVertexTextures ? (Ot.boneTexture === null && Ot.computeBoneTexture(),
            dt.setValue($, "boneTexture", Ot.boneTexture, ae),
            dt.setValue($, "boneTextureSize", Ot.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
        }
        const ir = pe.morphAttributes;
        if ((ir.position !== void 0 || ir.normal !== void 0 || ir.color !== void 0 && Ve.isWebGL2 === !0) && Ce.update(ve, pe, Z, ys),
        (tr || mt.receiveShadow !== ve.receiveShadow) && (mt.receiveShadow = ve.receiveShadow,
        dt.setValue($, "receiveShadow", ve.receiveShadow)),
        Z.isMeshGouraudMaterial && Z.envMap !== null && (Pt.envMap.value = yt,
        Pt.flipEnvMap.value = yt.isCubeTexture && yt.isRenderTargetTexture === !1 ? -1 : 1),
        tr && (dt.setValue($, "toneMappingExposure", v.toneMappingExposure),
        mt.needsLights && Th(Pt, nr),
        et && Z.fog === !0 && At.refreshFogUniforms(Pt, et),
        At.refreshMaterialUniforms(Pt, Z, z, I, Y),
        ug.upload($, mt.uniformsList, Pt, ae)),
        Z.isShaderMaterial && Z.uniformsNeedUpdate === !0 && (ug.upload($, mt.uniformsList, Pt, ae),
        Z.uniformsNeedUpdate = !1),
        Z.isSpriteMaterial && dt.setValue($, "center", ve.center),
        dt.setValue($, "modelViewMatrix", ve.modelViewMatrix),
        dt.setValue($, "normalMatrix", ve.normalMatrix),
        dt.setValue($, "modelMatrix", ve.matrixWorld),
        Z.isShaderMaterial || Z.isRawShaderMaterial) {
            const Ot = Z.uniformsGroups;
            for (let On = 0, xs = Ot.length; On < xs; On++)
                if (Ve.isWebGL2) {
                    const _s = Ot[On];
                    Ke.update(_s, ys),
                    Ke.bind(_s, ys)
                } else
                    console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
        }
        return ys
    }
    function Th(k, ee) {
        k.ambientLightColor.needsUpdate = ee,
        k.lightProbe.needsUpdate = ee,
        k.directionalLights.needsUpdate = ee,
        k.directionalLightShadows.needsUpdate = ee,
        k.pointLights.needsUpdate = ee,
        k.pointLightShadows.needsUpdate = ee,
        k.spotLights.needsUpdate = ee,
        k.spotLightShadows.needsUpdate = ee,
        k.rectAreaLights.needsUpdate = ee,
        k.hemisphereLights.needsUpdate = ee
    }
    function Rc(k) {
        return k.isMeshLambertMaterial || k.isMeshToonMaterial || k.isMeshPhongMaterial || k.isMeshStandardMaterial || k.isShadowMaterial || k.isShaderMaterial && k.lights === !0
    }
    this.getActiveCubeFace = function() {
        return _
    }
    ,
    this.getActiveMipmapLevel = function() {
        return A
    }
    ,
    this.getRenderTarget = function() {
        return w
    }
    ,
    this.setRenderTargetTextures = function(k, ee, pe) {
        de.get(k.texture).__webglTexture = ee,
        de.get(k.depthTexture).__webglTexture = pe;
        const Z = de.get(k);
        Z.__hasExternalTextures = !0,
        Z.__hasExternalTextures && (Z.__autoAllocateDepthBuffer = pe === void 0,
        Z.__autoAllocateDepthBuffer || Oe.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
        Z.__useRenderToTexture = !1))
    }
    ,
    this.setRenderTargetFramebuffer = function(k, ee) {
        const pe = de.get(k);
        pe.__webglFramebuffer = ee,
        pe.__useDefaultFramebuffer = ee === void 0
    }
    ,
    this.setRenderTarget = function(k, ee=0, pe=0) {
        w = k,
        _ = ee,
        A = pe;
        let Z = !0
          , ve = null
          , et = !1
          , at = !1;
        if (k) {
            const yt = de.get(k);
            yt.__useDefaultFramebuffer !== void 0 ? (we.bindFramebuffer(36160, null),
            Z = !1) : yt.__webglFramebuffer === void 0 ? ae.setupRenderTarget(k) : yt.__hasExternalTextures && ae.rebindTextures(k, de.get(k.texture).__webglTexture, de.get(k.depthTexture).__webglTexture);
            const Et = k.texture;
            (Et.isData3DTexture || Et.isDataArrayTexture || Et.isCompressedArrayTexture) && (at = !0);
            const St = de.get(k).__webglFramebuffer;
            k.isWebGLCubeRenderTarget ? (ve = St[ee],
            et = !0) : Ve.isWebGL2 && k.samples > 0 && ae.useMultisampledRTT(k) === !1 ? ve = de.get(k).__webglMultisampledFramebuffer : ve = St,
            P.copy(k.viewport),
            R.copy(k.scissor),
            E = k.scissorTest
        } else
            P.copy(G).multiplyScalar(z).floor(),
            R.copy(K).multiplyScalar(z).floor(),
            E = ne;
        if (we.bindFramebuffer(36160, ve) && Ve.drawBuffers && Z && we.drawBuffers(k, ve),
        we.viewport(P),
        we.scissor(R),
        we.setScissorTest(E),
        et) {
            const yt = de.get(k.texture);
            $.framebufferTexture2D(36160, 36064, 34069 + ee, yt.__webglTexture, pe)
        } else if (at) {
            const yt = de.get(k.texture)
              , Et = ee || 0;
            $.framebufferTextureLayer(36160, 36064, yt.__webglTexture, pe || 0, Et)
        }
        M = -1
    }
    ,
    this.readRenderTargetPixels = function(k, ee, pe, Z, ve, et, at) {
        if (!(k && k.isWebGLRenderTarget)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            return
        }
        let pt = de.get(k).__webglFramebuffer;
        if (k.isWebGLCubeRenderTarget && at !== void 0 && (pt = pt[at]),
        pt) {
            we.bindFramebuffer(36160, pt);
            try {
                const yt = k.texture
                  , Et = yt.format
                  , St = yt.type;
                if (Et !== Ti && De.convert(Et) !== $.getParameter(35739)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    return
                }
                const Mt = St === ic && (Oe.has("EXT_color_buffer_half_float") || Ve.isWebGL2 && Oe.has("EXT_color_buffer_float"));
                if (St !== qs && De.convert(St) !== $.getParameter(35738) && !(St === zs && (Ve.isWebGL2 || Oe.has("OES_texture_float") || Oe.has("WEBGL_color_buffer_float"))) && !Mt) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    return
                }
                ee >= 0 && ee <= k.width - Z && pe >= 0 && pe <= k.height - ve && $.readPixels(ee, pe, Z, ve, De.convert(Et), De.convert(St), et)
            } finally {
                const yt = w !== null ? de.get(w).__webglFramebuffer : null;
                we.bindFramebuffer(36160, yt)
            }
        }
    }
    ,
    this.copyFramebufferToTexture = function(k, ee, pe=0) {
        const Z = Math.pow(2, -pe)
          , ve = Math.floor(ee.image.width * Z)
          , et = Math.floor(ee.image.height * Z);
        ae.setTexture2D(ee, 0),
        $.copyTexSubImage2D(3553, pe, 0, 0, k.x, k.y, ve, et),
        we.unbindTexture()
    }
    ,
    this.copyTextureToTexture = function(k, ee, pe, Z=0) {
        const ve = ee.image.width
          , et = ee.image.height
          , at = De.convert(pe.format)
          , pt = De.convert(pe.type);
        ae.setTexture2D(pe, 0),
        $.pixelStorei(37440, pe.flipY),
        $.pixelStorei(37441, pe.premultiplyAlpha),
        $.pixelStorei(3317, pe.unpackAlignment),
        ee.isDataTexture ? $.texSubImage2D(3553, Z, k.x, k.y, ve, et, at, pt, ee.image.data) : ee.isCompressedTexture ? $.compressedTexSubImage2D(3553, Z, k.x, k.y, ee.mipmaps[0].width, ee.mipmaps[0].height, at, ee.mipmaps[0].data) : $.texSubImage2D(3553, Z, k.x, k.y, at, pt, ee.image),
        Z === 0 && pe.generateMipmaps && $.generateMipmap(3553),
        we.unbindTexture()
    }
    ,
    this.copyTextureToTexture3D = function(k, ee, pe, Z, ve=0) {
        if (v.isWebGL1Renderer) {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
            return
        }
        const et = k.max.x - k.min.x + 1
          , at = k.max.y - k.min.y + 1
          , pt = k.max.z - k.min.z + 1
          , yt = De.convert(Z.format)
          , Et = De.convert(Z.type);
        let St;
        if (Z.isData3DTexture)
            ae.setTexture3D(Z, 0),
            St = 32879;
        else if (Z.isDataArrayTexture)
            ae.setTexture2DArray(Z, 0),
            St = 35866;
        else {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
            return
        }
        $.pixelStorei(37440, Z.flipY),
        $.pixelStorei(37441, Z.premultiplyAlpha),
        $.pixelStorei(3317, Z.unpackAlignment);
        const Mt = $.getParameter(3314)
          , fn = $.getParameter(32878)
          , ui = $.getParameter(3316)
          , br = $.getParameter(3315)
          , vs = $.getParameter(32877)
          , Zt = pe.isCompressedTexture ? pe.mipmaps[0] : pe.image;
        $.pixelStorei(3314, Zt.width),
        $.pixelStorei(32878, Zt.height),
        $.pixelStorei(3316, k.min.x),
        $.pixelStorei(3315, k.min.y),
        $.pixelStorei(32877, k.min.z),
        pe.isDataTexture || pe.isData3DTexture ? $.texSubImage3D(St, ve, ee.x, ee.y, ee.z, et, at, pt, yt, Et, Zt.data) : pe.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
        $.compressedTexSubImage3D(St, ve, ee.x, ee.y, ee.z, et, at, pt, yt, Zt.data)) : $.texSubImage3D(St, ve, ee.x, ee.y, ee.z, et, at, pt, yt, Et, Zt),
        $.pixelStorei(3314, Mt),
        $.pixelStorei(32878, fn),
        $.pixelStorei(3316, ui),
        $.pixelStorei(3315, br),
        $.pixelStorei(32877, vs),
        ve === 0 && Z.generateMipmaps && $.generateMipmap(St),
        we.unbindTexture()
    }
    ,
    this.initTexture = function(k) {
        k.isCubeTexture ? ae.setTextureCube(k, 0) : k.isData3DTexture ? ae.setTexture3D(k, 0) : k.isDataArrayTexture || k.isCompressedArrayTexture ? ae.setTexture2DArray(k, 0) : ae.setTexture2D(k, 0),
        we.unbindTexture()
    }
    ,
    this.resetState = function() {
        _ = 0,
        A = 0,
        w = null,
        we.reset(),
        ge.reset()
    }
    ,
    typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
        detail: this
    }))
}
class QR extends Rw {
}
QR.prototype.isWebGL1Renderer = !0;
class B0 {
    constructor(e, t=25e-5) {
        this.isFogExp2 = !0,
        this.name = "",
        this.color = new Ie(e),
        this.density = t
    }
    clone() {
        return new B0(this.color,this.density)
    }
    toJSON() {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
        }
    }
}
class R0 {
    constructor(e, t=1, i=1e3) {
        this.isFog = !0,
        this.name = "",
        this.color = new Ie(e),
        this.near = t,
        this.far = i
    }
    clone() {
        return new R0(this.color,this.near,this.far)
    }
    toJSON() {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }
}
class Iw extends Rt {
    constructor() {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.backgroundBlurriness = 0,
        this.backgroundIntensity = 1,
        this.overrideMaterial = null,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        this.backgroundBlurriness = e.backgroundBlurriness,
        this.backgroundIntensity = e.backgroundIntensity,
        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
        this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
        t
    }
    get autoUpdate() {
        return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),
        this.matrixWorldAutoUpdate
    }
    set autoUpdate(e) {
        console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),
        this.matrixWorldAutoUpdate = e
    }
}
class nh {
    constructor(e, t) {
        this.isInterleavedBuffer = !0,
        this.array = e,
        this.stride = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.usage = bd,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0,
        this.uuid = Ji()
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    copy(e) {
        return this.array = new e.array.constructor(e.array),
        this.count = e.count,
        this.stride = e.stride,
        this.usage = e.usage,
        this
    }
    copyAt(e, t, i) {
        e *= this.stride,
        i *= t.stride;
        for (let r = 0, s = this.stride; r < s; r++)
            this.array[e + r] = t.array[i + r];
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ji()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
          , i = new this.constructor(t,this.stride);
        return i.setUsage(this.usage),
        i
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    toJSON(e) {
        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ji()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
        {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const di = new D;
class ia {
    constructor(e, t, i, r=!1) {
        this.isInterleavedBufferAttribute = !0,
        this.name = "",
        this.data = e,
        this.itemSize = t,
        this.offset = i,
        this.normalized = r
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e
    }
    applyMatrix4(e) {
        for (let t = 0, i = this.data.count; t < i; t++)
            di.fromBufferAttribute(this, t),
            di.applyMatrix4(e),
            this.setXYZ(t, di.x, di.y, di.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++)
            di.fromBufferAttribute(this, t),
            di.applyNormalMatrix(e),
            this.setXYZ(t, di.x, di.y, di.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++)
            di.fromBufferAttribute(this, t),
            di.transformDirection(e),
            this.setXYZ(t, di.x, di.y, di.z);
        return this
    }
    setX(e, t) {
        return this.normalized && (t = Vt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset] = t,
        this
    }
    setY(e, t) {
        return this.normalized && (t = Vt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 1] = t,
        this
    }
    setZ(e, t) {
        return this.normalized && (t = Vt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 2] = t,
        this
    }
    setW(e, t) {
        return this.normalized && (t = Vt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 3] = t,
        this
    }
    getX(e) {
        let t = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (t = Gs(t, this.array)),
        t
    }
    getY(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (t = Gs(t, this.array)),
        t
    }
    getZ(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (t = Gs(t, this.array)),
        t
    }
    getW(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (t = Gs(t, this.array)),
        t
    }
    setXY(e, t, i) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = Vt(t, this.array),
        i = Vt(i, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = i,
        this
    }
    setXYZ(e, t, i, r) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = Vt(t, this.array),
        i = Vt(i, this.array),
        r = Vt(r, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = i,
        this.data.array[e + 2] = r,
        this
    }
    setXYZW(e, t, i, r, s) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = Vt(t, this.array),
        i = Vt(i, this.array),
        r = Vt(r, this.array),
        s = Vt(s, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = i,
        this.data.array[e + 2] = r,
        this.data.array[e + 3] = s,
        this
    }
    clone(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
                const r = i * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++)
                    t.push(this.data.array[r + s])
            }
            return new Nt(new this.array.constructor(t),this.itemSize,this.normalized)
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
            new ia(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
    }
    toJSON(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
                const r = i * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++)
                    t.push(this.data.array[r + s])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized
            }
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
            {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
    }
}
class Lw extends Tn {
    constructor(e) {
        super(),
        this.isSpriteMaterial = !0,
        this.type = "SpriteMaterial",
        this.color = new Ie(16777215),
        this.map = null,
        this.alphaMap = null,
        this.rotation = 0,
        this.sizeAttenuation = !0,
        this.transparent = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.rotation = e.rotation,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
let cu;
const hf = new D
  , fu = new D
  , du = new D
  , hu = new me
  , pf = new me
  , ZR = new ot
  , rm = new D
  , mf = new D
  , sm = new D
  , EE = new me
  , sx = new me
  , TE = new me;
class qR extends Rt {
    constructor(e) {
        if (super(),
        this.isSprite = !0,
        this.type = "Sprite",
        cu === void 0) {
            cu = new ft;
            const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1])
              , i = new nh(t,5);
            cu.setIndex([0, 1, 2, 0, 2, 3]),
            cu.setAttribute("position", new ia(i,3,0,!1)),
            cu.setAttribute("uv", new ia(i,2,3,!1))
        }
        this.geometry = cu,
        this.material = e !== void 0 ? e : new Lw,
        this.center = new me(.5,.5)
    }
    raycast(e, t) {
        e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
        fu.setFromMatrixScale(this.matrixWorld),
        ZR.copy(e.camera.matrixWorld),
        this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld),
        du.setFromMatrixPosition(this.modelViewMatrix),
        e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && fu.multiplyScalar(-du.z);
        const i = this.material.rotation;
        let r, s;
        i !== 0 && (s = Math.cos(i),
        r = Math.sin(i));
        const o = this.center;
        om(rm.set(-.5, -.5, 0), du, o, fu, r, s),
        om(mf.set(.5, -.5, 0), du, o, fu, r, s),
        om(sm.set(.5, .5, 0), du, o, fu, r, s),
        EE.set(0, 0),
        sx.set(1, 0),
        TE.set(1, 1);
        let a = e.ray.intersectTriangle(rm, mf, sm, !1, hf);
        if (a === null && (om(mf.set(-.5, .5, 0), du, o, fu, r, s),
        sx.set(0, 1),
        a = e.ray.intersectTriangle(rm, sm, mf, !1, hf),
        a === null))
            return;
        const l = e.ray.origin.distanceTo(hf);
        l < e.near || l > e.far || t.push({
            distance: l,
            point: hf.clone(),
            uv: yr.getUV(hf, rm, mf, sm, EE, sx, TE, new me),
            face: null,
            object: this
        })
    }
    copy(e, t) {
        return super.copy(e, t),
        e.center !== void 0 && this.center.copy(e.center),
        this.material = e.material,
        this
    }
}
function om(n, e, t, i, r, s) {
    hu.subVectors(n, t).addScalar(.5).multiply(i),
    r !== void 0 ? (pf.x = s * hu.x - r * hu.y,
    pf.y = r * hu.x + s * hu.y) : pf.copy(hu),
    n.copy(e),
    n.x += pf.x,
    n.y += pf.y,
    n.applyMatrix4(ZR)
}
const am = new D
  , PE = new D;
class $R extends Rt {
    constructor() {
        super(),
        this._currentLevel = 0,
        this.type = "LOD",
        Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            },
            isLOD: {
                value: !0
            }
        }),
        this.autoUpdate = !0
    }
    copy(e) {
        super.copy(e, !1);
        const t = e.levels;
        for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            this.addLevel(s.object.clone(), s.distance, s.hysteresis)
        }
        return this.autoUpdate = e.autoUpdate,
        this
    }
    addLevel(e, t=0, i=0) {
        t = Math.abs(t);
        const r = this.levels;
        let s;
        for (s = 0; s < r.length && !(t < r[s].distance); s++)
            ;
        return r.splice(s, 0, {
            distance: t,
            hysteresis: i,
            object: e
        }),
        this.add(e),
        this
    }
    getCurrentLevel() {
        return this._currentLevel
    }
    getObjectForDistance(e) {
        const t = this.levels;
        if (t.length > 0) {
            let i, r;
            for (i = 1,
            r = t.length; i < r; i++) {
                let s = t[i].distance;
                if (t[i].object.visible && (s -= s * t[i].hysteresis),
                e < s)
                    break
            }
            return t[i - 1].object
        }
        return null
    }
    raycast(e, t) {
        if (this.levels.length > 0) {
            am.setFromMatrixPosition(this.matrixWorld);
            const r = e.ray.origin.distanceTo(am);
            this.getObjectForDistance(r).raycast(e, t)
        }
    }
    update(e) {
        const t = this.levels;
        if (t.length > 1) {
            am.setFromMatrixPosition(e.matrixWorld),
            PE.setFromMatrixPosition(this.matrixWorld);
            const i = am.distanceTo(PE) / e.zoom;
            t[0].object.visible = !0;
            let r, s;
            for (r = 1,
            s = t.length; r < s; r++) {
                let o = t[r].distance;
                if (t[r].object.visible && (o -= o * t[r].hysteresis),
                i >= o)
                    t[r - 1].object.visible = !1,
                    t[r].object.visible = !0;
                else
                    break
            }
            for (this._currentLevel = r - 1; r < s; r++)
                t[r].object.visible = !1
        }
    }
    toJSON(e) {
        const t = super.toJSON(e);
        this.autoUpdate === !1 && (t.object.autoUpdate = !1),
        t.object.levels = [];
        const i = this.levels;
        for (let r = 0, s = i.length; r < s; r++) {
            const o = i[r];
            t.object.levels.push({
                object: o.object.uuid,
                distance: o.distance,
                hysteresis: o.hysteresis
            })
        }
        return t
    }
}
const BE = new D
  , RE = new Ut
  , IE = new Ut
  , X9 = new D
  , LE = new ot;
class Dw extends Ln {
    constructor(e, t) {
        super(e, t),
        this.isSkinnedMesh = !0,
        this.type = "SkinnedMesh",
        this.bindMode = "attached",
        this.bindMatrix = new ot,
        this.bindMatrixInverse = new ot
    }
    copy(e, t) {
        return super.copy(e, t),
        this.bindMode = e.bindMode,
        this.bindMatrix.copy(e.bindMatrix),
        this.bindMatrixInverse.copy(e.bindMatrixInverse),
        this.skeleton = e.skeleton,
        this
    }
    bind(e, t) {
        this.skeleton = e,
        t === void 0 && (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        t = this.matrixWorld),
        this.bindMatrix.copy(t),
        this.bindMatrixInverse.copy(t).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        const e = new Ut
          , t = this.geometry.attributes.skinWeight;
        for (let i = 0, r = t.count; i < r; i++) {
            e.fromBufferAttribute(t, i);
            const s = 1 / e.manhattanLength();
            s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
            t.setXYZW(i, e.x, e.y, e.z, e.w)
        }
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    boneTransform(e, t) {
        const i = this.skeleton
          , r = this.geometry;
        RE.fromBufferAttribute(r.attributes.skinIndex, e),
        IE.fromBufferAttribute(r.attributes.skinWeight, e),
        BE.copy(t).applyMatrix4(this.bindMatrix),
        t.set(0, 0, 0);
        for (let s = 0; s < 4; s++) {
            const o = IE.getComponent(s);
            if (o !== 0) {
                const a = RE.getComponent(s);
                LE.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]),
                t.addScaledVector(X9.copy(BE).applyMatrix4(LE), o)
            }
        }
        return t.applyMatrix4(this.bindMatrixInverse)
    }
}
class I0 extends Rt {
    constructor() {
        super(),
        this.isBone = !0,
        this.type = "Bone"
    }
}
class Ju extends tn {
    constructor(e=null, t=1, i=1, r, s, o, a, l, c=gn, d=gn, h, p) {
        super(null, o, a, l, c, d, r, s, h, p),
        this.isDataTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i
        },
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
const DE = new ot
  , Y9 = new ot;
class ih {
    constructor(e=[], t=[]) {
        this.uuid = Ji(),
        this.bones = e.slice(0),
        this.boneInverses = t,
        this.boneMatrices = null,
        this.boneTexture = null,
        this.boneTextureSize = 0,
        this.frame = -1,
        this.init()
    }
    init() {
        const e = this.bones
          , t = this.boneInverses;
        if (this.boneMatrices = new Float32Array(e.length * 16),
        t.length === 0)
            this.calculateInverses();
        else if (e.length !== t.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
            this.boneInverses = [];
            for (let i = 0, r = this.bones.length; i < r; i++)
                this.boneInverses.push(new ot)
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = new ot;
            this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
            this.boneInverses.push(i)
        }
    }
    pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && i.matrixWorld.copy(this.boneInverses[e]).invert()
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(),
            i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld),
            i.matrix.decompose(i.position, i.quaternion, i.scale))
        }
    }
    update() {
        const e = this.bones
          , t = this.boneInverses
          , i = this.boneMatrices
          , r = this.boneTexture;
        for (let s = 0, o = e.length; s < o; s++) {
            const a = e[s] ? e[s].matrixWorld : Y9;
            DE.multiplyMatrices(a, t[s]),
            DE.toArray(i, s * 16)
        }
        r !== null && (r.needsUpdate = !0)
    }
    clone() {
        return new ih(this.bones,this.boneInverses)
    }
    computeBoneTexture() {
        let e = Math.sqrt(this.bones.length * 4);
        e = NR(e),
        e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const i = new Ju(t,e,e,Ti,zs);
        return i.needsUpdate = !0,
        this.boneMatrices = t,
        this.boneTexture = i,
        this.boneTextureSize = e,
        this
    }
    getBoneByName(e) {
        for (let t = 0, i = this.bones.length; t < i; t++) {
            const r = this.bones[t];
            if (r.name === e)
                return r
        }
    }
    dispose() {
        this.boneTexture !== null && (this.boneTexture.dispose(),
        this.boneTexture = null)
    }
    fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let i = 0, r = e.bones.length; i < r; i++) {
            const s = e.bones[i];
            let o = t[s];
            o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s),
            o = new I0),
            this.bones.push(o),
            this.boneInverses.push(new ot().fromArray(e.boneInverses[i]))
        }
        return this.init(),
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.5,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        e.uuid = this.uuid;
        const t = this.bones
          , i = this.boneInverses;
        for (let r = 0, s = t.length; r < s; r++) {
            const o = t[r];
            e.bones.push(o.uuid);
            const a = i[r];
            e.boneInverses.push(a.toArray())
        }
        return e
    }
}
class ac extends Nt {
    constructor(e, t, i, r=1) {
        super(e, t, i),
        this.isInstancedBufferAttribute = !0,
        this.meshPerAttribute = r
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute,
        e.isInstancedBufferAttribute = !0,
        e
    }
}
const kE = new ot
  , FE = new ot
  , lm = []
  , K9 = new ot
  , gf = new Ln;
class eI extends Ln {
    constructor(e, t, i) {
        super(e, t),
        this.isInstancedMesh = !0,
        this.instanceMatrix = new ac(new Float32Array(i * 16),16),
        this.instanceColor = null,
        this.count = i,
        this.frustumCulled = !1;
        for (let r = 0; r < i; r++)
            this.setMatrixAt(r, K9)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.instanceMatrix.copy(e.instanceMatrix),
        e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()),
        this.count = e.count,
        this
    }
    getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, e * 3)
    }
    getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, e * 16)
    }
    raycast(e, t) {
        const i = this.matrixWorld
          , r = this.count;
        if (gf.geometry = this.geometry,
        gf.material = this.material,
        gf.material !== void 0)
            for (let s = 0; s < r; s++) {
                this.getMatrixAt(s, kE),
                FE.multiplyMatrices(i, kE),
                gf.matrixWorld = FE,
                gf.raycast(e, lm);
                for (let o = 0, a = lm.length; o < a; o++) {
                    const l = lm[o];
                    l.instanceId = s,
                    l.object = this,
                    t.push(l)
                }
                lm.length = 0
            }
    }
    setColorAt(e, t) {
        this.instanceColor === null && (this.instanceColor = new ac(new Float32Array(this.instanceMatrix.count * 3),3)),
        t.toArray(this.instanceColor.array, e * 3)
    }
    setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, e * 16)
    }
    updateMorphTargets() {}
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class li extends Tn {
    constructor(e) {
        super(),
        this.isLineBasicMaterial = !0,
        this.type = "LineBasicMaterial",
        this.color = new Ie(16777215),
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.linewidth = e.linewidth,
        this.linecap = e.linecap,
        this.linejoin = e.linejoin,
        this.fog = e.fog,
        this
    }
}
const NE = new D
  , OE = new D
  , UE = new ot
  , ox = new $d
  , um = new pa;
class eo extends Rt {
    constructor(e=new ft, t=new li) {
        super(),
        this.isLine = !0,
        this.type = "Line",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = e.material,
        this.geometry = e.geometry,
        this
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , i = [0];
            for (let r = 1, s = t.count; r < s; r++)
                NE.fromBufferAttribute(t, r - 1),
                OE.fromBufferAttribute(t, r),
                i[r] = i[r - 1],
                i[r] += NE.distanceTo(OE);
            e.setAttribute("lineDistance", new je(i,1))
        } else
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(e, t) {
        const i = this.geometry
          , r = this.matrixWorld
          , s = e.params.Line.threshold
          , o = i.drawRange;
        if (i.boundingSphere === null && i.computeBoundingSphere(),
        um.copy(i.boundingSphere),
        um.applyMatrix4(r),
        um.radius += s,
        e.ray.intersectsSphere(um) === !1)
            return;
        UE.copy(r).invert(),
        ox.copy(e.ray).applyMatrix4(UE);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , l = a * a
          , c = new D
          , d = new D
          , h = new D
          , p = new D
          , m = this.isLineSegments ? 2 : 1
          , y = i.index
          , x = i.attributes.position;
        if (y !== null) {
            const _ = Math.max(0, o.start)
              , A = Math.min(y.count, o.start + o.count);
            for (let w = _, M = A - 1; w < M; w += m) {
                const C = y.getX(w)
                  , P = y.getX(w + 1);
                if (c.fromBufferAttribute(x, C),
                d.fromBufferAttribute(x, P),
                ox.distanceSqToSegment(c, d, p, h) > l)
                    continue;
                p.applyMatrix4(this.matrixWorld);
                const E = e.ray.origin.distanceTo(p);
                E < e.near || E > e.far || t.push({
                    distance: E,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: w,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        } else {
            const _ = Math.max(0, o.start)
              , A = Math.min(x.count, o.start + o.count);
            for (let w = _, M = A - 1; w < M; w += m) {
                if (c.fromBufferAttribute(x, w),
                d.fromBufferAttribute(x, w + 1),
                ox.distanceSqToSegment(c, d, p, h) > l)
                    continue;
                p.applyMatrix4(this.matrixWorld);
                const P = e.ray.origin.distanceTo(p);
                P < e.near || P > e.far || t.push({
                    distance: P,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: w,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}
const zE = new D
  , GE = new D;
class Jr extends eo {
    constructor(e, t) {
        super(e, t),
        this.isLineSegments = !0,
        this.type = "LineSegments"
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , i = [];
            for (let r = 0, s = t.count; r < s; r += 2)
                zE.fromBufferAttribute(t, r),
                GE.fromBufferAttribute(t, r + 1),
                i[r] = r === 0 ? 0 : i[r - 1],
                i[r + 1] = i[r] + zE.distanceTo(GE);
            e.setAttribute("lineDistance", new je(i,1))
        } else
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class kw extends eo {
    constructor(e, t) {
        super(e, t),
        this.isLineLoop = !0,
        this.type = "LineLoop"
    }
}
class rh extends Tn {
    constructor(e) {
        super(),
        this.isPointsMaterial = !0,
        this.type = "PointsMaterial",
        this.color = new Ie(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
const HE = new ot
  , x_ = new $d
  , cm = new pa
  , fm = new D;
let Fw = class extends Rt {
    constructor(e=new ft, t=new rh) {
        super(),
        this.isPoints = !0,
        this.type = "Points",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = e.material,
        this.geometry = e.geometry,
        this
    }
    raycast(e, t) {
        const i = this.geometry
          , r = this.matrixWorld
          , s = e.params.Points.threshold
          , o = i.drawRange;
        if (i.boundingSphere === null && i.computeBoundingSphere(),
        cm.copy(i.boundingSphere),
        cm.applyMatrix4(r),
        cm.radius += s,
        e.ray.intersectsSphere(cm) === !1)
            return;
        HE.copy(r).invert(),
        x_.copy(e.ray).applyMatrix4(HE);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , l = a * a
          , c = i.index
          , h = i.attributes.position;
        if (c !== null) {
            const p = Math.max(0, o.start)
              , m = Math.min(c.count, o.start + o.count);
            for (let y = p, v = m; y < v; y++) {
                const x = c.getX(y);
                fm.fromBufferAttribute(h, x),
                VE(fm, x, l, r, e, t, this)
            }
        } else {
            const p = Math.max(0, o.start)
              , m = Math.min(h.count, o.start + o.count);
            for (let y = p, v = m; y < v; y++)
                fm.fromBufferAttribute(h, y),
                VE(fm, y, l, r, e, t, this)
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}
;
function VE(n, e, t, i, r, s, o) {
    const a = x_.distanceSqToPoint(n);
    if (a < t) {
        const l = new D;
        x_.closestPointToPoint(n, l),
        l.applyMatrix4(i);
        const c = r.ray.origin.distanceTo(l);
        if (c < r.near || c > r.far)
            return;
        s.push({
            distance: c,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: e,
            face: null,
            object: o
        })
    }
}
class Q9 extends tn {
    constructor(e, t, i, r, s, o, a, l, c) {
        super(e, t, i, r, s, o, a, l, c),
        this.isVideoTexture = !0,
        this.minFilter = o !== void 0 ? o : on,
        this.magFilter = s !== void 0 ? s : on,
        this.generateMipmaps = !1;
        const d = this;
        function h() {
            d.needsUpdate = !0,
            e.requestVideoFrameCallback(h)
        }
        "requestVideoFrameCallback"in e && e.requestVideoFrameCallback(h)
    }
    clone() {
        return new this.constructor(this.image).copy(this)
    }
    update() {
        const e = this.image;
        "requestVideoFrameCallback"in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
}
class Z9 extends tn {
    constructor(e, t, i) {
        super({
            width: e,
            height: t
        }),
        this.isFramebufferTexture = !0,
        this.format = i,
        this.magFilter = gn,
        this.minFilter = gn,
        this.generateMipmaps = !1,
        this.needsUpdate = !0
    }
}
class Nw extends tn {
    constructor(e, t, i, r, s, o, a, l, c, d, h, p) {
        super(null, o, a, l, c, d, r, s, h, p),
        this.isCompressedTexture = !0,
        this.image = {
            width: t,
            height: i
        },
        this.mipmaps = e,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
}
class q9 extends Nw {
    constructor(e, t, i, r, s, o) {
        super(e, t, i, s, o),
        this.isCompressedArrayTexture = !0,
        this.image.depth = r,
        this.wrapR = Xn
    }
}
class $9 extends tn {
    constructor(e, t, i, r, s, o, a, l, c) {
        super(e, t, i, r, s, o, a, l, c),
        this.isCanvasTexture = !0,
        this.needsUpdate = !0
    }
}
class Xr {
    constructor() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."),
        null
    }
    getPointAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getPoint(i, t)
    }
    getPoints(e=5) {
        const t = [];
        for (let i = 0; i <= e; i++)
            t.push(this.getPoint(i / e));
        return t
    }
    getSpacedPoints(e=5) {
        const t = [];
        for (let i = 0; i <= e; i++)
            t.push(this.getPointAt(i / e));
        return t
    }
    getLength() {
        const e = this.getLengths();
        return e[e.length - 1]
    }
    getLengths(e=this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
            return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let i, r = this.getPoint(0), s = 0;
        t.push(0);
        for (let o = 1; o <= e; o++)
            i = this.getPoint(o / e),
            s += i.distanceTo(r),
            t.push(s),
            r = i;
        return this.cacheArcLengths = t,
        t
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.getLengths()
    }
    getUtoTmapping(e, t) {
        const i = this.getLengths();
        let r = 0;
        const s = i.length;
        let o;
        t ? o = t : o = e * i[s - 1];
        let a = 0, l = s - 1, c;
        for (; a <= l; )
            if (r = Math.floor(a + (l - a) / 2),
            c = i[r] - o,
            c < 0)
                a = r + 1;
            else if (c > 0)
                l = r - 1;
            else {
                l = r;
                break
            }
        if (r = l,
        i[r] === o)
            return r / (s - 1);
        const d = i[r]
          , p = i[r + 1] - d
          , m = (o - d) / p;
        return (r + m) / (s - 1)
    }
    getTangent(e, t) {
        let r = e - 1e-4
          , s = e + 1e-4;
        r < 0 && (r = 0),
        s > 1 && (s = 1);
        const o = this.getPoint(r)
          , a = this.getPoint(s)
          , l = t || (o.isVector2 ? new me : new D);
        return l.copy(a).sub(o).normalize(),
        l
    }
    getTangentAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getTangent(i, t)
    }
    computeFrenetFrames(e, t) {
        const i = new D
          , r = []
          , s = []
          , o = []
          , a = new D
          , l = new ot;
        for (let m = 0; m <= e; m++) {
            const y = m / e;
            r[m] = this.getTangentAt(y, new D)
        }
        s[0] = new D,
        o[0] = new D;
        let c = Number.MAX_VALUE;
        const d = Math.abs(r[0].x)
          , h = Math.abs(r[0].y)
          , p = Math.abs(r[0].z);
        d <= c && (c = d,
        i.set(1, 0, 0)),
        h <= c && (c = h,
        i.set(0, 1, 0)),
        p <= c && i.set(0, 0, 1),
        a.crossVectors(r[0], i).normalize(),
        s[0].crossVectors(r[0], a),
        o[0].crossVectors(r[0], s[0]);
        for (let m = 1; m <= e; m++) {
            if (s[m] = s[m - 1].clone(),
            o[m] = o[m - 1].clone(),
            a.crossVectors(r[m - 1], r[m]),
            a.length() > Number.EPSILON) {
                a.normalize();
                const y = Math.acos(wn(r[m - 1].dot(r[m]), -1, 1));
                s[m].applyMatrix4(l.makeRotationAxis(a, y))
            }
            o[m].crossVectors(r[m], s[m])
        }
        if (t === !0) {
            let m = Math.acos(wn(s[0].dot(s[e]), -1, 1));
            m /= e,
            r[0].dot(a.crossVectors(s[0], s[e])) > 0 && (m = -m);
            for (let y = 1; y <= e; y++)
                s[y].applyMatrix4(l.makeRotationAxis(r[y], m * y)),
                o[y].crossVectors(r[y], s[y])
        }
        return {
            tangents: r,
            normals: s,
            binormals: o
        }
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return e.arcLengthDivisions = this.arcLengthDivisions,
        e.type = this.type,
        e
    }
    fromJSON(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
}
class L0 extends Xr {
    constructor(e=0, t=0, i=1, r=1, s=0, o=Math.PI * 2, a=!1, l=0) {
        super(),
        this.isEllipseCurve = !0,
        this.type = "EllipseCurve",
        this.aX = e,
        this.aY = t,
        this.xRadius = i,
        this.yRadius = r,
        this.aStartAngle = s,
        this.aEndAngle = o,
        this.aClockwise = a,
        this.aRotation = l
    }
    getPoint(e, t) {
        const i = t || new me
          , r = Math.PI * 2;
        let s = this.aEndAngle - this.aStartAngle;
        const o = Math.abs(s) < Number.EPSILON;
        for (; s < 0; )
            s += r;
        for (; s > r; )
            s -= r;
        s < Number.EPSILON && (o ? s = 0 : s = r),
        this.aClockwise === !0 && !o && (s === r ? s = -r : s = s - r);
        const a = this.aStartAngle + e * s;
        let l = this.aX + this.xRadius * Math.cos(a)
          , c = this.aY + this.yRadius * Math.sin(a);
        if (this.aRotation !== 0) {
            const d = Math.cos(this.aRotation)
              , h = Math.sin(this.aRotation)
              , p = l - this.aX
              , m = c - this.aY;
            l = p * d - m * h + this.aX,
            c = p * h + m * d + this.aY
        }
        return i.set(l, c)
    }
    copy(e) {
        return super.copy(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.aX = this.aX,
        e.aY = this.aY,
        e.xRadius = this.xRadius,
        e.yRadius = this.yRadius,
        e.aStartAngle = this.aStartAngle,
        e.aEndAngle = this.aEndAngle,
        e.aClockwise = this.aClockwise,
        e.aRotation = this.aRotation,
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
}
class tI extends L0 {
    constructor(e, t, i, r, s, o) {
        super(e, t, i, i, r, s, o),
        this.isArcCurve = !0,
        this.type = "ArcCurve"
    }
}
function Ow() {
    let n = 0
      , e = 0
      , t = 0
      , i = 0;
    function r(s, o, a, l) {
        n = s,
        e = a,
        t = -3 * s + 3 * o - 2 * a - l,
        i = 2 * s - 2 * o + a + l
    }
    return {
        initCatmullRom: function(s, o, a, l, c) {
            r(o, a, c * (a - s), c * (l - o))
        },
        initNonuniformCatmullRom: function(s, o, a, l, c, d, h) {
            let p = (o - s) / c - (a - s) / (c + d) + (a - o) / d
              , m = (a - o) / d - (l - o) / (d + h) + (l - a) / h;
            p *= d,
            m *= d,
            r(o, a, p, m)
        },
        calc: function(s) {
            const o = s * s
              , a = o * s;
            return n + e * s + t * o + i * a
        }
    }
}
const dm = new D
  , ax = new Ow
  , lx = new Ow
  , ux = new Ow;
class nI extends Xr {
    constructor(e=[], t=!1, i="centripetal", r=.5) {
        super(),
        this.isCatmullRomCurve3 = !0,
        this.type = "CatmullRomCurve3",
        this.points = e,
        this.closed = t,
        this.curveType = i,
        this.tension = r
    }
    getPoint(e, t=new D) {
        const i = t
          , r = this.points
          , s = r.length
          , o = (s - (this.closed ? 0 : 1)) * e;
        let a = Math.floor(o)
          , l = o - a;
        this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : l === 0 && a === s - 1 && (a = s - 2,
        l = 1);
        let c, d;
        this.closed || a > 0 ? c = r[(a - 1) % s] : (dm.subVectors(r[0], r[1]).add(r[0]),
        c = dm);
        const h = r[a % s]
          , p = r[(a + 1) % s];
        if (this.closed || a + 2 < s ? d = r[(a + 2) % s] : (dm.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]),
        d = dm),
        this.curveType === "centripetal" || this.curveType === "chordal") {
            const m = this.curveType === "chordal" ? .5 : .25;
            let y = Math.pow(c.distanceToSquared(h), m)
              , v = Math.pow(h.distanceToSquared(p), m)
              , x = Math.pow(p.distanceToSquared(d), m);
            v < 1e-4 && (v = 1),
            y < 1e-4 && (y = v),
            x < 1e-4 && (x = v),
            ax.initNonuniformCatmullRom(c.x, h.x, p.x, d.x, y, v, x),
            lx.initNonuniformCatmullRom(c.y, h.y, p.y, d.y, y, v, x),
            ux.initNonuniformCatmullRom(c.z, h.z, p.z, d.z, y, v, x)
        } else
            this.curveType === "catmullrom" && (ax.initCatmullRom(c.x, h.x, p.x, d.x, this.tension),
            lx.initCatmullRom(c.y, h.y, p.y, d.y, this.tension),
            ux.initCatmullRom(c.z, h.z, p.z, d.z, this.tension));
        return i.set(ax.calc(l), lx.calc(l), ux.calc(l)),
        i
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(r.clone())
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, i = this.points.length; t < i; t++) {
            const r = this.points[t];
            e.points.push(r.toArray())
        }
        return e.closed = this.closed,
        e.curveType = this.curveType,
        e.tension = this.tension,
        e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(new D().fromArray(r))
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
}
function WE(n, e, t, i, r) {
    const s = (i - e) * .5
      , o = (r - t) * .5
      , a = n * n
      , l = n * a;
    return (2 * t - 2 * i + s + o) * l + (-3 * t + 3 * i - 2 * s - o) * a + s * n + t
}
function eH(n, e) {
    const t = 1 - n;
    return t * t * e
}
function tH(n, e) {
    return 2 * (1 - n) * n * e
}
function nH(n, e) {
    return n * n * e
}
function Jf(n, e, t, i) {
    return eH(n, e) + tH(n, t) + nH(n, i)
}
function iH(n, e) {
    const t = 1 - n;
    return t * t * t * e
}
function rH(n, e) {
    const t = 1 - n;
    return 3 * t * t * n * e
}
function sH(n, e) {
    return 3 * (1 - n) * n * n * e
}
function oH(n, e) {
    return n * n * n * e
}
function Xf(n, e, t, i, r) {
    return iH(n, e) + rH(n, t) + sH(n, i) + oH(n, r)
}
class Uw extends Xr {
    constructor(e=new me, t=new me, i=new me, r=new me) {
        super(),
        this.isCubicBezierCurve = !0,
        this.type = "CubicBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i,
        this.v3 = r
    }
    getPoint(e, t=new me) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2
          , a = this.v3;
        return i.set(Xf(e, r.x, s.x, o.x, a.x), Xf(e, r.y, s.y, o.y, a.y)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class iI extends Xr {
    constructor(e=new D, t=new D, i=new D, r=new D) {
        super(),
        this.isCubicBezierCurve3 = !0,
        this.type = "CubicBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i,
        this.v3 = r
    }
    getPoint(e, t=new D) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2
          , a = this.v3;
        return i.set(Xf(e, r.x, s.x, o.x, a.x), Xf(e, r.y, s.y, o.y, a.y), Xf(e, r.z, s.z, o.z, a.z)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class D0 extends Xr {
    constructor(e=new me, t=new me) {
        super(),
        this.isLineCurve = !0,
        this.type = "LineCurve",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new me) {
        const i = t;
        return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1),
        i.multiplyScalar(e).add(this.v1)),
        i
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t) {
        const i = t || new me;
        return i.copy(this.v2).sub(this.v1).normalize(),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class rI extends Xr {
    constructor(e=new D, t=new D) {
        super(),
        this.isLineCurve3 = !0,
        this.type = "LineCurve3",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new D) {
        const i = t;
        return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1),
        i.multiplyScalar(e).add(this.v1)),
        i
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class zw extends Xr {
    constructor(e=new me, t=new me, i=new me) {
        super(),
        this.isQuadraticBezierCurve = !0,
        this.type = "QuadraticBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i
    }
    getPoint(e, t=new me) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2;
        return i.set(Jf(e, r.x, s.x, o.x), Jf(e, r.y, s.y, o.y)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class Gw extends Xr {
    constructor(e=new D, t=new D, i=new D) {
        super(),
        this.isQuadraticBezierCurve3 = !0,
        this.type = "QuadraticBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i
    }
    getPoint(e, t=new D) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2;
        return i.set(Jf(e, r.x, s.x, o.x), Jf(e, r.y, s.y, o.y), Jf(e, r.z, s.z, o.z)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class Hw extends Xr {
    constructor(e=[]) {
        super(),
        this.isSplineCurve = !0,
        this.type = "SplineCurve",
        this.points = e
    }
    getPoint(e, t=new me) {
        const i = t
          , r = this.points
          , s = (r.length - 1) * e
          , o = Math.floor(s)
          , a = s - o
          , l = r[o === 0 ? o : o - 1]
          , c = r[o]
          , d = r[o > r.length - 2 ? r.length - 1 : o + 1]
          , h = r[o > r.length - 3 ? r.length - 1 : o + 2];
        return i.set(WE(a, l.x, c.x, d.x, h.x), WE(a, l.y, c.y, d.y, h.y)),
        i
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(r.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, i = this.points.length; t < i; t++) {
            const r = this.points[t];
            e.points.push(r.toArray())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(new me().fromArray(r))
        }
        return this
    }
}
var Vw = Object.freeze({
    __proto__: null,
    ArcCurve: tI,
    CatmullRomCurve3: nI,
    CubicBezierCurve: Uw,
    CubicBezierCurve3: iI,
    EllipseCurve: L0,
    LineCurve: D0,
    LineCurve3: rI,
    QuadraticBezierCurve: zw,
    QuadraticBezierCurve3: Gw,
    SplineCurve: Hw
});
class sI extends Xr {
    constructor() {
        super(),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    add(e) {
        this.curves.push(e)
    }
    closePath() {
        const e = this.curves[0].getPoint(0)
          , t = this.curves[this.curves.length - 1].getPoint(1);
        e.equals(t) || this.curves.push(new D0(t,e))
    }
    getPoint(e, t) {
        const i = e * this.getLength()
          , r = this.getCurveLengths();
        let s = 0;
        for (; s < r.length; ) {
            if (r[s] >= i) {
                const o = r[s] - i
                  , a = this.curves[s]
                  , l = a.getLength()
                  , c = l === 0 ? 0 : 1 - o / l;
                return a.getPointAt(c, t)
            }
            s++
        }
        return null
    }
    getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1]
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.cacheLengths = null,
        this.getCurveLengths()
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
            return this.cacheLengths;
        const e = [];
        let t = 0;
        for (let i = 0, r = this.curves.length; i < r; i++)
            t += this.curves[i].getLength(),
            e.push(t);
        return this.cacheLengths = e,
        e
    }
    getSpacedPoints(e=40) {
        const t = [];
        for (let i = 0; i <= e; i++)
            t.push(this.getPoint(i / e));
        return this.autoClose && t.push(t[0]),
        t
    }
    getPoints(e=12) {
        const t = [];
        let i;
        for (let r = 0, s = this.curves; r < s.length; r++) {
            const o = s[r]
              , a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e
              , l = o.getPoints(a);
            for (let c = 0; c < l.length; c++) {
                const d = l[c];
                i && i.equals(d) || (t.push(d),
                i = d)
            }
        }
        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]),
        t
    }
    copy(e) {
        super.copy(e),
        this.curves = [];
        for (let t = 0, i = e.curves.length; t < i; t++) {
            const r = e.curves[t];
            this.curves.push(r.clone())
        }
        return this.autoClose = e.autoClose,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.autoClose = this.autoClose,
        e.curves = [];
        for (let t = 0, i = this.curves.length; t < i; t++) {
            const r = this.curves[t];
            e.curves.push(r.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.autoClose = e.autoClose,
        this.curves = [];
        for (let t = 0, i = e.curves.length; t < i; t++) {
            const r = e.curves[t];
            this.curves.push(new Vw[r.type]().fromJSON(r))
        }
        return this
    }
}
class Td extends sI {
    constructor(e) {
        super(),
        this.type = "Path",
        this.currentPoint = new me,
        e && this.setFromPoints(e)
    }
    setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, i = e.length; t < i; t++)
            this.lineTo(e[t].x, e[t].y);
        return this
    }
    moveTo(e, t) {
        return this.currentPoint.set(e, t),
        this
    }
    lineTo(e, t) {
        const i = new D0(this.currentPoint.clone(),new me(e,t));
        return this.curves.push(i),
        this.currentPoint.set(e, t),
        this
    }
    quadraticCurveTo(e, t, i, r) {
        const s = new zw(this.currentPoint.clone(),new me(e,t),new me(i,r));
        return this.curves.push(s),
        this.currentPoint.set(i, r),
        this
    }
    bezierCurveTo(e, t, i, r, s, o) {
        const a = new Uw(this.currentPoint.clone(),new me(e,t),new me(i,r),new me(s,o));
        return this.curves.push(a),
        this.currentPoint.set(s, o),
        this
    }
    splineThru(e) {
        const t = [this.currentPoint.clone()].concat(e)
          , i = new Hw(t);
        return this.curves.push(i),
        this.currentPoint.copy(e[e.length - 1]),
        this
    }
    arc(e, t, i, r, s, o) {
        const a = this.currentPoint.x
          , l = this.currentPoint.y;
        return this.absarc(e + a, t + l, i, r, s, o),
        this
    }
    absarc(e, t, i, r, s, o) {
        return this.absellipse(e, t, i, i, r, s, o),
        this
    }
    ellipse(e, t, i, r, s, o, a, l) {
        const c = this.currentPoint.x
          , d = this.currentPoint.y;
        return this.absellipse(e + c, t + d, i, r, s, o, a, l),
        this
    }
    absellipse(e, t, i, r, s, o, a, l) {
        const c = new L0(e,t,i,r,s,o,a,l);
        if (this.curves.length > 0) {
            const h = c.getPoint(0);
            h.equals(this.currentPoint) || this.lineTo(h.x, h.y)
        }
        this.curves.push(c);
        const d = c.getPoint(1);
        return this.currentPoint.copy(d),
        this
    }
    copy(e) {
        return super.copy(e),
        this.currentPoint.copy(e.currentPoint),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.currentPoint = this.currentPoint.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.currentPoint.fromArray(e.currentPoint),
        this
    }
}
class Sc extends ft {
    constructor(e=[new me(0,-.5), new me(.5,0), new me(0,.5)], t=12, i=0, r=Math.PI * 2) {
        super(),
        this.type = "LatheGeometry",
        this.parameters = {
            points: e,
            segments: t,
            phiStart: i,
            phiLength: r
        },
        t = Math.floor(t),
        r = wn(r, 0, Math.PI * 2);
        const s = []
          , o = []
          , a = []
          , l = []
          , c = []
          , d = 1 / t
          , h = new D
          , p = new me
          , m = new D
          , y = new D
          , v = new D;
        let x = 0
          , _ = 0;
        for (let A = 0; A <= e.length - 1; A++)
            switch (A) {
            case 0:
                x = e[A + 1].x - e[A].x,
                _ = e[A + 1].y - e[A].y,
                m.x = _ * 1,
                m.y = -x,
                m.z = _ * 0,
                v.copy(m),
                m.normalize(),
                l.push(m.x, m.y, m.z);
                break;
            case e.length - 1:
                l.push(v.x, v.y, v.z);
                break;
            default:
                x = e[A + 1].x - e[A].x,
                _ = e[A + 1].y - e[A].y,
                m.x = _ * 1,
                m.y = -x,
                m.z = _ * 0,
                y.copy(m),
                m.x += v.x,
                m.y += v.y,
                m.z += v.z,
                m.normalize(),
                l.push(m.x, m.y, m.z),
                v.copy(y)
            }
        for (let A = 0; A <= t; A++) {
            const w = i + A * d * r
              , M = Math.sin(w)
              , C = Math.cos(w);
            for (let P = 0; P <= e.length - 1; P++) {
                h.x = e[P].x * M,
                h.y = e[P].y,
                h.z = e[P].x * C,
                o.push(h.x, h.y, h.z),
                p.x = A / t,
                p.y = P / (e.length - 1),
                a.push(p.x, p.y);
                const R = l[3 * P + 0] * M
                  , E = l[3 * P + 1]
                  , B = l[3 * P + 0] * C;
                c.push(R, E, B)
            }
        }
        for (let A = 0; A < t; A++)
            for (let w = 0; w < e.length - 1; w++) {
                const M = w + A * e.length
                  , C = M
                  , P = M + e.length
                  , R = M + e.length + 1
                  , E = M + 1;
                s.push(C, P, E),
                s.push(R, E, P)
            }
        this.setIndex(s),
        this.setAttribute("position", new je(o,3)),
        this.setAttribute("uv", new je(a,2)),
        this.setAttribute("normal", new je(c,3))
    }
    static fromJSON(e) {
        return new Sc(e.points,e.segments,e.phiStart,e.phiLength)
    }
}
class sh extends Sc {
    constructor(e=1, t=1, i=4, r=8) {
        const s = new Td;
        s.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
        s.absarc(0, t / 2, e, 0, Math.PI * .5),
        super(s.getPoints(i), r),
        this.type = "CapsuleGeometry",
        this.parameters = {
            radius: e,
            height: t,
            capSegments: i,
            radialSegments: r
        }
    }
    static fromJSON(e) {
        return new sh(e.radius,e.length,e.capSegments,e.radialSegments)
    }
}
class oh extends ft {
    constructor(e=1, t=32, i=0, r=Math.PI * 2) {
        super(),
        this.type = "CircleGeometry",
        this.parameters = {
            radius: e,
            segments: t,
            thetaStart: i,
            thetaLength: r
        },
        t = Math.max(3, t);
        const s = []
          , o = []
          , a = []
          , l = []
          , c = new D
          , d = new me;
        o.push(0, 0, 0),
        a.push(0, 0, 1),
        l.push(.5, .5);
        for (let h = 0, p = 3; h <= t; h++,
        p += 3) {
            const m = i + h / t * r;
            c.x = e * Math.cos(m),
            c.y = e * Math.sin(m),
            o.push(c.x, c.y, c.z),
            a.push(0, 0, 1),
            d.x = (o[p] / e + 1) / 2,
            d.y = (o[p + 1] / e + 1) / 2,
            l.push(d.x, d.y)
        }
        for (let h = 1; h <= t; h++)
            s.push(h, h + 1, 0);
        this.setIndex(s),
        this.setAttribute("position", new je(o,3)),
        this.setAttribute("normal", new je(a,3)),
        this.setAttribute("uv", new je(l,2))
    }
    static fromJSON(e) {
        return new oh(e.radius,e.segments,e.thetaStart,e.thetaLength)
    }
}
class Bl extends ft {
    constructor(e=1, t=1, i=1, r=32, s=1, o=!1, a=0, l=Math.PI * 2) {
        super(),
        this.type = "CylinderGeometry",
        this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: i,
            radialSegments: r,
            heightSegments: s,
            openEnded: o,
            thetaStart: a,
            thetaLength: l
        };
        const c = this;
        r = Math.floor(r),
        s = Math.floor(s);
        const d = []
          , h = []
          , p = []
          , m = [];
        let y = 0;
        const v = []
          , x = i / 2;
        let _ = 0;
        A(),
        o === !1 && (e > 0 && w(!0),
        t > 0 && w(!1)),
        this.setIndex(d),
        this.setAttribute("position", new je(h,3)),
        this.setAttribute("normal", new je(p,3)),
        this.setAttribute("uv", new je(m,2));
        function A() {
            const M = new D
              , C = new D;
            let P = 0;
            const R = (t - e) / i;
            for (let E = 0; E <= s; E++) {
                const B = []
                  , I = E / s
                  , z = I * (t - e) + e;
                for (let q = 0; q <= r; q++) {
                    const W = q / r
                      , G = W * l + a
                      , K = Math.sin(G)
                      , ne = Math.cos(G);
                    C.x = z * K,
                    C.y = -I * i + x,
                    C.z = z * ne,
                    h.push(C.x, C.y, C.z),
                    M.set(K, R, ne).normalize(),
                    p.push(M.x, M.y, M.z),
                    m.push(W, 1 - I),
                    B.push(y++)
                }
                v.push(B)
            }
            for (let E = 0; E < r; E++)
                for (let B = 0; B < s; B++) {
                    const I = v[B][E]
                      , z = v[B + 1][E]
                      , q = v[B + 1][E + 1]
                      , W = v[B][E + 1];
                    d.push(I, z, W),
                    d.push(z, q, W),
                    P += 6
                }
            c.addGroup(_, P, 0),
            _ += P
        }
        function w(M) {
            const C = y
              , P = new me
              , R = new D;
            let E = 0;
            const B = M === !0 ? e : t
              , I = M === !0 ? 1 : -1;
            for (let q = 1; q <= r; q++)
                h.push(0, x * I, 0),
                p.push(0, I, 0),
                m.push(.5, .5),
                y++;
            const z = y;
            for (let q = 0; q <= r; q++) {
                const G = q / r * l + a
                  , K = Math.cos(G)
                  , ne = Math.sin(G);
                R.x = B * ne,
                R.y = x * I,
                R.z = B * K,
                h.push(R.x, R.y, R.z),
                p.push(0, I, 0),
                P.x = K * .5 + .5,
                P.y = ne * .5 * I + .5,
                m.push(P.x, P.y),
                y++
            }
            for (let q = 0; q < r; q++) {
                const W = C + q
                  , G = z + q;
                M === !0 ? d.push(G, G + 1, W) : d.push(G + 1, G, W),
                E += 3
            }
            c.addGroup(_, E, M === !0 ? 1 : 2),
            _ += E
        }
    }
    static fromJSON(e) {
        return new Bl(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
    }
}
class ah extends Bl {
    constructor(e=1, t=1, i=32, r=1, s=!1, o=0, a=Math.PI * 2) {
        super(0, e, t, i, r, s, o, a),
        this.type = "ConeGeometry",
        this.parameters = {
            radius: e,
            height: t,
            radialSegments: i,
            heightSegments: r,
            openEnded: s,
            thetaStart: o,
            thetaLength: a
        }
    }
    static fromJSON(e) {
        return new ah(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
    }
}
class oo extends ft {
    constructor(e=[], t=[], i=1, r=0) {
        super(),
        this.type = "PolyhedronGeometry",
        this.parameters = {
            vertices: e,
            indices: t,
            radius: i,
            detail: r
        };
        const s = []
          , o = [];
        a(r),
        c(i),
        d(),
        this.setAttribute("position", new je(s,3)),
        this.setAttribute("normal", new je(s.slice(),3)),
        this.setAttribute("uv", new je(o,2)),
        r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
        function a(A) {
            const w = new D
              , M = new D
              , C = new D;
            for (let P = 0; P < t.length; P += 3)
                m(t[P + 0], w),
                m(t[P + 1], M),
                m(t[P + 2], C),
                l(w, M, C, A)
        }
        function l(A, w, M, C) {
            const P = C + 1
              , R = [];
            for (let E = 0; E <= P; E++) {
                R[E] = [];
                const B = A.clone().lerp(M, E / P)
                  , I = w.clone().lerp(M, E / P)
                  , z = P - E;
                for (let q = 0; q <= z; q++)
                    q === 0 && E === P ? R[E][q] = B : R[E][q] = B.clone().lerp(I, q / z)
            }
            for (let E = 0; E < P; E++)
                for (let B = 0; B < 2 * (P - E) - 1; B++) {
                    const I = Math.floor(B / 2);
                    B % 2 === 0 ? (p(R[E][I + 1]),
                    p(R[E + 1][I]),
                    p(R[E][I])) : (p(R[E][I + 1]),
                    p(R[E + 1][I + 1]),
                    p(R[E + 1][I]))
                }
        }
        function c(A) {
            const w = new D;
            for (let M = 0; M < s.length; M += 3)
                w.x = s[M + 0],
                w.y = s[M + 1],
                w.z = s[M + 2],
                w.normalize().multiplyScalar(A),
                s[M + 0] = w.x,
                s[M + 1] = w.y,
                s[M + 2] = w.z
        }
        function d() {
            const A = new D;
            for (let w = 0; w < s.length; w += 3) {
                A.x = s[w + 0],
                A.y = s[w + 1],
                A.z = s[w + 2];
                const M = x(A) / 2 / Math.PI + .5
                  , C = _(A) / Math.PI + .5;
                o.push(M, 1 - C)
            }
            y(),
            h()
        }
        function h() {
            for (let A = 0; A < o.length; A += 6) {
                const w = o[A + 0]
                  , M = o[A + 2]
                  , C = o[A + 4]
                  , P = Math.max(w, M, C)
                  , R = Math.min(w, M, C);
                P > .9 && R < .1 && (w < .2 && (o[A + 0] += 1),
                M < .2 && (o[A + 2] += 1),
                C < .2 && (o[A + 4] += 1))
            }
        }
        function p(A) {
            s.push(A.x, A.y, A.z)
        }
        function m(A, w) {
            const M = A * 3;
            w.x = e[M + 0],
            w.y = e[M + 1],
            w.z = e[M + 2]
        }
        function y() {
            const A = new D
              , w = new D
              , M = new D
              , C = new D
              , P = new me
              , R = new me
              , E = new me;
            for (let B = 0, I = 0; B < s.length; B += 9,
            I += 6) {
                A.set(s[B + 0], s[B + 1], s[B + 2]),
                w.set(s[B + 3], s[B + 4], s[B + 5]),
                M.set(s[B + 6], s[B + 7], s[B + 8]),
                P.set(o[I + 0], o[I + 1]),
                R.set(o[I + 2], o[I + 3]),
                E.set(o[I + 4], o[I + 5]),
                C.copy(A).add(w).add(M).divideScalar(3);
                const z = x(C);
                v(P, I + 0, A, z),
                v(R, I + 2, w, z),
                v(E, I + 4, M, z)
            }
        }
        function v(A, w, M, C) {
            C < 0 && A.x === 1 && (o[w] = A.x - 1),
            M.x === 0 && M.z === 0 && (o[w] = C / 2 / Math.PI + .5)
        }
        function x(A) {
            return Math.atan2(A.z, -A.x)
        }
        function _(A) {
            return Math.atan2(-A.y, Math.sqrt(A.x * A.x + A.z * A.z))
        }
    }
    static fromJSON(e) {
        return new oo(e.vertices,e.indices,e.radius,e.details)
    }
}
class lh extends oo {
    constructor(e=1, t=0) {
        const i = (1 + Math.sqrt(5)) / 2
          , r = 1 / i
          , s = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, 0, -i, 0, -r, i, 0, -r, -i, 0, r, i, 0, r]
          , o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
        super(s, o, e, t),
        this.type = "DodecahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new lh(e.radius,e.detail)
    }
}
const hm = new D
  , pm = new D
  , cx = new D
  , mm = new yr;
class oI extends ft {
    constructor(e=null, t=1) {
        if (super(),
        this.type = "EdgesGeometry",
        this.parameters = {
            geometry: e,
            thresholdAngle: t
        },
        e !== null) {
            const r = Math.pow(10, 4)
              , s = Math.cos(dl * t)
              , o = e.getIndex()
              , a = e.getAttribute("position")
              , l = o ? o.count : a.count
              , c = [0, 0, 0]
              , d = ["a", "b", "c"]
              , h = new Array(3)
              , p = {}
              , m = [];
            for (let y = 0; y < l; y += 3) {
                o ? (c[0] = o.getX(y),
                c[1] = o.getX(y + 1),
                c[2] = o.getX(y + 2)) : (c[0] = y,
                c[1] = y + 1,
                c[2] = y + 2);
                const {a: v, b: x, c: _} = mm;
                if (v.fromBufferAttribute(a, c[0]),
                x.fromBufferAttribute(a, c[1]),
                _.fromBufferAttribute(a, c[2]),
                mm.getNormal(cx),
                h[0] = `${Math.round(v.x * r)},${Math.round(v.y * r)},${Math.round(v.z * r)}`,
                h[1] = `${Math.round(x.x * r)},${Math.round(x.y * r)},${Math.round(x.z * r)}`,
                h[2] = `${Math.round(_.x * r)},${Math.round(_.y * r)},${Math.round(_.z * r)}`,
                !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0]))
                    for (let A = 0; A < 3; A++) {
                        const w = (A + 1) % 3
                          , M = h[A]
                          , C = h[w]
                          , P = mm[d[A]]
                          , R = mm[d[w]]
                          , E = `${M}_${C}`
                          , B = `${C}_${M}`;
                        B in p && p[B] ? (cx.dot(p[B].normal) <= s && (m.push(P.x, P.y, P.z),
                        m.push(R.x, R.y, R.z)),
                        p[B] = null) : E in p || (p[E] = {
                            index0: c[A],
                            index1: c[w],
                            normal: cx.clone()
                        })
                    }
            }
            for (const y in p)
                if (p[y]) {
                    const {index0: v, index1: x} = p[y];
                    hm.fromBufferAttribute(a, v),
                    pm.fromBufferAttribute(a, x),
                    m.push(hm.x, hm.y, hm.z),
                    m.push(pm.x, pm.y, pm.z)
                }
            this.setAttribute("position", new je(m,3))
        }
    }
}
class ml extends Td {
    constructor(e) {
        super(e),
        this.uuid = Ji(),
        this.type = "Shape",
        this.holes = []
    }
    getPointsHoles(e) {
        const t = [];
        for (let i = 0, r = this.holes.length; i < r; i++)
            t[i] = this.holes[i].getPoints(e);
        return t
    }
    extractPoints(e) {
        return {
            shape: this.getPoints(e),
            holes: this.getPointsHoles(e)
        }
    }
    copy(e) {
        super.copy(e),
        this.holes = [];
        for (let t = 0, i = e.holes.length; t < i; t++) {
            const r = e.holes[t];
            this.holes.push(r.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.uuid = this.uuid,
        e.holes = [];
        for (let t = 0, i = this.holes.length; t < i; t++) {
            const r = this.holes[t];
            e.holes.push(r.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.uuid = e.uuid,
        this.holes = [];
        for (let t = 0, i = e.holes.length; t < i; t++) {
            const r = e.holes[t];
            this.holes.push(new Td().fromJSON(r))
        }
        return this
    }
}
const aH = {
    triangulate: function(n, e, t=2) {
        const i = e && e.length
          , r = i ? e[0] * t : n.length;
        let s = aI(n, 0, r, t, !0);
        const o = [];
        if (!s || s.next === s.prev)
            return o;
        let a, l, c, d, h, p, m;
        if (i && (s = dH(n, e, s, t)),
        n.length > 80 * t) {
            a = c = n[0],
            l = d = n[1];
            for (let y = t; y < r; y += t)
                h = n[y],
                p = n[y + 1],
                h < a && (a = h),
                p < l && (l = p),
                h > c && (c = h),
                p > d && (d = p);
            m = Math.max(c - a, d - l),
            m = m !== 0 ? 32767 / m : 0
        }
        return Pd(s, o, t, a, l, m, 0),
        o
    }
};
function aI(n, e, t, i, r) {
    let s, o;
    if (r === SH(n, e, t, i) > 0)
        for (s = e; s < t; s += i)
            o = jE(s, n[s], n[s + 1], o);
    else
        for (s = t - i; s >= e; s -= i)
            o = jE(s, n[s], n[s + 1], o);
    return o && k0(o, o.next) && (Rd(o),
    o = o.next),
    o
}
function Sl(n, e) {
    if (!n)
        return n;
    e || (e = n);
    let t = n, i;
    do
        if (i = !1,
        !t.steiner && (k0(t, t.next) || an(t.prev, t, t.next) === 0)) {
            if (Rd(t),
            t = e = t.prev,
            t === t.next)
                break;
            i = !0
        } else
            t = t.next;
    while (i || t !== e);
    return e
}
function Pd(n, e, t, i, r, s, o) {
    if (!n)
        return;
    !o && s && vH(n, i, r, s);
    let a = n, l, c;
    for (; n.prev !== n.next; ) {
        if (l = n.prev,
        c = n.next,
        s ? uH(n, i, r, s) : lH(n)) {
            e.push(l.i / t | 0),
            e.push(n.i / t | 0),
            e.push(c.i / t | 0),
            Rd(n),
            n = c.next,
            a = c.next;
            continue
        }
        if (n = c,
        n === a) {
            o ? o === 1 ? (n = cH(Sl(n), e, t),
            Pd(n, e, t, i, r, s, 2)) : o === 2 && fH(n, e, t, i, r, s) : Pd(Sl(n), e, t, i, r, s, 1);
            break
        }
    }
}
function lH(n) {
    const e = n.prev
      , t = n
      , i = n.next;
    if (an(e, t, i) >= 0)
        return !1;
    const r = e.x
      , s = t.x
      , o = i.x
      , a = e.y
      , l = t.y
      , c = i.y
      , d = r < s ? r < o ? r : o : s < o ? s : o
      , h = a < l ? a < c ? a : c : l < c ? l : c
      , p = r > s ? r > o ? r : o : s > o ? s : o
      , m = a > l ? a > c ? a : c : l > c ? l : c;
    let y = i.next;
    for (; y !== e; ) {
        if (y.x >= d && y.x <= p && y.y >= h && y.y <= m && Ru(r, a, s, l, o, c, y.x, y.y) && an(y.prev, y, y.next) >= 0)
            return !1;
        y = y.next
    }
    return !0
}
function uH(n, e, t, i) {
    const r = n.prev
      , s = n
      , o = n.next;
    if (an(r, s, o) >= 0)
        return !1;
    const a = r.x
      , l = s.x
      , c = o.x
      , d = r.y
      , h = s.y
      , p = o.y
      , m = a < l ? a < c ? a : c : l < c ? l : c
      , y = d < h ? d < p ? d : p : h < p ? h : p
      , v = a > l ? a > c ? a : c : l > c ? l : c
      , x = d > h ? d > p ? d : p : h > p ? h : p
      , _ = __(m, y, e, t, i)
      , A = __(v, x, e, t, i);
    let w = n.prevZ
      , M = n.nextZ;
    for (; w && w.z >= _ && M && M.z <= A; ) {
        if (w.x >= m && w.x <= v && w.y >= y && w.y <= x && w !== r && w !== o && Ru(a, d, l, h, c, p, w.x, w.y) && an(w.prev, w, w.next) >= 0 || (w = w.prevZ,
        M.x >= m && M.x <= v && M.y >= y && M.y <= x && M !== r && M !== o && Ru(a, d, l, h, c, p, M.x, M.y) && an(M.prev, M, M.next) >= 0))
            return !1;
        M = M.nextZ
    }
    for (; w && w.z >= _; ) {
        if (w.x >= m && w.x <= v && w.y >= y && w.y <= x && w !== r && w !== o && Ru(a, d, l, h, c, p, w.x, w.y) && an(w.prev, w, w.next) >= 0)
            return !1;
        w = w.prevZ
    }
    for (; M && M.z <= A; ) {
        if (M.x >= m && M.x <= v && M.y >= y && M.y <= x && M !== r && M !== o && Ru(a, d, l, h, c, p, M.x, M.y) && an(M.prev, M, M.next) >= 0)
            return !1;
        M = M.nextZ
    }
    return !0
}
function cH(n, e, t) {
    let i = n;
    do {
        const r = i.prev
          , s = i.next.next;
        !k0(r, s) && lI(r, i, i.next, s) && Bd(r, s) && Bd(s, r) && (e.push(r.i / t | 0),
        e.push(i.i / t | 0),
        e.push(s.i / t | 0),
        Rd(i),
        Rd(i.next),
        i = n = s),
        i = i.next
    } while (i !== n);
    return Sl(i)
}
function fH(n, e, t, i, r, s) {
    let o = n;
    do {
        let a = o.next.next;
        for (; a !== o.prev; ) {
            if (o.i !== a.i && _H(o, a)) {
                let l = uI(o, a);
                o = Sl(o, o.next),
                l = Sl(l, l.next),
                Pd(o, e, t, i, r, s, 0),
                Pd(l, e, t, i, r, s, 0);
                return
            }
            a = a.next
        }
        o = o.next
    } while (o !== n)
}
function dH(n, e, t, i) {
    const r = [];
    let s, o, a, l, c;
    for (s = 0,
    o = e.length; s < o; s++)
        a = e[s] * i,
        l = s < o - 1 ? e[s + 1] * i : n.length,
        c = aI(n, a, l, i, !1),
        c === c.next && (c.steiner = !0),
        r.push(xH(c));
    for (r.sort(hH),
    s = 0; s < r.length; s++)
        t = pH(r[s], t);
    return t
}
function hH(n, e) {
    return n.x - e.x
}
function pH(n, e) {
    const t = mH(n, e);
    if (!t)
        return e;
    const i = uI(t, n);
    return Sl(i, i.next),
    Sl(t, t.next)
}
function mH(n, e) {
    let t = e, i = -1 / 0, r;
    const s = n.x
      , o = n.y;
    do {
        if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
            const p = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
            if (p <= s && p > i && (i = p,
            r = t.x < t.next.x ? t : t.next,
            p === s))
                return r
        }
        t = t.next
    } while (t !== e);
    if (!r)
        return null;
    const a = r
      , l = r.x
      , c = r.y;
    let d = 1 / 0, h;
    t = r;
    do
        s >= t.x && t.x >= l && s !== t.x && Ru(o < c ? s : i, o, l, c, o < c ? i : s, o, t.x, t.y) && (h = Math.abs(o - t.y) / (s - t.x),
        Bd(t, n) && (h < d || h === d && (t.x > r.x || t.x === r.x && gH(r, t))) && (r = t,
        d = h)),
        t = t.next;
    while (t !== a);
    return r
}
function gH(n, e) {
    return an(n.prev, n, e.prev) < 0 && an(e.next, n, n.next) < 0
}
function vH(n, e, t, i) {
    let r = n;
    do
        r.z === 0 && (r.z = __(r.x, r.y, e, t, i)),
        r.prevZ = r.prev,
        r.nextZ = r.next,
        r = r.next;
    while (r !== n);
    r.prevZ.nextZ = null,
    r.prevZ = null,
    yH(r)
}
function yH(n) {
    let e, t, i, r, s, o, a, l, c = 1;
    do {
        for (t = n,
        n = null,
        s = null,
        o = 0; t; ) {
            for (o++,
            i = t,
            a = 0,
            e = 0; e < c && (a++,
            i = i.nextZ,
            !!i); e++)
                ;
            for (l = c; a > 0 || l > 0 && i; )
                a !== 0 && (l === 0 || !i || t.z <= i.z) ? (r = t,
                t = t.nextZ,
                a--) : (r = i,
                i = i.nextZ,
                l--),
                s ? s.nextZ = r : n = r,
                r.prevZ = s,
                s = r;
            t = i
        }
        s.nextZ = null,
        c *= 2
    } while (o > 1);
    return n
}
function __(n, e, t, i, r) {
    return n = (n - t) * r | 0,
    e = (e - i) * r | 0,
    n = (n | n << 8) & 16711935,
    n = (n | n << 4) & 252645135,
    n = (n | n << 2) & 858993459,
    n = (n | n << 1) & 1431655765,
    e = (e | e << 8) & 16711935,
    e = (e | e << 4) & 252645135,
    e = (e | e << 2) & 858993459,
    e = (e | e << 1) & 1431655765,
    n | e << 1
}
function xH(n) {
    let e = n
      , t = n;
    do
        (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e),
        e = e.next;
    while (e !== n);
    return t
}
function Ru(n, e, t, i, r, s, o, a) {
    return (r - o) * (e - a) >= (n - o) * (s - a) && (n - o) * (i - a) >= (t - o) * (e - a) && (t - o) * (s - a) >= (r - o) * (i - a)
}
function _H(n, e) {
    return n.next.i !== e.i && n.prev.i !== e.i && !AH(n, e) && (Bd(n, e) && Bd(e, n) && wH(n, e) && (an(n.prev, n, e.prev) || an(n, e.prev, e)) || k0(n, e) && an(n.prev, n, n.next) > 0 && an(e.prev, e, e.next) > 0)
}
function an(n, e, t) {
    return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y)
}
function k0(n, e) {
    return n.x === e.x && n.y === e.y
}
function lI(n, e, t, i) {
    const r = vm(an(n, e, t))
      , s = vm(an(n, e, i))
      , o = vm(an(t, i, n))
      , a = vm(an(t, i, e));
    return !!(r !== s && o !== a || r === 0 && gm(n, t, e) || s === 0 && gm(n, i, e) || o === 0 && gm(t, n, i) || a === 0 && gm(t, e, i))
}
function gm(n, e, t) {
    return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) && e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y)
}
function vm(n) {
    return n > 0 ? 1 : n < 0 ? -1 : 0
}
function AH(n, e) {
    let t = n;
    do {
        if (t.i !== n.i && t.next.i !== n.i && t.i !== e.i && t.next.i !== e.i && lI(t, t.next, n, e))
            return !0;
        t = t.next
    } while (t !== n);
    return !1
}
function Bd(n, e) {
    return an(n.prev, n, n.next) < 0 ? an(n, e, n.next) >= 0 && an(n, n.prev, e) >= 0 : an(n, e, n.prev) < 0 || an(n, n.next, e) < 0
}
function wH(n, e) {
    let t = n
      , i = !1;
    const r = (n.x + e.x) / 2
      , s = (n.y + e.y) / 2;
    do
        t.y > s != t.next.y > s && t.next.y !== t.y && r < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (i = !i),
        t = t.next;
    while (t !== n);
    return i
}
function uI(n, e) {
    const t = new A_(n.i,n.x,n.y)
      , i = new A_(e.i,e.x,e.y)
      , r = n.next
      , s = e.prev;
    return n.next = e,
    e.prev = n,
    t.next = r,
    r.prev = t,
    i.next = t,
    t.prev = i,
    s.next = i,
    i.prev = s,
    i
}
function jE(n, e, t, i) {
    const r = new A_(n,e,t);
    return i ? (r.next = i.next,
    r.prev = i,
    i.next.prev = r,
    i.next = r) : (r.prev = r,
    r.next = r),
    r
}
function Rd(n) {
    n.next.prev = n.prev,
    n.prev.next = n.next,
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ)
}
function A_(n, e, t) {
    this.i = n,
    this.x = e,
    this.y = t,
    this.prev = null,
    this.next = null,
    this.z = 0,
    this.prevZ = null,
    this.nextZ = null,
    this.steiner = !1
}
function SH(n, e, t, i) {
    let r = 0;
    for (let s = e, o = t - i; s < t; s += i)
        r += (n[o] - n[s]) * (n[s + 1] + n[o + 1]),
        o = s;
    return r
}
class cs {
    static area(e) {
        const t = e.length;
        let i = 0;
        for (let r = t - 1, s = 0; s < t; r = s++)
            i += e[r].x * e[s].y - e[s].x * e[r].y;
        return i * .5
    }
    static isClockWise(e) {
        return cs.area(e) < 0
    }
    static triangulateShape(e, t) {
        const i = []
          , r = []
          , s = [];
        JE(e),
        XE(i, e);
        let o = e.length;
        t.forEach(JE);
        for (let l = 0; l < t.length; l++)
            r.push(o),
            o += t[l].length,
            XE(i, t[l]);
        const a = aH.triangulate(i, r);
        for (let l = 0; l < a.length; l += 3)
            s.push(a.slice(l, l + 3));
        return s
    }
}
function JE(n) {
    const e = n.length;
    e > 2 && n[e - 1].equals(n[0]) && n.pop()
}
function XE(n, e) {
    for (let t = 0; t < e.length; t++)
        n.push(e[t].x),
        n.push(e[t].y)
}
class uh extends ft {
    constructor(e=new ml([new me(.5,.5), new me(-.5,.5), new me(-.5,-.5), new me(.5,-.5)]), t={}) {
        super(),
        this.type = "ExtrudeGeometry",
        this.parameters = {
            shapes: e,
            options: t
        },
        e = Array.isArray(e) ? e : [e];
        const i = this
          , r = []
          , s = [];
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a];
            o(c)
        }
        this.setAttribute("position", new je(r,3)),
        this.setAttribute("uv", new je(s,2)),
        this.computeVertexNormals();
        function o(a) {
            const l = []
              , c = t.curveSegments !== void 0 ? t.curveSegments : 12
              , d = t.steps !== void 0 ? t.steps : 1
              , h = t.depth !== void 0 ? t.depth : 1;
            let p = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0
              , m = t.bevelThickness !== void 0 ? t.bevelThickness : .2
              , y = t.bevelSize !== void 0 ? t.bevelSize : m - .1
              , v = t.bevelOffset !== void 0 ? t.bevelOffset : 0
              , x = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
            const _ = t.extrudePath
              , A = t.UVGenerator !== void 0 ? t.UVGenerator : MH;
            let w, M = !1, C, P, R, E;
            _ && (w = _.getSpacedPoints(d),
            M = !0,
            p = !1,
            C = _.computeFrenetFrames(d, !1),
            P = new D,
            R = new D,
            E = new D),
            p || (x = 0,
            m = 0,
            y = 0,
            v = 0);
            const B = a.extractPoints(c);
            let I = B.shape;
            const z = B.holes;
            if (!cs.isClockWise(I)) {
                I = I.reverse();
                for (let de = 0, ae = z.length; de < ae; de++) {
                    const be = z[de];
                    cs.isClockWise(be) && (z[de] = be.reverse())
                }
            }
            const W = cs.triangulateShape(I, z)
              , G = I;
            for (let de = 0, ae = z.length; de < ae; de++) {
                const be = z[de];
                I = I.concat(be)
            }
            function K(de, ae, be) {
                return ae || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                ae.clone().multiplyScalar(be).add(de)
            }
            const ne = I.length
              , oe = W.length;
            function F(de, ae, be) {
                let Ge, Be, $e;
                const Ye = de.x - ae.x
                  , Je = de.y - ae.y
                  , At = be.x - de.x
                  , Ct = be.y - de.y
                  , O = Ye * Ye + Je * Je
                  , L = Ye * Ct - Je * At;
                if (Math.abs(L) > Number.EPSILON) {
                    const se = Math.sqrt(O)
                      , Se = Math.sqrt(At * At + Ct * Ct)
                      , Ce = ae.x - Je / se
                      , Pe = ae.y + Ye / se
                      , rt = be.x - Ct / Se
                      , De = be.y + At / Se
                      , ge = ((rt - Ce) * Ct - (De - Pe) * At) / (Ye * Ct - Je * At);
                    Ge = Ce + Ye * ge - de.x,
                    Be = Pe + Je * ge - de.y;
                    const Ke = Ge * Ge + Be * Be;
                    if (Ke <= 2)
                        return new me(Ge,Be);
                    $e = Math.sqrt(Ke / 2)
                } else {
                    let se = !1;
                    Ye > Number.EPSILON ? At > Number.EPSILON && (se = !0) : Ye < -Number.EPSILON ? At < -Number.EPSILON && (se = !0) : Math.sign(Je) === Math.sign(Ct) && (se = !0),
                    se ? (Ge = -Je,
                    Be = Ye,
                    $e = Math.sqrt(O)) : (Ge = Ye,
                    Be = Je,
                    $e = Math.sqrt(O / 2))
                }
                return new me(Ge / $e,Be / $e)
            }
            const V = [];
            for (let de = 0, ae = G.length, be = ae - 1, Ge = de + 1; de < ae; de++,
            be++,
            Ge++)
                be === ae && (be = 0),
                Ge === ae && (Ge = 0),
                V[de] = F(G[de], G[be], G[Ge]);
            const Y = [];
            let re, j = V.concat();
            for (let de = 0, ae = z.length; de < ae; de++) {
                const be = z[de];
                re = [];
                for (let Ge = 0, Be = be.length, $e = Be - 1, Ye = Ge + 1; Ge < Be; Ge++,
                $e++,
                Ye++)
                    $e === Be && ($e = 0),
                    Ye === Be && (Ye = 0),
                    re[Ge] = F(be[Ge], be[$e], be[Ye]);
                Y.push(re),
                j = j.concat(re)
            }
            for (let de = 0; de < x; de++) {
                const ae = de / x
                  , be = m * Math.cos(ae * Math.PI / 2)
                  , Ge = y * Math.sin(ae * Math.PI / 2) + v;
                for (let Be = 0, $e = G.length; Be < $e; Be++) {
                    const Ye = K(G[Be], V[Be], Ge);
                    Ne(Ye.x, Ye.y, -be)
                }
                for (let Be = 0, $e = z.length; Be < $e; Be++) {
                    const Ye = z[Be];
                    re = Y[Be];
                    for (let Je = 0, At = Ye.length; Je < At; Je++) {
                        const Ct = K(Ye[Je], re[Je], Ge);
                        Ne(Ct.x, Ct.y, -be)
                    }
                }
            }
            const ie = y + v;
            for (let de = 0; de < ne; de++) {
                const ae = p ? K(I[de], j[de], ie) : I[de];
                M ? (R.copy(C.normals[0]).multiplyScalar(ae.x),
                P.copy(C.binormals[0]).multiplyScalar(ae.y),
                E.copy(w[0]).add(R).add(P),
                Ne(E.x, E.y, E.z)) : Ne(ae.x, ae.y, 0)
            }
            for (let de = 1; de <= d; de++)
                for (let ae = 0; ae < ne; ae++) {
                    const be = p ? K(I[ae], j[ae], ie) : I[ae];
                    M ? (R.copy(C.normals[de]).multiplyScalar(be.x),
                    P.copy(C.binormals[de]).multiplyScalar(be.y),
                    E.copy(w[de]).add(R).add(P),
                    Ne(E.x, E.y, E.z)) : Ne(be.x, be.y, h / d * de)
                }
            for (let de = x - 1; de >= 0; de--) {
                const ae = de / x
                  , be = m * Math.cos(ae * Math.PI / 2)
                  , Ge = y * Math.sin(ae * Math.PI / 2) + v;
                for (let Be = 0, $e = G.length; Be < $e; Be++) {
                    const Ye = K(G[Be], V[Be], Ge);
                    Ne(Ye.x, Ye.y, h + be)
                }
                for (let Be = 0, $e = z.length; Be < $e; Be++) {
                    const Ye = z[Be];
                    re = Y[Be];
                    for (let Je = 0, At = Ye.length; Je < At; Je++) {
                        const Ct = K(Ye[Je], re[Je], Ge);
                        M ? Ne(Ct.x, Ct.y + w[d - 1].y, w[d - 1].x + be) : Ne(Ct.x, Ct.y, h + be)
                    }
                }
            }
            ye(),
            _e();
            function ye() {
                const de = r.length / 3;
                if (p) {
                    let ae = 0
                      , be = ne * ae;
                    for (let Ge = 0; Ge < oe; Ge++) {
                        const Be = W[Ge];
                        Oe(Be[2] + be, Be[1] + be, Be[0] + be)
                    }
                    ae = d + x * 2,
                    be = ne * ae;
                    for (let Ge = 0; Ge < oe; Ge++) {
                        const Be = W[Ge];
                        Oe(Be[0] + be, Be[1] + be, Be[2] + be)
                    }
                } else {
                    for (let ae = 0; ae < oe; ae++) {
                        const be = W[ae];
                        Oe(be[2], be[1], be[0])
                    }
                    for (let ae = 0; ae < oe; ae++) {
                        const be = W[ae];
                        Oe(be[0] + ne * d, be[1] + ne * d, be[2] + ne * d)
                    }
                }
                i.addGroup(de, r.length / 3 - de, 0)
            }
            function _e() {
                const de = r.length / 3;
                let ae = 0;
                $(G, ae),
                ae += G.length;
                for (let be = 0, Ge = z.length; be < Ge; be++) {
                    const Be = z[be];
                    $(Be, ae),
                    ae += Be.length
                }
                i.addGroup(de, r.length / 3 - de, 1)
            }
            function $(de, ae) {
                let be = de.length;
                for (; --be >= 0; ) {
                    const Ge = be;
                    let Be = be - 1;
                    Be < 0 && (Be = de.length - 1);
                    for (let $e = 0, Ye = d + x * 2; $e < Ye; $e++) {
                        const Je = ne * $e
                          , At = ne * ($e + 1)
                          , Ct = ae + Ge + Je
                          , O = ae + Be + Je
                          , L = ae + Be + At
                          , se = ae + Ge + At;
                        Ve(Ct, O, L, se)
                    }
                }
            }
            function Ne(de, ae, be) {
                l.push(de),
                l.push(ae),
                l.push(be)
            }
            function Oe(de, ae, be) {
                we(de),
                we(ae),
                we(be);
                const Ge = r.length / 3
                  , Be = A.generateTopUV(i, r, Ge - 3, Ge - 2, Ge - 1);
                Le(Be[0]),
                Le(Be[1]),
                Le(Be[2])
            }
            function Ve(de, ae, be, Ge) {
                we(de),
                we(ae),
                we(Ge),
                we(ae),
                we(be),
                we(Ge);
                const Be = r.length / 3
                  , $e = A.generateSideWallUV(i, r, Be - 6, Be - 3, Be - 2, Be - 1);
                Le($e[0]),
                Le($e[1]),
                Le($e[3]),
                Le($e[1]),
                Le($e[2]),
                Le($e[3])
            }
            function we(de) {
                r.push(l[de * 3 + 0]),
                r.push(l[de * 3 + 1]),
                r.push(l[de * 3 + 2])
            }
            function Le(de) {
                s.push(de.x),
                s.push(de.y)
            }
        }
    }
    toJSON() {
        const e = super.toJSON()
          , t = this.parameters.shapes
          , i = this.parameters.options;
        return bH(t, i, e)
    }
    static fromJSON(e, t) {
        const i = [];
        for (let s = 0, o = e.shapes.length; s < o; s++) {
            const a = t[e.shapes[s]];
            i.push(a)
        }
        const r = e.options.extrudePath;
        return r !== void 0 && (e.options.extrudePath = new Vw[r.type]().fromJSON(r)),
        new uh(i,e.options)
    }
}
const MH = {
    generateTopUV: function(n, e, t, i, r) {
        const s = e[t * 3]
          , o = e[t * 3 + 1]
          , a = e[i * 3]
          , l = e[i * 3 + 1]
          , c = e[r * 3]
          , d = e[r * 3 + 1];
        return [new me(s,o), new me(a,l), new me(c,d)]
    },
    generateSideWallUV: function(n, e, t, i, r, s) {
        const o = e[t * 3]
          , a = e[t * 3 + 1]
          , l = e[t * 3 + 2]
          , c = e[i * 3]
          , d = e[i * 3 + 1]
          , h = e[i * 3 + 2]
          , p = e[r * 3]
          , m = e[r * 3 + 1]
          , y = e[r * 3 + 2]
          , v = e[s * 3]
          , x = e[s * 3 + 1]
          , _ = e[s * 3 + 2];
        return Math.abs(a - d) < Math.abs(o - c) ? [new me(o,1 - l), new me(c,1 - h), new me(p,1 - y), new me(v,1 - _)] : [new me(a,1 - l), new me(d,1 - h), new me(m,1 - y), new me(x,1 - _)]
    }
};
function bH(n, e, t) {
    if (t.shapes = [],
    Array.isArray(n))
        for (let i = 0, r = n.length; i < r; i++) {
            const s = n[i];
            t.shapes.push(s.uuid)
        }
    else
        t.shapes.push(n.uuid);
    return t.options = Object.assign({}, e),
    e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()),
    t
}
class ch extends oo {
    constructor(e=1, t=0) {
        const i = (1 + Math.sqrt(5)) / 2
          , r = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1]
          , s = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
        super(r, s, e, t),
        this.type = "IcosahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new ch(e.radius,e.detail)
    }
}
class Mc extends oo {
    constructor(e=1, t=0) {
        const i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1]
          , r = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
        super(i, r, e, t),
        this.type = "OctahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new Mc(e.radius,e.detail)
    }
}
class fh extends ft {
    constructor(e=.5, t=1, i=32, r=1, s=0, o=Math.PI * 2) {
        super(),
        this.type = "RingGeometry",
        this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: i,
            phiSegments: r,
            thetaStart: s,
            thetaLength: o
        },
        i = Math.max(3, i),
        r = Math.max(1, r);
        const a = []
          , l = []
          , c = []
          , d = [];
        let h = e;
        const p = (t - e) / r
          , m = new D
          , y = new me;
        for (let v = 0; v <= r; v++) {
            for (let x = 0; x <= i; x++) {
                const _ = s + x / i * o;
                m.x = h * Math.cos(_),
                m.y = h * Math.sin(_),
                l.push(m.x, m.y, m.z),
                c.push(0, 0, 1),
                y.x = (m.x / t + 1) / 2,
                y.y = (m.y / t + 1) / 2,
                d.push(y.x, y.y)
            }
            h += p
        }
        for (let v = 0; v < r; v++) {
            const x = v * (i + 1);
            for (let _ = 0; _ < i; _++) {
                const A = _ + x
                  , w = A
                  , M = A + i + 1
                  , C = A + i + 2
                  , P = A + 1;
                a.push(w, M, P),
                a.push(M, C, P)
            }
        }
        this.setIndex(a),
        this.setAttribute("position", new je(l,3)),
        this.setAttribute("normal", new je(c,3)),
        this.setAttribute("uv", new je(d,2))
    }
    static fromJSON(e) {
        return new fh(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)
    }
}
class dh extends ft {
    constructor(e=new ml([new me(0,.5), new me(-.5,-.5), new me(.5,-.5)]), t=12) {
        super(),
        this.type = "ShapeGeometry",
        this.parameters = {
            shapes: e,
            curveSegments: t
        };
        const i = []
          , r = []
          , s = []
          , o = [];
        let a = 0
          , l = 0;
        if (Array.isArray(e) === !1)
            c(e);
        else
            for (let d = 0; d < e.length; d++)
                c(e[d]),
                this.addGroup(a, l, d),
                a += l,
                l = 0;
        this.setIndex(i),
        this.setAttribute("position", new je(r,3)),
        this.setAttribute("normal", new je(s,3)),
        this.setAttribute("uv", new je(o,2));
        function c(d) {
            const h = r.length / 3
              , p = d.extractPoints(t);
            let m = p.shape;
            const y = p.holes;
            cs.isClockWise(m) === !1 && (m = m.reverse());
            for (let x = 0, _ = y.length; x < _; x++) {
                const A = y[x];
                cs.isClockWise(A) === !0 && (y[x] = A.reverse())
            }
            const v = cs.triangulateShape(m, y);
            for (let x = 0, _ = y.length; x < _; x++) {
                const A = y[x];
                m = m.concat(A)
            }
            for (let x = 0, _ = m.length; x < _; x++) {
                const A = m[x];
                r.push(A.x, A.y, 0),
                s.push(0, 0, 1),
                o.push(A.x, A.y)
            }
            for (let x = 0, _ = v.length; x < _; x++) {
                const A = v[x]
                  , w = A[0] + h
                  , M = A[1] + h
                  , C = A[2] + h;
                i.push(w, M, C),
                l += 3
            }
        }
    }
    toJSON() {
        const e = super.toJSON()
          , t = this.parameters.shapes;
        return CH(t, e)
    }
    static fromJSON(e, t) {
        const i = [];
        for (let r = 0, s = e.shapes.length; r < s; r++) {
            const o = t[e.shapes[r]];
            i.push(o)
        }
        return new dh(i,e.curveSegments)
    }
}
function CH(n, e) {
    if (e.shapes = [],
    Array.isArray(n))
        for (let t = 0, i = n.length; t < i; t++) {
            const r = n[t];
            e.shapes.push(r.uuid)
        }
    else
        e.shapes.push(n.uuid);
    return e
}
class bc extends ft {
    constructor(e=1, t=32, i=16, r=0, s=Math.PI * 2, o=0, a=Math.PI) {
        super(),
        this.type = "SphereGeometry",
        this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: r,
            phiLength: s,
            thetaStart: o,
            thetaLength: a
        },
        t = Math.max(3, Math.floor(t)),
        i = Math.max(2, Math.floor(i));
        const l = Math.min(o + a, Math.PI);
        let c = 0;
        const d = []
          , h = new D
          , p = new D
          , m = []
          , y = []
          , v = []
          , x = [];
        for (let _ = 0; _ <= i; _++) {
            const A = []
              , w = _ / i;
            let M = 0;
            _ == 0 && o == 0 ? M = .5 / t : _ == i && l == Math.PI && (M = -.5 / t);
            for (let C = 0; C <= t; C++) {
                const P = C / t;
                h.x = -e * Math.cos(r + P * s) * Math.sin(o + w * a),
                h.y = e * Math.cos(o + w * a),
                h.z = e * Math.sin(r + P * s) * Math.sin(o + w * a),
                y.push(h.x, h.y, h.z),
                p.copy(h).normalize(),
                v.push(p.x, p.y, p.z),
                x.push(P + M, 1 - w),
                A.push(c++)
            }
            d.push(A)
        }
        for (let _ = 0; _ < i; _++)
            for (let A = 0; A < t; A++) {
                const w = d[_][A + 1]
                  , M = d[_][A]
                  , C = d[_ + 1][A]
                  , P = d[_ + 1][A + 1];
                (_ !== 0 || o > 0) && m.push(w, M, P),
                (_ !== i - 1 || l < Math.PI) && m.push(M, C, P)
            }
        this.setIndex(m),
        this.setAttribute("position", new je(y,3)),
        this.setAttribute("normal", new je(v,3)),
        this.setAttribute("uv", new je(x,2))
    }
    static fromJSON(e) {
        return new bc(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)
    }
}
class hh extends oo {
    constructor(e=1, t=0) {
        const i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1]
          , r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
        super(i, r, e, t),
        this.type = "TetrahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new hh(e.radius,e.detail)
    }
}
class ph extends ft {
    constructor(e=1, t=.4, i=12, r=48, s=Math.PI * 2) {
        super(),
        this.type = "TorusGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            radialSegments: i,
            tubularSegments: r,
            arc: s
        },
        i = Math.floor(i),
        r = Math.floor(r);
        const o = []
          , a = []
          , l = []
          , c = []
          , d = new D
          , h = new D
          , p = new D;
        for (let m = 0; m <= i; m++)
            for (let y = 0; y <= r; y++) {
                const v = y / r * s
                  , x = m / i * Math.PI * 2;
                h.x = (e + t * Math.cos(x)) * Math.cos(v),
                h.y = (e + t * Math.cos(x)) * Math.sin(v),
                h.z = t * Math.sin(x),
                a.push(h.x, h.y, h.z),
                d.x = e * Math.cos(v),
                d.y = e * Math.sin(v),
                p.subVectors(h, d).normalize(),
                l.push(p.x, p.y, p.z),
                c.push(y / r),
                c.push(m / i)
            }
        for (let m = 1; m <= i; m++)
            for (let y = 1; y <= r; y++) {
                const v = (r + 1) * m + y - 1
                  , x = (r + 1) * (m - 1) + y - 1
                  , _ = (r + 1) * (m - 1) + y
                  , A = (r + 1) * m + y;
                o.push(v, x, A),
                o.push(x, _, A)
            }
        this.setIndex(o),
        this.setAttribute("position", new je(a,3)),
        this.setAttribute("normal", new je(l,3)),
        this.setAttribute("uv", new je(c,2))
    }
    static fromJSON(e) {
        return new ph(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)
    }
}
class mh extends ft {
    constructor(e=1, t=.4, i=64, r=8, s=2, o=3) {
        super(),
        this.type = "TorusKnotGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: i,
            radialSegments: r,
            p: s,
            q: o
        },
        i = Math.floor(i),
        r = Math.floor(r);
        const a = []
          , l = []
          , c = []
          , d = []
          , h = new D
          , p = new D
          , m = new D
          , y = new D
          , v = new D
          , x = new D
          , _ = new D;
        for (let w = 0; w <= i; ++w) {
            const M = w / i * s * Math.PI * 2;
            A(M, s, o, e, m),
            A(M + .01, s, o, e, y),
            x.subVectors(y, m),
            _.addVectors(y, m),
            v.crossVectors(x, _),
            _.crossVectors(v, x),
            v.normalize(),
            _.normalize();
            for (let C = 0; C <= r; ++C) {
                const P = C / r * Math.PI * 2
                  , R = -t * Math.cos(P)
                  , E = t * Math.sin(P);
                h.x = m.x + (R * _.x + E * v.x),
                h.y = m.y + (R * _.y + E * v.y),
                h.z = m.z + (R * _.z + E * v.z),
                l.push(h.x, h.y, h.z),
                p.subVectors(h, m).normalize(),
                c.push(p.x, p.y, p.z),
                d.push(w / i),
                d.push(C / r)
            }
        }
        for (let w = 1; w <= i; w++)
            for (let M = 1; M <= r; M++) {
                const C = (r + 1) * (w - 1) + (M - 1)
                  , P = (r + 1) * w + (M - 1)
                  , R = (r + 1) * w + M
                  , E = (r + 1) * (w - 1) + M;
                a.push(C, P, E),
                a.push(P, R, E)
            }
        this.setIndex(a),
        this.setAttribute("position", new je(l,3)),
        this.setAttribute("normal", new je(c,3)),
        this.setAttribute("uv", new je(d,2));
        function A(w, M, C, P, R) {
            const E = Math.cos(w)
              , B = Math.sin(w)
              , I = C / M * w
              , z = Math.cos(I);
            R.x = P * (2 + z) * .5 * E,
            R.y = P * (2 + z) * B * .5,
            R.z = P * Math.sin(I) * .5
        }
    }
    static fromJSON(e) {
        return new mh(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)
    }
}
class gh extends ft {
    constructor(e=new Gw(new D(-1,-1,0),new D(-1,1,0),new D(1,1,0)), t=64, i=1, r=8, s=!1) {
        super(),
        this.type = "TubeGeometry",
        this.parameters = {
            path: e,
            tubularSegments: t,
            radius: i,
            radialSegments: r,
            closed: s
        };
        const o = e.computeFrenetFrames(t, s);
        this.tangents = o.tangents,
        this.normals = o.normals,
        this.binormals = o.binormals;
        const a = new D
          , l = new D
          , c = new me;
        let d = new D;
        const h = []
          , p = []
          , m = []
          , y = [];
        v(),
        this.setIndex(y),
        this.setAttribute("position", new je(h,3)),
        this.setAttribute("normal", new je(p,3)),
        this.setAttribute("uv", new je(m,2));
        function v() {
            for (let w = 0; w < t; w++)
                x(w);
            x(s === !1 ? t : 0),
            A(),
            _()
        }
        function x(w) {
            d = e.getPointAt(w / t, d);
            const M = o.normals[w]
              , C = o.binormals[w];
            for (let P = 0; P <= r; P++) {
                const R = P / r * Math.PI * 2
                  , E = Math.sin(R)
                  , B = -Math.cos(R);
                l.x = B * M.x + E * C.x,
                l.y = B * M.y + E * C.y,
                l.z = B * M.z + E * C.z,
                l.normalize(),
                p.push(l.x, l.y, l.z),
                a.x = d.x + i * l.x,
                a.y = d.y + i * l.y,
                a.z = d.z + i * l.z,
                h.push(a.x, a.y, a.z)
            }
        }
        function _() {
            for (let w = 1; w <= t; w++)
                for (let M = 1; M <= r; M++) {
                    const C = (r + 1) * (w - 1) + (M - 1)
                      , P = (r + 1) * w + (M - 1)
                      , R = (r + 1) * w + M
                      , E = (r + 1) * (w - 1) + M;
                    y.push(C, P, E),
                    y.push(P, R, E)
                }
        }
        function A() {
            for (let w = 0; w <= t; w++)
                for (let M = 0; M <= r; M++)
                    c.x = w / t,
                    c.y = M / r,
                    m.push(c.x, c.y)
        }
    }
    toJSON() {
        const e = super.toJSON();
        return e.path = this.parameters.path.toJSON(),
        e
    }
    static fromJSON(e) {
        return new gh(new Vw[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)
    }
}
class cI extends ft {
    constructor(e=null) {
        if (super(),
        this.type = "WireframeGeometry",
        this.parameters = {
            geometry: e
        },
        e !== null) {
            const t = []
              , i = new Set
              , r = new D
              , s = new D;
            if (e.index !== null) {
                const o = e.attributes.position
                  , a = e.index;
                let l = e.groups;
                l.length === 0 && (l = [{
                    start: 0,
                    count: a.count,
                    materialIndex: 0
                }]);
                for (let c = 0, d = l.length; c < d; ++c) {
                    const h = l[c]
                      , p = h.start
                      , m = h.count;
                    for (let y = p, v = p + m; y < v; y += 3)
                        for (let x = 0; x < 3; x++) {
                            const _ = a.getX(y + x)
                              , A = a.getX(y + (x + 1) % 3);
                            r.fromBufferAttribute(o, _),
                            s.fromBufferAttribute(o, A),
                            YE(r, s, i) === !0 && (t.push(r.x, r.y, r.z),
                            t.push(s.x, s.y, s.z))
                        }
                }
            } else {
                const o = e.attributes.position;
                for (let a = 0, l = o.count / 3; a < l; a++)
                    for (let c = 0; c < 3; c++) {
                        const d = 3 * a + c
                          , h = 3 * a + (c + 1) % 3;
                        r.fromBufferAttribute(o, d),
                        s.fromBufferAttribute(o, h),
                        YE(r, s, i) === !0 && (t.push(r.x, r.y, r.z),
                        t.push(s.x, s.y, s.z))
                    }
            }
            this.setAttribute("position", new je(t,3))
        }
    }
}
function YE(n, e, t) {
    const i = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`
      , r = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
    return t.has(i) === !0 || t.has(r) === !0 ? !1 : (t.add(i),
    t.add(r),
    !0)
}
var KE = Object.freeze({
    __proto__: null,
    BoxGeometry: ma,
    CapsuleGeometry: sh,
    CircleGeometry: oh,
    ConeGeometry: ah,
    CylinderGeometry: Bl,
    DodecahedronGeometry: lh,
    EdgesGeometry: oI,
    ExtrudeGeometry: uh,
    IcosahedronGeometry: ch,
    LatheGeometry: Sc,
    OctahedronGeometry: Mc,
    PlaneGeometry: Ac,
    PolyhedronGeometry: oo,
    RingGeometry: fh,
    ShapeGeometry: dh,
    SphereGeometry: bc,
    TetrahedronGeometry: hh,
    TorusGeometry: ph,
    TorusKnotGeometry: mh,
    TubeGeometry: gh,
    WireframeGeometry: cI
});
class fI extends Tn {
    constructor(e) {
        super(),
        this.isShadowMaterial = !0,
        this.type = "ShadowMaterial",
        this.color = new Ie(0),
        this.transparent = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.fog = e.fog,
        this
    }
}
class dI extends ms {
    constructor(e) {
        super(e),
        this.isRawShaderMaterial = !0,
        this.type = "RawShaderMaterial"
    }
}
class Cc extends Tn {
    constructor(e) {
        super(),
        this.isMeshStandardMaterial = !0,
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new Ie(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Ie(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = so,
        this.normalScale = new me(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapIntensity = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapIntensity = e.envMapIntensity,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class ao extends Cc {
    constructor(e) {
        super(),
        this.isMeshPhysicalMaterial = !0,
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new me(1,1),
        this.clearcoatNormalMap = null,
        this.ior = 1.5,
        Object.defineProperty(this, "reflectivity", {
            get: function() {
                return wn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(t) {
                this.ior = (1 + .4 * t) / (1 - .4 * t)
            }
        }),
        this.iridescenceMap = null,
        this.iridescenceIOR = 1.3,
        this.iridescenceThicknessRange = [100, 400],
        this.iridescenceThicknessMap = null,
        this.sheenColor = new Ie(0),
        this.sheenColorMap = null,
        this.sheenRoughness = 1,
        this.sheenRoughnessMap = null,
        this.transmissionMap = null,
        this.thickness = 0,
        this.thicknessMap = null,
        this.attenuationDistance = 1 / 0,
        this.attenuationColor = new Ie(1,1,1),
        this.specularIntensity = 1,
        this.specularIntensityMap = null,
        this.specularColor = new Ie(1,1,1),
        this.specularColorMap = null,
        this._sheen = 0,
        this._clearcoat = 0,
        this._iridescence = 0,
        this._transmission = 0,
        this.setValues(e)
    }
    get sheen() {
        return this._sheen
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++,
        this._sheen = e
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++,
        this._clearcoat = e
    }
    get iridescence() {
        return this._iridescence
    }
    set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++,
        this._iridescence = e
    }
    get transmission() {
        return this._transmission
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++,
        this._transmission = e
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.clearcoat = e.clearcoat,
        this.clearcoatMap = e.clearcoatMap,
        this.clearcoatRoughness = e.clearcoatRoughness,
        this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
        this.clearcoatNormalMap = e.clearcoatNormalMap,
        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
        this.ior = e.ior,
        this.iridescence = e.iridescence,
        this.iridescenceMap = e.iridescenceMap,
        this.iridescenceIOR = e.iridescenceIOR,
        this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
        this.iridescenceThicknessMap = e.iridescenceThicknessMap,
        this.sheen = e.sheen,
        this.sheenColor.copy(e.sheenColor),
        this.sheenColorMap = e.sheenColorMap,
        this.sheenRoughness = e.sheenRoughness,
        this.sheenRoughnessMap = e.sheenRoughnessMap,
        this.transmission = e.transmission,
        this.transmissionMap = e.transmissionMap,
        this.thickness = e.thickness,
        this.thicknessMap = e.thicknessMap,
        this.attenuationDistance = e.attenuationDistance,
        this.attenuationColor.copy(e.attenuationColor),
        this.specularIntensity = e.specularIntensity,
        this.specularIntensityMap = e.specularIntensityMap,
        this.specularColor.copy(e.specularColor),
        this.specularColorMap = e.specularColorMap,
        this
    }
}
class hI extends Tn {
    constructor(e) {
        super(),
        this.isMeshPhongMaterial = !0,
        this.type = "MeshPhongMaterial",
        this.color = new Ie(16777215),
        this.specular = new Ie(1118481),
        this.shininess = 30,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Ie(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = so,
        this.normalScale = new me(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = qd,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.specular.copy(e.specular),
        this.shininess = e.shininess,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class pI extends Tn {
    constructor(e) {
        super(),
        this.isMeshToonMaterial = !0,
        this.defines = {
            TOON: ""
        },
        this.type = "MeshToonMaterial",
        this.color = new Ie(16777215),
        this.map = null,
        this.gradientMap = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Ie(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = so,
        this.normalScale = new me(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.gradientMap = e.gradientMap,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
class mI extends Tn {
    constructor(e) {
        super(),
        this.isMeshNormalMaterial = !0,
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = so,
        this.normalScale = new me(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.flatShading = !1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.flatShading = e.flatShading,
        this
    }
}
class gI extends Tn {
    constructor(e) {
        super(),
        this.isMeshLambertMaterial = !0,
        this.type = "MeshLambertMaterial",
        this.color = new Ie(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Ie(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = so,
        this.normalScale = new me(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = qd,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class vI extends Tn {
    constructor(e) {
        super(),
        this.isMeshMatcapMaterial = !0,
        this.defines = {
            MATCAP: ""
        },
        this.type = "MeshMatcapMaterial",
        this.color = new Ie(16777215),
        this.matcap = null,
        this.map = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = so,
        this.normalScale = new me(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            MATCAP: ""
        },
        this.color.copy(e.color),
        this.matcap = e.matcap,
        this.map = e.map,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class yI extends li {
    constructor(e) {
        super(),
        this.isLineDashedMaterial = !0,
        this.type = "LineDashedMaterial",
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.scale = e.scale,
        this.dashSize = e.dashSize,
        this.gapSize = e.gapSize,
        this
    }
}
function mr(n, e, t) {
    return Ww(n) ? new n.constructor(n.subarray(e, t !== void 0 ? t : n.length)) : n.slice(e, t)
}
function il(n, e, t) {
    return !n || !t && n.constructor === e ? n : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n) : Array.prototype.slice.call(n)
}
function Ww(n) {
    return ArrayBuffer.isView(n) && !(n instanceof DataView)
}
function xI(n) {
    function e(r, s) {
        return n[r] - n[s]
    }
    const t = n.length
      , i = new Array(t);
    for (let r = 0; r !== t; ++r)
        i[r] = r;
    return i.sort(e),
    i
}
function w_(n, e, t) {
    const i = n.length
      , r = new n.constructor(i);
    for (let s = 0, o = 0; o !== i; ++s) {
        const a = t[s] * e;
        for (let l = 0; l !== e; ++l)
            r[o++] = n[a + l]
    }
    return r
}
function jw(n, e, t, i) {
    let r = 1
      , s = n[0];
    for (; s !== void 0 && s[i] === void 0; )
        s = n[r++];
    if (s === void 0)
        return;
    let o = s[i];
    if (o !== void 0)
        if (Array.isArray(o))
            do
                o = s[i],
                o !== void 0 && (e.push(s.time),
                t.push.apply(t, o)),
                s = n[r++];
            while (s !== void 0);
        else if (o.toArray !== void 0)
            do
                o = s[i],
                o !== void 0 && (e.push(s.time),
                o.toArray(t, t.length)),
                s = n[r++];
            while (s !== void 0);
        else
            do
                o = s[i],
                o !== void 0 && (e.push(s.time),
                t.push(o)),
                s = n[r++];
            while (s !== void 0)
}
function EH(n, e, t, i, r=30) {
    const s = n.clone();
    s.name = e;
    const o = [];
    for (let l = 0; l < s.tracks.length; ++l) {
        const c = s.tracks[l]
          , d = c.getValueSize()
          , h = []
          , p = [];
        for (let m = 0; m < c.times.length; ++m) {
            const y = c.times[m] * r;
            if (!(y < t || y >= i)) {
                h.push(c.times[m]);
                for (let v = 0; v < d; ++v)
                    p.push(c.values[m * d + v])
            }
        }
        h.length !== 0 && (c.times = il(h, c.times.constructor),
        c.values = il(p, c.values.constructor),
        o.push(c))
    }
    s.tracks = o;
    let a = 1 / 0;
    for (let l = 0; l < s.tracks.length; ++l)
        a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]);
    for (let l = 0; l < s.tracks.length; ++l)
        s.tracks[l].shift(-1 * a);
    return s.resetDuration(),
    s
}
function TH(n, e=0, t=n, i=30) {
    i <= 0 && (i = 30);
    const r = t.tracks.length
      , s = e / i;
    for (let o = 0; o < r; ++o) {
        const a = t.tracks[o]
          , l = a.ValueTypeName;
        if (l === "bool" || l === "string")
            continue;
        const c = n.tracks.find(function(_) {
            return _.name === a.name && _.ValueTypeName === l
        });
        if (c === void 0)
            continue;
        let d = 0;
        const h = a.getValueSize();
        a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = h / 3);
        let p = 0;
        const m = c.getValueSize();
        c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (p = m / 3);
        const y = a.times.length - 1;
        let v;
        if (s <= a.times[0]) {
            const _ = d
              , A = h - d;
            v = mr(a.values, _, A)
        } else if (s >= a.times[y]) {
            const _ = y * h + d
              , A = _ + h - d;
            v = mr(a.values, _, A)
        } else {
            const _ = a.createInterpolant()
              , A = d
              , w = h - d;
            _.evaluate(s),
            v = mr(_.resultBuffer, A, w)
        }
        l === "quaternion" && new Qn().fromArray(v).normalize().conjugate().toArray(v);
        const x = c.times.length;
        for (let _ = 0; _ < x; ++_) {
            const A = _ * m + p;
            if (l === "quaternion")
                Qn.multiplyQuaternionsFlat(c.values, A, v, 0, c.values, A);
            else {
                const w = m - p * 2;
                for (let M = 0; M < w; ++M)
                    c.values[A + M] -= v[M]
            }
        }
    }
    return n.blendMode = yw,
    n
}
var PH = Object.freeze({
    __proto__: null,
    arraySlice: mr,
    convertArray: il,
    flattenJSON: jw,
    getKeyframeOrder: xI,
    isTypedArray: Ww,
    makeClipAdditive: TH,
    sortedArray: w_,
    subclip: EH
});
class Ec {
    constructor(e, t, i, r) {
        this.parameterPositions = e,
        this._cachedIndex = 0,
        this.resultBuffer = r !== void 0 ? r : new t.constructor(i),
        this.sampleValues = t,
        this.valueSize = i,
        this.settings = null,
        this.DefaultSettings_ = {}
    }
    evaluate(e) {
        const t = this.parameterPositions;
        let i = this._cachedIndex
          , r = t[i]
          , s = t[i - 1];
        e: {
            t: {
                let o;
                n: {
                    i: if (!(e < r)) {
                        for (let a = i + 2; ; ) {
                            if (r === void 0) {
                                if (e < s)
                                    break i;
                                return i = t.length,
                                this._cachedIndex = i,
                                this.copySampleValue_(i - 1)
                            }
                            if (i === a)
                                break;
                            if (s = r,
                            r = t[++i],
                            e < r)
                                break t
                        }
                        o = t.length;
                        break n
                    }
                    if (!(e >= s)) {
                        const a = t[1];
                        e < a && (i = 2,
                        s = a);
                        for (let l = i - 2; ; ) {
                            if (s === void 0)
                                return this._cachedIndex = 0,
                                this.copySampleValue_(0);
                            if (i === l)
                                break;
                            if (r = s,
                            s = t[--i - 1],
                            e >= s)
                                break t
                        }
                        o = i,
                        i = 0;
                        break n
                    }
                    break e
                }
                for (; i < o; ) {
                    const a = i + o >>> 1;
                    e < t[a] ? o = a : i = a + 1
                }
                if (r = t[i],
                s = t[i - 1],
                s === void 0)
                    return this._cachedIndex = 0,
                    this.copySampleValue_(0);
                if (r === void 0)
                    return i = t.length,
                    this._cachedIndex = i,
                    this.copySampleValue_(i - 1)
            }
            this._cachedIndex = i,
            this.intervalChanged_(i, s, r)
        }
        return this.interpolate_(i, s, e, r)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , i = this.sampleValues
          , r = this.valueSize
          , s = e * r;
        for (let o = 0; o !== r; ++o)
            t[o] = i[s + o];
        return t
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
class _I extends Ec {
    constructor(e, t, i, r) {
        super(e, t, i, r),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0,
        this.DefaultSettings_ = {
            endingStart: el,
            endingEnd: el
        }
    }
    intervalChanged_(e, t, i) {
        const r = this.parameterPositions;
        let s = e - 2
          , o = e + 1
          , a = r[s]
          , l = r[o];
        if (a === void 0)
            switch (this.getSettings_().endingStart) {
            case tl:
                s = e,
                a = 2 * t - i;
                break;
            case Md:
                s = r.length - 2,
                a = t + r[s] - r[s + 1];
                break;
            default:
                s = e,
                a = i
            }
        if (l === void 0)
            switch (this.getSettings_().endingEnd) {
            case tl:
                o = e,
                l = 2 * i - t;
                break;
            case Md:
                o = 1,
                l = i + r[1] - r[0];
                break;
            default:
                o = e - 1,
                l = t
            }
        const c = (i - t) * .5
          , d = this.valueSize;
        this._weightPrev = c / (t - a),
        this._weightNext = c / (l - i),
        this._offsetPrev = s * d,
        this._offsetNext = o * d
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = e * a
          , c = l - a
          , d = this._offsetPrev
          , h = this._offsetNext
          , p = this._weightPrev
          , m = this._weightNext
          , y = (i - t) / (r - t)
          , v = y * y
          , x = v * y
          , _ = -p * x + 2 * p * v - p * y
          , A = (1 + p) * x + (-1.5 - 2 * p) * v + (-.5 + p) * y + 1
          , w = (-1 - m) * x + (1.5 + m) * v + .5 * y
          , M = m * x - m * v;
        for (let C = 0; C !== a; ++C)
            s[C] = _ * o[d + C] + A * o[c + C] + w * o[l + C] + M * o[h + C];
        return s
    }
}
class Jw extends Ec {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = e * a
          , c = l - a
          , d = (i - t) / (r - t)
          , h = 1 - d;
        for (let p = 0; p !== a; ++p)
            s[p] = o[c + p] * h + o[l + p] * d;
        return s
    }
}
class AI extends Ec {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    interpolate_(e) {
        return this.copySampleValue_(e - 1)
    }
}
class Yr {
    constructor(e, t, i, r) {
        if (e === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (t === void 0 || t.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e,
        this.times = il(t, this.TimeBufferType),
        this.values = il(i, this.ValueBufferType),
        this.setInterpolation(r || this.DefaultInterpolation)
    }
    static toJSON(e) {
        const t = e.constructor;
        let i;
        if (t.toJSON !== this.toJSON)
            i = t.toJSON(e);
        else {
            i = {
                name: e.name,
                times: il(e.times, Array),
                values: il(e.values, Array)
            };
            const r = e.getInterpolation();
            r !== e.DefaultInterpolation && (i.interpolation = r)
        }
        return i.type = e.ValueTypeName,
        i
    }
    InterpolantFactoryMethodDiscrete(e) {
        return new AI(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodLinear(e) {
        return new Jw(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodSmooth(e) {
        return new _I(this.times,this.values,this.getValueSize(),e)
    }
    setInterpolation(e) {
        let t;
        switch (e) {
        case rc:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
        case wl:
            t = this.InterpolantFactoryMethodLinear;
            break;
        case og:
            t = this.InterpolantFactoryMethodSmooth;
            break
        }
        if (t === void 0) {
            const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
                if (e !== this.DefaultInterpolation)
                    this.setInterpolation(this.DefaultInterpolation);
                else
                    throw new Error(i);
            return console.warn("THREE.KeyframeTrack:", i),
            this
        }
        return this.createInterpolant = t,
        this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
            return rc;
        case this.InterpolantFactoryMethodLinear:
            return wl;
        case this.InterpolantFactoryMethodSmooth:
            return og
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift(e) {
        if (e !== 0) {
            const t = this.times;
            for (let i = 0, r = t.length; i !== r; ++i)
                t[i] += e
        }
        return this
    }
    scale(e) {
        if (e !== 1) {
            const t = this.times;
            for (let i = 0, r = t.length; i !== r; ++i)
                t[i] *= e
        }
        return this
    }
    trim(e, t) {
        const i = this.times
          , r = i.length;
        let s = 0
          , o = r - 1;
        for (; s !== r && i[s] < e; )
            ++s;
        for (; o !== -1 && i[o] > t; )
            --o;
        if (++o,
        s !== 0 || o !== r) {
            s >= o && (o = Math.max(o, 1),
            s = o - 1);
            const a = this.getValueSize();
            this.times = mr(i, s, o),
            this.values = mr(this.values, s * a, o * a)
        }
        return this
    }
    validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
        e = !1);
        const i = this.times
          , r = this.values
          , s = i.length;
        s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this),
        e = !1);
        let o = null;
        for (let a = 0; a !== s; a++) {
            const l = i[a];
            if (typeof l == "number" && isNaN(l)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l),
                e = !1;
                break
            }
            if (o !== null && o > l) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o),
                e = !1;
                break
            }
            o = l
        }
        if (r !== void 0 && Ww(r))
            for (let a = 0, l = r.length; a !== l; ++a) {
                const c = r[a];
                if (isNaN(c)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c),
                    e = !1;
                    break
                }
            }
        return e
    }
    optimize() {
        const e = mr(this.times)
          , t = mr(this.values)
          , i = this.getValueSize()
          , r = this.getInterpolation() === og
          , s = e.length - 1;
        let o = 1;
        for (let a = 1; a < s; ++a) {
            let l = !1;
            const c = e[a]
              , d = e[a + 1];
            if (c !== d && (a !== 1 || c !== e[0]))
                if (r)
                    l = !0;
                else {
                    const h = a * i
                      , p = h - i
                      , m = h + i;
                    for (let y = 0; y !== i; ++y) {
                        const v = t[h + y];
                        if (v !== t[p + y] || v !== t[m + y]) {
                            l = !0;
                            break
                        }
                    }
                }
            if (l) {
                if (a !== o) {
                    e[o] = e[a];
                    const h = a * i
                      , p = o * i;
                    for (let m = 0; m !== i; ++m)
                        t[p + m] = t[h + m]
                }
                ++o
            }
        }
        if (s > 0) {
            e[o] = e[s];
            for (let a = s * i, l = o * i, c = 0; c !== i; ++c)
                t[l + c] = t[a + c];
            ++o
        }
        return o !== e.length ? (this.times = mr(e, 0, o),
        this.values = mr(t, 0, o * i)) : (this.times = e,
        this.values = t),
        this
    }
    clone() {
        const e = mr(this.times, 0)
          , t = mr(this.values, 0)
          , i = this.constructor
          , r = new i(this.name,e,t);
        return r.createInterpolant = this.createInterpolant,
        r
    }
}
Yr.prototype.TimeBufferType = Float32Array;
Yr.prototype.ValueBufferType = Float32Array;
Yr.prototype.DefaultInterpolation = wl;
class Rl extends Yr {
}
Rl.prototype.ValueTypeName = "bool";
Rl.prototype.ValueBufferType = Array;
Rl.prototype.DefaultInterpolation = rc;
Rl.prototype.InterpolantFactoryMethodLinear = void 0;
Rl.prototype.InterpolantFactoryMethodSmooth = void 0;
class Xw extends Yr {
}
Xw.prototype.ValueTypeName = "color";
class lc extends Yr {
}
lc.prototype.ValueTypeName = "number";
class wI extends Ec {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = (i - t) / (r - t);
        let c = e * a;
        for (let d = c + a; c !== d; c += 4)
            Qn.slerpFlat(s, 0, o, c - a, o, c, l);
        return s
    }
}
class ra extends Yr {
    InterpolantFactoryMethodLinear(e) {
        return new wI(this.times,this.values,this.getValueSize(),e)
    }
}
ra.prototype.ValueTypeName = "quaternion";
ra.prototype.DefaultInterpolation = wl;
ra.prototype.InterpolantFactoryMethodSmooth = void 0;
class Il extends Yr {
}
Il.prototype.ValueTypeName = "string";
Il.prototype.ValueBufferType = Array;
Il.prototype.DefaultInterpolation = rc;
Il.prototype.InterpolantFactoryMethodLinear = void 0;
Il.prototype.InterpolantFactoryMethodSmooth = void 0;
class uc extends Yr {
}
uc.prototype.ValueTypeName = "vector";
class cc {
    constructor(e, t=-1, i, r=C0) {
        this.name = e,
        this.tracks = i,
        this.duration = t,
        this.blendMode = r,
        this.uuid = Ji(),
        this.duration < 0 && this.resetDuration()
    }
    static parse(e) {
        const t = []
          , i = e.tracks
          , r = 1 / (e.fps || 1);
        for (let o = 0, a = i.length; o !== a; ++o)
            t.push(RH(i[o]).scale(r));
        const s = new this(e.name,e.duration,t,e.blendMode);
        return s.uuid = e.uuid,
        s
    }
    static toJSON(e) {
        const t = []
          , i = e.tracks
          , r = {
            name: e.name,
            duration: e.duration,
            tracks: t,
            uuid: e.uuid,
            blendMode: e.blendMode
        };
        for (let s = 0, o = i.length; s !== o; ++s)
            t.push(Yr.toJSON(i[s]));
        return r
    }
    static CreateFromMorphTargetSequence(e, t, i, r) {
        const s = t.length
          , o = [];
        for (let a = 0; a < s; a++) {
            let l = []
              , c = [];
            l.push((a + s - 1) % s, a, (a + 1) % s),
            c.push(0, 1, 0);
            const d = xI(l);
            l = w_(l, 1, d),
            c = w_(c, 1, d),
            !r && l[0] === 0 && (l.push(s),
            c.push(c[0])),
            o.push(new lc(".morphTargetInfluences[" + t[a].name + "]",l,c).scale(1 / i))
        }
        return new this(e,-1,o)
    }
    static findByName(e, t) {
        let i = e;
        if (!Array.isArray(e)) {
            const r = e;
            i = r.geometry && r.geometry.animations || r.animations
        }
        for (let r = 0; r < i.length; r++)
            if (i[r].name === t)
                return i[r];
        return null
    }
    static CreateClipsFromMorphTargetSequences(e, t, i) {
        const r = {}
          , s = /^([\w-]*?)([\d]+)$/;
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a]
              , d = c.name.match(s);
            if (d && d.length > 1) {
                const h = d[1];
                let p = r[h];
                p || (r[h] = p = []),
                p.push(c)
            }
        }
        const o = [];
        for (const a in r)
            o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i));
        return o
    }
    static parseAnimation(e, t) {
        if (!e)
            return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
            null;
        const i = function(h, p, m, y, v) {
            if (m.length !== 0) {
                const x = []
                  , _ = [];
                jw(m, x, _, y),
                x.length !== 0 && v.push(new h(p,x,_))
            }
        }
          , r = []
          , s = e.name || "default"
          , o = e.fps || 30
          , a = e.blendMode;
        let l = e.length || -1;
        const c = e.hierarchy || [];
        for (let h = 0; h < c.length; h++) {
            const p = c[h].keys;
            if (!(!p || p.length === 0))
                if (p[0].morphTargets) {
                    const m = {};
                    let y;
                    for (y = 0; y < p.length; y++)
                        if (p[y].morphTargets)
                            for (let v = 0; v < p[y].morphTargets.length; v++)
                                m[p[y].morphTargets[v]] = -1;
                    for (const v in m) {
                        const x = []
                          , _ = [];
                        for (let A = 0; A !== p[y].morphTargets.length; ++A) {
                            const w = p[y];
                            x.push(w.time),
                            _.push(w.morphTarget === v ? 1 : 0)
                        }
                        r.push(new lc(".morphTargetInfluence[" + v + "]",x,_))
                    }
                    l = m.length * o
                } else {
                    const m = ".bones[" + t[h].name + "]";
                    i(uc, m + ".position", p, "pos", r),
                    i(ra, m + ".quaternion", p, "rot", r),
                    i(uc, m + ".scale", p, "scl", r)
                }
        }
        return r.length === 0 ? null : new this(s,l,r,a)
    }
    resetDuration() {
        const e = this.tracks;
        let t = 0;
        for (let i = 0, r = e.length; i !== r; ++i) {
            const s = this.tracks[i];
            t = Math.max(t, s.times[s.times.length - 1])
        }
        return this.duration = t,
        this
    }
    trim() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
        return this
    }
    validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
        return e
    }
    optimize() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
        return this
    }
    clone() {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
        return new this.constructor(this.name,this.duration,e,this.blendMode)
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}
function BH(n) {
    switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
        return lc;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
        return uc;
    case "color":
        return Xw;
    case "quaternion":
        return ra;
    case "bool":
    case "boolean":
        return Rl;
    case "string":
        return Il
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n)
}
function RH(n) {
    if (n.type === void 0)
        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = BH(n.type);
    if (n.times === void 0) {
        const t = []
          , i = [];
        jw(n.keys, t, i, "value"),
        n.times = t,
        n.values = i
    }
    return e.parse !== void 0 ? e.parse(n) : new e(n.name,n.times,n.values,n.interpolation)
}
const Ml = {
    enabled: !1,
    files: {},
    add: function(n, e) {
        this.enabled !== !1 && (this.files[n] = e)
    },
    get: function(n) {
        if (this.enabled !== !1)
            return this.files[n]
    },
    remove: function(n) {
        delete this.files[n]
    },
    clear: function() {
        this.files = {}
    }
};
class Yw {
    constructor(e, t, i) {
        const r = this;
        let s = !1, o = 0, a = 0, l;
        const c = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = i,
        this.itemStart = function(d) {
            a++,
            s === !1 && r.onStart !== void 0 && r.onStart(d, o, a),
            s = !0
        }
        ,
        this.itemEnd = function(d) {
            o++,
            r.onProgress !== void 0 && r.onProgress(d, o, a),
            o === a && (s = !1,
            r.onLoad !== void 0 && r.onLoad())
        }
        ,
        this.itemError = function(d) {
            r.onError !== void 0 && r.onError(d)
        }
        ,
        this.resolveURL = function(d) {
            return l ? l(d) : d
        }
        ,
        this.setURLModifier = function(d) {
            return l = d,
            this
        }
        ,
        this.addHandler = function(d, h) {
            return c.push(d, h),
            this
        }
        ,
        this.removeHandler = function(d) {
            const h = c.indexOf(d);
            return h !== -1 && c.splice(h, 2),
            this
        }
        ,
        this.getHandler = function(d) {
            for (let h = 0, p = c.length; h < p; h += 2) {
                const m = c[h]
                  , y = c[h + 1];
                if (m.global && (m.lastIndex = 0),
                m.test(d))
                    return y
            }
            return null
        }
    }
}
const Iu = new Yw;
class Ai {
    constructor(e) {
        this.manager = e !== void 0 ? e : Iu,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t) {
        const i = this;
        return new Promise(function(r, s) {
            i.load(e, r, t, s)
        }
        )
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e,
        this
    }
    setWithCredentials(e) {
        return this.withCredentials = e,
        this
    }
    setPath(e) {
        return this.path = e,
        this
    }
    setResourcePath(e) {
        return this.resourcePath = e,
        this
    }
    setRequestHeader(e) {
        return this.requestHeader = e,
        this
    }
}
const Is = {};
class IH extends Error {
    constructor(e, t) {
        super(e),
        this.response = t
    }
}
class Yi extends Ai {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = Ml.get(e);
        if (s !== void 0)
            return this.manager.itemStart(e),
            setTimeout(()=>{
                t && t(s),
                this.manager.itemEnd(e)
            }
            , 0),
            s;
        if (Is[e] !== void 0) {
            Is[e].push({
                onLoad: t,
                onProgress: i,
                onError: r
            });
            return
        }
        Is[e] = [],
        Is[e].push({
            onLoad: t,
            onProgress: i,
            onError: r
        });
        const o = new Request(e,{
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
        })
          , a = this.mimeType
          , l = this.responseType;
        fetch(o).then(c=>{
            if (c.status === 200 || c.status === 0) {
                if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0)
                    return c;
                const d = Is[e]
                  , h = c.body.getReader()
                  , p = c.headers.get("Content-Length") || c.headers.get("X-File-Size")
                  , m = p ? parseInt(p) : 0
                  , y = m !== 0;
                let v = 0;
                const x = new ReadableStream({
                    start(_) {
                        A();
                        function A() {
                            h.read().then(({done: w, value: M})=>{
                                if (w)
                                    _.close();
                                else {
                                    v += M.byteLength;
                                    const C = new ProgressEvent("progress",{
                                        lengthComputable: y,
                                        loaded: v,
                                        total: m
                                    });
                                    for (let P = 0, R = d.length; P < R; P++) {
                                        const E = d[P];
                                        E.onProgress && E.onProgress(C)
                                    }
                                    _.enqueue(M),
                                    A()
                                }
                            }
                            )
                        }
                    }
                });
                return new Response(x)
            } else
                throw new IH(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,c)
        }
        ).then(c=>{
            switch (l) {
            case "arraybuffer":
                return c.arrayBuffer();
            case "blob":
                return c.blob();
            case "document":
                return c.text().then(d=>new DOMParser().parseFromString(d, a));
            case "json":
                return c.json();
            default:
                if (a === void 0)
                    return c.text();
                {
                    const h = /charset="?([^;"\s]*)"?/i.exec(a)
                      , p = h && h[1] ? h[1].toLowerCase() : void 0
                      , m = new TextDecoder(p);
                    return c.arrayBuffer().then(y=>m.decode(y))
                }
            }
        }
        ).then(c=>{
            Ml.add(e, c);
            const d = Is[e];
            delete Is[e];
            for (let h = 0, p = d.length; h < p; h++) {
                const m = d[h];
                m.onLoad && m.onLoad(c)
            }
        }
        ).catch(c=>{
            const d = Is[e];
            if (d === void 0)
                throw this.manager.itemError(e),
                c;
            delete Is[e];
            for (let h = 0, p = d.length; h < p; h++) {
                const m = d[h];
                m.onError && m.onError(c)
            }
            this.manager.itemError(e)
        }
        ).finally(()=>{
            this.manager.itemEnd(e)
        }
        ),
        this.manager.itemStart(e)
    }
    setResponseType(e) {
        return this.responseType = e,
        this
    }
    setMimeType(e) {
        return this.mimeType = e,
        this
    }
}
class LH extends Ai {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new Yi(this.manager);
        o.setPath(this.path),
        o.setRequestHeader(this.requestHeader),
        o.setWithCredentials(this.withCredentials),
        o.load(e, function(a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (l) {
                r ? r(l) : console.error(l),
                s.manager.itemError(e)
            }
        }, i, r)
    }
    parse(e) {
        const t = [];
        for (let i = 0; i < e.length; i++) {
            const r = cc.parse(e[i]);
            t.push(r)
        }
        return t
    }
}
class DH extends Ai {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = []
          , a = new Nw
          , l = new Yi(this.manager);
        l.setPath(this.path),
        l.setResponseType("arraybuffer"),
        l.setRequestHeader(this.requestHeader),
        l.setWithCredentials(s.withCredentials);
        let c = 0;
        function d(h) {
            l.load(e[h], function(p) {
                const m = s.parse(p, !0);
                o[h] = {
                    width: m.width,
                    height: m.height,
                    format: m.format,
                    mipmaps: m.mipmaps
                },
                c += 1,
                c === 6 && (m.mipmapCount === 1 && (a.minFilter = on),
                a.image = o,
                a.format = m.format,
                a.needsUpdate = !0,
                t && t(a))
            }, i, r)
        }
        if (Array.isArray(e))
            for (let h = 0, p = e.length; h < p; ++h)
                d(h);
        else
            l.load(e, function(h) {
                const p = s.parse(h, !0);
                if (p.isCubemap) {
                    const m = p.mipmaps.length / p.mipmapCount;
                    for (let y = 0; y < m; y++) {
                        o[y] = {
                            mipmaps: []
                        };
                        for (let v = 0; v < p.mipmapCount; v++)
                            o[y].mipmaps.push(p.mipmaps[y * p.mipmapCount + v]),
                            o[y].format = p.format,
                            o[y].width = p.width,
                            o[y].height = p.height
                    }
                    a.image = o
                } else
                    a.image.width = p.width,
                    a.image.height = p.height,
                    a.mipmaps = p.mipmaps;
                p.mipmapCount === 1 && (a.minFilter = on),
                a.format = p.format,
                a.needsUpdate = !0,
                t && t(a)
            }, i, r);
        return a
    }
}
class Id extends Ai {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = this
          , o = Ml.get(e);
        if (o !== void 0)
            return s.manager.itemStart(e),
            setTimeout(function() {
                t && t(o),
                s.manager.itemEnd(e)
            }, 0),
            o;
        const a = Ed("img");
        function l() {
            d(),
            Ml.add(e, this),
            t && t(this),
            s.manager.itemEnd(e)
        }
        function c(h) {
            d(),
            r && r(h),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        }
        function d() {
            a.removeEventListener("load", l, !1),
            a.removeEventListener("error", c, !1)
        }
        return a.addEventListener("load", l, !1),
        a.addEventListener("error", c, !1),
        e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin),
        s.manager.itemStart(e),
        a.src = e,
        a
    }
}
class kH extends Ai {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = new th
          , o = new Id(this.manager);
        o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path);
        let a = 0;
        function l(c) {
            o.load(e[c], function(d) {
                s.images[c] = d,
                a++,
                a === 6 && (s.needsUpdate = !0,
                t && t(s))
            }, void 0, r)
        }
        for (let c = 0; c < e.length; ++c)
            l(c);
        return s
    }
}
class FH extends Ai {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new Ju
          , a = new Yi(this.manager);
        return a.setResponseType("arraybuffer"),
        a.setRequestHeader(this.requestHeader),
        a.setPath(this.path),
        a.setWithCredentials(s.withCredentials),
        a.load(e, function(l) {
            const c = s.parse(l);
            c && (c.image !== void 0 ? o.image = c.image : c.data !== void 0 && (o.image.width = c.width,
            o.image.height = c.height,
            o.image.data = c.data),
            o.wrapS = c.wrapS !== void 0 ? c.wrapS : Xn,
            o.wrapT = c.wrapT !== void 0 ? c.wrapT : Xn,
            o.magFilter = c.magFilter !== void 0 ? c.magFilter : on,
            o.minFilter = c.minFilter !== void 0 ? c.minFilter : on,
            o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1,
            c.encoding !== void 0 && (o.encoding = c.encoding),
            c.flipY !== void 0 && (o.flipY = c.flipY),
            c.format !== void 0 && (o.format = c.format),
            c.type !== void 0 && (o.type = c.type),
            c.mipmaps !== void 0 && (o.mipmaps = c.mipmaps,
            o.minFilter = ps),
            c.mipmapCount === 1 && (o.minFilter = on),
            c.generateMipmaps !== void 0 && (o.generateMipmaps = c.generateMipmaps),
            o.needsUpdate = !0,
            t && t(o, c))
        }, i, r),
        o
    }
}
class vh extends Ai {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = new tn
          , o = new Id(this.manager);
        return o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path),
        o.load(e, function(a) {
            s.image = a,
            s.needsUpdate = !0,
            t !== void 0 && t(s)
        }, i, r),
        s
    }
}
class ga extends Rt {
    constructor(e, t=1) {
        super(),
        this.isLight = !0,
        this.type = "Light",
        this.color = new Ie(e),
        this.intensity = t
    }
    dispose() {}
    copy(e, t) {
        return super.copy(e, t),
        this.color.copy(e.color),
        this.intensity = e.intensity,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.color = this.color.getHex(),
        t.object.intensity = this.intensity,
        this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
        this.distance !== void 0 && (t.object.distance = this.distance),
        this.angle !== void 0 && (t.object.angle = this.angle),
        this.decay !== void 0 && (t.object.decay = this.decay),
        this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
        this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
        t
    }
}
class SI extends ga {
    constructor(e, t, i) {
        super(e, i),
        this.isHemisphereLight = !0,
        this.type = "HemisphereLight",
        this.position.copy(Rt.DEFAULT_UP),
        this.updateMatrix(),
        this.groundColor = new Ie(t)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.groundColor.copy(e.groundColor),
        this
    }
}
const fx = new ot
  , QE = new D
  , ZE = new D;
class Kw {
    constructor(e) {
        this.camera = e,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new me(512,512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new ot,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new T0,
        this._frameExtents = new me(1,1),
        this._viewportCount = 1,
        this._viewports = [new Ut(0,0,1,1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        const t = this.camera
          , i = this.matrix;
        QE.setFromMatrixPosition(e.matrixWorld),
        t.position.copy(QE),
        ZE.setFromMatrixPosition(e.target.matrixWorld),
        t.lookAt(ZE),
        t.updateMatrixWorld(),
        fx.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(fx),
        i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        i.multiply(fx)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(),
        this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(),
        this.bias = e.bias,
        this.radius = e.radius,
        this.mapSize.copy(e.mapSize),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const e = {};
        return this.bias !== 0 && (e.bias = this.bias),
        this.normalBias !== 0 && (e.normalBias = this.normalBias),
        this.radius !== 1 && (e.radius = this.radius),
        (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
        e.camera = this.camera.toJSON(!1).object,
        delete e.camera.matrix,
        e
    }
}
class NH extends Kw {
    constructor() {
        super(new Wt(50,1,.5,500)),
        this.isSpotLightShadow = !0,
        this.focus = 1
    }
    updateMatrices(e) {
        const t = this.camera
          , i = Cd * 2 * e.angle * this.focus
          , r = this.mapSize.width / this.mapSize.height
          , s = e.distance || t.far;
        (i !== t.fov || r !== t.aspect || s !== t.far) && (t.fov = i,
        t.aspect = r,
        t.far = s,
        t.updateProjectionMatrix()),
        super.updateMatrices(e)
    }
    copy(e) {
        return super.copy(e),
        this.focus = e.focus,
        this
    }
}
class Qw extends ga {
    constructor(e, t, i=0, r=Math.PI / 3, s=0, o=2) {
        super(e, t),
        this.isSpotLight = !0,
        this.type = "SpotLight",
        this.position.copy(Rt.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new Rt,
        this.distance = i,
        this.angle = r,
        this.penumbra = s,
        this.decay = o,
        this.map = null,
        this.shadow = new NH
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power(e) {
        this.intensity = e / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.angle = e.angle,
        this.penumbra = e.penumbra,
        this.decay = e.decay,
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
const qE = new ot
  , vf = new D
  , dx = new D;
class OH extends Kw {
    constructor() {
        super(new Wt(90,1,.5,500)),
        this.isPointLightShadow = !0,
        this._frameExtents = new me(4,2),
        this._viewportCount = 6,
        this._viewports = [new Ut(2,1,1,1), new Ut(0,1,1,1), new Ut(3,1,1,1), new Ut(1,1,1,1), new Ut(3,0,1,1), new Ut(1,0,1,1)],
        this._cubeDirections = [new D(1,0,0), new D(-1,0,0), new D(0,0,1), new D(0,0,-1), new D(0,1,0), new D(0,-1,0)],
        this._cubeUps = [new D(0,1,0), new D(0,1,0), new D(0,1,0), new D(0,1,0), new D(0,0,1), new D(0,0,-1)]
    }
    updateMatrices(e, t=0) {
        const i = this.camera
          , r = this.matrix
          , s = e.distance || i.far;
        s !== i.far && (i.far = s,
        i.updateProjectionMatrix()),
        vf.setFromMatrixPosition(e.matrixWorld),
        i.position.copy(vf),
        dx.copy(i.position),
        dx.add(this._cubeDirections[t]),
        i.up.copy(this._cubeUps[t]),
        i.lookAt(dx),
        i.updateMatrixWorld(),
        r.makeTranslation(-vf.x, -vf.y, -vf.z),
        qE.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(qE)
    }
}
class Zw extends ga {
    constructor(e, t, i=0, r=2) {
        super(e, t),
        this.isPointLight = !0,
        this.type = "PointLight",
        this.distance = i,
        this.decay = r,
        this.shadow = new OH
    }
    get power() {
        return this.intensity * 4 * Math.PI
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.decay = e.decay,
        this.shadow = e.shadow.clone(),
        this
    }
}
class UH extends Kw {
    constructor() {
        super(new Vr(-5,5,5,-5,.5,500)),
        this.isDirectionalLightShadow = !0
    }
}
class qw extends ga {
    constructor(e, t) {
        super(e, t),
        this.isDirectionalLight = !0,
        this.type = "DirectionalLight",
        this.position.copy(Rt.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new Rt,
        this.shadow = new UH
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e),
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
class MI extends ga {
    constructor(e, t) {
        super(e, t),
        this.isAmbientLight = !0,
        this.type = "AmbientLight"
    }
}
class bI extends ga {
    constructor(e, t, i=10, r=10) {
        super(e, t),
        this.isRectAreaLight = !0,
        this.type = "RectAreaLight",
        this.width = i,
        this.height = r
    }
    get power() {
        return this.intensity * this.width * this.height * Math.PI
    }
    set power(e) {
        this.intensity = e / (this.width * this.height * Math.PI)
    }
    copy(e) {
        return super.copy(e),
        this.width = e.width,
        this.height = e.height,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.width = this.width,
        t.object.height = this.height,
        t
    }
}
class CI {
    constructor() {
        this.isSphericalHarmonics3 = !0,
        this.coefficients = [];
        for (let e = 0; e < 9; e++)
            this.coefficients.push(new D)
    }
    set(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].copy(e[t]);
        return this
    }
    zero() {
        for (let e = 0; e < 9; e++)
            this.coefficients[e].set(0, 0, 0);
        return this
    }
    getAt(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z
          , o = this.coefficients;
        return t.copy(o[0]).multiplyScalar(.282095),
        t.addScaledVector(o[1], .488603 * r),
        t.addScaledVector(o[2], .488603 * s),
        t.addScaledVector(o[3], .488603 * i),
        t.addScaledVector(o[4], 1.092548 * (i * r)),
        t.addScaledVector(o[5], 1.092548 * (r * s)),
        t.addScaledVector(o[6], .315392 * (3 * s * s - 1)),
        t.addScaledVector(o[7], 1.092548 * (i * s)),
        t.addScaledVector(o[8], .546274 * (i * i - r * r)),
        t
    }
    getIrradianceAt(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z
          , o = this.coefficients;
        return t.copy(o[0]).multiplyScalar(.886227),
        t.addScaledVector(o[1], 2 * .511664 * r),
        t.addScaledVector(o[2], 2 * .511664 * s),
        t.addScaledVector(o[3], 2 * .511664 * i),
        t.addScaledVector(o[4], 2 * .429043 * i * r),
        t.addScaledVector(o[5], 2 * .429043 * r * s),
        t.addScaledVector(o[6], .743125 * s * s - .247708),
        t.addScaledVector(o[7], 2 * .429043 * i * s),
        t.addScaledVector(o[8], .429043 * (i * i - r * r)),
        t
    }
    add(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].add(e.coefficients[t]);
        return this
    }
    addScaledSH(e, t) {
        for (let i = 0; i < 9; i++)
            this.coefficients[i].addScaledVector(e.coefficients[i], t);
        return this
    }
    scale(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].multiplyScalar(e);
        return this
    }
    lerp(e, t) {
        for (let i = 0; i < 9; i++)
            this.coefficients[i].lerp(e.coefficients[i], t);
        return this
    }
    equals(e) {
        for (let t = 0; t < 9; t++)
            if (!this.coefficients[t].equals(e.coefficients[t]))
                return !1;
        return !0
    }
    copy(e) {
        return this.set(e.coefficients)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    fromArray(e, t=0) {
        const i = this.coefficients;
        for (let r = 0; r < 9; r++)
            i[r].fromArray(e, t + r * 3);
        return this
    }
    toArray(e=[], t=0) {
        const i = this.coefficients;
        for (let r = 0; r < 9; r++)
            i[r].toArray(e, t + r * 3);
        return e
    }
    static getBasisAt(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z;
        t[0] = .282095,
        t[1] = .488603 * r,
        t[2] = .488603 * s,
        t[3] = .488603 * i,
        t[4] = 1.092548 * i * r,
        t[5] = 1.092548 * r * s,
        t[6] = .315392 * (3 * s * s - 1),
        t[7] = 1.092548 * i * s,
        t[8] = .546274 * (i * i - r * r)
    }
}
class F0 extends ga {
    constructor(e=new CI, t=1) {
        super(void 0, t),
        this.isLightProbe = !0,
        this.sh = e
    }
    copy(e) {
        return super.copy(e),
        this.sh.copy(e.sh),
        this
    }
    fromJSON(e) {
        return this.intensity = e.intensity,
        this.sh.fromArray(e.sh),
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.sh = this.sh.toArray(),
        t
    }
}
class N0 extends Ai {
    constructor(e) {
        super(e),
        this.textures = {}
    }
    load(e, t, i, r) {
        const s = this
          , o = new Yi(s.manager);
        o.setPath(s.path),
        o.setRequestHeader(s.requestHeader),
        o.setWithCredentials(s.withCredentials),
        o.load(e, function(a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (l) {
                r ? r(l) : console.error(l),
                s.manager.itemError(e)
            }
        }, i, r)
    }
    parse(e) {
        const t = this.textures;
        function i(s) {
            return t[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s),
            t[s]
        }
        const r = N0.createMaterialFromType(e.type);
        if (e.uuid !== void 0 && (r.uuid = e.uuid),
        e.name !== void 0 && (r.name = e.name),
        e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color),
        e.roughness !== void 0 && (r.roughness = e.roughness),
        e.metalness !== void 0 && (r.metalness = e.metalness),
        e.sheen !== void 0 && (r.sheen = e.sheen),
        e.sheenColor !== void 0 && (r.sheenColor = new Ie().setHex(e.sheenColor)),
        e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness),
        e.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(e.emissive),
        e.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(e.specular),
        e.specularIntensity !== void 0 && (r.specularIntensity = e.specularIntensity),
        e.specularColor !== void 0 && r.specularColor !== void 0 && r.specularColor.setHex(e.specularColor),
        e.shininess !== void 0 && (r.shininess = e.shininess),
        e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat),
        e.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = e.clearcoatRoughness),
        e.iridescence !== void 0 && (r.iridescence = e.iridescence),
        e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR),
        e.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = e.iridescenceThicknessRange),
        e.transmission !== void 0 && (r.transmission = e.transmission),
        e.thickness !== void 0 && (r.thickness = e.thickness),
        e.attenuationDistance !== void 0 && (r.attenuationDistance = e.attenuationDistance),
        e.attenuationColor !== void 0 && r.attenuationColor !== void 0 && r.attenuationColor.setHex(e.attenuationColor),
        e.fog !== void 0 && (r.fog = e.fog),
        e.flatShading !== void 0 && (r.flatShading = e.flatShading),
        e.blending !== void 0 && (r.blending = e.blending),
        e.combine !== void 0 && (r.combine = e.combine),
        e.side !== void 0 && (r.side = e.side),
        e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide),
        e.opacity !== void 0 && (r.opacity = e.opacity),
        e.transparent !== void 0 && (r.transparent = e.transparent),
        e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest),
        e.depthTest !== void 0 && (r.depthTest = e.depthTest),
        e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite),
        e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite),
        e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite),
        e.stencilWriteMask !== void 0 && (r.stencilWriteMask = e.stencilWriteMask),
        e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc),
        e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef),
        e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask),
        e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail),
        e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail),
        e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass),
        e.wireframe !== void 0 && (r.wireframe = e.wireframe),
        e.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = e.wireframeLinewidth),
        e.wireframeLinecap !== void 0 && (r.wireframeLinecap = e.wireframeLinecap),
        e.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = e.wireframeLinejoin),
        e.rotation !== void 0 && (r.rotation = e.rotation),
        e.linewidth !== 1 && (r.linewidth = e.linewidth),
        e.dashSize !== void 0 && (r.dashSize = e.dashSize),
        e.gapSize !== void 0 && (r.gapSize = e.gapSize),
        e.scale !== void 0 && (r.scale = e.scale),
        e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset),
        e.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = e.polygonOffsetFactor),
        e.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = e.polygonOffsetUnits),
        e.dithering !== void 0 && (r.dithering = e.dithering),
        e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage),
        e.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = e.premultipliedAlpha),
        e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass),
        e.visible !== void 0 && (r.visible = e.visible),
        e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped),
        e.userData !== void 0 && (r.userData = e.userData),
        e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors),
        e.uniforms !== void 0)
            for (const s in e.uniforms) {
                const o = e.uniforms[s];
                switch (r.uniforms[s] = {},
                o.type) {
                case "t":
                    r.uniforms[s].value = i(o.value);
                    break;
                case "c":
                    r.uniforms[s].value = new Ie().setHex(o.value);
                    break;
                case "v2":
                    r.uniforms[s].value = new me().fromArray(o.value);
                    break;
                case "v3":
                    r.uniforms[s].value = new D().fromArray(o.value);
                    break;
                case "v4":
                    r.uniforms[s].value = new Ut().fromArray(o.value);
                    break;
                case "m3":
                    r.uniforms[s].value = new gi().fromArray(o.value);
                    break;
                case "m4":
                    r.uniforms[s].value = new ot().fromArray(o.value);
                    break;
                default:
                    r.uniforms[s].value = o.value
                }
            }
        if (e.defines !== void 0 && (r.defines = e.defines),
        e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader),
        e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader),
        e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion),
        e.extensions !== void 0)
            for (const s in e.extensions)
                r.extensions[s] = e.extensions[s];
        if (e.size !== void 0 && (r.size = e.size),
        e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation),
        e.map !== void 0 && (r.map = i(e.map)),
        e.matcap !== void 0 && (r.matcap = i(e.matcap)),
        e.alphaMap !== void 0 && (r.alphaMap = i(e.alphaMap)),
        e.bumpMap !== void 0 && (r.bumpMap = i(e.bumpMap)),
        e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale),
        e.normalMap !== void 0 && (r.normalMap = i(e.normalMap)),
        e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType),
        e.normalScale !== void 0) {
            let s = e.normalScale;
            Array.isArray(s) === !1 && (s = [s, s]),
            r.normalScale = new me().fromArray(s)
        }
        return e.displacementMap !== void 0 && (r.displacementMap = i(e.displacementMap)),
        e.displacementScale !== void 0 && (r.displacementScale = e.displacementScale),
        e.displacementBias !== void 0 && (r.displacementBias = e.displacementBias),
        e.roughnessMap !== void 0 && (r.roughnessMap = i(e.roughnessMap)),
        e.metalnessMap !== void 0 && (r.metalnessMap = i(e.metalnessMap)),
        e.emissiveMap !== void 0 && (r.emissiveMap = i(e.emissiveMap)),
        e.emissiveIntensity !== void 0 && (r.emissiveIntensity = e.emissiveIntensity),
        e.specularMap !== void 0 && (r.specularMap = i(e.specularMap)),
        e.specularIntensityMap !== void 0 && (r.specularIntensityMap = i(e.specularIntensityMap)),
        e.specularColorMap !== void 0 && (r.specularColorMap = i(e.specularColorMap)),
        e.envMap !== void 0 && (r.envMap = i(e.envMap)),
        e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity),
        e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity),
        e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio),
        e.lightMap !== void 0 && (r.lightMap = i(e.lightMap)),
        e.lightMapIntensity !== void 0 && (r.lightMapIntensity = e.lightMapIntensity),
        e.aoMap !== void 0 && (r.aoMap = i(e.aoMap)),
        e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity),
        e.gradientMap !== void 0 && (r.gradientMap = i(e.gradientMap)),
        e.clearcoatMap !== void 0 && (r.clearcoatMap = i(e.clearcoatMap)),
        e.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)),
        e.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = i(e.clearcoatNormalMap)),
        e.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new me().fromArray(e.clearcoatNormalScale)),
        e.iridescenceMap !== void 0 && (r.iridescenceMap = i(e.iridescenceMap)),
        e.iridescenceThicknessMap !== void 0 && (r.iridescenceThicknessMap = i(e.iridescenceThicknessMap)),
        e.transmissionMap !== void 0 && (r.transmissionMap = i(e.transmissionMap)),
        e.thicknessMap !== void 0 && (r.thicknessMap = i(e.thicknessMap)),
        e.sheenColorMap !== void 0 && (r.sheenColorMap = i(e.sheenColorMap)),
        e.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = i(e.sheenRoughnessMap)),
        r
    }
    setTextures(e) {
        return this.textures = e,
        this
    }
    static createMaterialFromType(e) {
        const t = {
            ShadowMaterial: fI,
            SpriteMaterial: Lw,
            RawShaderMaterial: dI,
            ShaderMaterial: ms,
            PointsMaterial: rh,
            MeshPhysicalMaterial: ao,
            MeshStandardMaterial: Cc,
            MeshPhongMaterial: hI,
            MeshToonMaterial: pI,
            MeshNormalMaterial: mI,
            MeshLambertMaterial: gI,
            MeshDepthMaterial: Pw,
            MeshDistanceMaterial: Bw,
            MeshBasicMaterial: Wi,
            MeshMatcapMaterial: vI,
            LineDashedMaterial: yI,
            LineBasicMaterial: li,
            Material: Tn
        };
        return new t[e]
    }
}
class fs {
    static decodeText(e) {
        if (typeof TextDecoder < "u")
            return new TextDecoder().decode(e);
        let t = "";
        for (let i = 0, r = e.length; i < r; i++)
            t += String.fromCharCode(e[i]);
        try {
            return decodeURIComponent(escape(t))
        } catch {
            return t
        }
    }
    static extractUrlBase(e) {
        const t = e.lastIndexOf("/");
        return t === -1 ? "./" : e.slice(0, t + 1)
    }
    static resolveURL(e, t) {
        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
    }
}
class EI extends ft {
    constructor() {
        super(),
        this.isInstancedBufferGeometry = !0,
        this.type = "InstancedBufferGeometry",
        this.instanceCount = 1 / 0
    }
    copy(e) {
        return super.copy(e),
        this.instanceCount = e.instanceCount,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.instanceCount = this.instanceCount,
        e.isInstancedBufferGeometry = !0,
        e
    }
}
class TI extends Ai {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new Yi(s.manager);
        o.setPath(s.path),
        o.setRequestHeader(s.requestHeader),
        o.setWithCredentials(s.withCredentials),
        o.load(e, function(a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (l) {
                r ? r(l) : console.error(l),
                s.manager.itemError(e)
            }
        }, i, r)
    }
    parse(e) {
        const t = {}
          , i = {};
        function r(m, y) {
            if (t[y] !== void 0)
                return t[y];
            const x = m.interleavedBuffers[y]
              , _ = s(m, x.buffer)
              , A = Pu(x.type, _)
              , w = new nh(A,x.stride);
            return w.uuid = x.uuid,
            t[y] = w,
            w
        }
        function s(m, y) {
            if (i[y] !== void 0)
                return i[y];
            const x = m.arrayBuffers[y]
              , _ = new Uint32Array(x).buffer;
            return i[y] = _,
            _
        }
        const o = e.isInstancedBufferGeometry ? new EI : new ft
          , a = e.data.index;
        if (a !== void 0) {
            const m = Pu(a.type, a.array);
            o.setIndex(new Nt(m,1))
        }
        const l = e.data.attributes;
        for (const m in l) {
            const y = l[m];
            let v;
            if (y.isInterleavedBufferAttribute) {
                const x = r(e.data, y.data);
                v = new ia(x,y.itemSize,y.offset,y.normalized)
            } else {
                const x = Pu(y.type, y.array)
                  , _ = y.isInstancedBufferAttribute ? ac : Nt;
                v = new _(x,y.itemSize,y.normalized)
            }
            y.name !== void 0 && (v.name = y.name),
            y.usage !== void 0 && v.setUsage(y.usage),
            y.updateRange !== void 0 && (v.updateRange.offset = y.updateRange.offset,
            v.updateRange.count = y.updateRange.count),
            o.setAttribute(m, v)
        }
        const c = e.data.morphAttributes;
        if (c)
            for (const m in c) {
                const y = c[m]
                  , v = [];
                for (let x = 0, _ = y.length; x < _; x++) {
                    const A = y[x];
                    let w;
                    if (A.isInterleavedBufferAttribute) {
                        const M = r(e.data, A.data);
                        w = new ia(M,A.itemSize,A.offset,A.normalized)
                    } else {
                        const M = Pu(A.type, A.array);
                        w = new Nt(M,A.itemSize,A.normalized)
                    }
                    A.name !== void 0 && (w.name = A.name),
                    v.push(w)
                }
                o.morphAttributes[m] = v
            }
        e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
        const h = e.data.groups || e.data.drawcalls || e.data.offsets;
        if (h !== void 0)
            for (let m = 0, y = h.length; m !== y; ++m) {
                const v = h[m];
                o.addGroup(v.start, v.count, v.materialIndex)
            }
        const p = e.data.boundingSphere;
        if (p !== void 0) {
            const m = new D;
            p.center !== void 0 && m.fromArray(p.center),
            o.boundingSphere = new pa(m,p.radius)
        }
        return e.name && (o.name = e.name),
        e.userData && (o.userData = e.userData),
        o
    }
}
class zH extends Ai {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = this.path === "" ? fs.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || o;
        const a = new Yi(this.manager);
        a.setPath(this.path),
        a.setRequestHeader(this.requestHeader),
        a.setWithCredentials(this.withCredentials),
        a.load(e, function(l) {
            let c = null;
            try {
                c = JSON.parse(l)
            } catch (h) {
                r !== void 0 && r(h),
                console.error("THREE:ObjectLoader: Can't parse " + e + ".", h.message);
                return
            }
            const d = c.metadata;
            if (d === void 0 || d.type === void 0 || d.type.toLowerCase() === "geometry") {
                r !== void 0 && r(new Error("THREE.ObjectLoader: Can't load " + e)),
                console.error("THREE.ObjectLoader: Can't load " + e);
                return
            }
            s.parse(c, t)
        }, i, r)
    }
    async loadAsync(e, t) {
        const i = this
          , r = this.path === "" ? fs.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || r;
        const s = new Yi(this.manager);
        s.setPath(this.path),
        s.setRequestHeader(this.requestHeader),
        s.setWithCredentials(this.withCredentials);
        const o = await s.loadAsync(e, t)
          , a = JSON.parse(o)
          , l = a.metadata;
        if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry")
            throw new Error("THREE.ObjectLoader: Can't load " + e);
        return await i.parseAsync(a)
    }
    parse(e, t) {
        const i = this.parseAnimations(e.animations)
          , r = this.parseShapes(e.shapes)
          , s = this.parseGeometries(e.geometries, r)
          , o = this.parseImages(e.images, function() {
            t !== void 0 && t(c)
        })
          , a = this.parseTextures(e.textures, o)
          , l = this.parseMaterials(e.materials, a)
          , c = this.parseObject(e.object, s, l, a, i)
          , d = this.parseSkeletons(e.skeletons, c);
        if (this.bindSkeletons(c, d),
        t !== void 0) {
            let h = !1;
            for (const p in o)
                if (o[p].data instanceof HTMLImageElement) {
                    h = !0;
                    break
                }
            h === !1 && t(c)
        }
        return c
    }
    async parseAsync(e) {
        const t = this.parseAnimations(e.animations)
          , i = this.parseShapes(e.shapes)
          , r = this.parseGeometries(e.geometries, i)
          , s = await this.parseImagesAsync(e.images)
          , o = this.parseTextures(e.textures, s)
          , a = this.parseMaterials(e.materials, o)
          , l = this.parseObject(e.object, r, a, o, t)
          , c = this.parseSkeletons(e.skeletons, l);
        return this.bindSkeletons(l, c),
        l
    }
    parseShapes(e) {
        const t = {};
        if (e !== void 0)
            for (let i = 0, r = e.length; i < r; i++) {
                const s = new ml().fromJSON(e[i]);
                t[s.uuid] = s
            }
        return t
    }
    parseSkeletons(e, t) {
        const i = {}
          , r = {};
        if (t.traverse(function(s) {
            s.isBone && (r[s.uuid] = s)
        }),
        e !== void 0)
            for (let s = 0, o = e.length; s < o; s++) {
                const a = new ih().fromJSON(e[s], r);
                i[a.uuid] = a
            }
        return i
    }
    parseGeometries(e, t) {
        const i = {};
        if (e !== void 0) {
            const r = new TI;
            for (let s = 0, o = e.length; s < o; s++) {
                let a;
                const l = e[s];
                switch (l.type) {
                case "BufferGeometry":
                case "InstancedBufferGeometry":
                    a = r.parse(l);
                    break;
                default:
                    l.type in KE ? a = KE[l.type].fromJSON(l, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`)
                }
                a.uuid = l.uuid,
                l.name !== void 0 && (a.name = l.name),
                a.isBufferGeometry === !0 && l.userData !== void 0 && (a.userData = l.userData),
                i[l.uuid] = a
            }
        }
        return i
    }
    parseMaterials(e, t) {
        const i = {}
          , r = {};
        if (e !== void 0) {
            const s = new N0;
            s.setTextures(t);
            for (let o = 0, a = e.length; o < a; o++) {
                const l = e[o];
                i[l.uuid] === void 0 && (i[l.uuid] = s.parse(l)),
                r[l.uuid] = i[l.uuid]
            }
        }
        return r
    }
    parseAnimations(e) {
        const t = {};
        if (e !== void 0)
            for (let i = 0; i < e.length; i++) {
                const r = e[i]
                  , s = cc.parse(r);
                t[s.uuid] = s
            }
        return t
    }
    parseImages(e, t) {
        const i = this
          , r = {};
        let s;
        function o(l) {
            return i.manager.itemStart(l),
            s.load(l, function() {
                i.manager.itemEnd(l)
            }, void 0, function() {
                i.manager.itemError(l),
                i.manager.itemEnd(l)
            })
        }
        function a(l) {
            if (typeof l == "string") {
                const c = l
                  , d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : i.resourcePath + c;
                return o(d)
            } else
                return l.data ? {
                    data: Pu(l.type, l.data),
                    width: l.width,
                    height: l.height
                } : null
        }
        if (e !== void 0 && e.length > 0) {
            const l = new Yw(t);
            s = new Id(l),
            s.setCrossOrigin(this.crossOrigin);
            for (let c = 0, d = e.length; c < d; c++) {
                const h = e[c]
                  , p = h.url;
                if (Array.isArray(p)) {
                    const m = [];
                    for (let y = 0, v = p.length; y < v; y++) {
                        const x = p[y]
                          , _ = a(x);
                        _ !== null && (_ instanceof HTMLImageElement ? m.push(_) : m.push(new Ju(_.data,_.width,_.height)))
                    }
                    r[h.uuid] = new nl(m)
                } else {
                    const m = a(h.url);
                    r[h.uuid] = new nl(m)
                }
            }
        }
        return r
    }
    async parseImagesAsync(e) {
        const t = this
          , i = {};
        let r;
        async function s(o) {
            if (typeof o == "string") {
                const a = o
                  , l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
                return await r.loadAsync(l)
            } else
                return o.data ? {
                    data: Pu(o.type, o.data),
                    width: o.width,
                    height: o.height
                } : null
        }
        if (e !== void 0 && e.length > 0) {
            r = new Id(this.manager),
            r.setCrossOrigin(this.crossOrigin);
            for (let o = 0, a = e.length; o < a; o++) {
                const l = e[o]
                  , c = l.url;
                if (Array.isArray(c)) {
                    const d = [];
                    for (let h = 0, p = c.length; h < p; h++) {
                        const m = c[h]
                          , y = await s(m);
                        y !== null && (y instanceof HTMLImageElement ? d.push(y) : d.push(new Ju(y.data,y.width,y.height)))
                    }
                    i[l.uuid] = new nl(d)
                } else {
                    const d = await s(l.url);
                    i[l.uuid] = new nl(d)
                }
            }
        }
        return i
    }
    parseTextures(e, t) {
        function i(s, o) {
            return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s),
            o[s])
        }
        const r = {};
        if (e !== void 0)
            for (let s = 0, o = e.length; s < o; s++) {
                const a = e[s];
                a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
                t[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
                const l = t[a.image]
                  , c = l.data;
                let d;
                Array.isArray(c) ? (d = new th,
                c.length === 6 && (d.needsUpdate = !0)) : (c && c.data ? d = new Ju : d = new tn,
                c && (d.needsUpdate = !0)),
                d.source = l,
                d.uuid = a.uuid,
                a.name !== void 0 && (d.name = a.name),
                a.mapping !== void 0 && (d.mapping = i(a.mapping, GH)),
                a.offset !== void 0 && d.offset.fromArray(a.offset),
                a.repeat !== void 0 && d.repeat.fromArray(a.repeat),
                a.center !== void 0 && d.center.fromArray(a.center),
                a.rotation !== void 0 && (d.rotation = a.rotation),
                a.wrap !== void 0 && (d.wrapS = i(a.wrap[0], $E),
                d.wrapT = i(a.wrap[1], $E)),
                a.format !== void 0 && (d.format = a.format),
                a.type !== void 0 && (d.type = a.type),
                a.encoding !== void 0 && (d.encoding = a.encoding),
                a.minFilter !== void 0 && (d.minFilter = i(a.minFilter, eT)),
                a.magFilter !== void 0 && (d.magFilter = i(a.magFilter, eT)),
                a.anisotropy !== void 0 && (d.anisotropy = a.anisotropy),
                a.flipY !== void 0 && (d.flipY = a.flipY),
                a.generateMipmaps !== void 0 && (d.generateMipmaps = a.generateMipmaps),
                a.premultiplyAlpha !== void 0 && (d.premultiplyAlpha = a.premultiplyAlpha),
                a.unpackAlignment !== void 0 && (d.unpackAlignment = a.unpackAlignment),
                a.userData !== void 0 && (d.userData = a.userData),
                r[a.uuid] = d
            }
        return r
    }
    parseObject(e, t, i, r, s) {
        let o;
        function a(p) {
            return t[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", p),
            t[p]
        }
        function l(p) {
            if (p !== void 0) {
                if (Array.isArray(p)) {
                    const m = [];
                    for (let y = 0, v = p.length; y < v; y++) {
                        const x = p[y];
                        i[x] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", x),
                        m.push(i[x])
                    }
                    return m
                }
                return i[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", p),
                i[p]
            }
        }
        function c(p) {
            return r[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", p),
            r[p]
        }
        let d, h;
        switch (e.type) {
        case "Scene":
            o = new Iw,
            e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new Ie(e.background) : o.background = c(e.background)),
            e.environment !== void 0 && (o.environment = c(e.environment)),
            e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new R0(e.fog.color,e.fog.near,e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new B0(e.fog.color,e.fog.density))),
            e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness),
            e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity);
            break;
        case "PerspectiveCamera":
            o = new Wt(e.fov,e.aspect,e.near,e.far),
            e.focus !== void 0 && (o.focus = e.focus),
            e.zoom !== void 0 && (o.zoom = e.zoom),
            e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge),
            e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset),
            e.view !== void 0 && (o.view = Object.assign({}, e.view));
            break;
        case "OrthographicCamera":
            o = new Vr(e.left,e.right,e.top,e.bottom,e.near,e.far),
            e.zoom !== void 0 && (o.zoom = e.zoom),
            e.view !== void 0 && (o.view = Object.assign({}, e.view));
            break;
        case "AmbientLight":
            o = new MI(e.color,e.intensity);
            break;
        case "DirectionalLight":
            o = new qw(e.color,e.intensity);
            break;
        case "PointLight":
            o = new Zw(e.color,e.intensity,e.distance,e.decay);
            break;
        case "RectAreaLight":
            o = new bI(e.color,e.intensity,e.width,e.height);
            break;
        case "SpotLight":
            o = new Qw(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);
            break;
        case "HemisphereLight":
            o = new SI(e.color,e.groundColor,e.intensity);
            break;
        case "LightProbe":
            o = new F0().fromJSON(e);
            break;
        case "SkinnedMesh":
            d = a(e.geometry),
            h = l(e.material),
            o = new Dw(d,h),
            e.bindMode !== void 0 && (o.bindMode = e.bindMode),
            e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix),
            e.skeleton !== void 0 && (o.skeleton = e.skeleton);
            break;
        case "Mesh":
            d = a(e.geometry),
            h = l(e.material),
            o = new Ln(d,h);
            break;
        case "InstancedMesh":
            d = a(e.geometry),
            h = l(e.material);
            const p = e.count
              , m = e.instanceMatrix
              , y = e.instanceColor;
            o = new eI(d,h,p),
            o.instanceMatrix = new ac(new Float32Array(m.array),16),
            y !== void 0 && (o.instanceColor = new ac(new Float32Array(y.array),y.itemSize));
            break;
        case "LOD":
            o = new $R;
            break;
        case "Line":
            o = new eo(a(e.geometry),l(e.material));
            break;
        case "LineLoop":
            o = new kw(a(e.geometry),l(e.material));
            break;
        case "LineSegments":
            o = new Jr(a(e.geometry),l(e.material));
            break;
        case "PointCloud":
        case "Points":
            o = new Fw(a(e.geometry),l(e.material));
            break;
        case "Sprite":
            o = new qR(l(e.material));
            break;
        case "Group":
            o = new Hs;
            break;
        case "Bone":
            o = new I0;
            break;
        default:
            o = new Rt
        }
        if (o.uuid = e.uuid,
        e.name !== void 0 && (o.name = e.name),
        e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix),
        e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate),
        o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position),
        e.rotation !== void 0 && o.rotation.fromArray(e.rotation),
        e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion),
        e.scale !== void 0 && o.scale.fromArray(e.scale)),
        e.castShadow !== void 0 && (o.castShadow = e.castShadow),
        e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow),
        e.shadow && (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))),
        e.visible !== void 0 && (o.visible = e.visible),
        e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled),
        e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder),
        e.userData !== void 0 && (o.userData = e.userData),
        e.layers !== void 0 && (o.layers.mask = e.layers),
        e.children !== void 0) {
            const p = e.children;
            for (let m = 0; m < p.length; m++)
                o.add(this.parseObject(p[m], t, i, r, s))
        }
        if (e.animations !== void 0) {
            const p = e.animations;
            for (let m = 0; m < p.length; m++) {
                const y = p[m];
                o.animations.push(s[y])
            }
        }
        if (e.type === "LOD") {
            e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
            const p = e.levels;
            for (let m = 0; m < p.length; m++) {
                const y = p[m]
                  , v = o.getObjectByProperty("uuid", y.object);
                v !== void 0 && o.addLevel(v, y.distance, y.hysteresis)
            }
        }
        return o
    }
    bindSkeletons(e, t) {
        Object.keys(t).length !== 0 && e.traverse(function(i) {
            if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) {
                const r = t[i.skeleton];
                r === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", i.skeleton) : i.bind(r, i.bindMatrix)
            }
        })
    }
}
const GH = {
    UVMapping: M0,
    CubeReflectionMapping: ea,
    CubeRefractionMapping: ta,
    EquirectangularReflectionMapping: Ad,
    EquirectangularRefractionMapping: wd,
    CubeUVReflectionMapping: _c
}
  , $E = {
    RepeatWrapping: na,
    ClampToEdgeWrapping: Xn,
    MirroredRepeatWrapping: nc
}
  , eT = {
    NearestFilter: gn,
    NearestMipmapNearestFilter: Sd,
    NearestMipmapLinearFilter: ju,
    LinearFilter: on,
    LinearMipmapNearestFilter: b0,
    LinearMipmapLinearFilter: ps
};
class PI extends Ai {
    constructor(e) {
        super(e),
        this.isImageBitmapLoader = !0,
        typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.options = {
            premultiplyAlpha: "none"
        }
    }
    setOptions(e) {
        return this.options = e,
        this
    }
    load(e, t, i, r) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = this
          , o = Ml.get(e);
        if (o !== void 0)
            return s.manager.itemStart(e),
            setTimeout(function() {
                t && t(o),
                s.manager.itemEnd(e)
            }, 0),
            o;
        const a = {};
        a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include",
        a.headers = this.requestHeader,
        fetch(e, a).then(function(l) {
            return l.blob()
        }).then(function(l) {
            return createImageBitmap(l, Object.assign(s.options, {
                colorSpaceConversion: "none"
            }))
        }).then(function(l) {
            Ml.add(e, l),
            t && t(l),
            s.manager.itemEnd(e)
        }).catch(function(l) {
            r && r(l),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        }),
        s.manager.itemStart(e)
    }
}
let ym;
class $w {
    static getContext() {
        return ym === void 0 && (ym = new (window.AudioContext || window.webkitAudioContext)),
        ym
    }
    static setContext(e) {
        ym = e
    }
}
class HH extends Ai {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new Yi(this.manager);
        o.setResponseType("arraybuffer"),
        o.setPath(this.path),
        o.setRequestHeader(this.requestHeader),
        o.setWithCredentials(this.withCredentials),
        o.load(e, function(a) {
            try {
                const l = a.slice(0);
                $w.getContext().decodeAudioData(l, function(d) {
                    t(d)
                })
            } catch (l) {
                r ? r(l) : console.error(l),
                s.manager.itemError(e)
            }
        }, i, r)
    }
}
class VH extends F0 {
    constructor(e, t, i=1) {
        super(void 0, i),
        this.isHemisphereLightProbe = !0;
        const r = new Ie().set(e)
          , s = new Ie().set(t)
          , o = new D(r.r,r.g,r.b)
          , a = new D(s.r,s.g,s.b)
          , l = Math.sqrt(Math.PI)
          , c = l * Math.sqrt(.75);
        this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l),
        this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c)
    }
}
class WH extends F0 {
    constructor(e, t=1) {
        super(void 0, t),
        this.isAmbientLightProbe = !0;
        const i = new Ie().set(e);
        this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }
}
const tT = new ot
  , nT = new ot
  , Ia = new ot;
class jH {
    constructor() {
        this.type = "StereoCamera",
        this.aspect = 1,
        this.eyeSep = .064,
        this.cameraL = new Wt,
        this.cameraL.layers.enable(1),
        this.cameraL.matrixAutoUpdate = !1,
        this.cameraR = new Wt,
        this.cameraR.layers.enable(2),
        this.cameraR.matrixAutoUpdate = !1,
        this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        }
    }
    update(e) {
        const t = this._cache;
        if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
            t.focus = e.focus,
            t.fov = e.fov,
            t.aspect = e.aspect * this.aspect,
            t.near = e.near,
            t.far = e.far,
            t.zoom = e.zoom,
            t.eyeSep = this.eyeSep,
            Ia.copy(e.projectionMatrix);
            const r = t.eyeSep / 2
              , s = r * t.near / t.focus
              , o = t.near * Math.tan(dl * t.fov * .5) / t.zoom;
            let a, l;
            nT.elements[12] = -r,
            tT.elements[12] = r,
            a = -o * t.aspect + s,
            l = o * t.aspect + s,
            Ia.elements[0] = 2 * t.near / (l - a),
            Ia.elements[8] = (l + a) / (l - a),
            this.cameraL.projectionMatrix.copy(Ia),
            a = -o * t.aspect - s,
            l = o * t.aspect - s,
            Ia.elements[0] = 2 * t.near / (l - a),
            Ia.elements[8] = (l + a) / (l - a),
            this.cameraR.projectionMatrix.copy(Ia)
        }
        this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(nT),
        this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(tT)
    }
}
class eS {
    constructor(e=!0) {
        this.autoStart = e,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    start() {
        this.startTime = iT(),
        this.oldTime = this.startTime,
        this.elapsedTime = 0,
        this.running = !0
    }
    stop() {
        this.getElapsedTime(),
        this.running = !1,
        this.autoStart = !1
    }
    getElapsedTime() {
        return this.getDelta(),
        this.elapsedTime
    }
    getDelta() {
        let e = 0;
        if (this.autoStart && !this.running)
            return this.start(),
            0;
        if (this.running) {
            const t = iT();
            e = (t - this.oldTime) / 1e3,
            this.oldTime = t,
            this.elapsedTime += e
        }
        return e
    }
}
function iT() {
    return (typeof performance > "u" ? Date : performance).now()
}
const La = new D
  , rT = new Qn
  , JH = new D
  , Da = new D;
class XH extends Rt {
    constructor() {
        super(),
        this.type = "AudioListener",
        this.context = $w.getContext(),
        this.gain = this.context.createGain(),
        this.gain.connect(this.context.destination),
        this.filter = null,
        this.timeDelta = 0,
        this._clock = new eS
    }
    getInput() {
        return this.gain
    }
    removeFilter() {
        return this.filter !== null && (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        this.filter = null),
        this
    }
    getFilter() {
        return this.filter
    }
    setFilter(e) {
        return this.filter !== null ? (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
        this.filter = e,
        this.gain.connect(this.filter),
        this.filter.connect(this.context.destination),
        this
    }
    getMasterVolume() {
        return this.gain.gain.value
    }
    setMasterVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
        this
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e);
        const t = this.context.listener
          , i = this.up;
        if (this.timeDelta = this._clock.getDelta(),
        this.matrixWorld.decompose(La, rT, JH),
        Da.set(0, 0, -1).applyQuaternion(rT),
        t.positionX) {
            const r = this.context.currentTime + this.timeDelta;
            t.positionX.linearRampToValueAtTime(La.x, r),
            t.positionY.linearRampToValueAtTime(La.y, r),
            t.positionZ.linearRampToValueAtTime(La.z, r),
            t.forwardX.linearRampToValueAtTime(Da.x, r),
            t.forwardY.linearRampToValueAtTime(Da.y, r),
            t.forwardZ.linearRampToValueAtTime(Da.z, r),
            t.upX.linearRampToValueAtTime(i.x, r),
            t.upY.linearRampToValueAtTime(i.y, r),
            t.upZ.linearRampToValueAtTime(i.z, r)
        } else
            t.setPosition(La.x, La.y, La.z),
            t.setOrientation(Da.x, Da.y, Da.z, i.x, i.y, i.z)
    }
}
class BI extends Rt {
    constructor(e) {
        super(),
        this.type = "Audio",
        this.listener = e,
        this.context = e.context,
        this.gain = this.context.createGain(),
        this.gain.connect(e.getInput()),
        this.autoplay = !1,
        this.buffer = null,
        this.detune = 0,
        this.loop = !1,
        this.loopStart = 0,
        this.loopEnd = 0,
        this.offset = 0,
        this.duration = void 0,
        this.playbackRate = 1,
        this.isPlaying = !1,
        this.hasPlaybackControl = !0,
        this.source = null,
        this.sourceType = "empty",
        this._startedAt = 0,
        this._progress = 0,
        this._connected = !1,
        this.filters = []
    }
    getOutput() {
        return this.gain
    }
    setNodeSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "audioNode",
        this.source = e,
        this.connect(),
        this
    }
    setMediaElementSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaNode",
        this.source = this.context.createMediaElementSource(e),
        this.connect(),
        this
    }
    setMediaStreamSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaStreamNode",
        this.source = this.context.createMediaStreamSource(e),
        this.connect(),
        this
    }
    setBuffer(e) {
        return this.buffer = e,
        this.sourceType = "buffer",
        this.autoplay && this.play(),
        this
    }
    play(e=0) {
        if (this.isPlaying === !0) {
            console.warn("THREE.Audio: Audio is already playing.");
            return
        }
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        this._startedAt = this.context.currentTime + e;
        const t = this.context.createBufferSource();
        return t.buffer = this.buffer,
        t.loop = this.loop,
        t.loopStart = this.loopStart,
        t.loopEnd = this.loopEnd,
        t.onended = this.onEnded.bind(this),
        t.start(this._startedAt, this._progress + this.offset, this.duration),
        this.isPlaying = !0,
        this.source = t,
        this.setDetune(this.detune),
        this.setPlaybackRate(this.playbackRate),
        this.connect()
    }
    pause() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
        this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        this.source.onended = null,
        this.isPlaying = !1),
        this
    }
    stop() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this._progress = 0,
        this.source.stop(),
        this.source.onended = null,
        this.isPlaying = !1,
        this
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
                this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput())
        } else
            this.source.connect(this.getOutput());
        return this._connected = !0,
        this
    }
    disconnect() {
        if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
                this.filters[e - 1].disconnect(this.filters[e]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput())
        } else
            this.source.disconnect(this.getOutput());
        return this._connected = !1,
        this
    }
    getFilters() {
        return this.filters
    }
    setFilters(e) {
        return e || (e = []),
        this._connected === !0 ? (this.disconnect(),
        this.filters = e.slice(),
        this.connect()) : this.filters = e.slice(),
        this
    }
    setDetune(e) {
        if (this.detune = e,
        this.source.detune !== void 0)
            return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
            this
    }
    getDetune() {
        return this.detune
    }
    getFilter() {
        return this.getFilters()[0]
    }
    setFilter(e) {
        return this.setFilters(e ? [e] : [])
    }
    setPlaybackRate(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.playbackRate = e,
        this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
        this
    }
    getPlaybackRate() {
        return this.playbackRate
    }
    onEnded() {
        this.isPlaying = !1
    }
    getLoop() {
        return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."),
        !1) : this.loop
    }
    setLoop(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.loop = e,
        this.isPlaying === !0 && (this.source.loop = this.loop),
        this
    }
    setLoopStart(e) {
        return this.loopStart = e,
        this
    }
    setLoopEnd(e) {
        return this.loopEnd = e,
        this
    }
    getVolume() {
        return this.gain.gain.value
    }
    setVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
        this
    }
}
const ka = new D
  , sT = new Qn
  , YH = new D
  , Fa = new D;
class KH extends BI {
    constructor(e) {
        super(e),
        this.panner = this.context.createPanner(),
        this.panner.panningModel = "HRTF",
        this.panner.connect(this.gain)
    }
    disconnect() {
        super.disconnect(),
        this.panner.disconnect(this.gain)
    }
    getOutput() {
        return this.panner
    }
    getRefDistance() {
        return this.panner.refDistance
    }
    setRefDistance(e) {
        return this.panner.refDistance = e,
        this
    }
    getRolloffFactor() {
        return this.panner.rolloffFactor
    }
    setRolloffFactor(e) {
        return this.panner.rolloffFactor = e,
        this
    }
    getDistanceModel() {
        return this.panner.distanceModel
    }
    setDistanceModel(e) {
        return this.panner.distanceModel = e,
        this
    }
    getMaxDistance() {
        return this.panner.maxDistance
    }
    setMaxDistance(e) {
        return this.panner.maxDistance = e,
        this
    }
    setDirectionalCone(e, t, i) {
        return this.panner.coneInnerAngle = e,
        this.panner.coneOuterAngle = t,
        this.panner.coneOuterGain = i,
        this
    }
    updateMatrixWorld(e) {
        if (super.updateMatrixWorld(e),
        this.hasPlaybackControl === !0 && this.isPlaying === !1)
            return;
        this.matrixWorld.decompose(ka, sT, YH),
        Fa.set(0, 0, 1).applyQuaternion(sT);
        const t = this.panner;
        if (t.positionX) {
            const i = this.context.currentTime + this.listener.timeDelta;
            t.positionX.linearRampToValueAtTime(ka.x, i),
            t.positionY.linearRampToValueAtTime(ka.y, i),
            t.positionZ.linearRampToValueAtTime(ka.z, i),
            t.orientationX.linearRampToValueAtTime(Fa.x, i),
            t.orientationY.linearRampToValueAtTime(Fa.y, i),
            t.orientationZ.linearRampToValueAtTime(Fa.z, i)
        } else
            t.setPosition(ka.x, ka.y, ka.z),
            t.setOrientation(Fa.x, Fa.y, Fa.z)
    }
}
class QH {
    constructor(e, t=2048) {
        this.analyser = e.context.createAnalyser(),
        this.analyser.fftSize = t,
        this.data = new Uint8Array(this.analyser.frequencyBinCount),
        e.getOutput().connect(this.analyser)
    }
    getFrequencyData() {
        return this.analyser.getByteFrequencyData(this.data),
        this.data
    }
    getAverageFrequency() {
        let e = 0;
        const t = this.getFrequencyData();
        for (let i = 0; i < t.length; i++)
            e += t[i];
        return e / t.length
    }
}
class RI {
    constructor(e, t, i) {
        this.binding = e,
        this.valueSize = i;
        let r, s, o;
        switch (t) {
        case "quaternion":
            r = this._slerp,
            s = this._slerpAdditive,
            o = this._setAdditiveIdentityQuaternion,
            this.buffer = new Float64Array(i * 6),
            this._workIndex = 5;
            break;
        case "string":
        case "bool":
            r = this._select,
            s = this._select,
            o = this._setAdditiveIdentityOther,
            this.buffer = new Array(i * 5);
            break;
        default:
            r = this._lerp,
            s = this._lerpAdditive,
            o = this._setAdditiveIdentityNumeric,
            this.buffer = new Float64Array(i * 5)
        }
        this._mixBufferRegion = r,
        this._mixBufferRegionAdditive = s,
        this._setIdentity = o,
        this._origIndex = 3,
        this._addIndex = 4,
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        this.useCount = 0,
        this.referenceCount = 0
    }
    accumulate(e, t) {
        const i = this.buffer
          , r = this.valueSize
          , s = e * r + r;
        let o = this.cumulativeWeight;
        if (o === 0) {
            for (let a = 0; a !== r; ++a)
                i[s + a] = i[a];
            o = t
        } else {
            o += t;
            const a = t / o;
            this._mixBufferRegion(i, s, 0, a, r)
        }
        this.cumulativeWeight = o
    }
    accumulateAdditive(e) {
        const t = this.buffer
          , i = this.valueSize
          , r = i * this._addIndex;
        this.cumulativeWeightAdditive === 0 && this._setIdentity(),
        this._mixBufferRegionAdditive(t, r, 0, e, i),
        this.cumulativeWeightAdditive += e
    }
    apply(e) {
        const t = this.valueSize
          , i = this.buffer
          , r = e * t + t
          , s = this.cumulativeWeight
          , o = this.cumulativeWeightAdditive
          , a = this.binding;
        if (this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        s < 1) {
            const l = t * this._origIndex;
            this._mixBufferRegion(i, r, l, 1 - s, t)
        }
        o > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t);
        for (let l = t, c = t + t; l !== c; ++l)
            if (i[l] !== i[l + t]) {
                a.setValue(i, r);
                break
            }
    }
    saveOriginalState() {
        const e = this.binding
          , t = this.buffer
          , i = this.valueSize
          , r = i * this._origIndex;
        e.getValue(t, r);
        for (let s = i, o = r; s !== o; ++s)
            t[s] = t[r + s % i];
        this._setIdentity(),
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0
    }
    restoreOriginalState() {
        const e = this.valueSize * 3;
        this.binding.setValue(this.buffer, e)
    }
    _setAdditiveIdentityNumeric() {
        const e = this._addIndex * this.valueSize
          , t = e + this.valueSize;
        for (let i = e; i < t; i++)
            this.buffer[i] = 0
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(),
        this.buffer[this._addIndex * this.valueSize + 3] = 1
    }
    _setAdditiveIdentityOther() {
        const e = this._origIndex * this.valueSize
          , t = this._addIndex * this.valueSize;
        for (let i = 0; i < this.valueSize; i++)
            this.buffer[t + i] = this.buffer[e + i]
    }
    _select(e, t, i, r, s) {
        if (r >= .5)
            for (let o = 0; o !== s; ++o)
                e[t + o] = e[i + o]
    }
    _slerp(e, t, i, r) {
        Qn.slerpFlat(e, t, e, t, e, i, r)
    }
    _slerpAdditive(e, t, i, r, s) {
        const o = this._workIndex * s;
        Qn.multiplyQuaternionsFlat(e, o, e, t, e, i),
        Qn.slerpFlat(e, t, e, t, e, o, r)
    }
    _lerp(e, t, i, r, s) {
        const o = 1 - r;
        for (let a = 0; a !== s; ++a) {
            const l = t + a;
            e[l] = e[l] * o + e[i + a] * r
        }
    }
    _lerpAdditive(e, t, i, r, s) {
        for (let o = 0; o !== s; ++o) {
            const a = t + o;
            e[a] = e[a] + e[i + o] * r
        }
    }
}
const tS = "\\[\\]\\.:\\/"
  , ZH = new RegExp("[" + tS + "]","g")
  , nS = "[^" + tS + "]"
  , qH = "[^" + tS.replace("\\.", "") + "]"
  , $H = /((?:WC+[\/:])*)/.source.replace("WC", nS)
  , e6 = /(WCOD+)?/.source.replace("WCOD", qH)
  , t6 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", nS)
  , n6 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", nS)
  , i6 = new RegExp("^" + $H + e6 + t6 + n6 + "$")
  , r6 = ["material", "materials", "bones", "map"];
class s6 {
    constructor(e, t, i) {
        const r = i || Bt.parseTrackName(t);
        this._targetGroup = e,
        this._bindings = e.subscribe_(t, r)
    }
    getValue(e, t) {
        this.bind();
        const i = this._targetGroup.nCachedObjects_
          , r = this._bindings[i];
        r !== void 0 && r.getValue(e, t)
    }
    setValue(e, t) {
        const i = this._bindings;
        for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r)
            i[r].setValue(e, t)
    }
    bind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
            e[t].bind()
    }
    unbind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
            e[t].unbind()
    }
}
class Bt {
    constructor(e, t, i) {
        this.path = t,
        this.parsedPath = i || Bt.parseTrackName(t),
        this.node = Bt.findNode(e, this.parsedPath.nodeName) || e,
        this.rootNode = e,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
    static create(e, t, i) {
        return e && e.isAnimationObjectGroup ? new Bt.Composite(e,t,i) : new Bt(e,t,i)
    }
    static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(ZH, "")
    }
    static parseTrackName(e) {
        const t = i6.exec(e);
        if (t === null)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const i = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6]
        }
          , r = i.nodeName && i.nodeName.lastIndexOf(".");
        if (r !== void 0 && r !== -1) {
            const s = i.nodeName.substring(r + 1);
            r6.indexOf(s) !== -1 && (i.nodeName = i.nodeName.substring(0, r),
            i.objectName = s)
        }
        if (i.propertyName === null || i.propertyName.length === 0)
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return i
    }
    static findNode(e, t) {
        if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
            return e;
        if (e.skeleton) {
            const i = e.skeleton.getBoneByName(t);
            if (i !== void 0)
                return i
        }
        if (e.children) {
            const i = function(s) {
                for (let o = 0; o < s.length; o++) {
                    const a = s[o];
                    if (a.name === t || a.uuid === t)
                        return a;
                    const l = i(a.children);
                    if (l)
                        return l
                }
                return null
            }
              , r = i(e.children);
            if (r)
                return r
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName]
    }
    _getValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r)
            e[t++] = i[r]
    }
    _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t)
    }
    _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t]
    }
    _setValue_direct_setNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r)
            i[r] = e[t++]
    }
    _setValue_array_setNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r)
            i[r] = e[t++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r)
            i[r] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t]
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t)
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(e, t) {
        this.bind(),
        this.getValue(e, t)
    }
    _setValue_unbound(e, t) {
        this.bind(),
        this.setValue(e, t)
    }
    bind() {
        let e = this.node;
        const t = this.parsedPath
          , i = t.objectName
          , r = t.propertyName;
        let s = t.propertyIndex;
        if (e || (e = Bt.findNode(this.rootNode, t.nodeName) || this.rootNode,
        this.node = e),
        this.getValue = this._getValue_unavailable,
        this.setValue = this._setValue_unavailable,
        !e) {
            console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            return
        }
        if (i) {
            let c = t.objectIndex;
            switch (i) {
            case "materials":
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.materials) {
                    console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    return
                }
                e = e.material.materials;
                break;
            case "bones":
                if (!e.skeleton) {
                    console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    return
                }
                e = e.skeleton.bones;
                for (let d = 0; d < e.length; d++)
                    if (e[d].name === c) {
                        c = d;
                        break
                    }
                break;
            case "map":
                if ("map"in e) {
                    e = e.map;
                    break
                }
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.map) {
                    console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                    return
                }
                e = e.material.map;
                break;
            default:
                if (e[i] === void 0) {
                    console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    return
                }
                e = e[i]
            }
            if (c !== void 0) {
                if (e[c] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                    return
                }
                e = e[c]
            }
        }
        const o = e[r];
        if (o === void 0) {
            const c = t.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + r + " but it wasn't found.", e);
            return
        }
        let a = this.Versioning.None;
        this.targetObject = e,
        e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
        let l = this.BindingType.Direct;
        if (s !== void 0) {
            if (r === "morphTargetInfluences") {
                if (!e.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if (!e.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return
                }
                e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s])
            }
            l = this.BindingType.ArrayElement,
            this.resolvedProperty = o,
            this.propertyIndex = s
        } else
            o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray,
            this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray,
            this.resolvedProperty = o) : this.propertyName = r;
        this.getValue = this.GetterByBindingType[l],
        this.setValue = this.SetterByBindingTypeAndVersioning[l][a]
    }
    unbind() {
        this.node = null,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
}
Bt.Composite = s6;
Bt.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
Bt.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
Bt.prototype.GetterByBindingType = [Bt.prototype._getValue_direct, Bt.prototype._getValue_array, Bt.prototype._getValue_arrayElement, Bt.prototype._getValue_toArray];
Bt.prototype.SetterByBindingTypeAndVersioning = [[Bt.prototype._setValue_direct, Bt.prototype._setValue_direct_setNeedsUpdate, Bt.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Bt.prototype._setValue_array, Bt.prototype._setValue_array_setNeedsUpdate, Bt.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Bt.prototype._setValue_arrayElement, Bt.prototype._setValue_arrayElement_setNeedsUpdate, Bt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Bt.prototype._setValue_fromArray, Bt.prototype._setValue_fromArray_setNeedsUpdate, Bt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
class o6 {
    constructor() {
        this.isAnimationObjectGroup = !0,
        this.uuid = Ji(),
        this._objects = Array.prototype.slice.call(arguments),
        this.nCachedObjects_ = 0;
        const e = {};
        this._indicesByUUID = e;
        for (let i = 0, r = arguments.length; i !== r; ++i)
            e[arguments[i].uuid] = i;
        this._paths = [],
        this._parsedPaths = [],
        this._bindings = [],
        this._bindingsIndicesByPath = {};
        const t = this;
        this.stats = {
            objects: {
                get total() {
                    return t._objects.length
                },
                get inUse() {
                    return this.total - t.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return t._bindings.length
            }
        }
    }
    add() {
        const e = this._objects
          , t = this._indicesByUUID
          , i = this._paths
          , r = this._parsedPaths
          , s = this._bindings
          , o = s.length;
        let a, l = e.length, c = this.nCachedObjects_;
        for (let d = 0, h = arguments.length; d !== h; ++d) {
            const p = arguments[d]
              , m = p.uuid;
            let y = t[m];
            if (y === void 0) {
                y = l++,
                t[m] = y,
                e.push(p);
                for (let v = 0, x = o; v !== x; ++v)
                    s[v].push(new Bt(p,i[v],r[v]))
            } else if (y < c) {
                a = e[y];
                const v = --c
                  , x = e[v];
                t[x.uuid] = y,
                e[y] = x,
                t[m] = v,
                e[v] = p;
                for (let _ = 0, A = o; _ !== A; ++_) {
                    const w = s[_]
                      , M = w[v];
                    let C = w[y];
                    w[y] = M,
                    C === void 0 && (C = new Bt(p,i[_],r[_])),
                    w[v] = C
                }
            } else
                e[y] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
        }
        this.nCachedObjects_ = c
    }
    remove() {
        const e = this._objects
          , t = this._indicesByUUID
          , i = this._bindings
          , r = i.length;
        let s = this.nCachedObjects_;
        for (let o = 0, a = arguments.length; o !== a; ++o) {
            const l = arguments[o]
              , c = l.uuid
              , d = t[c];
            if (d !== void 0 && d >= s) {
                const h = s++
                  , p = e[h];
                t[p.uuid] = d,
                e[d] = p,
                t[c] = h,
                e[h] = l;
                for (let m = 0, y = r; m !== y; ++m) {
                    const v = i[m]
                      , x = v[h]
                      , _ = v[d];
                    v[d] = x,
                    v[h] = _
                }
            }
        }
        this.nCachedObjects_ = s
    }
    uncache() {
        const e = this._objects
          , t = this._indicesByUUID
          , i = this._bindings
          , r = i.length;
        let s = this.nCachedObjects_
          , o = e.length;
        for (let a = 0, l = arguments.length; a !== l; ++a) {
            const c = arguments[a]
              , d = c.uuid
              , h = t[d];
            if (h !== void 0)
                if (delete t[d],
                h < s) {
                    const p = --s
                      , m = e[p]
                      , y = --o
                      , v = e[y];
                    t[m.uuid] = h,
                    e[h] = m,
                    t[v.uuid] = p,
                    e[p] = v,
                    e.pop();
                    for (let x = 0, _ = r; x !== _; ++x) {
                        const A = i[x]
                          , w = A[p]
                          , M = A[y];
                        A[h] = w,
                        A[p] = M,
                        A.pop()
                    }
                } else {
                    const p = --o
                      , m = e[p];
                    p > 0 && (t[m.uuid] = h),
                    e[h] = m,
                    e.pop();
                    for (let y = 0, v = r; y !== v; ++y) {
                        const x = i[y];
                        x[h] = x[p],
                        x.pop()
                    }
                }
        }
        this.nCachedObjects_ = s
    }
    subscribe_(e, t) {
        const i = this._bindingsIndicesByPath;
        let r = i[e];
        const s = this._bindings;
        if (r !== void 0)
            return s[r];
        const o = this._paths
          , a = this._parsedPaths
          , l = this._objects
          , c = l.length
          , d = this.nCachedObjects_
          , h = new Array(c);
        r = s.length,
        i[e] = r,
        o.push(e),
        a.push(t),
        s.push(h);
        for (let p = d, m = l.length; p !== m; ++p) {
            const y = l[p];
            h[p] = new Bt(y,e,t)
        }
        return h
    }
    unsubscribe_(e) {
        const t = this._bindingsIndicesByPath
          , i = t[e];
        if (i !== void 0) {
            const r = this._paths
              , s = this._parsedPaths
              , o = this._bindings
              , a = o.length - 1
              , l = o[a]
              , c = e[a];
            t[c] = i,
            o[i] = l,
            o.pop(),
            s[i] = s[a],
            s.pop(),
            r[i] = r[a],
            r.pop()
        }
    }
}
class a6 {
    constructor(e, t, i=null, r=t.blendMode) {
        this._mixer = e,
        this._clip = t,
        this._localRoot = i,
        this.blendMode = r;
        const s = t.tracks
          , o = s.length
          , a = new Array(o)
          , l = {
            endingStart: el,
            endingEnd: el
        };
        for (let c = 0; c !== o; ++c) {
            const d = s[c].createInterpolant(null);
            a[c] = d,
            d.settings = l
        }
        this._interpolantSettings = l,
        this._interpolants = a,
        this._propertyBindings = new Array(o),
        this._cacheIndex = null,
        this._byClipCacheIndex = null,
        this._timeScaleInterpolant = null,
        this._weightInterpolant = null,
        this.loop = BR,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this.timeScale = 1,
        this._effectiveTimeScale = 1,
        this.weight = 1,
        this._effectiveWeight = 1,
        this.repetitions = 1 / 0,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtStart = !0,
        this.zeroSlopeAtEnd = !0
    }
    play() {
        return this._mixer._activateAction(this),
        this
    }
    stop() {
        return this._mixer._deactivateAction(this),
        this.reset()
    }
    reset() {
        return this.paused = !1,
        this.enabled = !0,
        this.time = 0,
        this._loopCount = -1,
        this._startTime = null,
        this.stopFading().stopWarping()
    }
    isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
    }
    isScheduled() {
        return this._mixer._isActiveAction(this)
    }
    startAt(e) {
        return this._startTime = e,
        this
    }
    setLoop(e, t) {
        return this.loop = e,
        this.repetitions = t,
        this
    }
    setEffectiveWeight(e) {
        return this.weight = e,
        this._effectiveWeight = this.enabled ? e : 0,
        this.stopFading()
    }
    getEffectiveWeight() {
        return this._effectiveWeight
    }
    fadeIn(e) {
        return this._scheduleFading(e, 0, 1)
    }
    fadeOut(e) {
        return this._scheduleFading(e, 1, 0)
    }
    crossFadeFrom(e, t, i) {
        if (e.fadeOut(t),
        this.fadeIn(t),
        i) {
            const r = this._clip.duration
              , s = e._clip.duration
              , o = s / r
              , a = r / s;
            e.warp(1, o, t),
            this.warp(a, 1, t)
        }
        return this
    }
    crossFadeTo(e, t, i) {
        return e.crossFadeFrom(this, t, i)
    }
    stopFading() {
        const e = this._weightInterpolant;
        return e !== null && (this._weightInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    setEffectiveTimeScale(e) {
        return this.timeScale = e,
        this._effectiveTimeScale = this.paused ? 0 : e,
        this.stopWarping()
    }
    getEffectiveTimeScale() {
        return this._effectiveTimeScale
    }
    setDuration(e) {
        return this.timeScale = this._clip.duration / e,
        this.stopWarping()
    }
    syncWith(e) {
        return this.time = e.time,
        this.timeScale = e.timeScale,
        this.stopWarping()
    }
    halt(e) {
        return this.warp(this._effectiveTimeScale, 0, e)
    }
    warp(e, t, i) {
        const r = this._mixer
          , s = r.time
          , o = this.timeScale;
        let a = this._timeScaleInterpolant;
        a === null && (a = r._lendControlInterpolant(),
        this._timeScaleInterpolant = a);
        const l = a.parameterPositions
          , c = a.sampleValues;
        return l[0] = s,
        l[1] = s + i,
        c[0] = e / o,
        c[1] = t / o,
        this
    }
    stopWarping() {
        const e = this._timeScaleInterpolant;
        return e !== null && (this._timeScaleInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    getMixer() {
        return this._mixer
    }
    getClip() {
        return this._clip
    }
    getRoot() {
        return this._localRoot || this._mixer._root
    }
    _update(e, t, i, r) {
        if (!this.enabled) {
            this._updateWeight(e);
            return
        }
        const s = this._startTime;
        if (s !== null) {
            const l = (e - s) * i;
            l < 0 || i === 0 ? t = 0 : (this._startTime = null,
            t = i * l)
        }
        t *= this._updateTimeScale(e);
        const o = this._updateTime(t)
          , a = this._updateWeight(e);
        if (a > 0) {
            const l = this._interpolants
              , c = this._propertyBindings;
            switch (this.blendMode) {
            case yw:
                for (let d = 0, h = l.length; d !== h; ++d)
                    l[d].evaluate(o),
                    c[d].accumulateAdditive(a);
                break;
            case C0:
            default:
                for (let d = 0, h = l.length; d !== h; ++d)
                    l[d].evaluate(o),
                    c[d].accumulate(r, a)
            }
        }
    }
    _updateWeight(e) {
        let t = 0;
        if (this.enabled) {
            t = this.weight;
            const i = this._weightInterpolant;
            if (i !== null) {
                const r = i.evaluate(e)[0];
                t *= r,
                e > i.parameterPositions[1] && (this.stopFading(),
                r === 0 && (this.enabled = !1))
            }
        }
        return this._effectiveWeight = t,
        t
    }
    _updateTimeScale(e) {
        let t = 0;
        if (!this.paused) {
            t = this.timeScale;
            const i = this._timeScaleInterpolant;
            if (i !== null) {
                const r = i.evaluate(e)[0];
                t *= r,
                e > i.parameterPositions[1] && (this.stopWarping(),
                t === 0 ? this.paused = !0 : this.timeScale = t)
            }
        }
        return this._effectiveTimeScale = t,
        t
    }
    _updateTime(e) {
        const t = this._clip.duration
          , i = this.loop;
        let r = this.time + e
          , s = this._loopCount;
        const o = i === RR;
        if (e === 0)
            return s === -1 ? r : o && (s & 1) === 1 ? t - r : r;
        if (i === PR) {
            s === -1 && (this._loopCount = 0,
            this._setEndings(!0, !0, !1));
            e: {
                if (r >= t)
                    r = t;
                else if (r < 0)
                    r = 0;
                else {
                    this.time = r;
                    break e
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                this.time = r,
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e < 0 ? -1 : 1
                })
            }
        } else {
            if (s === -1 && (e >= 0 ? (s = 0,
            this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)),
            r >= t || r < 0) {
                const a = Math.floor(r / t);
                r -= t * a,
                s += Math.abs(a);
                const l = this.repetitions - s;
                if (l <= 0)
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    r = e > 0 ? t : 0,
                    this.time = r,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e > 0 ? 1 : -1
                    });
                else {
                    if (l === 1) {
                        const c = e < 0;
                        this._setEndings(c, !c, o)
                    } else
                        this._setEndings(!1, !1, o);
                    this._loopCount = s,
                    this.time = r,
                    this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: a
                    })
                }
            } else
                this.time = r;
            if (o && (s & 1) === 1)
                return t - r
        }
        return r
    }
    _setEndings(e, t, i) {
        const r = this._interpolantSettings;
        i ? (r.endingStart = tl,
        r.endingEnd = tl) : (e ? r.endingStart = this.zeroSlopeAtStart ? tl : el : r.endingStart = Md,
        t ? r.endingEnd = this.zeroSlopeAtEnd ? tl : el : r.endingEnd = Md)
    }
    _scheduleFading(e, t, i) {
        const r = this._mixer
          , s = r.time;
        let o = this._weightInterpolant;
        o === null && (o = r._lendControlInterpolant(),
        this._weightInterpolant = o);
        const a = o.parameterPositions
          , l = o.sampleValues;
        return a[0] = s,
        l[0] = t,
        a[1] = s + e,
        l[1] = i,
        this
    }
}
const l6 = new Float32Array(1);
class u6 extends gs {
    constructor(e) {
        super(),
        this._root = e,
        this._initMemoryManager(),
        this._accuIndex = 0,
        this.time = 0,
        this.timeScale = 1
    }
    _bindAction(e, t) {
        const i = e._localRoot || this._root
          , r = e._clip.tracks
          , s = r.length
          , o = e._propertyBindings
          , a = e._interpolants
          , l = i.uuid
          , c = this._bindingsByRootAndName;
        let d = c[l];
        d === void 0 && (d = {},
        c[l] = d);
        for (let h = 0; h !== s; ++h) {
            const p = r[h]
              , m = p.name;
            let y = d[m];
            if (y !== void 0)
                ++y.referenceCount,
                o[h] = y;
            else {
                if (y = o[h],
                y !== void 0) {
                    y._cacheIndex === null && (++y.referenceCount,
                    this._addInactiveBinding(y, l, m));
                    continue
                }
                const v = t && t._propertyBindings[h].binding.parsedPath;
                y = new RI(Bt.create(i, m, v),p.ValueTypeName,p.getValueSize()),
                ++y.referenceCount,
                this._addInactiveBinding(y, l, m),
                o[h] = y
            }
            a[h].resultBuffer = y.buffer
        }
    }
    _activateAction(e) {
        if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
                const i = (e._localRoot || this._root).uuid
                  , r = e._clip.uuid
                  , s = this._actionsByClip[r];
                this._bindAction(e, s && s.knownActions[0]),
                this._addInactiveAction(e, r, i)
            }
            const t = e._propertyBindings;
            for (let i = 0, r = t.length; i !== r; ++i) {
                const s = t[i];
                s.useCount++ === 0 && (this._lendBinding(s),
                s.saveOriginalState())
            }
            this._lendAction(e)
        }
    }
    _deactivateAction(e) {
        if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let i = 0, r = t.length; i !== r; ++i) {
                const s = t[i];
                --s.useCount === 0 && (s.restoreOriginalState(),
                this._takeBackBinding(s))
            }
            this._takeBackAction(e)
        }
    }
    _initMemoryManager() {
        this._actions = [],
        this._nActiveActions = 0,
        this._actionsByClip = {},
        this._bindings = [],
        this._nActiveBindings = 0,
        this._bindingsByRootAndName = {},
        this._controlInterpolants = [],
        this._nActiveControlInterpolants = 0;
        const e = this;
        this.stats = {
            actions: {
                get total() {
                    return e._actions.length
                },
                get inUse() {
                    return e._nActiveActions
                }
            },
            bindings: {
                get total() {
                    return e._bindings.length
                },
                get inUse() {
                    return e._nActiveBindings
                }
            },
            controlInterpolants: {
                get total() {
                    return e._controlInterpolants.length
                },
                get inUse() {
                    return e._nActiveControlInterpolants
                }
            }
        }
    }
    _isActiveAction(e) {
        const t = e._cacheIndex;
        return t !== null && t < this._nActiveActions
    }
    _addInactiveAction(e, t, i) {
        const r = this._actions
          , s = this._actionsByClip;
        let o = s[t];
        if (o === void 0)
            o = {
                knownActions: [e],
                actionByRoot: {}
            },
            e._byClipCacheIndex = 0,
            s[t] = o;
        else {
            const a = o.knownActions;
            e._byClipCacheIndex = a.length,
            a.push(e)
        }
        e._cacheIndex = r.length,
        r.push(e),
        o.actionByRoot[i] = e
    }
    _removeInactiveAction(e) {
        const t = this._actions
          , i = t[t.length - 1]
          , r = e._cacheIndex;
        i._cacheIndex = r,
        t[r] = i,
        t.pop(),
        e._cacheIndex = null;
        const s = e._clip.uuid
          , o = this._actionsByClip
          , a = o[s]
          , l = a.knownActions
          , c = l[l.length - 1]
          , d = e._byClipCacheIndex;
        c._byClipCacheIndex = d,
        l[d] = c,
        l.pop(),
        e._byClipCacheIndex = null;
        const h = a.actionByRoot
          , p = (e._localRoot || this._root).uuid;
        delete h[p],
        l.length === 0 && delete o[s],
        this._removeInactiveBindingsForAction(e)
    }
    _removeInactiveBindingsForAction(e) {
        const t = e._propertyBindings;
        for (let i = 0, r = t.length; i !== r; ++i) {
            const s = t[i];
            --s.referenceCount === 0 && this._removeInactiveBinding(s)
        }
    }
    _lendAction(e) {
        const t = this._actions
          , i = e._cacheIndex
          , r = this._nActiveActions++
          , s = t[r];
        e._cacheIndex = r,
        t[r] = e,
        s._cacheIndex = i,
        t[i] = s
    }
    _takeBackAction(e) {
        const t = this._actions
          , i = e._cacheIndex
          , r = --this._nActiveActions
          , s = t[r];
        e._cacheIndex = r,
        t[r] = e,
        s._cacheIndex = i,
        t[i] = s
    }
    _addInactiveBinding(e, t, i) {
        const r = this._bindingsByRootAndName
          , s = this._bindings;
        let o = r[t];
        o === void 0 && (o = {},
        r[t] = o),
        o[i] = e,
        e._cacheIndex = s.length,
        s.push(e)
    }
    _removeInactiveBinding(e) {
        const t = this._bindings
          , i = e.binding
          , r = i.rootNode.uuid
          , s = i.path
          , o = this._bindingsByRootAndName
          , a = o[r]
          , l = t[t.length - 1]
          , c = e._cacheIndex;
        l._cacheIndex = c,
        t[c] = l,
        t.pop(),
        delete a[s],
        Object.keys(a).length === 0 && delete o[r]
    }
    _lendBinding(e) {
        const t = this._bindings
          , i = e._cacheIndex
          , r = this._nActiveBindings++
          , s = t[r];
        e._cacheIndex = r,
        t[r] = e,
        s._cacheIndex = i,
        t[i] = s
    }
    _takeBackBinding(e) {
        const t = this._bindings
          , i = e._cacheIndex
          , r = --this._nActiveBindings
          , s = t[r];
        e._cacheIndex = r,
        t[r] = e,
        s._cacheIndex = i,
        t[i] = s
    }
    _lendControlInterpolant() {
        const e = this._controlInterpolants
          , t = this._nActiveControlInterpolants++;
        let i = e[t];
        return i === void 0 && (i = new Jw(new Float32Array(2),new Float32Array(2),1,l6),
        i.__cacheIndex = t,
        e[t] = i),
        i
    }
    _takeBackControlInterpolant(e) {
        const t = this._controlInterpolants
          , i = e.__cacheIndex
          , r = --this._nActiveControlInterpolants
          , s = t[r];
        e.__cacheIndex = r,
        t[r] = e,
        s.__cacheIndex = i,
        t[i] = s
    }
    clipAction(e, t, i) {
        const r = t || this._root
          , s = r.uuid;
        let o = typeof e == "string" ? cc.findByName(r, e) : e;
        const a = o !== null ? o.uuid : e
          , l = this._actionsByClip[a];
        let c = null;
        if (i === void 0 && (o !== null ? i = o.blendMode : i = C0),
        l !== void 0) {
            const h = l.actionByRoot[s];
            if (h !== void 0 && h.blendMode === i)
                return h;
            c = l.knownActions[0],
            o === null && (o = c._clip)
        }
        if (o === null)
            return null;
        const d = new a6(this,o,t,i);
        return this._bindAction(d, c),
        this._addInactiveAction(d, a, s),
        d
    }
    existingAction(e, t) {
        const i = t || this._root
          , r = i.uuid
          , s = typeof e == "string" ? cc.findByName(i, e) : e
          , o = s ? s.uuid : e
          , a = this._actionsByClip[o];
        return a !== void 0 && a.actionByRoot[r] || null
    }
    stopAllAction() {
        const e = this._actions
          , t = this._nActiveActions;
        for (let i = t - 1; i >= 0; --i)
            e[i].stop();
        return this
    }
    update(e) {
        e *= this.timeScale;
        const t = this._actions
          , i = this._nActiveActions
          , r = this.time += e
          , s = Math.sign(e)
          , o = this._accuIndex ^= 1;
        for (let c = 0; c !== i; ++c)
            t[c]._update(r, e, s, o);
        const a = this._bindings
          , l = this._nActiveBindings;
        for (let c = 0; c !== l; ++c)
            a[c].apply(o);
        return this
    }
    setTime(e) {
        this.time = 0;
        for (let t = 0; t < this._actions.length; t++)
            this._actions[t].time = 0;
        return this.update(e)
    }
    getRoot() {
        return this._root
    }
    uncacheClip(e) {
        const t = this._actions
          , i = e.uuid
          , r = this._actionsByClip
          , s = r[i];
        if (s !== void 0) {
            const o = s.knownActions;
            for (let a = 0, l = o.length; a !== l; ++a) {
                const c = o[a];
                this._deactivateAction(c);
                const d = c._cacheIndex
                  , h = t[t.length - 1];
                c._cacheIndex = null,
                c._byClipCacheIndex = null,
                h._cacheIndex = d,
                t[d] = h,
                t.pop(),
                this._removeInactiveBindingsForAction(c)
            }
            delete r[i]
        }
    }
    uncacheRoot(e) {
        const t = e.uuid
          , i = this._actionsByClip;
        for (const o in i) {
            const a = i[o].actionByRoot
              , l = a[t];
            l !== void 0 && (this._deactivateAction(l),
            this._removeInactiveAction(l))
        }
        const r = this._bindingsByRootAndName
          , s = r[t];
        if (s !== void 0)
            for (const o in s) {
                const a = s[o];
                a.restoreOriginalState(),
                this._removeInactiveBinding(a)
            }
    }
    uncacheAction(e, t) {
        const i = this.existingAction(e, t);
        i !== null && (this._deactivateAction(i),
        this._removeInactiveAction(i))
    }
}
class iS {
    constructor(e) {
        this.value = e
    }
    clone() {
        return new iS(this.value.clone === void 0 ? this.value : this.value.clone())
    }
}
let c6 = 0;
class f6 extends gs {
    constructor() {
        super(),
        this.isUniformsGroup = !0,
        Object.defineProperty(this, "id", {
            value: c6++
        }),
        this.name = "",
        this.usage = bd,
        this.uniforms = []
    }
    add(e) {
        return this.uniforms.push(e),
        this
    }
    remove(e) {
        const t = this.uniforms.indexOf(e);
        return t !== -1 && this.uniforms.splice(t, 1),
        this
    }
    setName(e) {
        return this.name = e,
        this
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    dispose() {
        return this.dispatchEvent({
            type: "dispose"
        }),
        this
    }
    copy(e) {
        this.name = e.name,
        this.usage = e.usage;
        const t = e.uniforms;
        this.uniforms.length = 0;
        for (let i = 0, r = t.length; i < r; i++)
            this.uniforms.push(t[i].clone());
        return this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class d6 extends nh {
    constructor(e, t, i=1) {
        super(e, t),
        this.isInstancedInterleavedBuffer = !0,
        this.meshPerAttribute = i
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    clone(e) {
        const t = super.clone(e);
        return t.meshPerAttribute = this.meshPerAttribute,
        t
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.isInstancedInterleavedBuffer = !0,
        t.meshPerAttribute = this.meshPerAttribute,
        t
    }
}
class h6 {
    constructor(e, t, i, r, s) {
        this.isGLBufferAttribute = !0,
        this.name = "",
        this.buffer = e,
        this.type = t,
        this.itemSize = i,
        this.elementSize = r,
        this.count = s,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setBuffer(e) {
        return this.buffer = e,
        this
    }
    setType(e, t) {
        return this.type = e,
        this.elementSize = t,
        this
    }
    setItemSize(e) {
        return this.itemSize = e,
        this
    }
    setCount(e) {
        return this.count = e,
        this
    }
}
class II {
    constructor(e, t, i=0, r=1 / 0) {
        this.ray = new $d(e,t),
        this.near = i,
        this.far = r,
        this.camera = null,
        this.layers = new pl,
        this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }
    }
    set(e, t) {
        this.ray.set(e, t)
    }
    setFromCamera(e, t) {
        t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
        this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
    }
    intersectObject(e, t=!0, i=[]) {
        return S_(e, this, i, t),
        i.sort(oT),
        i
    }
    intersectObjects(e, t=!0, i=[]) {
        for (let r = 0, s = e.length; r < s; r++)
            S_(e[r], this, i, t);
        return i.sort(oT),
        i
    }
}
function oT(n, e) {
    return n.distance - e.distance
}
function S_(n, e, t, i) {
    if (n.layers.test(e.layers) && n.raycast(e, t),
    i === !0) {
        const r = n.children;
        for (let s = 0, o = r.length; s < o; s++)
            S_(r[s], e, t, !0)
    }
}
class M_ {
    constructor(e=1, t=0, i=0) {
        return this.radius = e,
        this.phi = t,
        this.theta = i,
        this
    }
    set(e, t, i) {
        return this.radius = e,
        this.phi = t,
        this.theta = i,
        this
    }
    copy(e) {
        return this.radius = e.radius,
        this.phi = e.phi,
        this.theta = e.theta,
        this
    }
    makeSafe() {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
        this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, i) {
        return this.radius = Math.sqrt(e * e + t * t + i * i),
        this.radius === 0 ? (this.theta = 0,
        this.phi = 0) : (this.theta = Math.atan2(e, i),
        this.phi = Math.acos(wn(t / this.radius, -1, 1))),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class p6 {
    constructor(e=1, t=0, i=0) {
        return this.radius = e,
        this.theta = t,
        this.y = i,
        this
    }
    set(e, t, i) {
        return this.radius = e,
        this.theta = t,
        this.y = i,
        this
    }
    copy(e) {
        return this.radius = e.radius,
        this.theta = e.theta,
        this.y = e.y,
        this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, i) {
        return this.radius = Math.sqrt(e * e + i * i),
        this.theta = Math.atan2(e, i),
        this.y = t,
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const aT = new me;
class m6 {
    constructor(e=new me(1 / 0,1 / 0), t=new me(-1 / 0,-1 / 0)) {
        this.isBox2 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const i = aT.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(i),
        this.max.copy(e).add(i),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = 1 / 0,
        this.max.x = this.max.y = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return aT.copy(e).clamp(this.min, this.max).sub(e).length()
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const lT = new D
  , xm = new D;
class g6 {
    constructor(e=new D, t=new D) {
        this.start = e,
        this.end = t
    }
    set(e, t) {
        return this.start.copy(e),
        this.end.copy(t),
        this
    }
    copy(e) {
        return this.start.copy(e.start),
        this.end.copy(e.end),
        this
    }
    getCenter(e) {
        return e.addVectors(this.start, this.end).multiplyScalar(.5)
    }
    delta(e) {
        return e.subVectors(this.end, this.start)
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end)
    }
    distance() {
        return this.start.distanceTo(this.end)
    }
    at(e, t) {
        return this.delta(t).multiplyScalar(e).add(this.start)
    }
    closestPointToPointParameter(e, t) {
        lT.subVectors(e, this.start),
        xm.subVectors(this.end, this.start);
        const i = xm.dot(xm);
        let s = xm.dot(lT) / i;
        return t && (s = wn(s, 0, 1)),
        s
    }
    closestPointToPoint(e, t, i) {
        const r = this.closestPointToPointParameter(e, t);
        return this.delta(i).multiplyScalar(r).add(this.start)
    }
    applyMatrix4(e) {
        return this.start.applyMatrix4(e),
        this.end.applyMatrix4(e),
        this
    }
    equals(e) {
        return e.start.equals(this.start) && e.end.equals(this.end)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const uT = new D;
class v6 extends Rt {
    constructor(e, t) {
        super(),
        this.light = e,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = t,
        this.type = "SpotLightHelper";
        const i = new ft
          , r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (let o = 0, a = 1, l = 32; o < l; o++,
        a++) {
            const c = o / l * Math.PI * 2
              , d = a / l * Math.PI * 2;
            r.push(Math.cos(c), Math.sin(c), 1, Math.cos(d), Math.sin(d), 1)
        }
        i.setAttribute("position", new je(r,3));
        const s = new li({
            fog: !1,
            toneMapped: !1
        });
        this.cone = new Jr(i,s),
        this.add(this.cone),
        this.update()
    }
    dispose() {
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.light.target.updateWorldMatrix(!0, !1);
        const e = this.light.distance ? this.light.distance : 1e3
          , t = e * Math.tan(this.light.angle);
        this.cone.scale.set(t, t, e),
        uT.setFromMatrixPosition(this.light.target.matrixWorld),
        this.cone.lookAt(uT),
        this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    }
}
const So = new D
  , _m = new ot
  , hx = new ot;
class y6 extends Jr {
    constructor(e) {
        const t = LI(e)
          , i = new ft
          , r = []
          , s = []
          , o = new Ie(0,0,1)
          , a = new Ie(0,1,0);
        for (let c = 0; c < t.length; c++) {
            const d = t[c];
            d.parent && d.parent.isBone && (r.push(0, 0, 0),
            r.push(0, 0, 0),
            s.push(o.r, o.g, o.b),
            s.push(a.r, a.g, a.b))
        }
        i.setAttribute("position", new je(r,3)),
        i.setAttribute("color", new je(s,3));
        const l = new li({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0
        });
        super(i, l),
        this.isSkeletonHelper = !0,
        this.type = "SkeletonHelper",
        this.root = e,
        this.bones = t,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1
    }
    updateMatrixWorld(e) {
        const t = this.bones
          , i = this.geometry
          , r = i.getAttribute("position");
        hx.copy(this.root.matrixWorld).invert();
        for (let s = 0, o = 0; s < t.length; s++) {
            const a = t[s];
            a.parent && a.parent.isBone && (_m.multiplyMatrices(hx, a.matrixWorld),
            So.setFromMatrixPosition(_m),
            r.setXYZ(o, So.x, So.y, So.z),
            _m.multiplyMatrices(hx, a.parent.matrixWorld),
            So.setFromMatrixPosition(_m),
            r.setXYZ(o + 1, So.x, So.y, So.z),
            o += 2)
        }
        i.getAttribute("position").needsUpdate = !0,
        super.updateMatrixWorld(e)
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
function LI(n) {
    const e = [];
    n.isBone === !0 && e.push(n);
    for (let t = 0; t < n.children.length; t++)
        e.push.apply(e, LI(n.children[t]));
    return e
}
class x6 extends Ln {
    constructor(e, t, i) {
        const r = new bc(t,4,2)
          , s = new Wi({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        });
        super(r, s),
        this.light = e,
        this.color = i,
        this.type = "PointLightHelper",
        this.matrix = this.light.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.update()
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }
}
const _6 = new D
  , cT = new Ie
  , fT = new Ie;
class A6 extends Rt {
    constructor(e, t, i) {
        super(),
        this.light = e,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = i,
        this.type = "HemisphereLightHelper";
        const r = new Mc(t);
        r.rotateY(Math.PI * .5),
        this.material = new Wi({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        }),
        this.color === void 0 && (this.material.vertexColors = !0);
        const s = r.getAttribute("position")
          , o = new Float32Array(s.count * 3);
        r.setAttribute("color", new Nt(o,3)),
        this.add(new Ln(r,this.material)),
        this.update()
    }
    dispose() {
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    update() {
        const e = this.children[0];
        if (this.color !== void 0)
            this.material.color.set(this.color);
        else {
            const t = e.geometry.getAttribute("color");
            cT.copy(this.light.color),
            fT.copy(this.light.groundColor);
            for (let i = 0, r = t.count; i < r; i++) {
                const s = i < r / 2 ? cT : fT;
                t.setXYZ(i, s.r, s.g, s.b)
            }
            t.needsUpdate = !0
        }
        this.light.updateWorldMatrix(!0, !1),
        e.lookAt(_6.setFromMatrixPosition(this.light.matrixWorld).negate())
    }
}
class w6 extends Jr {
    constructor(e=10, t=10, i=4473924, r=8947848) {
        i = new Ie(i),
        r = new Ie(r);
        const s = t / 2
          , o = e / t
          , a = e / 2
          , l = []
          , c = [];
        for (let p = 0, m = 0, y = -a; p <= t; p++,
        y += o) {
            l.push(-a, 0, y, a, 0, y),
            l.push(y, 0, -a, y, 0, a);
            const v = p === s ? i : r;
            v.toArray(c, m),
            m += 3,
            v.toArray(c, m),
            m += 3,
            v.toArray(c, m),
            m += 3,
            v.toArray(c, m),
            m += 3
        }
        const d = new ft;
        d.setAttribute("position", new je(l,3)),
        d.setAttribute("color", new je(c,3));
        const h = new li({
            vertexColors: !0,
            toneMapped: !1
        });
        super(d, h),
        this.type = "GridHelper"
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class S6 extends Jr {
    constructor(e=10, t=16, i=8, r=64, s=4473924, o=8947848) {
        s = new Ie(s),
        o = new Ie(o);
        const a = []
          , l = [];
        if (t > 1)
            for (let h = 0; h < t; h++) {
                const p = h / t * (Math.PI * 2)
                  , m = Math.sin(p) * e
                  , y = Math.cos(p) * e;
                a.push(0, 0, 0),
                a.push(m, 0, y);
                const v = h & 1 ? s : o;
                l.push(v.r, v.g, v.b),
                l.push(v.r, v.g, v.b)
            }
        for (let h = 0; h < i; h++) {
            const p = h & 1 ? s : o
              , m = e - e / i * h;
            for (let y = 0; y < r; y++) {
                let v = y / r * (Math.PI * 2)
                  , x = Math.sin(v) * m
                  , _ = Math.cos(v) * m;
                a.push(x, 0, _),
                l.push(p.r, p.g, p.b),
                v = (y + 1) / r * (Math.PI * 2),
                x = Math.sin(v) * m,
                _ = Math.cos(v) * m,
                a.push(x, 0, _),
                l.push(p.r, p.g, p.b)
            }
        }
        const c = new ft;
        c.setAttribute("position", new je(a,3)),
        c.setAttribute("color", new je(l,3));
        const d = new li({
            vertexColors: !0,
            toneMapped: !1
        });
        super(c, d),
        this.type = "PolarGridHelper"
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
const dT = new D
  , Am = new D
  , hT = new D;
class M6 extends Rt {
    constructor(e, t, i) {
        super(),
        this.light = e,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = i,
        this.type = "DirectionalLightHelper",
        t === void 0 && (t = 1);
        let r = new ft;
        r.setAttribute("position", new je([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0],3));
        const s = new li({
            fog: !1,
            toneMapped: !1
        });
        this.lightPlane = new eo(r,s),
        this.add(this.lightPlane),
        r = new ft,
        r.setAttribute("position", new je([0, 0, 0, 0, 0, 1],3)),
        this.targetLine = new eo(r,s),
        this.add(this.targetLine),
        this.update()
    }
    dispose() {
        this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.light.target.updateWorldMatrix(!0, !1),
        dT.setFromMatrixPosition(this.light.matrixWorld),
        Am.setFromMatrixPosition(this.light.target.matrixWorld),
        hT.subVectors(Am, dT),
        this.lightPlane.lookAt(Am),
        this.color !== void 0 ? (this.lightPlane.material.color.set(this.color),
        this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
        this.targetLine.material.color.copy(this.light.color)),
        this.targetLine.lookAt(Am),
        this.targetLine.scale.z = hT.length()
    }
}
const wm = new D
  , pn = new eh;
class b6 extends Jr {
    constructor(e) {
        const t = new ft
          , i = new li({
            color: 16777215,
            vertexColors: !0,
            toneMapped: !1
        })
          , r = []
          , s = []
          , o = {};
        a("n1", "n2"),
        a("n2", "n4"),
        a("n4", "n3"),
        a("n3", "n1"),
        a("f1", "f2"),
        a("f2", "f4"),
        a("f4", "f3"),
        a("f3", "f1"),
        a("n1", "f1"),
        a("n2", "f2"),
        a("n3", "f3"),
        a("n4", "f4"),
        a("p", "n1"),
        a("p", "n2"),
        a("p", "n3"),
        a("p", "n4"),
        a("u1", "u2"),
        a("u2", "u3"),
        a("u3", "u1"),
        a("c", "t"),
        a("p", "c"),
        a("cn1", "cn2"),
        a("cn3", "cn4"),
        a("cf1", "cf2"),
        a("cf3", "cf4");
        function a(y, v) {
            l(y),
            l(v)
        }
        function l(y) {
            r.push(0, 0, 0),
            s.push(0, 0, 0),
            o[y] === void 0 && (o[y] = []),
            o[y].push(r.length / 3 - 1)
        }
        t.setAttribute("position", new je(r,3)),
        t.setAttribute("color", new je(s,3)),
        super(t, i),
        this.type = "CameraHelper",
        this.camera = e,
        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.pointMap = o,
        this.update();
        const c = new Ie(16755200)
          , d = new Ie(16711680)
          , h = new Ie(43775)
          , p = new Ie(16777215)
          , m = new Ie(3355443);
        this.setColors(c, d, h, p, m)
    }
    setColors(e, t, i, r, s) {
        const a = this.geometry.getAttribute("color");
        a.setXYZ(0, e.r, e.g, e.b),
        a.setXYZ(1, e.r, e.g, e.b),
        a.setXYZ(2, e.r, e.g, e.b),
        a.setXYZ(3, e.r, e.g, e.b),
        a.setXYZ(4, e.r, e.g, e.b),
        a.setXYZ(5, e.r, e.g, e.b),
        a.setXYZ(6, e.r, e.g, e.b),
        a.setXYZ(7, e.r, e.g, e.b),
        a.setXYZ(8, e.r, e.g, e.b),
        a.setXYZ(9, e.r, e.g, e.b),
        a.setXYZ(10, e.r, e.g, e.b),
        a.setXYZ(11, e.r, e.g, e.b),
        a.setXYZ(12, e.r, e.g, e.b),
        a.setXYZ(13, e.r, e.g, e.b),
        a.setXYZ(14, e.r, e.g, e.b),
        a.setXYZ(15, e.r, e.g, e.b),
        a.setXYZ(16, e.r, e.g, e.b),
        a.setXYZ(17, e.r, e.g, e.b),
        a.setXYZ(18, e.r, e.g, e.b),
        a.setXYZ(19, e.r, e.g, e.b),
        a.setXYZ(20, e.r, e.g, e.b),
        a.setXYZ(21, e.r, e.g, e.b),
        a.setXYZ(22, e.r, e.g, e.b),
        a.setXYZ(23, e.r, e.g, e.b),
        a.setXYZ(24, t.r, t.g, t.b),
        a.setXYZ(25, t.r, t.g, t.b),
        a.setXYZ(26, t.r, t.g, t.b),
        a.setXYZ(27, t.r, t.g, t.b),
        a.setXYZ(28, t.r, t.g, t.b),
        a.setXYZ(29, t.r, t.g, t.b),
        a.setXYZ(30, t.r, t.g, t.b),
        a.setXYZ(31, t.r, t.g, t.b),
        a.setXYZ(32, i.r, i.g, i.b),
        a.setXYZ(33, i.r, i.g, i.b),
        a.setXYZ(34, i.r, i.g, i.b),
        a.setXYZ(35, i.r, i.g, i.b),
        a.setXYZ(36, i.r, i.g, i.b),
        a.setXYZ(37, i.r, i.g, i.b),
        a.setXYZ(38, r.r, r.g, r.b),
        a.setXYZ(39, r.r, r.g, r.b),
        a.setXYZ(40, s.r, s.g, s.b),
        a.setXYZ(41, s.r, s.g, s.b),
        a.setXYZ(42, s.r, s.g, s.b),
        a.setXYZ(43, s.r, s.g, s.b),
        a.setXYZ(44, s.r, s.g, s.b),
        a.setXYZ(45, s.r, s.g, s.b),
        a.setXYZ(46, s.r, s.g, s.b),
        a.setXYZ(47, s.r, s.g, s.b),
        a.setXYZ(48, s.r, s.g, s.b),
        a.setXYZ(49, s.r, s.g, s.b),
        a.needsUpdate = !0
    }
    update() {
        const e = this.geometry
          , t = this.pointMap
          , i = 1
          , r = 1;
        pn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
        _n("c", t, e, pn, 0, 0, -1),
        _n("t", t, e, pn, 0, 0, 1),
        _n("n1", t, e, pn, -i, -r, -1),
        _n("n2", t, e, pn, i, -r, -1),
        _n("n3", t, e, pn, -i, r, -1),
        _n("n4", t, e, pn, i, r, -1),
        _n("f1", t, e, pn, -i, -r, 1),
        _n("f2", t, e, pn, i, -r, 1),
        _n("f3", t, e, pn, -i, r, 1),
        _n("f4", t, e, pn, i, r, 1),
        _n("u1", t, e, pn, i * .7, r * 1.1, -1),
        _n("u2", t, e, pn, -i * .7, r * 1.1, -1),
        _n("u3", t, e, pn, 0, r * 2, -1),
        _n("cf1", t, e, pn, -i, 0, 1),
        _n("cf2", t, e, pn, i, 0, 1),
        _n("cf3", t, e, pn, 0, -r, 1),
        _n("cf4", t, e, pn, 0, r, 1),
        _n("cn1", t, e, pn, -i, 0, -1),
        _n("cn2", t, e, pn, i, 0, -1),
        _n("cn3", t, e, pn, 0, -r, -1),
        _n("cn4", t, e, pn, 0, r, -1),
        e.getAttribute("position").needsUpdate = !0
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
function _n(n, e, t, i, r, s, o) {
    wm.set(r, s, o).unproject(i);
    const a = e[n];
    if (a !== void 0) {
        const l = t.getAttribute("position");
        for (let c = 0, d = a.length; c < d; c++)
            l.setXYZ(a[c], wm.x, wm.y, wm.z)
    }
}
const Sm = new ha;
class C6 extends Jr {
    constructor(e, t=16776960) {
        const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , r = new Float32Array(8 * 3)
          , s = new ft;
        s.setIndex(new Nt(i,1)),
        s.setAttribute("position", new Nt(r,3)),
        super(s, new li({
            color: t,
            toneMapped: !1
        })),
        this.object = e,
        this.type = "BoxHelper",
        this.matrixAutoUpdate = !1,
        this.update()
    }
    update(e) {
        if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."),
        this.object !== void 0 && Sm.setFromObject(this.object),
        Sm.isEmpty())
            return;
        const t = Sm.min
          , i = Sm.max
          , r = this.geometry.attributes.position
          , s = r.array;
        s[0] = i.x,
        s[1] = i.y,
        s[2] = i.z,
        s[3] = t.x,
        s[4] = i.y,
        s[5] = i.z,
        s[6] = t.x,
        s[7] = t.y,
        s[8] = i.z,
        s[9] = i.x,
        s[10] = t.y,
        s[11] = i.z,
        s[12] = i.x,
        s[13] = i.y,
        s[14] = t.z,
        s[15] = t.x,
        s[16] = i.y,
        s[17] = t.z,
        s[18] = t.x,
        s[19] = t.y,
        s[20] = t.z,
        s[21] = i.x,
        s[22] = t.y,
        s[23] = t.z,
        r.needsUpdate = !0,
        this.geometry.computeBoundingSphere()
    }
    setFromObject(e) {
        return this.object = e,
        this.update(),
        this
    }
    copy(e, t) {
        return super.copy(e, t),
        this.object = e.object,
        this
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class E6 extends Jr {
    constructor(e, t=16776960) {
        const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1]
          , s = new ft;
        s.setIndex(new Nt(i,1)),
        s.setAttribute("position", new je(r,3)),
        super(s, new li({
            color: t,
            toneMapped: !1
        })),
        this.box = e,
        this.type = "Box3Helper",
        this.geometry.computeBoundingSphere()
    }
    updateMatrixWorld(e) {
        const t = this.box;
        t.isEmpty() || (t.getCenter(this.position),
        t.getSize(this.scale),
        this.scale.multiplyScalar(.5),
        super.updateMatrixWorld(e))
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class T6 extends eo {
    constructor(e, t=1, i=16776960) {
        const r = i
          , s = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0]
          , o = new ft;
        o.setAttribute("position", new je(s,3)),
        o.computeBoundingSphere(),
        super(o, new li({
            color: r,
            toneMapped: !1
        })),
        this.type = "PlaneHelper",
        this.plane = e,
        this.size = t;
        const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0]
          , l = new ft;
        l.setAttribute("position", new je(a,3)),
        l.computeBoundingSphere(),
        this.add(new Ln(l,new Wi({
            color: r,
            opacity: .2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1
        })))
    }
    updateMatrixWorld(e) {
        this.position.set(0, 0, 0),
        this.scale.set(.5 * this.size, .5 * this.size, 1),
        this.lookAt(this.plane.normal),
        this.translateZ(-this.plane.constant),
        super.updateMatrixWorld(e)
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose(),
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
}
const pT = new D;
let Mm, px;
class P6 extends Rt {
    constructor(e=new D(0,0,1), t=new D(0,0,0), i=1, r=16776960, s=i * .2, o=s * .2) {
        super(),
        this.type = "ArrowHelper",
        Mm === void 0 && (Mm = new ft,
        Mm.setAttribute("position", new je([0, 0, 0, 0, 1, 0],3)),
        px = new Bl(0,.5,1,5,1),
        px.translate(0, -.5, 0)),
        this.position.copy(t),
        this.line = new eo(Mm,new li({
            color: r,
            toneMapped: !1
        })),
        this.line.matrixAutoUpdate = !1,
        this.add(this.line),
        this.cone = new Ln(px,new Wi({
            color: r,
            toneMapped: !1
        })),
        this.cone.matrixAutoUpdate = !1,
        this.add(this.cone),
        this.setDirection(e),
        this.setLength(i, s, o)
    }
    setDirection(e) {
        if (e.y > .99999)
            this.quaternion.set(0, 0, 0, 1);
        else if (e.y < -.99999)
            this.quaternion.set(1, 0, 0, 0);
        else {
            pT.set(e.z, 0, -e.x).normalize();
            const t = Math.acos(e.y);
            this.quaternion.setFromAxisAngle(pT, t)
        }
    }
    setLength(e, t=e * .2, i=t * .2) {
        this.line.scale.set(1, Math.max(1e-4, e - t), 1),
        this.line.updateMatrix(),
        this.cone.scale.set(i, t, i),
        this.cone.position.y = e,
        this.cone.updateMatrix()
    }
    setColor(e) {
        this.line.material.color.set(e),
        this.cone.material.color.set(e)
    }
    copy(e) {
        return super.copy(e, !1),
        this.line.copy(e.line),
        this.cone.copy(e.cone),
        this
    }
    dispose() {
        this.line.geometry.dispose(),
        this.line.material.dispose(),
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
}
class B6 extends Jr {
    constructor(e=1) {
        const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]
          , i = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]
          , r = new ft;
        r.setAttribute("position", new je(t,3)),
        r.setAttribute("color", new je(i,3));
        const s = new li({
            vertexColors: !0,
            toneMapped: !1
        });
        super(r, s),
        this.type = "AxesHelper"
    }
    setColors(e, t, i) {
        const r = new Ie
          , s = this.geometry.attributes.color.array;
        return r.set(e),
        r.toArray(s, 0),
        r.toArray(s, 3),
        r.set(t),
        r.toArray(s, 6),
        r.toArray(s, 9),
        r.set(i),
        r.toArray(s, 12),
        r.toArray(s, 15),
        this.geometry.attributes.color.needsUpdate = !0,
        this
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class R6 {
    constructor() {
        this.type = "ShapePath",
        this.color = new Ie,
        this.subPaths = [],
        this.currentPath = null
    }
    moveTo(e, t) {
        return this.currentPath = new Td,
        this.subPaths.push(this.currentPath),
        this.currentPath.moveTo(e, t),
        this
    }
    lineTo(e, t) {
        return this.currentPath.lineTo(e, t),
        this
    }
    quadraticCurveTo(e, t, i, r) {
        return this.currentPath.quadraticCurveTo(e, t, i, r),
        this
    }
    bezierCurveTo(e, t, i, r, s, o) {
        return this.currentPath.bezierCurveTo(e, t, i, r, s, o),
        this
    }
    splineThru(e) {
        return this.currentPath.splineThru(e),
        this
    }
    toShapes(e) {
        function t(_) {
            const A = [];
            for (let w = 0, M = _.length; w < M; w++) {
                const C = _[w]
                  , P = new ml;
                P.curves = C.curves,
                A.push(P)
            }
            return A
        }
        function i(_, A) {
            const w = A.length;
            let M = !1;
            for (let C = w - 1, P = 0; P < w; C = P++) {
                let R = A[C]
                  , E = A[P]
                  , B = E.x - R.x
                  , I = E.y - R.y;
                if (Math.abs(I) > Number.EPSILON) {
                    if (I < 0 && (R = A[P],
                    B = -B,
                    E = A[C],
                    I = -I),
                    _.y < R.y || _.y > E.y)
                        continue;
                    if (_.y === R.y) {
                        if (_.x === R.x)
                            return !0
                    } else {
                        const z = I * (_.x - R.x) - B * (_.y - R.y);
                        if (z === 0)
                            return !0;
                        if (z < 0)
                            continue;
                        M = !M
                    }
                } else {
                    if (_.y !== R.y)
                        continue;
                    if (E.x <= _.x && _.x <= R.x || R.x <= _.x && _.x <= E.x)
                        return !0
                }
            }
            return M
        }
        const r = cs.isClockWise
          , s = this.subPaths;
        if (s.length === 0)
            return [];
        let o, a, l;
        const c = [];
        if (s.length === 1)
            return a = s[0],
            l = new ml,
            l.curves = a.curves,
            c.push(l),
            c;
        let d = !r(s[0].getPoints());
        d = e ? !d : d;
        const h = []
          , p = [];
        let m = [], y = 0, v;
        p[y] = void 0,
        m[y] = [];
        for (let _ = 0, A = s.length; _ < A; _++)
            a = s[_],
            v = a.getPoints(),
            o = r(v),
            o = e ? !o : o,
            o ? (!d && p[y] && y++,
            p[y] = {
                s: new ml,
                p: v
            },
            p[y].s.curves = a.curves,
            d && y++,
            m[y] = []) : m[y].push({
                h: a,
                p: v[0]
            });
        if (!p[0])
            return t(s);
        if (p.length > 1) {
            let _ = !1
              , A = 0;
            for (let w = 0, M = p.length; w < M; w++)
                h[w] = [];
            for (let w = 0, M = p.length; w < M; w++) {
                const C = m[w];
                for (let P = 0; P < C.length; P++) {
                    const R = C[P];
                    let E = !0;
                    for (let B = 0; B < p.length; B++)
                        i(R.p, p[B].p) && (w !== B && A++,
                        E ? (E = !1,
                        h[B].push(R)) : _ = !0);
                    E && h[w].push(R)
                }
            }
            A > 0 && _ === !1 && (m = h)
        }
        let x;
        for (let _ = 0, A = p.length; _ < A; _++) {
            l = p[_].s,
            c.push(l),
            x = m[_];
            for (let w = 0, M = x.length; w < M; w++)
                l.holes.push(x[w].h)
        }
        return c
    }
}
const Fs = I6();
function I6() {
    const n = new ArrayBuffer(4)
      , e = new Float32Array(n)
      , t = new Uint32Array(n)
      , i = new Uint32Array(512)
      , r = new Uint32Array(512);
    for (let l = 0; l < 256; ++l) {
        const c = l - 127;
        c < -27 ? (i[l] = 0,
        i[l | 256] = 32768,
        r[l] = 24,
        r[l | 256] = 24) : c < -14 ? (i[l] = 1024 >> -c - 14,
        i[l | 256] = 1024 >> -c - 14 | 32768,
        r[l] = -c - 1,
        r[l | 256] = -c - 1) : c <= 15 ? (i[l] = c + 15 << 10,
        i[l | 256] = c + 15 << 10 | 32768,
        r[l] = 13,
        r[l | 256] = 13) : c < 128 ? (i[l] = 31744,
        i[l | 256] = 64512,
        r[l] = 24,
        r[l | 256] = 24) : (i[l] = 31744,
        i[l | 256] = 64512,
        r[l] = 13,
        r[l | 256] = 13)
    }
    const s = new Uint32Array(2048)
      , o = new Uint32Array(64)
      , a = new Uint32Array(64);
    for (let l = 1; l < 1024; ++l) {
        let c = l << 13
          , d = 0;
        for (; !(c & 8388608); )
            c <<= 1,
            d -= 8388608;
        c &= -8388609,
        d += 947912704,
        s[l] = c | d
    }
    for (let l = 1024; l < 2048; ++l)
        s[l] = 939524096 + (l - 1024 << 13);
    for (let l = 1; l < 31; ++l)
        o[l] = l << 23;
    o[31] = 1199570944,
    o[32] = 2147483648;
    for (let l = 33; l < 63; ++l)
        o[l] = 2147483648 + (l - 32 << 23);
    o[63] = 3347054592;
    for (let l = 1; l < 64; ++l)
        l !== 32 && (a[l] = 1024);
    return {
        floatView: e,
        uint32View: t,
        baseTable: i,
        shiftTable: r,
        mantissaTable: s,
        exponentTable: o,
        offsetTable: a
    }
}
function L6(n) {
    Math.abs(n) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    n = wn(n, -65504, 65504),
    Fs.floatView[0] = n;
    const e = Fs.uint32View[0]
      , t = e >> 23 & 511;
    return Fs.baseTable[t] + ((e & 8388607) >> Fs.shiftTable[t])
}
function D6(n) {
    const e = n >> 10;
    return Fs.uint32View[0] = Fs.mantissaTable[Fs.offsetTable[e] + (n & 1023)] + Fs.exponentTable[e],
    Fs.floatView[0]
}
var k6 = Object.freeze({
    __proto__: null,
    fromHalfFloat: D6,
    toHalfFloat: L6
});
class F6 extends ma {
    constructor(e, t, i, r, s, o) {
        console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."),
        super(e, t, i, r, s, o)
    }
}
class N6 extends sh {
    constructor(e, t, i, r) {
        console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."),
        super(e, t, i, r)
    }
}
class O6 extends oh {
    constructor(e, t, i, r) {
        console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."),
        super(e, t, i, r)
    }
}
class U6 extends ah {
    constructor(e, t, i, r, s, o, a) {
        console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."),
        super(e, t, i, r, s, o, a)
    }
}
class z6 extends Bl {
    constructor(e, t, i, r, s, o, a, l) {
        console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."),
        super(e, t, i, r, s, o, a, l)
    }
}
class G6 extends lh {
    constructor(e, t) {
        console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."),
        super(e, t)
    }
}
class H6 extends uh {
    constructor(e, t) {
        console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."),
        super(e, t)
    }
}
class V6 extends ch {
    constructor(e, t) {
        console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."),
        super(e, t)
    }
}
class W6 extends Sc {
    constructor(e, t, i, r) {
        console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."),
        super(e, t, i, r)
    }
}
class j6 extends Mc {
    constructor(e, t) {
        console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."),
        super(e, t)
    }
}
class J6 extends Ac {
    constructor(e, t, i, r) {
        console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."),
        super(e, t, i, r)
    }
}
class X6 extends oo {
    constructor(e, t, i, r) {
        console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."),
        super(e, t, i, r)
    }
}
class Y6 extends fh {
    constructor(e, t, i, r, s, o) {
        console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."),
        super(e, t, i, r, s, o)
    }
}
class K6 extends dh {
    constructor(e, t) {
        console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."),
        super(e, t)
    }
}
class Q6 extends bc {
    constructor(e, t, i, r, s, o, a) {
        console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."),
        super(e, t, i, r, s, o, a)
    }
}
class Z6 extends hh {
    constructor(e, t) {
        console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."),
        super(e, t)
    }
}
class q6 extends ph {
    constructor(e, t, i, r, s) {
        console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."),
        super(e, t, i, r, s)
    }
}
class $6 extends mh {
    constructor(e, t, i, r, s, o) {
        console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."),
        super(e, t, i, r, s, o)
    }
}
class e8 extends gh {
    constructor(e, t, i, r, s) {
        console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."),
        super(e, t, i, r, s)
    }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: w0
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = w0);
const b_ = Object.freeze(Object.defineProperty({
    __proto__: null,
    ACESFilmicToneMapping: gw,
    AddEquation: Xa,
    AddOperation: uR,
    AdditiveAnimationBlendMode: yw,
    AdditiveBlending: G1,
    AlphaFormat: xR,
    AlwaysDepth: nR,
    AlwaysStencilFunc: FR,
    AmbientLight: MI,
    AmbientLightProbe: WH,
    AnimationClip: cc,
    AnimationLoader: LH,
    AnimationMixer: u6,
    AnimationObjectGroup: o6,
    AnimationUtils: PH,
    ArcCurve: tI,
    ArrayCamera: YR,
    ArrowHelper: P6,
    Audio: BI,
    AudioAnalyser: QH,
    AudioContext: $w,
    AudioListener: XH,
    AudioLoader: HH,
    AxesHelper: B6,
    BackSide: Li,
    BasicDepthPacking: LR,
    BasicShadowMap: HB,
    Bone: I0,
    BooleanKeyframeTrack: Rl,
    Box2: m6,
    Box3: ha,
    Box3Helper: E6,
    BoxBufferGeometry: F6,
    BoxGeometry: ma,
    BoxHelper: C6,
    BufferAttribute: Nt,
    BufferGeometry: ft,
    BufferGeometryLoader: TI,
    ByteType: pR,
    Cache: Ml,
    Camera: eh,
    CameraHelper: b6,
    CanvasTexture: $9,
    CapsuleBufferGeometry: N6,
    CapsuleGeometry: sh,
    CatmullRomCurve3: nI,
    CineonToneMapping: dR,
    CircleBufferGeometry: O6,
    CircleGeometry: oh,
    ClampToEdgeWrapping: Xn,
    Clock: eS,
    Color: Ie,
    ColorKeyframeTrack: Xw,
    ColorManagement: si,
    CompressedArrayTexture: q9,
    CompressedTexture: Nw,
    CompressedTextureLoader: DH,
    ConeBufferGeometry: U6,
    ConeGeometry: ah,
    CubeCamera: Cw,
    CubeReflectionMapping: ea,
    CubeRefractionMapping: ta,
    CubeTexture: th,
    CubeTextureLoader: kH,
    CubeUVReflectionMapping: _c,
    CubicBezierCurve: Uw,
    CubicBezierCurve3: iI,
    CubicInterpolant: _I,
    CullFaceBack: z1,
    CullFaceFront: GB,
    CullFaceFrontBack: r4,
    CullFaceNone: zB,
    Curve: Xr,
    CurvePath: sI,
    CustomBlending: VB,
    CustomToneMapping: hR,
    CylinderBufferGeometry: z6,
    CylinderGeometry: Bl,
    Cylindrical: p6,
    Data3DTexture: Sw,
    DataArrayTexture: E0,
    DataTexture: Ju,
    DataTextureLoader: FH,
    DataUtils: k6,
    DecrementStencilOp: m4,
    DecrementWrapStencilOp: v4,
    DefaultLoadingManager: Iu,
    DepthFormat: Qo,
    DepthStencilFormat: Al,
    DepthTexture: KR,
    DirectionalLight: qw,
    DirectionalLightHelper: M6,
    DiscreteInterpolant: AI,
    DodecahedronBufferGeometry: G6,
    DodecahedronGeometry: lh,
    DoubleSide: Or,
    DstAlphaFactor: QB,
    DstColorFactor: qB,
    DynamicCopyUsage: R4,
    DynamicDrawUsage: fl,
    DynamicReadUsage: T4,
    EdgesGeometry: oI,
    EllipseCurve: L0,
    EqualDepth: rR,
    EqualStencilFunc: A4,
    EquirectangularReflectionMapping: Ad,
    EquirectangularRefractionMapping: wd,
    Euler: Pl,
    EventDispatcher: gs,
    ExtrudeBufferGeometry: H6,
    ExtrudeGeometry: uh,
    FileLoader: Yi,
    Float16BufferAttribute: fU,
    Float32BufferAttribute: je,
    Float64BufferAttribute: dU,
    FloatType: zs,
    Fog: R0,
    FogExp2: B0,
    FramebufferTexture: Z9,
    FrontSide: hs,
    Frustum: T0,
    GLBufferAttribute: h6,
    GLSL1: L4,
    GLSL3: m_,
    GreaterDepth: oR,
    GreaterEqualDepth: sR,
    GreaterEqualStencilFunc: b4,
    GreaterStencilFunc: S4,
    GridHelper: w6,
    Group: Hs,
    HalfFloatType: ic,
    HemisphereLight: SI,
    HemisphereLightHelper: A6,
    HemisphereLightProbe: VH,
    IcosahedronBufferGeometry: V6,
    IcosahedronGeometry: ch,
    ImageBitmapLoader: PI,
    ImageLoader: Id,
    ImageUtils: ww,
    IncrementStencilOp: p4,
    IncrementWrapStencilOp: g4,
    InstancedBufferAttribute: ac,
    InstancedBufferGeometry: EI,
    InstancedInterleavedBuffer: d6,
    InstancedMesh: eI,
    Int16BufferAttribute: uU,
    Int32BufferAttribute: cU,
    Int8BufferAttribute: oU,
    IntType: gR,
    InterleavedBuffer: nh,
    InterleavedBufferAttribute: ia,
    Interpolant: Ec,
    InterpolateDiscrete: rc,
    InterpolateLinear: wl,
    InterpolateSmooth: og,
    InvertStencilOp: y4,
    KeepStencilOp: ag,
    KeyframeTrack: Yr,
    LOD: $R,
    LatheBufferGeometry: W6,
    LatheGeometry: Sc,
    Layers: pl,
    LessDepth: iR,
    LessEqualDepth: zg,
    LessEqualStencilFunc: w4,
    LessStencilFunc: _4,
    Light: ga,
    LightProbe: F0,
    Line: eo,
    Line3: g6,
    LineBasicMaterial: li,
    LineCurve: D0,
    LineCurve3: rI,
    LineDashedMaterial: yI,
    LineLoop: kw,
    LineSegments: Jr,
    LinearEncoding: $s,
    LinearFilter: on,
    LinearInterpolant: Jw,
    LinearMipMapLinearFilter: u4,
    LinearMipMapNearestFilter: l4,
    LinearMipmapLinearFilter: ps,
    LinearMipmapNearestFilter: b0,
    LinearSRGBColorSpace: sc,
    LinearToneMapping: cR,
    Loader: Ai,
    LoaderUtils: fs,
    LoadingManager: Yw,
    LoopOnce: PR,
    LoopPingPong: RR,
    LoopRepeat: BR,
    LuminanceAlphaFormat: AR,
    LuminanceFormat: _R,
    MOUSE: Ga,
    Material: Tn,
    MaterialLoader: N0,
    MathUtils: Aw,
    Matrix3: gi,
    Matrix4: ot,
    MaxEquation: j1,
    Mesh: Ln,
    MeshBasicMaterial: Wi,
    MeshDepthMaterial: Pw,
    MeshDistanceMaterial: Bw,
    MeshLambertMaterial: gI,
    MeshMatcapMaterial: vI,
    MeshNormalMaterial: mI,
    MeshPhongMaterial: hI,
    MeshPhysicalMaterial: ao,
    MeshStandardMaterial: Cc,
    MeshToonMaterial: pI,
    MinEquation: W1,
    MirroredRepeatWrapping: nc,
    MixOperation: lR,
    MultiplyBlending: V1,
    MultiplyOperation: qd,
    NearestFilter: gn,
    NearestMipMapLinearFilter: a4,
    NearestMipMapNearestFilter: o4,
    NearestMipmapLinearFilter: ju,
    NearestMipmapNearestFilter: Sd,
    NeverDepth: tR,
    NeverStencilFunc: x4,
    NoBlending: js,
    NoColorSpace: f4,
    NoToneMapping: Hr,
    NormalAnimationBlendMode: C0,
    NormalBlending: ul,
    NotEqualDepth: aR,
    NotEqualStencilFunc: M4,
    NumberKeyframeTrack: lc,
    Object3D: Rt,
    ObjectLoader: zH,
    ObjectSpaceNormalMap: kR,
    OctahedronBufferGeometry: j6,
    OctahedronGeometry: Mc,
    OneFactor: XB,
    OneMinusDstAlphaFactor: ZB,
    OneMinusDstColorFactor: $B,
    OneMinusSrcAlphaFactor: mw,
    OneMinusSrcColorFactor: KB,
    OrthographicCamera: Vr,
    PCFShadowMap: S0,
    PCFSoftShadowMap: Wf,
    PMREMGenerator: v_,
    Path: Td,
    PerspectiveCamera: Wt,
    Plane: Ro,
    PlaneBufferGeometry: J6,
    PlaneGeometry: Ac,
    PlaneHelper: T6,
    PointLight: Zw,
    PointLightHelper: x6,
    Points: Fw,
    PointsMaterial: rh,
    PolarGridHelper: S6,
    PolyhedronBufferGeometry: X6,
    PolyhedronGeometry: oo,
    PositionalAudio: KH,
    PropertyBinding: Bt,
    PropertyMixer: RI,
    QuadraticBezierCurve: zw,
    QuadraticBezierCurve3: Gw,
    Quaternion: Qn,
    QuaternionKeyframeTrack: ra,
    QuaternionLinearInterpolant: wI,
    RED_GREEN_RGTC2_Format: h_,
    RED_RGTC1_Format: TR,
    REVISION: w0,
    RGBADepthPacking: DR,
    RGBAFormat: Ti,
    RGBAIntegerFormat: CR,
    RGBA_ASTC_10x10_Format: u_,
    RGBA_ASTC_10x5_Format: o_,
    RGBA_ASTC_10x6_Format: a_,
    RGBA_ASTC_10x8_Format: l_,
    RGBA_ASTC_12x10_Format: c_,
    RGBA_ASTC_12x12_Format: f_,
    RGBA_ASTC_4x4_Format: q1,
    RGBA_ASTC_5x4_Format: $1,
    RGBA_ASTC_5x5_Format: e_,
    RGBA_ASTC_6x5_Format: t_,
    RGBA_ASTC_6x6_Format: n_,
    RGBA_ASTC_8x5_Format: i_,
    RGBA_ASTC_8x6_Format: r_,
    RGBA_ASTC_8x8_Format: s_,
    RGBA_BPTC_Format: sg,
    RGBA_ETC2_EAC_Format: Z1,
    RGBA_PVRTC_2BPPV1_Format: K1,
    RGBA_PVRTC_4BPPV1_Format: Y1,
    RGBA_S3TC_DXT1_Format: ng,
    RGBA_S3TC_DXT3_Format: ig,
    RGBA_S3TC_DXT5_Format: rg,
    RGB_ETC1_Format: ER,
    RGB_ETC2_Format: Q1,
    RGB_PVRTC_2BPPV1_Format: X1,
    RGB_PVRTC_4BPPV1_Format: J1,
    RGB_S3TC_DXT1_Format: tg,
    RGFormat: MR,
    RGIntegerFormat: bR,
    RawShaderMaterial: dI,
    Ray: $d,
    Raycaster: II,
    RectAreaLight: bI,
    RedFormat: wR,
    RedIntegerFormat: SR,
    ReinhardToneMapping: fR,
    RepeatWrapping: na,
    ReplaceStencilOp: h4,
    ReverseSubtractEquation: jB,
    RingBufferGeometry: Y6,
    RingGeometry: fh,
    SIGNED_RED_GREEN_RGTC2_Format: p_,
    SIGNED_RED_RGTC1_Format: d_,
    SRGBColorSpace: kr,
    Scene: Iw,
    ShaderChunk: vt,
    ShaderLib: Nr,
    ShaderMaterial: ms,
    ShadowMaterial: fI,
    Shape: ml,
    ShapeBufferGeometry: K6,
    ShapeGeometry: dh,
    ShapePath: R6,
    ShapeUtils: cs,
    ShortType: mR,
    Skeleton: ih,
    SkeletonHelper: y6,
    SkinnedMesh: Dw,
    Source: nl,
    Sphere: pa,
    SphereBufferGeometry: Q6,
    SphereGeometry: bc,
    Spherical: M_,
    SphericalHarmonics3: CI,
    SplineCurve: Hw,
    SpotLight: Qw,
    SpotLightHelper: v6,
    Sprite: qR,
    SpriteMaterial: Lw,
    SrcAlphaFactor: pw,
    SrcAlphaSaturateFactor: eR,
    SrcColorFactor: YB,
    StaticCopyUsage: B4,
    StaticDrawUsage: bd,
    StaticReadUsage: E4,
    StereoCamera: jH,
    StreamCopyUsage: I4,
    StreamDrawUsage: C4,
    StreamReadUsage: P4,
    StringKeyframeTrack: Il,
    SubtractEquation: WB,
    SubtractiveBlending: H1,
    TOUCH: Ha,
    TangentSpaceNormalMap: so,
    TetrahedronBufferGeometry: Z6,
    TetrahedronGeometry: hh,
    Texture: tn,
    TextureLoader: vh,
    TorusBufferGeometry: q6,
    TorusGeometry: ph,
    TorusKnotBufferGeometry: $6,
    TorusKnotGeometry: mh,
    Triangle: yr,
    TriangleFanDrawMode: xw,
    TriangleStripDrawMode: IR,
    TrianglesDrawMode: c4,
    TubeBufferGeometry: e8,
    TubeGeometry: gh,
    TwoPassDoubleSide: s4,
    UVMapping: M0,
    Uint16BufferAttribute: Mw,
    Uint32BufferAttribute: bw,
    Uint8BufferAttribute: aU,
    Uint8ClampedBufferAttribute: lU,
    Uniform: iS,
    UniformsGroup: f6,
    UniformsLib: Re,
    UniformsUtils: GR,
    UnsignedByteType: qs,
    UnsignedInt248Type: cl,
    UnsignedIntType: No,
    UnsignedShort4444Type: vR,
    UnsignedShort5551Type: yR,
    UnsignedShortType: vw,
    VSMShadowMap: $a,
    Vector2: me,
    Vector3: D,
    Vector4: Ut,
    VectorKeyframeTrack: uc,
    VideoTexture: Q9,
    WebGL1Renderer: QR,
    WebGL3DRenderTarget: Q4,
    WebGLArrayRenderTarget: K4,
    WebGLCubeRenderTarget: Ew,
    WebGLMultipleRenderTargets: Z4,
    WebGLRenderTarget: jr,
    WebGLRenderer: Rw,
    WebGLUtils: XR,
    WireframeGeometry: cI,
    WrapAroundEnding: Md,
    ZeroCurvatureEnding: el,
    ZeroFactor: JB,
    ZeroSlopeEnding: tl,
    ZeroStencilOp: d4,
    _SRGBAFormat: Gg,
    sRGBEncoding: Tt
}, Symbol.toStringTag, {
    value: "Module"
}));
var Oo = {}
  , t8 = {
    get exports() {
        return Oo
    },
    set exports(n) {
        Oo = n
    }
}
  , Ll = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Ll.ConcurrentRoot = 1;
Ll.ContinuousEventPriority = 4;
Ll.DefaultEventPriority = 16;
Ll.DiscreteEventPriority = 1;
Ll.IdleEventPriority = 536870912;
Ll.LegacyRoot = 0;
(function(n) {
    n.exports = Ll
}
)(t8);
function n8(n) {
    let e;
    const t = new Set
      , i = (c,d)=>{
        const h = typeof c == "function" ? c(e) : c;
        if (h !== e) {
            const p = e;
            e = d ? h : Object.assign({}, e, h),
            t.forEach(m=>m(e, p))
        }
    }
      , r = ()=>e
      , s = (c,d=r,h=Object.is)=>{
        console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
        let p = d(e);
        function m() {
            const y = d(e);
            if (!h(p, y)) {
                const v = p;
                c(p = y, v)
            }
        }
        return t.add(m),
        ()=>t.delete(m)
    }
      , l = {
        setState: i,
        getState: r,
        subscribe: (c,d,h)=>d || h ? s(c, d, h) : (t.add(c),
        ()=>t.delete(c)),
        destroy: ()=>t.clear()
    };
    return e = n(i, r, l),
    l
}
const i8 = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent)
  , mT = i8 ? U.useEffect : U.useLayoutEffect;
function DI(n) {
    const e = typeof n == "function" ? n8(n) : n
      , t = (i=e.getState,r=Object.is)=>{
        const [,s] = U.useReducer(x=>x + 1, 0)
          , o = e.getState()
          , a = U.useRef(o)
          , l = U.useRef(i)
          , c = U.useRef(r)
          , d = U.useRef(!1)
          , h = U.useRef();
        h.current === void 0 && (h.current = i(o));
        let p, m = !1;
        (a.current !== o || l.current !== i || c.current !== r || d.current) && (p = i(o),
        m = !r(h.current, p)),
        mT(()=>{
            m && (h.current = p),
            a.current = o,
            l.current = i,
            c.current = r,
            d.current = !1
        }
        );
        const y = U.useRef(o);
        mT(()=>{
            const x = ()=>{
                try {
                    const A = e.getState()
                      , w = l.current(A);
                    c.current(h.current, w) || (a.current = A,
                    h.current = w,
                    s())
                } catch {
                    d.current = !0,
                    s()
                }
            }
              , _ = e.subscribe(x);
            return e.getState() !== y.current && x(),
            _
        }
        , []);
        const v = m ? p : h.current;
        return U.useDebugValue(v),
        v
    }
    ;
    return Object.assign(t, e),
    t[Symbol.iterator] = function() {
        console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
        const i = [t, e];
        return {
            next() {
                const r = i.length <= 0;
                return {
                    value: i.shift(),
                    done: r
                }
            }
        }
    }
    ,
    t
}
var C_ = {}
  , r8 = {
    get exports() {
        return C_
    },
    set exports(n) {
        C_ = n
    }
}
  , Ld = {}
  , s8 = {
    get exports() {
        return Ld
    },
    set exports(n) {
        Ld = n
    }
}
  , kI = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(n) {
    function e(F, V) {
        var Y = F.length;
        F.push(V);
        e: for (; 0 < Y; ) {
            var re = Y - 1 >>> 1
              , j = F[re];
            if (0 < r(j, V))
                F[re] = V,
                F[Y] = j,
                Y = re;
            else
                break e
        }
    }
    function t(F) {
        return F.length === 0 ? null : F[0]
    }
    function i(F) {
        if (F.length === 0)
            return null;
        var V = F[0]
          , Y = F.pop();
        if (Y !== V) {
            F[0] = Y;
            e: for (var re = 0, j = F.length, ie = j >>> 1; re < ie; ) {
                var ye = 2 * (re + 1) - 1
                  , _e = F[ye]
                  , $ = ye + 1
                  , Ne = F[$];
                if (0 > r(_e, Y))
                    $ < j && 0 > r(Ne, _e) ? (F[re] = Ne,
                    F[$] = Y,
                    re = $) : (F[re] = _e,
                    F[ye] = Y,
                    re = ye);
                else if ($ < j && 0 > r(Ne, Y))
                    F[re] = Ne,
                    F[$] = Y,
                    re = $;
                else
                    break e
            }
        }
        return V
    }
    function r(F, V) {
        var Y = F.sortIndex - V.sortIndex;
        return Y !== 0 ? Y : F.id - V.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var s = performance;
        n.unstable_now = function() {
            return s.now()
        }
    } else {
        var o = Date
          , a = o.now();
        n.unstable_now = function() {
            return o.now() - a
        }
    }
    var l = []
      , c = []
      , d = 1
      , h = null
      , p = 3
      , m = !1
      , y = !1
      , v = !1
      , x = typeof setTimeout == "function" ? setTimeout : null
      , _ = typeof clearTimeout == "function" ? clearTimeout : null
      , A = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function w(F) {
        for (var V = t(c); V !== null; ) {
            if (V.callback === null)
                i(c);
            else if (V.startTime <= F)
                i(c),
                V.sortIndex = V.expirationTime,
                e(l, V);
            else
                break;
            V = t(c)
        }
    }
    function M(F) {
        if (v = !1,
        w(F),
        !y)
            if (t(l) !== null)
                y = !0,
                ne(C);
            else {
                var V = t(c);
                V !== null && oe(M, V.startTime - F)
            }
    }
    function C(F, V) {
        y = !1,
        v && (v = !1,
        _(E),
        E = -1),
        m = !0;
        var Y = p;
        try {
            for (w(V),
            h = t(l); h !== null && (!(h.expirationTime > V) || F && !z()); ) {
                var re = h.callback;
                if (typeof re == "function") {
                    h.callback = null,
                    p = h.priorityLevel;
                    var j = re(h.expirationTime <= V);
                    V = n.unstable_now(),
                    typeof j == "function" ? h.callback = j : h === t(l) && i(l),
                    w(V)
                } else
                    i(l);
                h = t(l)
            }
            if (h !== null)
                var ie = !0;
            else {
                var ye = t(c);
                ye !== null && oe(M, ye.startTime - V),
                ie = !1
            }
            return ie
        } finally {
            h = null,
            p = Y,
            m = !1
        }
    }
    var P = !1
      , R = null
      , E = -1
      , B = 5
      , I = -1;
    function z() {
        return !(n.unstable_now() - I < B)
    }
    function q() {
        if (R !== null) {
            var F = n.unstable_now();
            I = F;
            var V = !0;
            try {
                V = R(!0, F)
            } finally {
                V ? W() : (P = !1,
                R = null)
            }
        } else
            P = !1
    }
    var W;
    if (typeof A == "function")
        W = function() {
            A(q)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var G = new MessageChannel
          , K = G.port2;
        G.port1.onmessage = q,
        W = function() {
            K.postMessage(null)
        }
    } else
        W = function() {
            x(q, 0)
        }
        ;
    function ne(F) {
        R = F,
        P || (P = !0,
        W())
    }
    function oe(F, V) {
        E = x(function() {
            F(n.unstable_now())
        }, V)
    }
    n.unstable_IdlePriority = 5,
    n.unstable_ImmediatePriority = 1,
    n.unstable_LowPriority = 4,
    n.unstable_NormalPriority = 3,
    n.unstable_Profiling = null,
    n.unstable_UserBlockingPriority = 2,
    n.unstable_cancelCallback = function(F) {
        F.callback = null
    }
    ,
    n.unstable_continueExecution = function() {
        y || m || (y = !0,
        ne(C))
    }
    ,
    n.unstable_forceFrameRate = function(F) {
        0 > F || 125 < F ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : B = 0 < F ? Math.floor(1e3 / F) : 5
    }
    ,
    n.unstable_getCurrentPriorityLevel = function() {
        return p
    }
    ,
    n.unstable_getFirstCallbackNode = function() {
        return t(l)
    }
    ,
    n.unstable_next = function(F) {
        switch (p) {
        case 1:
        case 2:
        case 3:
            var V = 3;
            break;
        default:
            V = p
        }
        var Y = p;
        p = V;
        try {
            return F()
        } finally {
            p = Y
        }
    }
    ,
    n.unstable_pauseExecution = function() {}
    ,
    n.unstable_requestPaint = function() {}
    ,
    n.unstable_runWithPriority = function(F, V) {
        switch (F) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            F = 3
        }
        var Y = p;
        p = F;
        try {
            return V()
        } finally {
            p = Y
        }
    }
    ,
    n.unstable_scheduleCallback = function(F, V, Y) {
        var re = n.unstable_now();
        switch (typeof Y == "object" && Y !== null ? (Y = Y.delay,
        Y = typeof Y == "number" && 0 < Y ? re + Y : re) : Y = re,
        F) {
        case 1:
            var j = -1;
            break;
        case 2:
            j = 250;
            break;
        case 5:
            j = 1073741823;
            break;
        case 4:
            j = 1e4;
            break;
        default:
            j = 5e3
        }
        return j = Y + j,
        F = {
            id: d++,
            callback: V,
            priorityLevel: F,
            startTime: Y,
            expirationTime: j,
            sortIndex: -1
        },
        Y > re ? (F.sortIndex = Y,
        e(c, F),
        t(l) === null && F === t(c) && (v ? (_(E),
        E = -1) : v = !0,
        oe(M, Y - re))) : (F.sortIndex = j,
        e(l, F),
        y || m || (y = !0,
        ne(C))),
        F
    }
    ,
    n.unstable_shouldYield = z,
    n.unstable_wrapCallback = function(F) {
        var V = p;
        return function() {
            var Y = p;
            p = V;
            try {
                return F.apply(this, arguments)
            } finally {
                p = Y
            }
        }
    }
}
)(kI);
(function(n) {
    n.exports = kI
}
)(s8);
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var o8 = function(e) {
    var t = {}
      , i = U
      , r = Ld
      , s = Object.assign;
    function o(u) {
        for (var f = "https://reactjs.org/docs/error-decoder.html?invariant=" + u, g = 1; g < arguments.length; g++)
            f += "&args[]=" + encodeURIComponent(arguments[g]);
        return "Minified React error #" + u + "; visit " + f + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    var a = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
      , l = Symbol.for("react.element")
      , c = Symbol.for("react.portal")
      , d = Symbol.for("react.fragment")
      , h = Symbol.for("react.strict_mode")
      , p = Symbol.for("react.profiler")
      , m = Symbol.for("react.provider")
      , y = Symbol.for("react.context")
      , v = Symbol.for("react.forward_ref")
      , x = Symbol.for("react.suspense")
      , _ = Symbol.for("react.suspense_list")
      , A = Symbol.for("react.memo")
      , w = Symbol.for("react.lazy")
      , M = Symbol.for("react.offscreen")
      , C = Symbol.iterator;
    function P(u) {
        return u === null || typeof u != "object" ? null : (u = C && u[C] || u["@@iterator"],
        typeof u == "function" ? u : null)
    }
    function R(u) {
        if (u == null)
            return null;
        if (typeof u == "function")
            return u.displayName || u.name || null;
        if (typeof u == "string")
            return u;
        switch (u) {
        case d:
            return "Fragment";
        case c:
            return "Portal";
        case p:
            return "Profiler";
        case h:
            return "StrictMode";
        case x:
            return "Suspense";
        case _:
            return "SuspenseList"
        }
        if (typeof u == "object")
            switch (u.$$typeof) {
            case y:
                return (u.displayName || "Context") + ".Consumer";
            case m:
                return (u._context.displayName || "Context") + ".Provider";
            case v:
                var f = u.render;
                return u = u.displayName,
                u || (u = f.displayName || f.name || "",
                u = u !== "" ? "ForwardRef(" + u + ")" : "ForwardRef"),
                u;
            case A:
                return f = u.displayName || null,
                f !== null ? f : R(u.type) || "Memo";
            case w:
                f = u._payload,
                u = u._init;
                try {
                    return R(u(f))
                } catch {}
            }
        return null
    }
    function E(u) {
        var f = u.type;
        switch (u.tag) {
        case 24:
            return "Cache";
        case 9:
            return (f.displayName || "Context") + ".Consumer";
        case 10:
            return (f._context.displayName || "Context") + ".Provider";
        case 18:
            return "DehydratedFragment";
        case 11:
            return u = f.render,
            u = u.displayName || u.name || "",
            f.displayName || (u !== "" ? "ForwardRef(" + u + ")" : "ForwardRef");
        case 7:
            return "Fragment";
        case 5:
            return f;
        case 4:
            return "Portal";
        case 3:
            return "Root";
        case 6:
            return "Text";
        case 16:
            return R(f);
        case 8:
            return f === h ? "StrictMode" : "Mode";
        case 22:
            return "Offscreen";
        case 12:
            return "Profiler";
        case 21:
            return "Scope";
        case 13:
            return "Suspense";
        case 19:
            return "SuspenseList";
        case 25:
            return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
            if (typeof f == "function")
                return f.displayName || f.name || null;
            if (typeof f == "string")
                return f
        }
        return null
    }
    function B(u) {
        var f = u
          , g = u;
        if (u.alternate)
            for (; f.return; )
                f = f.return;
        else {
            u = f;
            do
                f = u,
                f.flags & 4098 && (g = f.return),
                u = f.return;
            while (u)
        }
        return f.tag === 3 ? g : null
    }
    function I(u) {
        if (B(u) !== u)
            throw Error(o(188))
    }
    function z(u) {
        var f = u.alternate;
        if (!f) {
            if (f = B(u),
            f === null)
                throw Error(o(188));
            return f !== u ? null : u
        }
        for (var g = u, S = f; ; ) {
            var b = g.return;
            if (b === null)
                break;
            var T = b.alternate;
            if (T === null) {
                if (S = b.return,
                S !== null) {
                    g = S;
                    continue
                }
                break
            }
            if (b.child === T.child) {
                for (T = b.child; T; ) {
                    if (T === g)
                        return I(b),
                        u;
                    if (T === S)
                        return I(b),
                        f;
                    T = T.sibling
                }
                throw Error(o(188))
            }
            if (g.return !== S.return)
                g = b,
                S = T;
            else {
                for (var N = !1, J = b.child; J; ) {
                    if (J === g) {
                        N = !0,
                        g = b,
                        S = T;
                        break
                    }
                    if (J === S) {
                        N = !0,
                        S = b,
                        g = T;
                        break
                    }
                    J = J.sibling
                }
                if (!N) {
                    for (J = T.child; J; ) {
                        if (J === g) {
                            N = !0,
                            g = T,
                            S = b;
                            break
                        }
                        if (J === S) {
                            N = !0,
                            S = T,
                            g = b;
                            break
                        }
                        J = J.sibling
                    }
                    if (!N)
                        throw Error(o(189))
                }
            }
            if (g.alternate !== S)
                throw Error(o(190))
        }
        if (g.tag !== 3)
            throw Error(o(188));
        return g.stateNode.current === g ? u : f
    }
    function q(u) {
        return u = z(u),
        u !== null ? W(u) : null
    }
    function W(u) {
        if (u.tag === 5 || u.tag === 6)
            return u;
        for (u = u.child; u !== null; ) {
            var f = W(u);
            if (f !== null)
                return f;
            u = u.sibling
        }
        return null
    }
    function G(u) {
        if (u.tag === 5 || u.tag === 6)
            return u;
        for (u = u.child; u !== null; ) {
            if (u.tag !== 4) {
                var f = G(u);
                if (f !== null)
                    return f
            }
            u = u.sibling
        }
        return null
    }
    var K = Array.isArray, ne = e.getPublicInstance, oe = e.getRootHostContext, F = e.getChildHostContext, V = e.prepareForCommit, Y = e.resetAfterCommit, re = e.createInstance, j = e.appendInitialChild, ie = e.finalizeInitialChildren, ye = e.prepareUpdate, _e = e.shouldSetTextContent, $ = e.createTextInstance, Ne = e.scheduleTimeout, Oe = e.cancelTimeout, Ve = e.noTimeout, we = e.isPrimaryRenderer, Le = e.supportsMutation, de = e.supportsPersistence, ae = e.supportsHydration, be = e.getInstanceFromNode, Ge = e.preparePortalMount, Be = e.getCurrentEventPriority, $e = e.detachDeletedInstance, Ye = e.supportsMicrotasks, Je = e.scheduleMicrotask, At = e.supportsTestSelectors, Ct = e.findFiberRoot, O = e.getBoundingRect, L = e.getTextContent, se = e.isHiddenSubtree, Se = e.matchAccessibilityRole, Ce = e.setFocusIfFocusable, Pe = e.setupIntersectionObserver, rt = e.appendChild, De = e.appendChildToContainer, ge = e.commitTextUpdate, Ke = e.commitMount, H = e.commitUpdate, le = e.insertBefore, Ae = e.insertInContainerBefore, Te = e.removeChild, tt = e.removeChildFromContainer, _t = e.resetTextContent, Jt = e.hideInstance, X = e.hideTextInstance, ce = e.unhideInstance, xe = e.unhideTextInstance, Ue = e.clearContainer, Ze = e.cloneInstance, It = e.createContainerChildSet, yn = e.appendChildToContainerChildSet, Nn = e.finalizeContainerChildren, Kr = e.replaceContainerChildren, Gt = e.cloneHiddenInstance, er = e.cloneHiddenTextInstance, wi = e.canHydrateInstance, Eh = e.canHydrateTextInstance, nv = e.canHydrateSuspenseInstance, Th = e.isSuspenseInstancePending, Rc = e.isSuspenseInstanceFallback, k = e.registerSuspenseInstanceRetry, ee = e.getNextHydratableSibling, pe = e.getFirstHydratableChild, Z = e.getFirstHydratableChildWithinContainer, ve = e.getFirstHydratableChildWithinSuspenseInstance, et = e.hydrateInstance, at = e.hydrateTextInstance, pt = e.hydrateSuspenseInstance, yt = e.getNextHydratableInstanceAfterSuspenseInstance, Et = e.commitHydratedContainer, St = e.commitHydratedSuspenseInstance, Mt = e.clearSuspenseBoundary, fn = e.clearSuspenseBoundaryFromContainer, ui = e.shouldDeleteUnhydratedTailInstances, br = e.didNotMatchHydratedContainerTextInstance, vs = e.didNotMatchHydratedTextInstance, Zt;
    function mt(u) {
        if (Zt === void 0)
            try {
                throw Error()
            } catch (g) {
                var f = g.stack.trim().match(/\n( *(at )?)/);
                Zt = f && f[1] || ""
            }
        return `
` + Zt + u
    }
    var xa = !1;
    function dn(u, f) {
        if (!u || xa)
            return "";
        xa = !0;
        var g = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            if (f)
                if (f = function() {
                    throw Error()
                }
                ,
                Object.defineProperty(f.prototype, "props", {
                    set: function() {
                        throw Error()
                    }
                }),
                typeof Reflect == "object" && Reflect.construct) {
                    try {
                        Reflect.construct(f, [])
                    } catch (Ee) {
                        var S = Ee
                    }
                    Reflect.construct(u, [], f)
                } else {
                    try {
                        f.call()
                    } catch (Ee) {
                        S = Ee
                    }
                    u.call(f.prototype)
                }
            else {
                try {
                    throw Error()
                } catch (Ee) {
                    S = Ee
                }
                u()
            }
        } catch (Ee) {
            if (Ee && S && typeof Ee.stack == "string") {
                for (var b = Ee.stack.split(`
`), T = S.stack.split(`
`), N = b.length - 1, J = T.length - 1; 1 <= N && 0 <= J && b[N] !== T[J]; )
                    J--;
                for (; 1 <= N && 0 <= J; N--,
                J--)
                    if (b[N] !== T[J]) {
                        if (N !== 1 || J !== 1)
                            do
                                if (N--,
                                J--,
                                0 > J || b[N] !== T[J]) {
                                    var fe = `
` + b[N].replace(" at new ", " at ");
                                    return u.displayName && fe.includes("<anonymous>") && (fe = fe.replace("<anonymous>", u.displayName)),
                                    fe
                                }
                            while (1 <= N && 0 <= J);
                        break
                    }
            }
        } finally {
            xa = !1,
            Error.prepareStackTrace = g
        }
        return (u = u ? u.displayName || u.name : "") ? mt(u) : ""
    }
    var ys = Object.prototype.hasOwnProperty
      , Fl = []
      , tr = -1;
    function nr(u) {
        return {
            current: u
        }
    }
    function dt(u) {
        0 > tr || (u.current = Fl[tr],
        Fl[tr] = null,
        tr--)
    }
    function Pt(u, f) {
        tr++,
        Fl[tr] = u.current,
        u.current = f
    }
    var ir = {}
      , Ot = nr(ir)
      , On = nr(!1)
      , xs = ir;
    function _s(u, f) {
        var g = u.type.contextTypes;
        if (!g)
            return ir;
        var S = u.stateNode;
        if (S && S.__reactInternalMemoizedUnmaskedChildContext === f)
            return S.__reactInternalMemoizedMaskedChildContext;
        var b = {}, T;
        for (T in g)
            b[T] = f[T];
        return S && (u = u.stateNode,
        u.__reactInternalMemoizedUnmaskedChildContext = f,
        u.__reactInternalMemoizedMaskedChildContext = b),
        b
    }
    function Si(u) {
        return u = u.childContextTypes,
        u != null
    }
    function Ph() {
        dt(On),
        dt(Ot)
    }
    function qS(u, f, g) {
        if (Ot.current !== ir)
            throw Error(o(168));
        Pt(Ot, f),
        Pt(On, g)
    }
    function $S(u, f, g) {
        var S = u.stateNode;
        if (f = f.childContextTypes,
        typeof S.getChildContext != "function")
            return g;
        S = S.getChildContext();
        for (var b in S)
            if (!(b in f))
                throw Error(o(108, E(u) || "Unknown", b));
        return s({}, g, S)
    }
    function Bh(u) {
        return u = (u = u.stateNode) && u.__reactInternalMemoizedMergedChildContext || ir,
        xs = Ot.current,
        Pt(Ot, u),
        Pt(On, On.current),
        !0
    }
    function eM(u, f, g) {
        var S = u.stateNode;
        if (!S)
            throw Error(o(169));
        g ? (u = $S(u, f, xs),
        S.__reactInternalMemoizedMergedChildContext = u,
        dt(On),
        dt(Ot),
        Pt(Ot, u)) : dt(On),
        Pt(On, g)
    }
    var Cr = Math.clz32 ? Math.clz32 : uk
      , ak = Math.log
      , lk = Math.LN2;
    function uk(u) {
        return u >>>= 0,
        u === 0 ? 32 : 31 - (ak(u) / lk | 0) | 0
    }
    var Rh = 64
      , Ih = 4194304;
    function Ic(u) {
        switch (u & -u) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return u & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return u & 130023424;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 1073741824;
        default:
            return u
        }
    }
    function Lh(u, f) {
        var g = u.pendingLanes;
        if (g === 0)
            return 0;
        var S = 0
          , b = u.suspendedLanes
          , T = u.pingedLanes
          , N = g & 268435455;
        if (N !== 0) {
            var J = N & ~b;
            J !== 0 ? S = Ic(J) : (T &= N,
            T !== 0 && (S = Ic(T)))
        } else
            N = g & ~b,
            N !== 0 ? S = Ic(N) : T !== 0 && (S = Ic(T));
        if (S === 0)
            return 0;
        if (f !== 0 && f !== S && !(f & b) && (b = S & -S,
        T = f & -f,
        b >= T || b === 16 && (T & 4194240) !== 0))
            return f;
        if (S & 4 && (S |= g & 16),
        f = u.entangledLanes,
        f !== 0)
            for (u = u.entanglements,
            f &= S; 0 < f; )
                g = 31 - Cr(f),
                b = 1 << g,
                S |= u[g],
                f &= ~b;
        return S
    }
    function ck(u, f) {
        switch (u) {
        case 1:
        case 2:
        case 4:
            return f + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return f + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
        }
    }
    function fk(u, f) {
        for (var g = u.suspendedLanes, S = u.pingedLanes, b = u.expirationTimes, T = u.pendingLanes; 0 < T; ) {
            var N = 31 - Cr(T)
              , J = 1 << N
              , fe = b[N];
            fe === -1 ? (!(J & g) || J & S) && (b[N] = ck(J, f)) : fe <= f && (u.expiredLanes |= J),
            T &= ~J
        }
    }
    function iv(u) {
        return u = u.pendingLanes & -1073741825,
        u !== 0 ? u : u & 1073741824 ? 1073741824 : 0
    }
    function rv(u) {
        for (var f = [], g = 0; 31 > g; g++)
            f.push(u);
        return f
    }
    function Lc(u, f, g) {
        u.pendingLanes |= f,
        f !== 536870912 && (u.suspendedLanes = 0,
        u.pingedLanes = 0),
        u = u.eventTimes,
        f = 31 - Cr(f),
        u[f] = g
    }
    function dk(u, f) {
        var g = u.pendingLanes & ~f;
        u.pendingLanes = f,
        u.suspendedLanes = 0,
        u.pingedLanes = 0,
        u.expiredLanes &= f,
        u.mutableReadLanes &= f,
        u.entangledLanes &= f,
        f = u.entanglements;
        var S = u.eventTimes;
        for (u = u.expirationTimes; 0 < g; ) {
            var b = 31 - Cr(g)
              , T = 1 << b;
            f[b] = 0,
            S[b] = -1,
            u[b] = -1,
            g &= ~T
        }
    }
    function sv(u, f) {
        var g = u.entangledLanes |= f;
        for (u = u.entanglements; g; ) {
            var S = 31 - Cr(g)
              , b = 1 << S;
            b & f | u[S] & f && (u[S] |= f),
            g &= ~b
        }
    }
    var Dt = 0;
    function tM(u) {
        return u &= -u,
        1 < u ? 4 < u ? u & 268435455 ? 16 : 536870912 : 4 : 1
    }
    var ov = r.unstable_scheduleCallback
      , nM = r.unstable_cancelCallback
      , hk = r.unstable_shouldYield
      , pk = r.unstable_requestPaint
      , Un = r.unstable_now
      , av = r.unstable_ImmediatePriority
      , mk = r.unstable_UserBlockingPriority
      , lv = r.unstable_NormalPriority
      , gk = r.unstable_IdlePriority
      , Dh = null
      , Qr = null;
    function vk(u) {
        if (Qr && typeof Qr.onCommitFiberRoot == "function")
            try {
                Qr.onCommitFiberRoot(Dh, u, void 0, (u.current.flags & 128) === 128)
            } catch {}
    }
    function yk(u, f) {
        return u === f && (u !== 0 || 1 / u === 1 / f) || u !== u && f !== f
    }
    var Zr = typeof Object.is == "function" ? Object.is : yk
      , As = null
      , kh = !1
      , uv = !1;
    function iM(u) {
        As === null ? As = [u] : As.push(u)
    }
    function xk(u) {
        kh = !0,
        iM(u)
    }
    function qr() {
        if (!uv && As !== null) {
            uv = !0;
            var u = 0
              , f = Dt;
            try {
                var g = As;
                for (Dt = 1; u < g.length; u++) {
                    var S = g[u];
                    do
                        S = S(!0);
                    while (S !== null)
                }
                As = null,
                kh = !1
            } catch (b) {
                throw As !== null && (As = As.slice(u + 1)),
                ov(av, qr),
                b
            } finally {
                Dt = f,
                uv = !1
            }
        }
        return null
    }
    var _k = a.ReactCurrentBatchConfig;
    function Fh(u, f) {
        if (Zr(u, f))
            return !0;
        if (typeof u != "object" || u === null || typeof f != "object" || f === null)
            return !1;
        var g = Object.keys(u)
          , S = Object.keys(f);
        if (g.length !== S.length)
            return !1;
        for (S = 0; S < g.length; S++) {
            var b = g[S];
            if (!ys.call(f, b) || !Zr(u[b], f[b]))
                return !1
        }
        return !0
    }
    function Ak(u) {
        switch (u.tag) {
        case 5:
            return mt(u.type);
        case 16:
            return mt("Lazy");
        case 13:
            return mt("Suspense");
        case 19:
            return mt("SuspenseList");
        case 0:
        case 2:
        case 15:
            return u = dn(u.type, !1),
            u;
        case 11:
            return u = dn(u.type.render, !1),
            u;
        case 1:
            return u = dn(u.type, !0),
            u;
        default:
            return ""
        }
    }
    function Er(u, f) {
        if (u && u.defaultProps) {
            f = s({}, f),
            u = u.defaultProps;
            for (var g in u)
                f[g] === void 0 && (f[g] = u[g]);
            return f
        }
        return f
    }
    var Nh = nr(null)
      , Oh = null
      , Nl = null
      , cv = null;
    function fv() {
        cv = Nl = Oh = null
    }
    function rM(u, f, g) {
        we ? (Pt(Nh, f._currentValue),
        f._currentValue = g) : (Pt(Nh, f._currentValue2),
        f._currentValue2 = g)
    }
    function dv(u) {
        var f = Nh.current;
        dt(Nh),
        we ? u._currentValue = f : u._currentValue2 = f
    }
    function hv(u, f, g) {
        for (; u !== null; ) {
            var S = u.alternate;
            if ((u.childLanes & f) !== f ? (u.childLanes |= f,
            S !== null && (S.childLanes |= f)) : S !== null && (S.childLanes & f) !== f && (S.childLanes |= f),
            u === g)
                break;
            u = u.return
        }
    }
    function Ol(u, f) {
        Oh = u,
        cv = Nl = null,
        u = u.dependencies,
        u !== null && u.firstContext !== null && (u.lanes & f && (Ni = !0),
        u.firstContext = null)
    }
    function rr(u) {
        var f = we ? u._currentValue : u._currentValue2;
        if (cv !== u)
            if (u = {
                context: u,
                memoizedValue: f,
                next: null
            },
            Nl === null) {
                if (Oh === null)
                    throw Error(o(308));
                Nl = u,
                Oh.dependencies = {
                    lanes: 0,
                    firstContext: u
                }
            } else
                Nl = Nl.next = u;
        return f
    }
    var $r = null
      , uo = !1;
    function pv(u) {
        u.updateQueue = {
            baseState: u.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                interleaved: null,
                lanes: 0
            },
            effects: null
        }
    }
    function sM(u, f) {
        u = u.updateQueue,
        f.updateQueue === u && (f.updateQueue = {
            baseState: u.baseState,
            firstBaseUpdate: u.firstBaseUpdate,
            lastBaseUpdate: u.lastBaseUpdate,
            shared: u.shared,
            effects: u.effects
        })
    }
    function ws(u, f) {
        return {
            eventTime: u,
            lane: f,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }
    function co(u, f) {
        var g = u.updateQueue;
        g !== null && (g = g.shared,
        Sn !== null && u.mode & 1 && !(xt & 2) ? (u = g.interleaved,
        u === null ? (f.next = f,
        $r === null ? $r = [g] : $r.push(g)) : (f.next = u.next,
        u.next = f),
        g.interleaved = f) : (u = g.pending,
        u === null ? f.next = f : (f.next = u.next,
        u.next = f),
        g.pending = f))
    }
    function Uh(u, f, g) {
        if (f = f.updateQueue,
        f !== null && (f = f.shared,
        (g & 4194240) !== 0)) {
            var S = f.lanes;
            S &= u.pendingLanes,
            g |= S,
            f.lanes = g,
            sv(u, g)
        }
    }
    function oM(u, f) {
        var g = u.updateQueue
          , S = u.alternate;
        if (S !== null && (S = S.updateQueue,
        g === S)) {
            var b = null
              , T = null;
            if (g = g.firstBaseUpdate,
            g !== null) {
                do {
                    var N = {
                        eventTime: g.eventTime,
                        lane: g.lane,
                        tag: g.tag,
                        payload: g.payload,
                        callback: g.callback,
                        next: null
                    };
                    T === null ? b = T = N : T = T.next = N,
                    g = g.next
                } while (g !== null);
                T === null ? b = T = f : T = T.next = f
            } else
                b = T = f;
            g = {
                baseState: S.baseState,
                firstBaseUpdate: b,
                lastBaseUpdate: T,
                shared: S.shared,
                effects: S.effects
            },
            u.updateQueue = g;
            return
        }
        u = g.lastBaseUpdate,
        u === null ? g.firstBaseUpdate = f : u.next = f,
        g.lastBaseUpdate = f
    }
    function zh(u, f, g, S) {
        var b = u.updateQueue;
        uo = !1;
        var T = b.firstBaseUpdate
          , N = b.lastBaseUpdate
          , J = b.shared.pending;
        if (J !== null) {
            b.shared.pending = null;
            var fe = J
              , Ee = fe.next;
            fe.next = null,
            N === null ? T = Ee : N.next = Ee,
            N = fe;
            var We = u.alternate;
            We !== null && (We = We.updateQueue,
            J = We.lastBaseUpdate,
            J !== N && (J === null ? We.firstBaseUpdate = Ee : J.next = Ee,
            We.lastBaseUpdate = fe))
        }
        if (T !== null) {
            var lt = b.baseState;
            N = 0,
            We = Ee = fe = null,
            J = T;
            do {
                var nt = J.lane
                  , Ht = J.eventTime;
                if ((S & nt) === nt) {
                    We !== null && (We = We.next = {
                        eventTime: Ht,
                        lane: 0,
                        tag: J.tag,
                        payload: J.payload,
                        callback: J.callback,
                        next: null
                    });
                    e: {
                        var qe = u
                          , ti = J;
                        switch (nt = f,
                        Ht = g,
                        ti.tag) {
                        case 1:
                            if (qe = ti.payload,
                            typeof qe == "function") {
                                lt = qe.call(Ht, lt, nt);
                                break e
                            }
                            lt = qe;
                            break e;
                        case 3:
                            qe.flags = qe.flags & -65537 | 128;
                        case 0:
                            if (qe = ti.payload,
                            nt = typeof qe == "function" ? qe.call(Ht, lt, nt) : qe,
                            nt == null)
                                break e;
                            lt = s({}, lt, nt);
                            break e;
                        case 2:
                            uo = !0
                        }
                    }
                    J.callback !== null && J.lane !== 0 && (u.flags |= 64,
                    nt = b.effects,
                    nt === null ? b.effects = [J] : nt.push(J))
                } else
                    Ht = {
                        eventTime: Ht,
                        lane: nt,
                        tag: J.tag,
                        payload: J.payload,
                        callback: J.callback,
                        next: null
                    },
                    We === null ? (Ee = We = Ht,
                    fe = lt) : We = We.next = Ht,
                    N |= nt;
                if (J = J.next,
                J === null) {
                    if (J = b.shared.pending,
                    J === null)
                        break;
                    nt = J,
                    J = nt.next,
                    nt.next = null,
                    b.lastBaseUpdate = nt,
                    b.shared.pending = null
                }
            } while (1);
            if (We === null && (fe = lt),
            b.baseState = fe,
            b.firstBaseUpdate = Ee,
            b.lastBaseUpdate = We,
            f = b.shared.interleaved,
            f !== null) {
                b = f;
                do
                    N |= b.lane,
                    b = b.next;
                while (b !== f)
            } else
                T === null && (b.shared.lanes = 0);
            Xl |= N,
            u.lanes = N,
            u.memoizedState = lt
        }
    }
    function aM(u, f, g) {
        if (u = f.effects,
        f.effects = null,
        u !== null)
            for (f = 0; f < u.length; f++) {
                var S = u[f]
                  , b = S.callback;
                if (b !== null) {
                    if (S.callback = null,
                    S = g,
                    typeof b != "function")
                        throw Error(o(191, b));
                    b.call(S)
                }
            }
    }
    var lM = new i.Component().refs;
    function mv(u, f, g, S) {
        f = u.memoizedState,
        g = g(S, f),
        g = g == null ? f : s({}, f, g),
        u.memoizedState = g,
        u.lanes === 0 && (u.updateQueue.baseState = g)
    }
    var Gh = {
        isMounted: function(u) {
            return (u = u._reactInternals) ? B(u) === u : !1
        },
        enqueueSetState: function(u, f, g) {
            u = u._reactInternals;
            var S = fi()
              , b = po(u)
              , T = ws(S, b);
            T.payload = f,
            g != null && (T.callback = g),
            co(u, T),
            f = ur(u, b, S),
            f !== null && Uh(f, u, b)
        },
        enqueueReplaceState: function(u, f, g) {
            u = u._reactInternals;
            var S = fi()
              , b = po(u)
              , T = ws(S, b);
            T.tag = 1,
            T.payload = f,
            g != null && (T.callback = g),
            co(u, T),
            f = ur(u, b, S),
            f !== null && Uh(f, u, b)
        },
        enqueueForceUpdate: function(u, f) {
            u = u._reactInternals;
            var g = fi()
              , S = po(u)
              , b = ws(g, S);
            b.tag = 2,
            f != null && (b.callback = f),
            co(u, b),
            f = ur(u, S, g),
            f !== null && Uh(f, u, S)
        }
    };
    function uM(u, f, g, S, b, T, N) {
        return u = u.stateNode,
        typeof u.shouldComponentUpdate == "function" ? u.shouldComponentUpdate(S, T, N) : f.prototype && f.prototype.isPureReactComponent ? !Fh(g, S) || !Fh(b, T) : !0
    }
    function cM(u, f, g) {
        var S = !1
          , b = ir
          , T = f.contextType;
        return typeof T == "object" && T !== null ? T = rr(T) : (b = Si(f) ? xs : Ot.current,
        S = f.contextTypes,
        T = (S = S != null) ? _s(u, b) : ir),
        f = new f(g,T),
        u.memoizedState = f.state !== null && f.state !== void 0 ? f.state : null,
        f.updater = Gh,
        u.stateNode = f,
        f._reactInternals = u,
        S && (u = u.stateNode,
        u.__reactInternalMemoizedUnmaskedChildContext = b,
        u.__reactInternalMemoizedMaskedChildContext = T),
        f
    }
    function fM(u, f, g, S) {
        u = f.state,
        typeof f.componentWillReceiveProps == "function" && f.componentWillReceiveProps(g, S),
        typeof f.UNSAFE_componentWillReceiveProps == "function" && f.UNSAFE_componentWillReceiveProps(g, S),
        f.state !== u && Gh.enqueueReplaceState(f, f.state, null)
    }
    function gv(u, f, g, S) {
        var b = u.stateNode;
        b.props = g,
        b.state = u.memoizedState,
        b.refs = lM,
        pv(u);
        var T = f.contextType;
        typeof T == "object" && T !== null ? b.context = rr(T) : (T = Si(f) ? xs : Ot.current,
        b.context = _s(u, T)),
        b.state = u.memoizedState,
        T = f.getDerivedStateFromProps,
        typeof T == "function" && (mv(u, f, T, g),
        b.state = u.memoizedState),
        typeof f.getDerivedStateFromProps == "function" || typeof b.getSnapshotBeforeUpdate == "function" || typeof b.UNSAFE_componentWillMount != "function" && typeof b.componentWillMount != "function" || (f = b.state,
        typeof b.componentWillMount == "function" && b.componentWillMount(),
        typeof b.UNSAFE_componentWillMount == "function" && b.UNSAFE_componentWillMount(),
        f !== b.state && Gh.enqueueReplaceState(b, b.state, null),
        zh(u, g, b, S),
        b.state = u.memoizedState),
        typeof b.componentDidMount == "function" && (u.flags |= 4194308)
    }
    var Ul = []
      , zl = 0
      , Hh = null
      , Vh = 0
      , sr = []
      , or = 0
      , _a = null
      , Ss = 1
      , Ms = "";
    function Aa(u, f) {
        Ul[zl++] = Vh,
        Ul[zl++] = Hh,
        Hh = u,
        Vh = f
    }
    function dM(u, f, g) {
        sr[or++] = Ss,
        sr[or++] = Ms,
        sr[or++] = _a,
        _a = u;
        var S = Ss;
        u = Ms;
        var b = 32 - Cr(S) - 1;
        S &= ~(1 << b),
        g += 1;
        var T = 32 - Cr(f) + b;
        if (30 < T) {
            var N = b - b % 5;
            T = (S & (1 << N) - 1).toString(32),
            S >>= N,
            b -= N,
            Ss = 1 << 32 - Cr(f) + b | g << b | S,
            Ms = T + u
        } else
            Ss = 1 << T | g << b | S,
            Ms = u
    }
    function vv(u) {
        u.return !== null && (Aa(u, 1),
        dM(u, 1, 0))
    }
    function yv(u) {
        for (; u === Hh; )
            Hh = Ul[--zl],
            Ul[zl] = null,
            Vh = Ul[--zl],
            Ul[zl] = null;
        for (; u === _a; )
            _a = sr[--or],
            sr[or] = null,
            Ms = sr[--or],
            sr[or] = null,
            Ss = sr[--or],
            sr[or] = null
    }
    var ki = null
      , Fi = null
      , qt = !1
      , Dc = !1
      , Tr = null;
    function hM(u, f) {
        var g = cr(5, null, null, 0);
        g.elementType = "DELETED",
        g.stateNode = f,
        g.return = u,
        f = u.deletions,
        f === null ? (u.deletions = [g],
        u.flags |= 16) : f.push(g)
    }
    function pM(u, f) {
        switch (u.tag) {
        case 5:
            return f = wi(f, u.type, u.pendingProps),
            f !== null ? (u.stateNode = f,
            ki = u,
            Fi = pe(f),
            !0) : !1;
        case 6:
            return f = Eh(f, u.pendingProps),
            f !== null ? (u.stateNode = f,
            ki = u,
            Fi = null,
            !0) : !1;
        case 13:
            if (f = nv(f),
            f !== null) {
                var g = _a !== null ? {
                    id: Ss,
                    overflow: Ms
                } : null;
                return u.memoizedState = {
                    dehydrated: f,
                    treeContext: g,
                    retryLane: 1073741824
                },
                g = cr(18, null, null, 0),
                g.stateNode = f,
                g.return = u,
                u.child = g,
                ki = u,
                Fi = null,
                !0
            }
            return !1;
        default:
            return !1
        }
    }
    function xv(u) {
        return (u.mode & 1) !== 0 && (u.flags & 128) === 0
    }
    function _v(u) {
        if (qt) {
            var f = Fi;
            if (f) {
                var g = f;
                if (!pM(u, f)) {
                    if (xv(u))
                        throw Error(o(418));
                    f = ee(g);
                    var S = ki;
                    f && pM(u, f) ? hM(S, g) : (u.flags = u.flags & -4097 | 2,
                    qt = !1,
                    ki = u)
                }
            } else {
                if (xv(u))
                    throw Error(o(418));
                u.flags = u.flags & -4097 | 2,
                qt = !1,
                ki = u
            }
        }
    }
    function mM(u) {
        for (u = u.return; u !== null && u.tag !== 5 && u.tag !== 3 && u.tag !== 13; )
            u = u.return;
        ki = u
    }
    function kc(u) {
        if (!ae || u !== ki)
            return !1;
        if (!qt)
            return mM(u),
            qt = !0,
            !1;
        if (u.tag !== 3 && (u.tag !== 5 || ui(u.type) && !_e(u.type, u.memoizedProps))) {
            var f = Fi;
            if (f) {
                if (xv(u)) {
                    for (u = Fi; u; )
                        u = ee(u);
                    throw Error(o(418))
                }
                for (; f; )
                    hM(u, f),
                    f = ee(f)
            }
        }
        if (mM(u),
        u.tag === 13) {
            if (!ae)
                throw Error(o(316));
            if (u = u.memoizedState,
            u = u !== null ? u.dehydrated : null,
            !u)
                throw Error(o(317));
            Fi = yt(u)
        } else
            Fi = ki ? ee(u.stateNode) : null;
        return !0
    }
    function Gl() {
        ae && (Fi = ki = null,
        Dc = qt = !1)
    }
    function Av(u) {
        Tr === null ? Tr = [u] : Tr.push(u)
    }
    function Fc(u, f, g) {
        if (u = g.ref,
        u !== null && typeof u != "function" && typeof u != "object") {
            if (g._owner) {
                if (g = g._owner,
                g) {
                    if (g.tag !== 1)
                        throw Error(o(309));
                    var S = g.stateNode
                }
                if (!S)
                    throw Error(o(147, u));
                var b = S
                  , T = "" + u;
                return f !== null && f.ref !== null && typeof f.ref == "function" && f.ref._stringRef === T ? f.ref : (f = function(N) {
                    var J = b.refs;
                    J === lM && (J = b.refs = {}),
                    N === null ? delete J[T] : J[T] = N
                }
                ,
                f._stringRef = T,
                f)
            }
            if (typeof u != "string")
                throw Error(o(284));
            if (!g._owner)
                throw Error(o(290, u))
        }
        return u
    }
    function Wh(u, f) {
        throw u = Object.prototype.toString.call(f),
        Error(o(31, u === "[object Object]" ? "object with keys {" + Object.keys(f).join(", ") + "}" : u))
    }
    function gM(u) {
        var f = u._init;
        return f(u._payload)
    }
    function vM(u) {
        function f(te, Q) {
            if (u) {
                var ue = te.deletions;
                ue === null ? (te.deletions = [Q],
                te.flags |= 16) : ue.push(Q)
            }
        }
        function g(te, Q) {
            if (!u)
                return null;
            for (; Q !== null; )
                f(te, Q),
                Q = Q.sibling;
            return null
        }
        function S(te, Q) {
            for (te = new Map; Q !== null; )
                Q.key !== null ? te.set(Q.key, Q) : te.set(Q.index, Q),
                Q = Q.sibling;
            return te
        }
        function b(te, Q) {
            return te = go(te, Q),
            te.index = 0,
            te.sibling = null,
            te
        }
        function T(te, Q, ue) {
            return te.index = ue,
            u ? (ue = te.alternate,
            ue !== null ? (ue = ue.index,
            ue < Q ? (te.flags |= 2,
            Q) : ue) : (te.flags |= 2,
            Q)) : (te.flags |= 1048576,
            Q)
        }
        function N(te) {
            return u && te.alternate === null && (te.flags |= 2),
            te
        }
        function J(te, Q, ue, Fe) {
            return Q === null || Q.tag !== 6 ? (Q = ry(ue, te.mode, Fe),
            Q.return = te,
            Q) : (Q = b(Q, ue),
            Q.return = te,
            Q)
        }
        function fe(te, Q, ue, Fe) {
            var Qe = ue.type;
            return Qe === d ? We(te, Q, ue.props.children, Fe, ue.key) : Q !== null && (Q.elementType === Qe || typeof Qe == "object" && Qe !== null && Qe.$$typeof === w && gM(Qe) === Q.type) ? (Fe = b(Q, ue.props),
            Fe.ref = Fc(te, Q, ue),
            Fe.return = te,
            Fe) : (Fe = Ap(ue.type, ue.key, ue.props, null, te.mode, Fe),
            Fe.ref = Fc(te, Q, ue),
            Fe.return = te,
            Fe)
        }
        function Ee(te, Q, ue, Fe) {
            return Q === null || Q.tag !== 4 || Q.stateNode.containerInfo !== ue.containerInfo || Q.stateNode.implementation !== ue.implementation ? (Q = sy(ue, te.mode, Fe),
            Q.return = te,
            Q) : (Q = b(Q, ue.children || []),
            Q.return = te,
            Q)
        }
        function We(te, Q, ue, Fe, Qe) {
            return Q === null || Q.tag !== 7 ? (Q = Ta(ue, te.mode, Fe, Qe),
            Q.return = te,
            Q) : (Q = b(Q, ue),
            Q.return = te,
            Q)
        }
        function lt(te, Q, ue) {
            if (typeof Q == "string" && Q !== "" || typeof Q == "number")
                return Q = ry("" + Q, te.mode, ue),
                Q.return = te,
                Q;
            if (typeof Q == "object" && Q !== null) {
                switch (Q.$$typeof) {
                case l:
                    return ue = Ap(Q.type, Q.key, Q.props, null, te.mode, ue),
                    ue.ref = Fc(te, null, Q),
                    ue.return = te,
                    ue;
                case c:
                    return Q = sy(Q, te.mode, ue),
                    Q.return = te,
                    Q;
                case w:
                    var Fe = Q._init;
                    return lt(te, Fe(Q._payload), ue)
                }
                if (K(Q) || P(Q))
                    return Q = Ta(Q, te.mode, ue, null),
                    Q.return = te,
                    Q;
                Wh(te, Q)
            }
            return null
        }
        function nt(te, Q, ue, Fe) {
            var Qe = Q !== null ? Q.key : null;
            if (typeof ue == "string" && ue !== "" || typeof ue == "number")
                return Qe !== null ? null : J(te, Q, "" + ue, Fe);
            if (typeof ue == "object" && ue !== null) {
                switch (ue.$$typeof) {
                case l:
                    return ue.key === Qe ? fe(te, Q, ue, Fe) : null;
                case c:
                    return ue.key === Qe ? Ee(te, Q, ue, Fe) : null;
                case w:
                    return Qe = ue._init,
                    nt(te, Q, Qe(ue._payload), Fe)
                }
                if (K(ue) || P(ue))
                    return Qe !== null ? null : We(te, Q, ue, Fe, null);
                Wh(te, ue)
            }
            return null
        }
        function Ht(te, Q, ue, Fe, Qe) {
            if (typeof Fe == "string" && Fe !== "" || typeof Fe == "number")
                return te = te.get(ue) || null,
                J(Q, te, "" + Fe, Qe);
            if (typeof Fe == "object" && Fe !== null) {
                switch (Fe.$$typeof) {
                case l:
                    return te = te.get(Fe.key === null ? ue : Fe.key) || null,
                    fe(Q, te, Fe, Qe);
                case c:
                    return te = te.get(Fe.key === null ? ue : Fe.key) || null,
                    Ee(Q, te, Fe, Qe);
                case w:
                    var gt = Fe._init;
                    return Ht(te, Q, ue, gt(Fe._payload), Qe)
                }
                if (K(Fe) || P(Fe))
                    return te = te.get(ue) || null,
                    We(Q, te, Fe, Qe, null);
                Wh(Q, Fe)
            }
            return null
        }
        function qe(te, Q, ue, Fe) {
            for (var Qe = null, gt = null, ut = Q, kt = Q = 0, Gn = null; ut !== null && kt < ue.length; kt++) {
                ut.index > kt ? (Gn = ut,
                ut = null) : Gn = ut.sibling;
                var Ft = nt(te, ut, ue[kt], Fe);
                if (Ft === null) {
                    ut === null && (ut = Gn);
                    break
                }
                u && ut && Ft.alternate === null && f(te, ut),
                Q = T(Ft, Q, kt),
                gt === null ? Qe = Ft : gt.sibling = Ft,
                gt = Ft,
                ut = Gn
            }
            if (kt === ue.length)
                return g(te, ut),
                qt && Aa(te, kt),
                Qe;
            if (ut === null) {
                for (; kt < ue.length; kt++)
                    ut = lt(te, ue[kt], Fe),
                    ut !== null && (Q = T(ut, Q, kt),
                    gt === null ? Qe = ut : gt.sibling = ut,
                    gt = ut);
                return qt && Aa(te, kt),
                Qe
            }
            for (ut = S(te, ut); kt < ue.length; kt++)
                Gn = Ht(ut, te, kt, ue[kt], Fe),
                Gn !== null && (u && Gn.alternate !== null && ut.delete(Gn.key === null ? kt : Gn.key),
                Q = T(Gn, Q, kt),
                gt === null ? Qe = Gn : gt.sibling = Gn,
                gt = Gn);
            return u && ut.forEach(function(vo) {
                return f(te, vo)
            }),
            qt && Aa(te, kt),
            Qe
        }
        function ti(te, Q, ue, Fe) {
            var Qe = P(ue);
            if (typeof Qe != "function")
                throw Error(o(150));
            if (ue = Qe.call(ue),
            ue == null)
                throw Error(o(151));
            for (var gt = Qe = null, ut = Q, kt = Q = 0, Gn = null, Ft = ue.next(); ut !== null && !Ft.done; kt++,
            Ft = ue.next()) {
                ut.index > kt ? (Gn = ut,
                ut = null) : Gn = ut.sibling;
                var vo = nt(te, ut, Ft.value, Fe);
                if (vo === null) {
                    ut === null && (ut = Gn);
                    break
                }
                u && ut && vo.alternate === null && f(te, ut),
                Q = T(vo, Q, kt),
                gt === null ? Qe = vo : gt.sibling = vo,
                gt = vo,
                ut = Gn
            }
            if (Ft.done)
                return g(te, ut),
                qt && Aa(te, kt),
                Qe;
            if (ut === null) {
                for (; !Ft.done; kt++,
                Ft = ue.next())
                    Ft = lt(te, Ft.value, Fe),
                    Ft !== null && (Q = T(Ft, Q, kt),
                    gt === null ? Qe = Ft : gt.sibling = Ft,
                    gt = Ft);
                return qt && Aa(te, kt),
                Qe
            }
            for (ut = S(te, ut); !Ft.done; kt++,
            Ft = ue.next())
                Ft = Ht(ut, te, kt, Ft.value, Fe),
                Ft !== null && (u && Ft.alternate !== null && ut.delete(Ft.key === null ? kt : Ft.key),
                Q = T(Ft, Q, kt),
                gt === null ? Qe = Ft : gt.sibling = Ft,
                gt = Ft);
            return u && ut.forEach(function(Zk) {
                return f(te, Zk)
            }),
            qt && Aa(te, kt),
            Qe
        }
        function fr(te, Q, ue, Fe) {
            if (typeof ue == "object" && ue !== null && ue.type === d && ue.key === null && (ue = ue.props.children),
            typeof ue == "object" && ue !== null) {
                switch (ue.$$typeof) {
                case l:
                    e: {
                        for (var Qe = ue.key, gt = Q; gt !== null; ) {
                            if (gt.key === Qe) {
                                if (Qe = ue.type,
                                Qe === d) {
                                    if (gt.tag === 7) {
                                        g(te, gt.sibling),
                                        Q = b(gt, ue.props.children),
                                        Q.return = te,
                                        te = Q;
                                        break e
                                    }
                                } else if (gt.elementType === Qe || typeof Qe == "object" && Qe !== null && Qe.$$typeof === w && gM(Qe) === gt.type) {
                                    g(te, gt.sibling),
                                    Q = b(gt, ue.props),
                                    Q.ref = Fc(te, gt, ue),
                                    Q.return = te,
                                    te = Q;
                                    break e
                                }
                                g(te, gt);
                                break
                            } else
                                f(te, gt);
                            gt = gt.sibling
                        }
                        ue.type === d ? (Q = Ta(ue.props.children, te.mode, Fe, ue.key),
                        Q.return = te,
                        te = Q) : (Fe = Ap(ue.type, ue.key, ue.props, null, te.mode, Fe),
                        Fe.ref = Fc(te, Q, ue),
                        Fe.return = te,
                        te = Fe)
                    }
                    return N(te);
                case c:
                    e: {
                        for (gt = ue.key; Q !== null; ) {
                            if (Q.key === gt)
                                if (Q.tag === 4 && Q.stateNode.containerInfo === ue.containerInfo && Q.stateNode.implementation === ue.implementation) {
                                    g(te, Q.sibling),
                                    Q = b(Q, ue.children || []),
                                    Q.return = te,
                                    te = Q;
                                    break e
                                } else {
                                    g(te, Q);
                                    break
                                }
                            else
                                f(te, Q);
                            Q = Q.sibling
                        }
                        Q = sy(ue, te.mode, Fe),
                        Q.return = te,
                        te = Q
                    }
                    return N(te);
                case w:
                    return gt = ue._init,
                    fr(te, Q, gt(ue._payload), Fe)
                }
                if (K(ue))
                    return qe(te, Q, ue, Fe);
                if (P(ue))
                    return ti(te, Q, ue, Fe);
                Wh(te, ue)
            }
            return typeof ue == "string" && ue !== "" || typeof ue == "number" ? (ue = "" + ue,
            Q !== null && Q.tag === 6 ? (g(te, Q.sibling),
            Q = b(Q, ue),
            Q.return = te,
            te = Q) : (g(te, Q),
            Q = ry(ue, te.mode, Fe),
            Q.return = te,
            te = Q),
            N(te)) : g(te, Q)
        }
        return fr
    }
    var Hl = vM(!0)
      , yM = vM(!1)
      , Nc = {}
      , ar = nr(Nc)
      , Oc = nr(Nc)
      , Vl = nr(Nc);
    function es(u) {
        if (u === Nc)
            throw Error(o(174));
        return u
    }
    function wv(u, f) {
        Pt(Vl, f),
        Pt(Oc, u),
        Pt(ar, Nc),
        u = oe(f),
        dt(ar),
        Pt(ar, u)
    }
    function Wl() {
        dt(ar),
        dt(Oc),
        dt(Vl)
    }
    function xM(u) {
        var f = es(Vl.current)
          , g = es(ar.current);
        f = F(g, u.type, f),
        g !== f && (Pt(Oc, u),
        Pt(ar, f))
    }
    function Sv(u) {
        Oc.current === u && (dt(ar),
        dt(Oc))
    }
    var nn = nr(0);
    function jh(u) {
        for (var f = u; f !== null; ) {
            if (f.tag === 13) {
                var g = f.memoizedState;
                if (g !== null && (g = g.dehydrated,
                g === null || Th(g) || Rc(g)))
                    return f
            } else if (f.tag === 19 && f.memoizedProps.revealOrder !== void 0) {
                if (f.flags & 128)
                    return f
            } else if (f.child !== null) {
                f.child.return = f,
                f = f.child;
                continue
            }
            if (f === u)
                break;
            for (; f.sibling === null; ) {
                if (f.return === null || f.return === u)
                    return null;
                f = f.return
            }
            f.sibling.return = f.return,
            f = f.sibling
        }
        return null
    }
    var Mv = [];
    function bv() {
        for (var u = 0; u < Mv.length; u++) {
            var f = Mv[u];
            we ? f._workInProgressVersionPrimary = null : f._workInProgressVersionSecondary = null
        }
        Mv.length = 0
    }
    var Jh = a.ReactCurrentDispatcher
      , lr = a.ReactCurrentBatchConfig
      , jl = 0
      , hn = null
      , qn = null
      , zn = null
      , Xh = !1
      , Uc = !1
      , zc = 0
      , wk = 0;
    function $n() {
        throw Error(o(321))
    }
    function Cv(u, f) {
        if (f === null)
            return !1;
        for (var g = 0; g < f.length && g < u.length; g++)
            if (!Zr(u[g], f[g]))
                return !1;
        return !0
    }
    function Ev(u, f, g, S, b, T) {
        if (jl = T,
        hn = f,
        f.memoizedState = null,
        f.updateQueue = null,
        f.lanes = 0,
        Jh.current = u === null || u.memoizedState === null ? Ck : Ek,
        u = g(S, b),
        Uc) {
            T = 0;
            do {
                if (Uc = !1,
                zc = 0,
                25 <= T)
                    throw Error(o(301));
                T += 1,
                zn = qn = null,
                f.updateQueue = null,
                Jh.current = Tk,
                u = g(S, b)
            } while (Uc)
        }
        if (Jh.current = qh,
        f = qn !== null && qn.next !== null,
        jl = 0,
        zn = qn = hn = null,
        Xh = !1,
        f)
            throw Error(o(300));
        return u
    }
    function Tv() {
        var u = zc !== 0;
        return zc = 0,
        u
    }
    function bs() {
        var u = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return zn === null ? hn.memoizedState = zn = u : zn = zn.next = u,
        zn
    }
    function ts() {
        if (qn === null) {
            var u = hn.alternate;
            u = u !== null ? u.memoizedState : null
        } else
            u = qn.next;
        var f = zn === null ? hn.memoizedState : zn.next;
        if (f !== null)
            zn = f,
            qn = u;
        else {
            if (u === null)
                throw Error(o(310));
            qn = u,
            u = {
                memoizedState: qn.memoizedState,
                baseState: qn.baseState,
                baseQueue: qn.baseQueue,
                queue: qn.queue,
                next: null
            },
            zn === null ? hn.memoizedState = zn = u : zn = zn.next = u
        }
        return zn
    }
    function wa(u, f) {
        return typeof f == "function" ? f(u) : f
    }
    function Yh(u) {
        var f = ts()
          , g = f.queue;
        if (g === null)
            throw Error(o(311));
        g.lastRenderedReducer = u;
        var S = qn
          , b = S.baseQueue
          , T = g.pending;
        if (T !== null) {
            if (b !== null) {
                var N = b.next;
                b.next = T.next,
                T.next = N
            }
            S.baseQueue = b = T,
            g.pending = null
        }
        if (b !== null) {
            T = b.next,
            S = S.baseState;
            var J = N = null
              , fe = null
              , Ee = T;
            do {
                var We = Ee.lane;
                if ((jl & We) === We)
                    fe !== null && (fe = fe.next = {
                        lane: 0,
                        action: Ee.action,
                        hasEagerState: Ee.hasEagerState,
                        eagerState: Ee.eagerState,
                        next: null
                    }),
                    S = Ee.hasEagerState ? Ee.eagerState : u(S, Ee.action);
                else {
                    var lt = {
                        lane: We,
                        action: Ee.action,
                        hasEagerState: Ee.hasEagerState,
                        eagerState: Ee.eagerState,
                        next: null
                    };
                    fe === null ? (J = fe = lt,
                    N = S) : fe = fe.next = lt,
                    hn.lanes |= We,
                    Xl |= We
                }
                Ee = Ee.next
            } while (Ee !== null && Ee !== T);
            fe === null ? N = S : fe.next = J,
            Zr(S, f.memoizedState) || (Ni = !0),
            f.memoizedState = S,
            f.baseState = N,
            f.baseQueue = fe,
            g.lastRenderedState = S
        }
        if (u = g.interleaved,
        u !== null) {
            b = u;
            do
                T = b.lane,
                hn.lanes |= T,
                Xl |= T,
                b = b.next;
            while (b !== u)
        } else
            b === null && (g.lanes = 0);
        return [f.memoizedState, g.dispatch]
    }
    function Kh(u) {
        var f = ts()
          , g = f.queue;
        if (g === null)
            throw Error(o(311));
        g.lastRenderedReducer = u;
        var S = g.dispatch
          , b = g.pending
          , T = f.memoizedState;
        if (b !== null) {
            g.pending = null;
            var N = b = b.next;
            do
                T = u(T, N.action),
                N = N.next;
            while (N !== b);
            Zr(T, f.memoizedState) || (Ni = !0),
            f.memoizedState = T,
            f.baseQueue === null && (f.baseState = T),
            g.lastRenderedState = T
        }
        return [T, S]
    }
    function _M() {}
    function AM(u, f) {
        var g = hn
          , S = ts()
          , b = f()
          , T = !Zr(S.memoizedState, b);
        if (T && (S.memoizedState = b,
        Ni = !0),
        S = S.queue,
        Hc(MM.bind(null, g, S, u), [u]),
        S.getSnapshot !== f || T || zn !== null && zn.memoizedState.tag & 1) {
            if (g.flags |= 2048,
            Gc(9, SM.bind(null, g, S, b, f), void 0, null),
            Sn === null)
                throw Error(o(349));
            jl & 30 || wM(g, f, b)
        }
        return b
    }
    function wM(u, f, g) {
        u.flags |= 16384,
        u = {
            getSnapshot: f,
            value: g
        },
        f = hn.updateQueue,
        f === null ? (f = {
            lastEffect: null,
            stores: null
        },
        hn.updateQueue = f,
        f.stores = [u]) : (g = f.stores,
        g === null ? f.stores = [u] : g.push(u))
    }
    function SM(u, f, g, S) {
        f.value = g,
        f.getSnapshot = S,
        bM(f) && ur(u, 1, -1)
    }
    function MM(u, f, g) {
        return g(function() {
            bM(f) && ur(u, 1, -1)
        })
    }
    function bM(u) {
        var f = u.getSnapshot;
        u = u.value;
        try {
            var g = f();
            return !Zr(u, g)
        } catch {
            return !0
        }
    }
    function Pv(u) {
        var f = bs();
        return typeof u == "function" && (u = u()),
        f.memoizedState = f.baseState = u,
        u = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: wa,
            lastRenderedState: u
        },
        f.queue = u,
        u = u.dispatch = bk.bind(null, hn, u),
        [f.memoizedState, u]
    }
    function Gc(u, f, g, S) {
        return u = {
            tag: u,
            create: f,
            destroy: g,
            deps: S,
            next: null
        },
        f = hn.updateQueue,
        f === null ? (f = {
            lastEffect: null,
            stores: null
        },
        hn.updateQueue = f,
        f.lastEffect = u.next = u) : (g = f.lastEffect,
        g === null ? f.lastEffect = u.next = u : (S = g.next,
        g.next = u,
        u.next = S,
        f.lastEffect = u)),
        u
    }
    function CM() {
        return ts().memoizedState
    }
    function Qh(u, f, g, S) {
        var b = bs();
        hn.flags |= u,
        b.memoizedState = Gc(1 | f, g, void 0, S === void 0 ? null : S)
    }
    function Zh(u, f, g, S) {
        var b = ts();
        S = S === void 0 ? null : S;
        var T = void 0;
        if (qn !== null) {
            var N = qn.memoizedState;
            if (T = N.destroy,
            S !== null && Cv(S, N.deps)) {
                b.memoizedState = Gc(f, g, T, S);
                return
            }
        }
        hn.flags |= u,
        b.memoizedState = Gc(1 | f, g, T, S)
    }
    function Bv(u, f) {
        return Qh(8390656, 8, u, f)
    }
    function Hc(u, f) {
        return Zh(2048, 8, u, f)
    }
    function EM(u, f) {
        return Zh(4, 2, u, f)
    }
    function TM(u, f) {
        return Zh(4, 4, u, f)
    }
    function PM(u, f) {
        if (typeof f == "function")
            return u = u(),
            f(u),
            function() {
                f(null)
            }
            ;
        if (f != null)
            return u = u(),
            f.current = u,
            function() {
                f.current = null
            }
    }
    function BM(u, f, g) {
        return g = g != null ? g.concat([u]) : null,
        Zh(4, 4, PM.bind(null, f, u), g)
    }
    function Rv() {}
    function RM(u, f) {
        var g = ts();
        f = f === void 0 ? null : f;
        var S = g.memoizedState;
        return S !== null && f !== null && Cv(f, S[1]) ? S[0] : (g.memoizedState = [u, f],
        u)
    }
    function IM(u, f) {
        var g = ts();
        f = f === void 0 ? null : f;
        var S = g.memoizedState;
        return S !== null && f !== null && Cv(f, S[1]) ? S[0] : (u = u(),
        g.memoizedState = [u, f],
        u)
    }
    function Sk(u, f) {
        var g = Dt;
        Dt = g !== 0 && 4 > g ? g : 4,
        u(!0);
        var S = lr.transition;
        lr.transition = {};
        try {
            u(!1),
            f()
        } finally {
            Dt = g,
            lr.transition = S
        }
    }
    function LM() {
        return ts().memoizedState
    }
    function Mk(u, f, g) {
        var S = po(u);
        g = {
            lane: S,
            action: g,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        DM(u) ? kM(f, g) : (FM(u, f, g),
        g = fi(),
        u = ur(u, S, g),
        u !== null && NM(u, f, S))
    }
    function bk(u, f, g) {
        var S = po(u)
          , b = {
            lane: S,
            action: g,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
        if (DM(u))
            kM(f, b);
        else {
            FM(u, f, b);
            var T = u.alternate;
            if (u.lanes === 0 && (T === null || T.lanes === 0) && (T = f.lastRenderedReducer,
            T !== null))
                try {
                    var N = f.lastRenderedState
                      , J = T(N, g);
                    if (b.hasEagerState = !0,
                    b.eagerState = J,
                    Zr(J, N))
                        return
                } catch {} finally {}
            g = fi(),
            u = ur(u, S, g),
            u !== null && NM(u, f, S)
        }
    }
    function DM(u) {
        var f = u.alternate;
        return u === hn || f !== null && f === hn
    }
    function kM(u, f) {
        Uc = Xh = !0;
        var g = u.pending;
        g === null ? f.next = f : (f.next = g.next,
        g.next = f),
        u.pending = f
    }
    function FM(u, f, g) {
        Sn !== null && u.mode & 1 && !(xt & 2) ? (u = f.interleaved,
        u === null ? (g.next = g,
        $r === null ? $r = [f] : $r.push(f)) : (g.next = u.next,
        u.next = g),
        f.interleaved = g) : (u = f.pending,
        u === null ? g.next = g : (g.next = u.next,
        u.next = g),
        f.pending = g)
    }
    function NM(u, f, g) {
        if (g & 4194240) {
            var S = f.lanes;
            S &= u.pendingLanes,
            g |= S,
            f.lanes = g,
            sv(u, g)
        }
    }
    var qh = {
        readContext: rr,
        useCallback: $n,
        useContext: $n,
        useEffect: $n,
        useImperativeHandle: $n,
        useInsertionEffect: $n,
        useLayoutEffect: $n,
        useMemo: $n,
        useReducer: $n,
        useRef: $n,
        useState: $n,
        useDebugValue: $n,
        useDeferredValue: $n,
        useTransition: $n,
        useMutableSource: $n,
        useSyncExternalStore: $n,
        useId: $n,
        unstable_isNewReconciler: !1
    }
      , Ck = {
        readContext: rr,
        useCallback: function(u, f) {
            return bs().memoizedState = [u, f === void 0 ? null : f],
            u
        },
        useContext: rr,
        useEffect: Bv,
        useImperativeHandle: function(u, f, g) {
            return g = g != null ? g.concat([u]) : null,
            Qh(4194308, 4, PM.bind(null, f, u), g)
        },
        useLayoutEffect: function(u, f) {
            return Qh(4194308, 4, u, f)
        },
        useInsertionEffect: function(u, f) {
            return Qh(4, 2, u, f)
        },
        useMemo: function(u, f) {
            var g = bs();
            return f = f === void 0 ? null : f,
            u = u(),
            g.memoizedState = [u, f],
            u
        },
        useReducer: function(u, f, g) {
            var S = bs();
            return f = g !== void 0 ? g(f) : f,
            S.memoizedState = S.baseState = f,
            u = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: u,
                lastRenderedState: f
            },
            S.queue = u,
            u = u.dispatch = Mk.bind(null, hn, u),
            [S.memoizedState, u]
        },
        useRef: function(u) {
            var f = bs();
            return u = {
                current: u
            },
            f.memoizedState = u
        },
        useState: Pv,
        useDebugValue: Rv,
        useDeferredValue: function(u) {
            var f = Pv(u)
              , g = f[0]
              , S = f[1];
            return Bv(function() {
                var b = lr.transition;
                lr.transition = {};
                try {
                    S(u)
                } finally {
                    lr.transition = b
                }
            }, [u]),
            g
        },
        useTransition: function() {
            var u = Pv(!1)
              , f = u[0];
            return u = Sk.bind(null, u[1]),
            bs().memoizedState = u,
            [f, u]
        },
        useMutableSource: function() {},
        useSyncExternalStore: function(u, f, g) {
            var S = hn
              , b = bs();
            if (qt) {
                if (g === void 0)
                    throw Error(o(407));
                g = g()
            } else {
                if (g = f(),
                Sn === null)
                    throw Error(o(349));
                jl & 30 || wM(S, f, g)
            }
            b.memoizedState = g;
            var T = {
                value: g,
                getSnapshot: f
            };
            return b.queue = T,
            Bv(MM.bind(null, S, T, u), [u]),
            S.flags |= 2048,
            Gc(9, SM.bind(null, S, T, g, f), void 0, null),
            g
        },
        useId: function() {
            var u = bs()
              , f = Sn.identifierPrefix;
            if (qt) {
                var g = Ms
                  , S = Ss;
                g = (S & ~(1 << 32 - Cr(S) - 1)).toString(32) + g,
                f = ":" + f + "R" + g,
                g = zc++,
                0 < g && (f += "H" + g.toString(32)),
                f += ":"
            } else
                g = wk++,
                f = ":" + f + "r" + g.toString(32) + ":";
            return u.memoizedState = f
        },
        unstable_isNewReconciler: !1
    }
      , Ek = {
        readContext: rr,
        useCallback: RM,
        useContext: rr,
        useEffect: Hc,
        useImperativeHandle: BM,
        useInsertionEffect: EM,
        useLayoutEffect: TM,
        useMemo: IM,
        useReducer: Yh,
        useRef: CM,
        useState: function() {
            return Yh(wa)
        },
        useDebugValue: Rv,
        useDeferredValue: function(u) {
            var f = Yh(wa)
              , g = f[0]
              , S = f[1];
            return Hc(function() {
                var b = lr.transition;
                lr.transition = {};
                try {
                    S(u)
                } finally {
                    lr.transition = b
                }
            }, [u]),
            g
        },
        useTransition: function() {
            var u = Yh(wa)[0]
              , f = ts().memoizedState;
            return [u, f]
        },
        useMutableSource: _M,
        useSyncExternalStore: AM,
        useId: LM,
        unstable_isNewReconciler: !1
    }
      , Tk = {
        readContext: rr,
        useCallback: RM,
        useContext: rr,
        useEffect: Hc,
        useImperativeHandle: BM,
        useInsertionEffect: EM,
        useLayoutEffect: TM,
        useMemo: IM,
        useReducer: Kh,
        useRef: CM,
        useState: function() {
            return Kh(wa)
        },
        useDebugValue: Rv,
        useDeferredValue: function(u) {
            var f = Kh(wa)
              , g = f[0]
              , S = f[1];
            return Hc(function() {
                var b = lr.transition;
                lr.transition = {};
                try {
                    S(u)
                } finally {
                    lr.transition = b
                }
            }, [u]),
            g
        },
        useTransition: function() {
            var u = Kh(wa)[0]
              , f = ts().memoizedState;
            return [u, f]
        },
        useMutableSource: _M,
        useSyncExternalStore: AM,
        useId: LM,
        unstable_isNewReconciler: !1
    };
    function Iv(u, f) {
        try {
            var g = ""
              , S = f;
            do
                g += Ak(S),
                S = S.return;
            while (S);
            var b = g
        } catch (T) {
            b = `
Error generating stack: ` + T.message + `
` + T.stack
        }
        return {
            value: u,
            source: f,
            stack: b
        }
    }
    function Lv(u, f) {
        try {
            console.error(f.value)
        } catch (g) {
            setTimeout(function() {
                throw g
            })
        }
    }
    var Pk = typeof WeakMap == "function" ? WeakMap : Map;
    function OM(u, f, g) {
        g = ws(-1, g),
        g.tag = 3,
        g.payload = {
            element: null
        };
        var S = f.value;
        return g.callback = function() {
            pp || (pp = !0,
            Zv = S),
            Lv(u, f)
        }
        ,
        g
    }
    function UM(u, f, g) {
        g = ws(-1, g),
        g.tag = 3;
        var S = u.type.getDerivedStateFromError;
        if (typeof S == "function") {
            var b = f.value;
            g.payload = function() {
                return S(b)
            }
            ,
            g.callback = function() {
                Lv(u, f)
            }
        }
        var T = u.stateNode;
        return T !== null && typeof T.componentDidCatch == "function" && (g.callback = function() {
            Lv(u, f),
            typeof S != "function" && (fo === null ? fo = new Set([this]) : fo.add(this));
            var N = f.stack;
            this.componentDidCatch(f.value, {
                componentStack: N !== null ? N : ""
            })
        }
        ),
        g
    }
    function zM(u, f, g) {
        var S = u.pingCache;
        if (S === null) {
            S = u.pingCache = new Pk;
            var b = new Set;
            S.set(f, b)
        } else
            b = S.get(f),
            b === void 0 && (b = new Set,
            S.set(f, b));
        b.has(g) || (b.add(g),
        u = Vk.bind(null, u, f, g),
        f.then(u, u))
    }
    function GM(u) {
        do {
            var f;
            if ((f = u.tag === 13) && (f = u.memoizedState,
            f = f !== null ? f.dehydrated !== null : !0),
            f)
                return u;
            u = u.return
        } while (u !== null);
        return null
    }
    function HM(u, f, g, S, b) {
        return u.mode & 1 ? (u.flags |= 65536,
        u.lanes = b,
        u) : (u === f ? u.flags |= 65536 : (u.flags |= 128,
        g.flags |= 131072,
        g.flags &= -52805,
        g.tag === 1 && (g.alternate === null ? g.tag = 17 : (f = ws(-1, 1),
        f.tag = 2,
        co(g, f))),
        g.lanes |= 1),
        u)
    }
    function ns(u) {
        u.flags |= 4
    }
    function VM(u, f) {
        if (u !== null && u.child === f.child)
            return !0;
        if (f.flags & 16)
            return !1;
        for (u = f.child; u !== null; ) {
            if (u.flags & 12854 || u.subtreeFlags & 12854)
                return !1;
            u = u.sibling
        }
        return !0
    }
    var Vc, Wc, $h, ep;
    if (Le)
        Vc = function(u, f) {
            for (var g = f.child; g !== null; ) {
                if (g.tag === 5 || g.tag === 6)
                    j(u, g.stateNode);
                else if (g.tag !== 4 && g.child !== null) {
                    g.child.return = g,
                    g = g.child;
                    continue
                }
                if (g === f)
                    break;
                for (; g.sibling === null; ) {
                    if (g.return === null || g.return === f)
                        return;
                    g = g.return
                }
                g.sibling.return = g.return,
                g = g.sibling
            }
        }
        ,
        Wc = function() {}
        ,
        $h = function(u, f, g, S, b) {
            if (u = u.memoizedProps,
            u !== S) {
                var T = f.stateNode
                  , N = es(ar.current);
                g = ye(T, g, u, S, b, N),
                (f.updateQueue = g) && ns(f)
            }
        }
        ,
        ep = function(u, f, g, S) {
            g !== S && ns(f)
        }
        ;
    else if (de) {
        Vc = function(u, f, g, S) {
            for (var b = f.child; b !== null; ) {
                if (b.tag === 5) {
                    var T = b.stateNode;
                    g && S && (T = Gt(T, b.type, b.memoizedProps, b)),
                    j(u, T)
                } else if (b.tag === 6)
                    T = b.stateNode,
                    g && S && (T = er(T, b.memoizedProps, b)),
                    j(u, T);
                else if (b.tag !== 4) {
                    if (b.tag === 22 && b.memoizedState !== null)
                        T = b.child,
                        T !== null && (T.return = b),
                        Vc(u, b, !0, !0);
                    else if (b.child !== null) {
                        b.child.return = b,
                        b = b.child;
                        continue
                    }
                }
                if (b === f)
                    break;
                for (; b.sibling === null; ) {
                    if (b.return === null || b.return === f)
                        return;
                    b = b.return
                }
                b.sibling.return = b.return,
                b = b.sibling
            }
        }
        ;
        var WM = function(u, f, g, S) {
            for (var b = f.child; b !== null; ) {
                if (b.tag === 5) {
                    var T = b.stateNode;
                    g && S && (T = Gt(T, b.type, b.memoizedProps, b)),
                    yn(u, T)
                } else if (b.tag === 6)
                    T = b.stateNode,
                    g && S && (T = er(T, b.memoizedProps, b)),
                    yn(u, T);
                else if (b.tag !== 4) {
                    if (b.tag === 22 && b.memoizedState !== null)
                        T = b.child,
                        T !== null && (T.return = b),
                        WM(u, b, !0, !0);
                    else if (b.child !== null) {
                        b.child.return = b,
                        b = b.child;
                        continue
                    }
                }
                if (b === f)
                    break;
                for (; b.sibling === null; ) {
                    if (b.return === null || b.return === f)
                        return;
                    b = b.return
                }
                b.sibling.return = b.return,
                b = b.sibling
            }
        };
        Wc = function(u, f) {
            var g = f.stateNode;
            if (!VM(u, f)) {
                u = g.containerInfo;
                var S = It(u);
                WM(S, f, !1, !1),
                g.pendingChildren = S,
                ns(f),
                Nn(u, S)
            }
        }
        ,
        $h = function(u, f, g, S, b) {
            var T = u.stateNode
              , N = u.memoizedProps;
            if ((u = VM(u, f)) && N === S)
                f.stateNode = T;
            else {
                var J = f.stateNode
                  , fe = es(ar.current)
                  , Ee = null;
                N !== S && (Ee = ye(J, g, N, S, b, fe)),
                u && Ee === null ? f.stateNode = T : (T = Ze(T, Ee, g, N, S, f, u, J),
                ie(T, g, S, b, fe) && ns(f),
                f.stateNode = T,
                u ? ns(f) : Vc(T, f, !1, !1))
            }
        }
        ,
        ep = function(u, f, g, S) {
            g !== S ? (u = es(Vl.current),
            g = es(ar.current),
            f.stateNode = $(S, u, g, f),
            ns(f)) : f.stateNode = u.stateNode
        }
    } else
        Wc = function() {}
        ,
        $h = function() {}
        ,
        ep = function() {}
        ;
    function jc(u, f) {
        if (!qt)
            switch (u.tailMode) {
            case "hidden":
                f = u.tail;
                for (var g = null; f !== null; )
                    f.alternate !== null && (g = f),
                    f = f.sibling;
                g === null ? u.tail = null : g.sibling = null;
                break;
            case "collapsed":
                g = u.tail;
                for (var S = null; g !== null; )
                    g.alternate !== null && (S = g),
                    g = g.sibling;
                S === null ? f || u.tail === null ? u.tail = null : u.tail.sibling = null : S.sibling = null
            }
    }
    function ei(u) {
        var f = u.alternate !== null && u.alternate.child === u.child
          , g = 0
          , S = 0;
        if (f)
            for (var b = u.child; b !== null; )
                g |= b.lanes | b.childLanes,
                S |= b.subtreeFlags & 14680064,
                S |= b.flags & 14680064,
                b.return = u,
                b = b.sibling;
        else
            for (b = u.child; b !== null; )
                g |= b.lanes | b.childLanes,
                S |= b.subtreeFlags,
                S |= b.flags,
                b.return = u,
                b = b.sibling;
        return u.subtreeFlags |= S,
        u.childLanes = g,
        f
    }
    function Bk(u, f, g) {
        var S = f.pendingProps;
        switch (yv(f),
        f.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return ei(f),
            null;
        case 1:
            return Si(f.type) && Ph(),
            ei(f),
            null;
        case 3:
            return S = f.stateNode,
            Wl(),
            dt(On),
            dt(Ot),
            bv(),
            S.pendingContext && (S.context = S.pendingContext,
            S.pendingContext = null),
            (u === null || u.child === null) && (kc(f) ? ns(f) : u === null || u.memoizedState.isDehydrated && !(f.flags & 256) || (f.flags |= 1024,
            Tr !== null && (ey(Tr),
            Tr = null))),
            Wc(u, f),
            ei(f),
            null;
        case 5:
            Sv(f),
            g = es(Vl.current);
            var b = f.type;
            if (u !== null && f.stateNode != null)
                $h(u, f, b, S, g),
                u.ref !== f.ref && (f.flags |= 512,
                f.flags |= 2097152);
            else {
                if (!S) {
                    if (f.stateNode === null)
                        throw Error(o(166));
                    return ei(f),
                    null
                }
                if (u = es(ar.current),
                kc(f)) {
                    if (!ae)
                        throw Error(o(175));
                    u = et(f.stateNode, f.type, f.memoizedProps, g, u, f, !Dc),
                    f.updateQueue = u,
                    u !== null && ns(f)
                } else {
                    var T = re(b, S, g, u, f);
                    Vc(T, f, !1, !1),
                    f.stateNode = T,
                    ie(T, b, S, g, u) && ns(f)
                }
                f.ref !== null && (f.flags |= 512,
                f.flags |= 2097152)
            }
            return ei(f),
            null;
        case 6:
            if (u && f.stateNode != null)
                ep(u, f, u.memoizedProps, S);
            else {
                if (typeof S != "string" && f.stateNode === null)
                    throw Error(o(166));
                if (u = es(Vl.current),
                g = es(ar.current),
                kc(f)) {
                    if (!ae)
                        throw Error(o(176));
                    if (u = f.stateNode,
                    S = f.memoizedProps,
                    (g = at(u, S, f, !Dc)) && (b = ki,
                    b !== null))
                        switch (T = (b.mode & 1) !== 0,
                        b.tag) {
                        case 3:
                            br(b.stateNode.containerInfo, u, S, T);
                            break;
                        case 5:
                            vs(b.type, b.memoizedProps, b.stateNode, u, S, T)
                        }
                    g && ns(f)
                } else
                    f.stateNode = $(S, u, g, f)
            }
            return ei(f),
            null;
        case 13:
            if (dt(nn),
            S = f.memoizedState,
            qt && Fi !== null && f.mode & 1 && !(f.flags & 128)) {
                for (u = Fi; u; )
                    u = ee(u);
                return Gl(),
                f.flags |= 98560,
                f
            }
            if (S !== null && S.dehydrated !== null) {
                if (S = kc(f),
                u === null) {
                    if (!S)
                        throw Error(o(318));
                    if (!ae)
                        throw Error(o(344));
                    if (u = f.memoizedState,
                    u = u !== null ? u.dehydrated : null,
                    !u)
                        throw Error(o(317));
                    pt(u, f)
                } else
                    Gl(),
                    !(f.flags & 128) && (f.memoizedState = null),
                    f.flags |= 4;
                return ei(f),
                null
            }
            return Tr !== null && (ey(Tr),
            Tr = null),
            f.flags & 128 ? (f.lanes = g,
            f) : (S = S !== null,
            g = !1,
            u === null ? kc(f) : g = u.memoizedState !== null,
            S && !g && (f.child.flags |= 8192,
            f.mode & 1 && (u === null || nn.current & 1 ? Pn === 0 && (Pn = 3) : ny())),
            f.updateQueue !== null && (f.flags |= 4),
            ei(f),
            null);
        case 4:
            return Wl(),
            Wc(u, f),
            u === null && Ge(f.stateNode.containerInfo),
            ei(f),
            null;
        case 10:
            return dv(f.type._context),
            ei(f),
            null;
        case 17:
            return Si(f.type) && Ph(),
            ei(f),
            null;
        case 19:
            if (dt(nn),
            b = f.memoizedState,
            b === null)
                return ei(f),
                null;
            if (S = (f.flags & 128) !== 0,
            T = b.rendering,
            T === null)
                if (S)
                    jc(b, !1);
                else {
                    if (Pn !== 0 || u !== null && u.flags & 128)
                        for (u = f.child; u !== null; ) {
                            if (T = jh(u),
                            T !== null) {
                                for (f.flags |= 128,
                                jc(b, !1),
                                u = T.updateQueue,
                                u !== null && (f.updateQueue = u,
                                f.flags |= 4),
                                f.subtreeFlags = 0,
                                u = g,
                                S = f.child; S !== null; )
                                    g = S,
                                    b = u,
                                    g.flags &= 14680066,
                                    T = g.alternate,
                                    T === null ? (g.childLanes = 0,
                                    g.lanes = b,
                                    g.child = null,
                                    g.subtreeFlags = 0,
                                    g.memoizedProps = null,
                                    g.memoizedState = null,
                                    g.updateQueue = null,
                                    g.dependencies = null,
                                    g.stateNode = null) : (g.childLanes = T.childLanes,
                                    g.lanes = T.lanes,
                                    g.child = T.child,
                                    g.subtreeFlags = 0,
                                    g.deletions = null,
                                    g.memoizedProps = T.memoizedProps,
                                    g.memoizedState = T.memoizedState,
                                    g.updateQueue = T.updateQueue,
                                    g.type = T.type,
                                    b = T.dependencies,
                                    g.dependencies = b === null ? null : {
                                        lanes: b.lanes,
                                        firstContext: b.firstContext
                                    }),
                                    S = S.sibling;
                                return Pt(nn, nn.current & 1 | 2),
                                f.child
                            }
                            u = u.sibling
                        }
                    b.tail !== null && Un() > Qv && (f.flags |= 128,
                    S = !0,
                    jc(b, !1),
                    f.lanes = 4194304)
                }
            else {
                if (!S)
                    if (u = jh(T),
                    u !== null) {
                        if (f.flags |= 128,
                        S = !0,
                        u = u.updateQueue,
                        u !== null && (f.updateQueue = u,
                        f.flags |= 4),
                        jc(b, !0),
                        b.tail === null && b.tailMode === "hidden" && !T.alternate && !qt)
                            return ei(f),
                            null
                    } else
                        2 * Un() - b.renderingStartTime > Qv && g !== 1073741824 && (f.flags |= 128,
                        S = !0,
                        jc(b, !1),
                        f.lanes = 4194304);
                b.isBackwards ? (T.sibling = f.child,
                f.child = T) : (u = b.last,
                u !== null ? u.sibling = T : f.child = T,
                b.last = T)
            }
            return b.tail !== null ? (f = b.tail,
            b.rendering = f,
            b.tail = f.sibling,
            b.renderingStartTime = Un(),
            f.sibling = null,
            u = nn.current,
            Pt(nn, S ? u & 1 | 2 : u & 1),
            f) : (ei(f),
            null);
        case 22:
        case 23:
            return ty(),
            S = f.memoizedState !== null,
            u !== null && u.memoizedState !== null !== S && (f.flags |= 8192),
            S && f.mode & 1 ? Oi & 1073741824 && (ei(f),
            Le && f.subtreeFlags & 6 && (f.flags |= 8192)) : ei(f),
            null;
        case 24:
            return null;
        case 25:
            return null
        }
        throw Error(o(156, f.tag))
    }
    var Rk = a.ReactCurrentOwner
      , Ni = !1;
    function ci(u, f, g, S) {
        f.child = u === null ? yM(f, null, g, S) : Hl(f, u.child, g, S)
    }
    function jM(u, f, g, S, b) {
        g = g.render;
        var T = f.ref;
        return Ol(f, b),
        S = Ev(u, f, g, S, T, b),
        g = Tv(),
        u !== null && !Ni ? (f.updateQueue = u.updateQueue,
        f.flags &= -2053,
        u.lanes &= ~b,
        Cs(u, f, b)) : (qt && g && vv(f),
        f.flags |= 1,
        ci(u, f, S, b),
        f.child)
    }
    function JM(u, f, g, S, b) {
        if (u === null) {
            var T = g.type;
            return typeof T == "function" && !iy(T) && T.defaultProps === void 0 && g.compare === null && g.defaultProps === void 0 ? (f.tag = 15,
            f.type = T,
            XM(u, f, T, S, b)) : (u = Ap(g.type, null, S, f, f.mode, b),
            u.ref = f.ref,
            u.return = f,
            f.child = u)
        }
        if (T = u.child,
        !(u.lanes & b)) {
            var N = T.memoizedProps;
            if (g = g.compare,
            g = g !== null ? g : Fh,
            g(N, S) && u.ref === f.ref)
                return Cs(u, f, b)
        }
        return f.flags |= 1,
        u = go(T, S),
        u.ref = f.ref,
        u.return = f,
        f.child = u
    }
    function XM(u, f, g, S, b) {
        if (u !== null && Fh(u.memoizedProps, S) && u.ref === f.ref)
            if (Ni = !1,
            (u.lanes & b) !== 0)
                u.flags & 131072 && (Ni = !0);
            else
                return f.lanes = u.lanes,
                Cs(u, f, b);
        return Dv(u, f, g, S, b)
    }
    function YM(u, f, g) {
        var S = f.pendingProps
          , b = S.children
          , T = u !== null ? u.memoizedState : null;
        if (S.mode === "hidden")
            if (!(f.mode & 1))
                f.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                },
                Pt(Jl, Oi),
                Oi |= g;
            else if (g & 1073741824)
                f.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                },
                S = T !== null ? T.baseLanes : g,
                Pt(Jl, Oi),
                Oi |= S;
            else
                return u = T !== null ? T.baseLanes | g : g,
                f.lanes = f.childLanes = 1073741824,
                f.memoizedState = {
                    baseLanes: u,
                    cachePool: null
                },
                f.updateQueue = null,
                Pt(Jl, Oi),
                Oi |= u,
                null;
        else
            T !== null ? (S = T.baseLanes | g,
            f.memoizedState = null) : S = g,
            Pt(Jl, Oi),
            Oi |= S;
        return ci(u, f, b, g),
        f.child
    }
    function KM(u, f) {
        var g = f.ref;
        (u === null && g !== null || u !== null && u.ref !== g) && (f.flags |= 512,
        f.flags |= 2097152)
    }
    function Dv(u, f, g, S, b) {
        var T = Si(g) ? xs : Ot.current;
        return T = _s(f, T),
        Ol(f, b),
        g = Ev(u, f, g, S, T, b),
        S = Tv(),
        u !== null && !Ni ? (f.updateQueue = u.updateQueue,
        f.flags &= -2053,
        u.lanes &= ~b,
        Cs(u, f, b)) : (qt && S && vv(f),
        f.flags |= 1,
        ci(u, f, g, b),
        f.child)
    }
    function QM(u, f, g, S, b) {
        if (Si(g)) {
            var T = !0;
            Bh(f)
        } else
            T = !1;
        if (Ol(f, b),
        f.stateNode === null)
            u !== null && (u.alternate = null,
            f.alternate = null,
            f.flags |= 2),
            cM(f, g, S),
            gv(f, g, S, b),
            S = !0;
        else if (u === null) {
            var N = f.stateNode
              , J = f.memoizedProps;
            N.props = J;
            var fe = N.context
              , Ee = g.contextType;
            typeof Ee == "object" && Ee !== null ? Ee = rr(Ee) : (Ee = Si(g) ? xs : Ot.current,
            Ee = _s(f, Ee));
            var We = g.getDerivedStateFromProps
              , lt = typeof We == "function" || typeof N.getSnapshotBeforeUpdate == "function";
            lt || typeof N.UNSAFE_componentWillReceiveProps != "function" && typeof N.componentWillReceiveProps != "function" || (J !== S || fe !== Ee) && fM(f, N, S, Ee),
            uo = !1;
            var nt = f.memoizedState;
            N.state = nt,
            zh(f, S, N, b),
            fe = f.memoizedState,
            J !== S || nt !== fe || On.current || uo ? (typeof We == "function" && (mv(f, g, We, S),
            fe = f.memoizedState),
            (J = uo || uM(f, g, J, S, nt, fe, Ee)) ? (lt || typeof N.UNSAFE_componentWillMount != "function" && typeof N.componentWillMount != "function" || (typeof N.componentWillMount == "function" && N.componentWillMount(),
            typeof N.UNSAFE_componentWillMount == "function" && N.UNSAFE_componentWillMount()),
            typeof N.componentDidMount == "function" && (f.flags |= 4194308)) : (typeof N.componentDidMount == "function" && (f.flags |= 4194308),
            f.memoizedProps = S,
            f.memoizedState = fe),
            N.props = S,
            N.state = fe,
            N.context = Ee,
            S = J) : (typeof N.componentDidMount == "function" && (f.flags |= 4194308),
            S = !1)
        } else {
            N = f.stateNode,
            sM(u, f),
            J = f.memoizedProps,
            Ee = f.type === f.elementType ? J : Er(f.type, J),
            N.props = Ee,
            lt = f.pendingProps,
            nt = N.context,
            fe = g.contextType,
            typeof fe == "object" && fe !== null ? fe = rr(fe) : (fe = Si(g) ? xs : Ot.current,
            fe = _s(f, fe));
            var Ht = g.getDerivedStateFromProps;
            (We = typeof Ht == "function" || typeof N.getSnapshotBeforeUpdate == "function") || typeof N.UNSAFE_componentWillReceiveProps != "function" && typeof N.componentWillReceiveProps != "function" || (J !== lt || nt !== fe) && fM(f, N, S, fe),
            uo = !1,
            nt = f.memoizedState,
            N.state = nt,
            zh(f, S, N, b);
            var qe = f.memoizedState;
            J !== lt || nt !== qe || On.current || uo ? (typeof Ht == "function" && (mv(f, g, Ht, S),
            qe = f.memoizedState),
            (Ee = uo || uM(f, g, Ee, S, nt, qe, fe) || !1) ? (We || typeof N.UNSAFE_componentWillUpdate != "function" && typeof N.componentWillUpdate != "function" || (typeof N.componentWillUpdate == "function" && N.componentWillUpdate(S, qe, fe),
            typeof N.UNSAFE_componentWillUpdate == "function" && N.UNSAFE_componentWillUpdate(S, qe, fe)),
            typeof N.componentDidUpdate == "function" && (f.flags |= 4),
            typeof N.getSnapshotBeforeUpdate == "function" && (f.flags |= 1024)) : (typeof N.componentDidUpdate != "function" || J === u.memoizedProps && nt === u.memoizedState || (f.flags |= 4),
            typeof N.getSnapshotBeforeUpdate != "function" || J === u.memoizedProps && nt === u.memoizedState || (f.flags |= 1024),
            f.memoizedProps = S,
            f.memoizedState = qe),
            N.props = S,
            N.state = qe,
            N.context = fe,
            S = Ee) : (typeof N.componentDidUpdate != "function" || J === u.memoizedProps && nt === u.memoizedState || (f.flags |= 4),
            typeof N.getSnapshotBeforeUpdate != "function" || J === u.memoizedProps && nt === u.memoizedState || (f.flags |= 1024),
            S = !1)
        }
        return kv(u, f, g, S, T, b)
    }
    function kv(u, f, g, S, b, T) {
        KM(u, f);
        var N = (f.flags & 128) !== 0;
        if (!S && !N)
            return b && eM(f, g, !1),
            Cs(u, f, T);
        S = f.stateNode,
        Rk.current = f;
        var J = N && typeof g.getDerivedStateFromError != "function" ? null : S.render();
        return f.flags |= 1,
        u !== null && N ? (f.child = Hl(f, u.child, null, T),
        f.child = Hl(f, null, J, T)) : ci(u, f, J, T),
        f.memoizedState = S.state,
        b && eM(f, g, !0),
        f.child
    }
    function ZM(u) {
        var f = u.stateNode;
        f.pendingContext ? qS(u, f.pendingContext, f.pendingContext !== f.context) : f.context && qS(u, f.context, !1),
        wv(u, f.containerInfo)
    }
    function qM(u, f, g, S, b) {
        return Gl(),
        Av(b),
        f.flags |= 256,
        ci(u, f, g, S),
        f.child
    }
    var tp = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0
    };
    function np(u) {
        return {
            baseLanes: u,
            cachePool: null
        }
    }
    function $M(u, f, g) {
        var S = f.pendingProps, b = nn.current, T = !1, N = (f.flags & 128) !== 0, J;
        if ((J = N) || (J = u !== null && u.memoizedState === null ? !1 : (b & 2) !== 0),
        J ? (T = !0,
        f.flags &= -129) : (u === null || u.memoizedState !== null) && (b |= 1),
        Pt(nn, b & 1),
        u === null)
            return _v(f),
            u = f.memoizedState,
            u !== null && (u = u.dehydrated,
            u !== null) ? (f.mode & 1 ? Rc(u) ? f.lanes = 8 : f.lanes = 1073741824 : f.lanes = 1,
            null) : (b = S.children,
            u = S.fallback,
            T ? (S = f.mode,
            T = f.child,
            b = {
                mode: "hidden",
                children: b
            },
            !(S & 1) && T !== null ? (T.childLanes = 0,
            T.pendingProps = b) : T = wp(b, S, 0, null),
            u = Ta(u, S, g, null),
            T.return = f,
            u.return = f,
            T.sibling = u,
            f.child = T,
            f.child.memoizedState = np(g),
            f.memoizedState = tp,
            u) : Fv(f, b));
        if (b = u.memoizedState,
        b !== null) {
            if (J = b.dehydrated,
            J !== null) {
                if (N)
                    return f.flags & 256 ? (f.flags &= -257,
                    ip(u, f, g, Error(o(422)))) : f.memoizedState !== null ? (f.child = u.child,
                    f.flags |= 128,
                    null) : (T = S.fallback,
                    b = f.mode,
                    S = wp({
                        mode: "visible",
                        children: S.children
                    }, b, 0, null),
                    T = Ta(T, b, g, null),
                    T.flags |= 2,
                    S.return = f,
                    T.return = f,
                    S.sibling = T,
                    f.child = S,
                    f.mode & 1 && Hl(f, u.child, null, g),
                    f.child.memoizedState = np(g),
                    f.memoizedState = tp,
                    T);
                if (!(f.mode & 1))
                    f = ip(u, f, g, null);
                else if (Rc(J))
                    f = ip(u, f, g, Error(o(419)));
                else if (S = (g & u.childLanes) !== 0,
                Ni || S) {
                    if (S = Sn,
                    S !== null) {
                        switch (g & -g) {
                        case 4:
                            T = 2;
                            break;
                        case 16:
                            T = 8;
                            break;
                        case 64:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                        case 67108864:
                            T = 32;
                            break;
                        case 536870912:
                            T = 268435456;
                            break;
                        default:
                            T = 0
                        }
                        S = T & (S.suspendedLanes | g) ? 0 : T,
                        S !== 0 && S !== b.retryLane && (b.retryLane = S,
                        ur(u, S, -1))
                    }
                    ny(),
                    f = ip(u, f, g, Error(o(421)))
                } else
                    Th(J) ? (f.flags |= 128,
                    f.child = u.child,
                    f = Wk.bind(null, u),
                    k(J, f),
                    f = null) : (g = b.treeContext,
                    ae && (Fi = ve(J),
                    ki = f,
                    qt = !0,
                    Tr = null,
                    Dc = !1,
                    g !== null && (sr[or++] = Ss,
                    sr[or++] = Ms,
                    sr[or++] = _a,
                    Ss = g.id,
                    Ms = g.overflow,
                    _a = f)),
                    f = Fv(f, f.pendingProps.children),
                    f.flags |= 4096);
                return f
            }
            return T ? (S = tb(u, f, S.children, S.fallback, g),
            T = f.child,
            b = u.child.memoizedState,
            T.memoizedState = b === null ? np(g) : {
                baseLanes: b.baseLanes | g,
                cachePool: null
            },
            T.childLanes = u.childLanes & ~g,
            f.memoizedState = tp,
            S) : (g = eb(u, f, S.children, g),
            f.memoizedState = null,
            g)
        }
        return T ? (S = tb(u, f, S.children, S.fallback, g),
        T = f.child,
        b = u.child.memoizedState,
        T.memoizedState = b === null ? np(g) : {
            baseLanes: b.baseLanes | g,
            cachePool: null
        },
        T.childLanes = u.childLanes & ~g,
        f.memoizedState = tp,
        S) : (g = eb(u, f, S.children, g),
        f.memoizedState = null,
        g)
    }
    function Fv(u, f) {
        return f = wp({
            mode: "visible",
            children: f
        }, u.mode, 0, null),
        f.return = u,
        u.child = f
    }
    function eb(u, f, g, S) {
        var b = u.child;
        return u = b.sibling,
        g = go(b, {
            mode: "visible",
            children: g
        }),
        !(f.mode & 1) && (g.lanes = S),
        g.return = f,
        g.sibling = null,
        u !== null && (S = f.deletions,
        S === null ? (f.deletions = [u],
        f.flags |= 16) : S.push(u)),
        f.child = g
    }
    function tb(u, f, g, S, b) {
        var T = f.mode;
        u = u.child;
        var N = u.sibling
          , J = {
            mode: "hidden",
            children: g
        };
        return !(T & 1) && f.child !== u ? (g = f.child,
        g.childLanes = 0,
        g.pendingProps = J,
        f.deletions = null) : (g = go(u, J),
        g.subtreeFlags = u.subtreeFlags & 14680064),
        N !== null ? S = go(N, S) : (S = Ta(S, T, b, null),
        S.flags |= 2),
        S.return = f,
        g.return = f,
        g.sibling = S,
        f.child = g,
        S
    }
    function ip(u, f, g, S) {
        return S !== null && Av(S),
        Hl(f, u.child, null, g),
        u = Fv(f, f.pendingProps.children),
        u.flags |= 2,
        f.memoizedState = null,
        u
    }
    function nb(u, f, g) {
        u.lanes |= f;
        var S = u.alternate;
        S !== null && (S.lanes |= f),
        hv(u.return, f, g)
    }
    function Nv(u, f, g, S, b) {
        var T = u.memoizedState;
        T === null ? u.memoizedState = {
            isBackwards: f,
            rendering: null,
            renderingStartTime: 0,
            last: S,
            tail: g,
            tailMode: b
        } : (T.isBackwards = f,
        T.rendering = null,
        T.renderingStartTime = 0,
        T.last = S,
        T.tail = g,
        T.tailMode = b)
    }
    function ib(u, f, g) {
        var S = f.pendingProps
          , b = S.revealOrder
          , T = S.tail;
        if (ci(u, f, S.children, g),
        S = nn.current,
        S & 2)
            S = S & 1 | 2,
            f.flags |= 128;
        else {
            if (u !== null && u.flags & 128)
                e: for (u = f.child; u !== null; ) {
                    if (u.tag === 13)
                        u.memoizedState !== null && nb(u, g, f);
                    else if (u.tag === 19)
                        nb(u, g, f);
                    else if (u.child !== null) {
                        u.child.return = u,
                        u = u.child;
                        continue
                    }
                    if (u === f)
                        break e;
                    for (; u.sibling === null; ) {
                        if (u.return === null || u.return === f)
                            break e;
                        u = u.return
                    }
                    u.sibling.return = u.return,
                    u = u.sibling
                }
            S &= 1
        }
        if (Pt(nn, S),
        !(f.mode & 1))
            f.memoizedState = null;
        else
            switch (b) {
            case "forwards":
                for (g = f.child,
                b = null; g !== null; )
                    u = g.alternate,
                    u !== null && jh(u) === null && (b = g),
                    g = g.sibling;
                g = b,
                g === null ? (b = f.child,
                f.child = null) : (b = g.sibling,
                g.sibling = null),
                Nv(f, !1, b, g, T);
                break;
            case "backwards":
                for (g = null,
                b = f.child,
                f.child = null; b !== null; ) {
                    if (u = b.alternate,
                    u !== null && jh(u) === null) {
                        f.child = b;
                        break
                    }
                    u = b.sibling,
                    b.sibling = g,
                    g = b,
                    b = u
                }
                Nv(f, !0, g, null, T);
                break;
            case "together":
                Nv(f, !1, null, null, void 0);
                break;
            default:
                f.memoizedState = null
            }
        return f.child
    }
    function Cs(u, f, g) {
        if (u !== null && (f.dependencies = u.dependencies),
        Xl |= f.lanes,
        !(g & f.childLanes))
            return null;
        if (u !== null && f.child !== u.child)
            throw Error(o(153));
        if (f.child !== null) {
            for (u = f.child,
            g = go(u, u.pendingProps),
            f.child = g,
            g.return = f; u.sibling !== null; )
                u = u.sibling,
                g = g.sibling = go(u, u.pendingProps),
                g.return = f;
            g.sibling = null
        }
        return f.child
    }
    function Ik(u, f, g) {
        switch (f.tag) {
        case 3:
            ZM(f),
            Gl();
            break;
        case 5:
            xM(f);
            break;
        case 1:
            Si(f.type) && Bh(f);
            break;
        case 4:
            wv(f, f.stateNode.containerInfo);
            break;
        case 10:
            rM(f, f.type._context, f.memoizedProps.value);
            break;
        case 13:
            var S = f.memoizedState;
            if (S !== null)
                return S.dehydrated !== null ? (Pt(nn, nn.current & 1),
                f.flags |= 128,
                null) : g & f.child.childLanes ? $M(u, f, g) : (Pt(nn, nn.current & 1),
                u = Cs(u, f, g),
                u !== null ? u.sibling : null);
            Pt(nn, nn.current & 1);
            break;
        case 19:
            if (S = (g & f.childLanes) !== 0,
            u.flags & 128) {
                if (S)
                    return ib(u, f, g);
                f.flags |= 128
            }
            var b = f.memoizedState;
            if (b !== null && (b.rendering = null,
            b.tail = null,
            b.lastEffect = null),
            Pt(nn, nn.current),
            S)
                break;
            return null;
        case 22:
        case 23:
            return f.lanes = 0,
            YM(u, f, g)
        }
        return Cs(u, f, g)
    }
    function Lk(u, f) {
        switch (yv(f),
        f.tag) {
        case 1:
            return Si(f.type) && Ph(),
            u = f.flags,
            u & 65536 ? (f.flags = u & -65537 | 128,
            f) : null;
        case 3:
            return Wl(),
            dt(On),
            dt(Ot),
            bv(),
            u = f.flags,
            u & 65536 && !(u & 128) ? (f.flags = u & -65537 | 128,
            f) : null;
        case 5:
            return Sv(f),
            null;
        case 13:
            if (dt(nn),
            u = f.memoizedState,
            u !== null && u.dehydrated !== null) {
                if (f.alternate === null)
                    throw Error(o(340));
                Gl()
            }
            return u = f.flags,
            u & 65536 ? (f.flags = u & -65537 | 128,
            f) : null;
        case 19:
            return dt(nn),
            null;
        case 4:
            return Wl(),
            null;
        case 10:
            return dv(f.type._context),
            null;
        case 22:
        case 23:
            return ty(),
            null;
        case 24:
            return null;
        default:
            return null
        }
    }
    var rp = !1
      , Sa = !1
      , Dk = typeof WeakSet == "function" ? WeakSet : Set
      , ke = null;
    function sp(u, f) {
        var g = u.ref;
        if (g !== null)
            if (typeof g == "function")
                try {
                    g(null)
                } catch (S) {
                    Ci(u, f, S)
                }
            else
                g.current = null
    }
    function Ov(u, f, g) {
        try {
            g()
        } catch (S) {
            Ci(u, f, S)
        }
    }
    var rb = !1;
    function kk(u, f) {
        for (V(u.containerInfo),
        ke = f; ke !== null; )
            if (u = ke,
            f = u.child,
            (u.subtreeFlags & 1028) !== 0 && f !== null)
                f.return = u,
                ke = f;
            else
                for (; ke !== null; ) {
                    u = ke;
                    try {
                        var g = u.alternate;
                        if (u.flags & 1024)
                            switch (u.tag) {
                            case 0:
                            case 11:
                            case 15:
                                break;
                            case 1:
                                if (g !== null) {
                                    var S = g.memoizedProps
                                      , b = g.memoizedState
                                      , T = u.stateNode
                                      , N = T.getSnapshotBeforeUpdate(u.elementType === u.type ? S : Er(u.type, S), b);
                                    T.__reactInternalSnapshotBeforeUpdate = N
                                }
                                break;
                            case 3:
                                Le && Ue(u.stateNode.containerInfo);
                                break;
                            case 5:
                            case 6:
                            case 4:
                            case 17:
                                break;
                            default:
                                throw Error(o(163))
                            }
                    } catch (J) {
                        Ci(u, u.return, J)
                    }
                    if (f = u.sibling,
                    f !== null) {
                        f.return = u.return,
                        ke = f;
                        break
                    }
                    ke = u.return
                }
        return g = rb,
        rb = !1,
        g
    }
    function Ma(u, f, g) {
        var S = f.updateQueue;
        if (S = S !== null ? S.lastEffect : null,
        S !== null) {
            var b = S = S.next;
            do {
                if ((b.tag & u) === u) {
                    var T = b.destroy;
                    b.destroy = void 0,
                    T !== void 0 && Ov(f, g, T)
                }
                b = b.next
            } while (b !== S)
        }
    }
    function Jc(u, f) {
        if (f = f.updateQueue,
        f = f !== null ? f.lastEffect : null,
        f !== null) {
            var g = f = f.next;
            do {
                if ((g.tag & u) === u) {
                    var S = g.create;
                    g.destroy = S()
                }
                g = g.next
            } while (g !== f)
        }
    }
    function Uv(u) {
        var f = u.ref;
        if (f !== null) {
            var g = u.stateNode;
            switch (u.tag) {
            case 5:
                u = ne(g);
                break;
            default:
                u = g
            }
            typeof f == "function" ? f(u) : f.current = u
        }
    }
    function sb(u, f, g) {
        if (Qr && typeof Qr.onCommitFiberUnmount == "function")
            try {
                Qr.onCommitFiberUnmount(Dh, f)
            } catch {}
        switch (f.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            if (u = f.updateQueue,
            u !== null && (u = u.lastEffect,
            u !== null)) {
                var S = u = u.next;
                do {
                    var b = S
                      , T = b.destroy;
                    b = b.tag,
                    T !== void 0 && (b & 2 || b & 4) && Ov(f, g, T),
                    S = S.next
                } while (S !== u)
            }
            break;
        case 1:
            if (sp(f, g),
            u = f.stateNode,
            typeof u.componentWillUnmount == "function")
                try {
                    u.props = f.memoizedProps,
                    u.state = f.memoizedState,
                    u.componentWillUnmount()
                } catch (N) {
                    Ci(f, g, N)
                }
            break;
        case 5:
            sp(f, g);
            break;
        case 4:
            Le ? fb(u, f, g) : de && de && (f = f.stateNode.containerInfo,
            g = It(f),
            Kr(f, g))
        }
    }
    function ob(u, f, g) {
        for (var S = f; ; )
            if (sb(u, S, g),
            S.child === null || Le && S.tag === 4) {
                if (S === f)
                    break;
                for (; S.sibling === null; ) {
                    if (S.return === null || S.return === f)
                        return;
                    S = S.return
                }
                S.sibling.return = S.return,
                S = S.sibling
            } else
                S.child.return = S,
                S = S.child
    }
    function ab(u) {
        var f = u.alternate;
        f !== null && (u.alternate = null,
        ab(f)),
        u.child = null,
        u.deletions = null,
        u.sibling = null,
        u.tag === 5 && (f = u.stateNode,
        f !== null && $e(f)),
        u.stateNode = null,
        u.return = null,
        u.dependencies = null,
        u.memoizedProps = null,
        u.memoizedState = null,
        u.pendingProps = null,
        u.stateNode = null,
        u.updateQueue = null
    }
    function lb(u) {
        return u.tag === 5 || u.tag === 3 || u.tag === 4
    }
    function ub(u) {
        e: for (; ; ) {
            for (; u.sibling === null; ) {
                if (u.return === null || lb(u.return))
                    return null;
                u = u.return
            }
            for (u.sibling.return = u.return,
            u = u.sibling; u.tag !== 5 && u.tag !== 6 && u.tag !== 18; ) {
                if (u.flags & 2 || u.child === null || u.tag === 4)
                    continue e;
                u.child.return = u,
                u = u.child
            }
            if (!(u.flags & 2))
                return u.stateNode
        }
    }
    function cb(u) {
        if (Le) {
            e: {
                for (var f = u.return; f !== null; ) {
                    if (lb(f))
                        break e;
                    f = f.return
                }
                throw Error(o(160))
            }
            var g = f;
            switch (g.tag) {
            case 5:
                f = g.stateNode,
                g.flags & 32 && (_t(f),
                g.flags &= -33),
                g = ub(u),
                Gv(u, g, f);
                break;
            case 3:
            case 4:
                f = g.stateNode.containerInfo,
                g = ub(u),
                zv(u, g, f);
                break;
            default:
                throw Error(o(161))
            }
        }
    }
    function zv(u, f, g) {
        var S = u.tag;
        if (S === 5 || S === 6)
            u = u.stateNode,
            f ? Ae(g, u, f) : De(g, u);
        else if (S !== 4 && (u = u.child,
        u !== null))
            for (zv(u, f, g),
            u = u.sibling; u !== null; )
                zv(u, f, g),
                u = u.sibling
    }
    function Gv(u, f, g) {
        var S = u.tag;
        if (S === 5 || S === 6)
            u = u.stateNode,
            f ? le(g, u, f) : rt(g, u);
        else if (S !== 4 && (u = u.child,
        u !== null))
            for (Gv(u, f, g),
            u = u.sibling; u !== null; )
                Gv(u, f, g),
                u = u.sibling
    }
    function fb(u, f, g) {
        for (var S = f, b = !1, T, N; ; ) {
            if (!b) {
                b = S.return;
                e: for (; ; ) {
                    if (b === null)
                        throw Error(o(160));
                    switch (T = b.stateNode,
                    b.tag) {
                    case 5:
                        N = !1;
                        break e;
                    case 3:
                        T = T.containerInfo,
                        N = !0;
                        break e;
                    case 4:
                        T = T.containerInfo,
                        N = !0;
                        break e
                    }
                    b = b.return
                }
                b = !0
            }
            if (S.tag === 5 || S.tag === 6)
                ob(u, S, g),
                N ? tt(T, S.stateNode) : Te(T, S.stateNode);
            else if (S.tag === 18)
                N ? fn(T, S.stateNode) : Mt(T, S.stateNode);
            else if (S.tag === 4) {
                if (S.child !== null) {
                    T = S.stateNode.containerInfo,
                    N = !0,
                    S.child.return = S,
                    S = S.child;
                    continue
                }
            } else if (sb(u, S, g),
            S.child !== null) {
                S.child.return = S,
                S = S.child;
                continue
            }
            if (S === f)
                break;
            for (; S.sibling === null; ) {
                if (S.return === null || S.return === f)
                    return;
                S = S.return,
                S.tag === 4 && (b = !1)
            }
            S.sibling.return = S.return,
            S = S.sibling
        }
    }
    function Hv(u, f) {
        if (Le) {
            switch (f.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                Ma(3, f, f.return),
                Jc(3, f),
                Ma(5, f, f.return);
                return;
            case 1:
                return;
            case 5:
                var g = f.stateNode;
                if (g != null) {
                    var S = f.memoizedProps;
                    u = u !== null ? u.memoizedProps : S;
                    var b = f.type
                      , T = f.updateQueue;
                    f.updateQueue = null,
                    T !== null && H(g, T, b, u, S, f)
                }
                return;
            case 6:
                if (f.stateNode === null)
                    throw Error(o(162));
                g = f.memoizedProps,
                ge(f.stateNode, u !== null ? u.memoizedProps : g, g);
                return;
            case 3:
                ae && u !== null && u.memoizedState.isDehydrated && Et(f.stateNode.containerInfo);
                return;
            case 12:
                return;
            case 13:
                op(f);
                return;
            case 19:
                op(f);
                return;
            case 17:
                return
            }
            throw Error(o(163))
        }
        switch (f.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            Ma(3, f, f.return),
            Jc(3, f),
            Ma(5, f, f.return);
            return;
        case 12:
            return;
        case 13:
            op(f);
            return;
        case 19:
            op(f);
            return;
        case 3:
            ae && u !== null && u.memoizedState.isDehydrated && Et(f.stateNode.containerInfo);
            break;
        case 22:
        case 23:
            return
        }
        e: if (de) {
            switch (f.tag) {
            case 1:
            case 5:
            case 6:
                break e;
            case 3:
            case 4:
                f = f.stateNode,
                Kr(f.containerInfo, f.pendingChildren);
                break e
            }
            throw Error(o(163))
        }
    }
    function op(u) {
        var f = u.updateQueue;
        if (f !== null) {
            u.updateQueue = null;
            var g = u.stateNode;
            g === null && (g = u.stateNode = new Dk),
            f.forEach(function(S) {
                var b = jk.bind(null, u, S);
                g.has(S) || (g.add(S),
                S.then(b, b))
            })
        }
    }
    function Fk(u, f) {
        for (ke = f; ke !== null; ) {
            f = ke;
            var g = f.deletions;
            if (g !== null)
                for (var S = 0; S < g.length; S++) {
                    var b = g[S];
                    try {
                        var T = u;
                        Le ? fb(T, b, f) : ob(T, b, f);
                        var N = b.alternate;
                        N !== null && (N.return = null),
                        b.return = null
                    } catch (Qe) {
                        Ci(b, f, Qe)
                    }
                }
            if (g = f.child,
            f.subtreeFlags & 12854 && g !== null)
                g.return = f,
                ke = g;
            else
                for (; ke !== null; ) {
                    f = ke;
                    try {
                        var J = f.flags;
                        if (J & 32 && Le && _t(f.stateNode),
                        J & 512) {
                            var fe = f.alternate;
                            if (fe !== null) {
                                var Ee = fe.ref;
                                Ee !== null && (typeof Ee == "function" ? Ee(null) : Ee.current = null)
                            }
                        }
                        if (J & 8192)
                            switch (f.tag) {
                            case 13:
                                if (f.memoizedState !== null) {
                                    var We = f.alternate;
                                    (We === null || We.memoizedState === null) && (Kv = Un())
                                }
                                break;
                            case 22:
                                var lt = f.memoizedState !== null
                                  , nt = f.alternate
                                  , Ht = nt !== null && nt.memoizedState !== null;
                                if (g = f,
                                Le) {
                                    e: if (S = g,
                                    b = lt,
                                    T = null,
                                    Le)
                                        for (var qe = S; ; ) {
                                            if (qe.tag === 5) {
                                                if (T === null) {
                                                    T = qe;
                                                    var ti = qe.stateNode;
                                                    b ? Jt(ti) : ce(qe.stateNode, qe.memoizedProps)
                                                }
                                            } else if (qe.tag === 6) {
                                                if (T === null) {
                                                    var fr = qe.stateNode;
                                                    b ? X(fr) : xe(fr, qe.memoizedProps)
                                                }
                                            } else if ((qe.tag !== 22 && qe.tag !== 23 || qe.memoizedState === null || qe === S) && qe.child !== null) {
                                                qe.child.return = qe,
                                                qe = qe.child;
                                                continue
                                            }
                                            if (qe === S)
                                                break;
                                            for (; qe.sibling === null; ) {
                                                if (qe.return === null || qe.return === S)
                                                    break e;
                                                T === qe && (T = null),
                                                qe = qe.return
                                            }
                                            T === qe && (T = null),
                                            qe.sibling.return = qe.return,
                                            qe = qe.sibling
                                        }
                                }
                                if (lt && !Ht && g.mode & 1) {
                                    ke = g;
                                    for (var te = g.child; te !== null; ) {
                                        for (g = ke = te; ke !== null; ) {
                                            S = ke;
                                            var Q = S.child;
                                            switch (S.tag) {
                                            case 0:
                                            case 11:
                                            case 14:
                                            case 15:
                                                Ma(4, S, S.return);
                                                break;
                                            case 1:
                                                sp(S, S.return);
                                                var ue = S.stateNode;
                                                if (typeof ue.componentWillUnmount == "function") {
                                                    var Fe = S.return;
                                                    try {
                                                        ue.props = S.memoizedProps,
                                                        ue.state = S.memoizedState,
                                                        ue.componentWillUnmount()
                                                    } catch (Qe) {
                                                        Ci(S, Fe, Qe)
                                                    }
                                                }
                                                break;
                                            case 5:
                                                sp(S, S.return);
                                                break;
                                            case 22:
                                                if (S.memoizedState !== null) {
                                                    pb(g);
                                                    continue
                                                }
                                            }
                                            Q !== null ? (Q.return = S,
                                            ke = Q) : pb(g)
                                        }
                                        te = te.sibling
                                    }
                                }
                            }
                        switch (J & 4102) {
                        case 2:
                            cb(f),
                            f.flags &= -3;
                            break;
                        case 6:
                            cb(f),
                            f.flags &= -3,
                            Hv(f.alternate, f);
                            break;
                        case 4096:
                            f.flags &= -4097;
                            break;
                        case 4100:
                            f.flags &= -4097,
                            Hv(f.alternate, f);
                            break;
                        case 4:
                            Hv(f.alternate, f)
                        }
                    } catch (Qe) {
                        Ci(f, f.return, Qe)
                    }
                    if (g = f.sibling,
                    g !== null) {
                        g.return = f.return,
                        ke = g;
                        break
                    }
                    ke = f.return
                }
        }
    }
    function Nk(u, f, g) {
        ke = u,
        db(u)
    }
    function db(u, f, g) {
        for (var S = (u.mode & 1) !== 0; ke !== null; ) {
            var b = ke
              , T = b.child;
            if (b.tag === 22 && S) {
                var N = b.memoizedState !== null || rp;
                if (!N) {
                    var J = b.alternate
                      , fe = J !== null && J.memoizedState !== null || Sa;
                    J = rp;
                    var Ee = Sa;
                    if (rp = N,
                    (Sa = fe) && !Ee)
                        for (ke = b; ke !== null; )
                            N = ke,
                            fe = N.child,
                            N.tag === 22 && N.memoizedState !== null ? mb(b) : fe !== null ? (fe.return = N,
                            ke = fe) : mb(b);
                    for (; T !== null; )
                        ke = T,
                        db(T),
                        T = T.sibling;
                    ke = b,
                    rp = J,
                    Sa = Ee
                }
                hb(u)
            } else
                b.subtreeFlags & 8772 && T !== null ? (T.return = b,
                ke = T) : hb(u)
        }
    }
    function hb(u) {
        for (; ke !== null; ) {
            var f = ke;
            if (f.flags & 8772) {
                var g = f.alternate;
                try {
                    if (f.flags & 8772)
                        switch (f.tag) {
                        case 0:
                        case 11:
                        case 15:
                            Sa || Jc(5, f);
                            break;
                        case 1:
                            var S = f.stateNode;
                            if (f.flags & 4 && !Sa)
                                if (g === null)
                                    S.componentDidMount();
                                else {
                                    var b = f.elementType === f.type ? g.memoizedProps : Er(f.type, g.memoizedProps);
                                    S.componentDidUpdate(b, g.memoizedState, S.__reactInternalSnapshotBeforeUpdate)
                                }
                            var T = f.updateQueue;
                            T !== null && aM(f, T, S);
                            break;
                        case 3:
                            var N = f.updateQueue;
                            if (N !== null) {
                                if (g = null,
                                f.child !== null)
                                    switch (f.child.tag) {
                                    case 5:
                                        g = ne(f.child.stateNode);
                                        break;
                                    case 1:
                                        g = f.child.stateNode
                                    }
                                aM(f, N, g)
                            }
                            break;
                        case 5:
                            var J = f.stateNode;
                            g === null && f.flags & 4 && Ke(J, f.type, f.memoizedProps, f);
                            break;
                        case 6:
                            break;
                        case 4:
                            break;
                        case 12:
                            break;
                        case 13:
                            if (ae && f.memoizedState === null) {
                                var fe = f.alternate;
                                if (fe !== null) {
                                    var Ee = fe.memoizedState;
                                    if (Ee !== null) {
                                        var We = Ee.dehydrated;
                                        We !== null && St(We)
                                    }
                                }
                            }
                            break;
                        case 19:
                        case 17:
                        case 21:
                        case 22:
                        case 23:
                            break;
                        default:
                            throw Error(o(163))
                        }
                    Sa || f.flags & 512 && Uv(f)
                } catch (lt) {
                    Ci(f, f.return, lt)
                }
            }
            if (f === u) {
                ke = null;
                break
            }
            if (g = f.sibling,
            g !== null) {
                g.return = f.return,
                ke = g;
                break
            }
            ke = f.return
        }
    }
    function pb(u) {
        for (; ke !== null; ) {
            var f = ke;
            if (f === u) {
                ke = null;
                break
            }
            var g = f.sibling;
            if (g !== null) {
                g.return = f.return,
                ke = g;
                break
            }
            ke = f.return
        }
    }
    function mb(u) {
        for (; ke !== null; ) {
            var f = ke;
            try {
                switch (f.tag) {
                case 0:
                case 11:
                case 15:
                    var g = f.return;
                    try {
                        Jc(4, f)
                    } catch (fe) {
                        Ci(f, g, fe)
                    }
                    break;
                case 1:
                    var S = f.stateNode;
                    if (typeof S.componentDidMount == "function") {
                        var b = f.return;
                        try {
                            S.componentDidMount()
                        } catch (fe) {
                            Ci(f, b, fe)
                        }
                    }
                    var T = f.return;
                    try {
                        Uv(f)
                    } catch (fe) {
                        Ci(f, T, fe)
                    }
                    break;
                case 5:
                    var N = f.return;
                    try {
                        Uv(f)
                    } catch (fe) {
                        Ci(f, N, fe)
                    }
                }
            } catch (fe) {
                Ci(f, f.return, fe)
            }
            if (f === u) {
                ke = null;
                break
            }
            var J = f.sibling;
            if (J !== null) {
                J.return = f.return,
                ke = J;
                break
            }
            ke = f.return
        }
    }
    var ap = 0
      , lp = 1
      , up = 2
      , cp = 3
      , fp = 4;
    if (typeof Symbol == "function" && Symbol.for) {
        var Xc = Symbol.for;
        ap = Xc("selector.component"),
        lp = Xc("selector.has_pseudo_class"),
        up = Xc("selector.role"),
        cp = Xc("selector.test_id"),
        fp = Xc("selector.text")
    }
    function Vv(u) {
        var f = be(u);
        if (f != null) {
            if (typeof f.memoizedProps["data-testname"] != "string")
                throw Error(o(364));
            return f
        }
        if (u = Ct(u),
        u === null)
            throw Error(o(362));
        return u.stateNode.current
    }
    function Wv(u, f) {
        switch (f.$$typeof) {
        case ap:
            if (u.type === f.value)
                return !0;
            break;
        case lp:
            e: {
                f = f.value,
                u = [u, 0];
                for (var g = 0; g < u.length; ) {
                    var S = u[g++]
                      , b = u[g++]
                      , T = f[b];
                    if (S.tag !== 5 || !se(S)) {
                        for (; T != null && Wv(S, T); )
                            b++,
                            T = f[b];
                        if (b === f.length) {
                            f = !0;
                            break e
                        } else
                            for (S = S.child; S !== null; )
                                u.push(S, b),
                                S = S.sibling
                    }
                }
                f = !1
            }
            return f;
        case up:
            if (u.tag === 5 && Se(u.stateNode, f.value))
                return !0;
            break;
        case fp:
            if ((u.tag === 5 || u.tag === 6) && (u = L(u),
            u !== null && 0 <= u.indexOf(f.value)))
                return !0;
            break;
        case cp:
            if (u.tag === 5 && (u = u.memoizedProps["data-testname"],
            typeof u == "string" && u.toLowerCase() === f.value.toLowerCase()))
                return !0;
            break;
        default:
            throw Error(o(365))
        }
        return !1
    }
    function jv(u) {
        switch (u.$$typeof) {
        case ap:
            return "<" + (R(u.value) || "Unknown") + ">";
        case lp:
            return ":has(" + (jv(u) || "") + ")";
        case up:
            return '[role="' + u.value + '"]';
        case fp:
            return '"' + u.value + '"';
        case cp:
            return '[data-testname="' + u.value + '"]';
        default:
            throw Error(o(365))
        }
    }
    function gb(u, f) {
        var g = [];
        u = [u, 0];
        for (var S = 0; S < u.length; ) {
            var b = u[S++]
              , T = u[S++]
              , N = f[T];
            if (b.tag !== 5 || !se(b)) {
                for (; N != null && Wv(b, N); )
                    T++,
                    N = f[T];
                if (T === f.length)
                    g.push(b);
                else
                    for (b = b.child; b !== null; )
                        u.push(b, T),
                        b = b.sibling
            }
        }
        return g
    }
    function Jv(u, f) {
        if (!At)
            throw Error(o(363));
        u = Vv(u),
        u = gb(u, f),
        f = [],
        u = Array.from(u);
        for (var g = 0; g < u.length; ) {
            var S = u[g++];
            if (S.tag === 5)
                se(S) || f.push(S.stateNode);
            else
                for (S = S.child; S !== null; )
                    u.push(S),
                    S = S.sibling
        }
        return f
    }
    var Ok = Math.ceil
      , dp = a.ReactCurrentDispatcher
      , Xv = a.ReactCurrentOwner
      , xn = a.ReactCurrentBatchConfig
      , xt = 0
      , Sn = null
      , Mn = null
      , jn = 0
      , Oi = 0
      , Jl = nr(0)
      , Pn = 0
      , Yc = null
      , Xl = 0
      , hp = 0
      , Yv = 0
      , Kc = null
      , Mi = null
      , Kv = 0
      , Qv = 1 / 0;
    function Yl() {
        Qv = Un() + 500
    }
    var pp = !1
      , Zv = null
      , fo = null
      , mp = !1
      , ho = null
      , gp = 0
      , Qc = 0
      , qv = null
      , vp = -1
      , yp = 0;
    function fi() {
        return xt & 6 ? Un() : vp !== -1 ? vp : vp = Un()
    }
    function po(u) {
        return u.mode & 1 ? xt & 2 && jn !== 0 ? jn & -jn : _k.transition !== null ? (yp === 0 && (u = Rh,
        Rh <<= 1,
        !(Rh & 4194240) && (Rh = 64),
        yp = u),
        yp) : (u = Dt,
        u !== 0 ? u : Be()) : 1
    }
    function ur(u, f, g) {
        if (50 < Qc)
            throw Qc = 0,
            qv = null,
            Error(o(185));
        var S = xp(u, f);
        return S === null ? null : (Lc(S, f, g),
        (!(xt & 2) || S !== Sn) && (S === Sn && (!(xt & 2) && (hp |= f),
        Pn === 4 && mo(S, jn)),
        bi(S, g),
        f === 1 && xt === 0 && !(u.mode & 1) && (Yl(),
        kh && qr())),
        S)
    }
    function xp(u, f) {
        u.lanes |= f;
        var g = u.alternate;
        for (g !== null && (g.lanes |= f),
        g = u,
        u = u.return; u !== null; )
            u.childLanes |= f,
            g = u.alternate,
            g !== null && (g.childLanes |= f),
            g = u,
            u = u.return;
        return g.tag === 3 ? g.stateNode : null
    }
    function bi(u, f) {
        var g = u.callbackNode;
        fk(u, f);
        var S = Lh(u, u === Sn ? jn : 0);
        if (S === 0)
            g !== null && nM(g),
            u.callbackNode = null,
            u.callbackPriority = 0;
        else if (f = S & -S,
        u.callbackPriority !== f) {
            if (g != null && nM(g),
            f === 1)
                u.tag === 0 ? xk(yb.bind(null, u)) : iM(yb.bind(null, u)),
                Ye ? Je(function() {
                    xt === 0 && qr()
                }) : ov(av, qr),
                g = null;
            else {
                switch (tM(S)) {
                case 1:
                    g = av;
                    break;
                case 4:
                    g = mk;
                    break;
                case 16:
                    g = lv;
                    break;
                case 536870912:
                    g = gk;
                    break;
                default:
                    g = lv
                }
                g = Eb(g, vb.bind(null, u))
            }
            u.callbackPriority = f,
            u.callbackNode = g
        }
    }
    function vb(u, f) {
        if (vp = -1,
        yp = 0,
        xt & 6)
            throw Error(o(327));
        var g = u.callbackNode;
        if (Ea() && u.callbackNode !== g)
            return null;
        var S = Lh(u, u === Sn ? jn : 0);
        if (S === 0)
            return null;
        if (S & 30 || S & u.expiredLanes || f)
            f = _p(u, S);
        else {
            f = S;
            var b = xt;
            xt |= 2;
            var T = Ab();
            (Sn !== u || jn !== f) && (Yl(),
            ba(u, f));
            do
                try {
                    Gk();
                    break
                } catch (J) {
                    _b(u, J)
                }
            while (1);
            fv(),
            dp.current = T,
            xt = b,
            Mn !== null ? f = 0 : (Sn = null,
            jn = 0,
            f = Pn)
        }
        if (f !== 0) {
            if (f === 2 && (b = iv(u),
            b !== 0 && (S = b,
            f = $v(u, b))),
            f === 1)
                throw g = Yc,
                ba(u, 0),
                mo(u, S),
                bi(u, Un()),
                g;
            if (f === 6)
                mo(u, S);
            else {
                if (b = u.current.alternate,
                !(S & 30) && !Uk(b) && (f = _p(u, S),
                f === 2 && (T = iv(u),
                T !== 0 && (S = T,
                f = $v(u, T))),
                f === 1))
                    throw g = Yc,
                    ba(u, 0),
                    mo(u, S),
                    bi(u, Un()),
                    g;
                switch (u.finishedWork = b,
                u.finishedLanes = S,
                f) {
                case 0:
                case 1:
                    throw Error(o(345));
                case 2:
                    Ca(u, Mi);
                    break;
                case 3:
                    if (mo(u, S),
                    (S & 130023424) === S && (f = Kv + 500 - Un(),
                    10 < f)) {
                        if (Lh(u, 0) !== 0)
                            break;
                        if (b = u.suspendedLanes,
                        (b & S) !== S) {
                            fi(),
                            u.pingedLanes |= u.suspendedLanes & b;
                            break
                        }
                        u.timeoutHandle = Ne(Ca.bind(null, u, Mi), f);
                        break
                    }
                    Ca(u, Mi);
                    break;
                case 4:
                    if (mo(u, S),
                    (S & 4194240) === S)
                        break;
                    for (f = u.eventTimes,
                    b = -1; 0 < S; ) {
                        var N = 31 - Cr(S);
                        T = 1 << N,
                        N = f[N],
                        N > b && (b = N),
                        S &= ~T
                    }
                    if (S = b,
                    S = Un() - S,
                    S = (120 > S ? 120 : 480 > S ? 480 : 1080 > S ? 1080 : 1920 > S ? 1920 : 3e3 > S ? 3e3 : 4320 > S ? 4320 : 1960 * Ok(S / 1960)) - S,
                    10 < S) {
                        u.timeoutHandle = Ne(Ca.bind(null, u, Mi), S);
                        break
                    }
                    Ca(u, Mi);
                    break;
                case 5:
                    Ca(u, Mi);
                    break;
                default:
                    throw Error(o(329))
                }
            }
        }
        return bi(u, Un()),
        u.callbackNode === g ? vb.bind(null, u) : null
    }
    function $v(u, f) {
        var g = Kc;
        return u.current.memoizedState.isDehydrated && (ba(u, f).flags |= 256),
        u = _p(u, f),
        u !== 2 && (f = Mi,
        Mi = g,
        f !== null && ey(f)),
        u
    }
    function ey(u) {
        Mi === null ? Mi = u : Mi.push.apply(Mi, u)
    }
    function Uk(u) {
        for (var f = u; ; ) {
            if (f.flags & 16384) {
                var g = f.updateQueue;
                if (g !== null && (g = g.stores,
                g !== null))
                    for (var S = 0; S < g.length; S++) {
                        var b = g[S]
                          , T = b.getSnapshot;
                        b = b.value;
                        try {
                            if (!Zr(T(), b))
                                return !1
                        } catch {
                            return !1
                        }
                    }
            }
            if (g = f.child,
            f.subtreeFlags & 16384 && g !== null)
                g.return = f,
                f = g;
            else {
                if (f === u)
                    break;
                for (; f.sibling === null; ) {
                    if (f.return === null || f.return === u)
                        return !0;
                    f = f.return
                }
                f.sibling.return = f.return,
                f = f.sibling
            }
        }
        return !0
    }
    function mo(u, f) {
        for (f &= ~Yv,
        f &= ~hp,
        u.suspendedLanes |= f,
        u.pingedLanes &= ~f,
        u = u.expirationTimes; 0 < f; ) {
            var g = 31 - Cr(f)
              , S = 1 << g;
            u[g] = -1,
            f &= ~S
        }
    }
    function yb(u) {
        if (xt & 6)
            throw Error(o(327));
        Ea();
        var f = Lh(u, 0);
        if (!(f & 1))
            return bi(u, Un()),
            null;
        var g = _p(u, f);
        if (u.tag !== 0 && g === 2) {
            var S = iv(u);
            S !== 0 && (f = S,
            g = $v(u, S))
        }
        if (g === 1)
            throw g = Yc,
            ba(u, 0),
            mo(u, f),
            bi(u, Un()),
            g;
        if (g === 6)
            throw Error(o(345));
        return u.finishedWork = u.current.alternate,
        u.finishedLanes = f,
        Ca(u, Mi),
        bi(u, Un()),
        null
    }
    function xb(u) {
        ho !== null && ho.tag === 0 && !(xt & 6) && Ea();
        var f = xt;
        xt |= 1;
        var g = xn.transition
          , S = Dt;
        try {
            if (xn.transition = null,
            Dt = 1,
            u)
                return u()
        } finally {
            Dt = S,
            xn.transition = g,
            xt = f,
            !(xt & 6) && qr()
        }
    }
    function ty() {
        Oi = Jl.current,
        dt(Jl)
    }
    function ba(u, f) {
        u.finishedWork = null,
        u.finishedLanes = 0;
        var g = u.timeoutHandle;
        if (g !== Ve && (u.timeoutHandle = Ve,
        Oe(g)),
        Mn !== null)
            for (g = Mn.return; g !== null; ) {
                var S = g;
                switch (yv(S),
                S.tag) {
                case 1:
                    S = S.type.childContextTypes,
                    S != null && Ph();
                    break;
                case 3:
                    Wl(),
                    dt(On),
                    dt(Ot),
                    bv();
                    break;
                case 5:
                    Sv(S);
                    break;
                case 4:
                    Wl();
                    break;
                case 13:
                    dt(nn);
                    break;
                case 19:
                    dt(nn);
                    break;
                case 10:
                    dv(S.type._context);
                    break;
                case 22:
                case 23:
                    ty()
                }
                g = g.return
            }
        if (Sn = u,
        Mn = u = go(u.current, null),
        jn = Oi = f,
        Pn = 0,
        Yc = null,
        Yv = hp = Xl = 0,
        Mi = Kc = null,
        $r !== null) {
            for (f = 0; f < $r.length; f++)
                if (g = $r[f],
                S = g.interleaved,
                S !== null) {
                    g.interleaved = null;
                    var b = S.next
                      , T = g.pending;
                    if (T !== null) {
                        var N = T.next;
                        T.next = b,
                        S.next = N
                    }
                    g.pending = S
                }
            $r = null
        }
        return u
    }
    function _b(u, f) {
        do {
            var g = Mn;
            try {
                if (fv(),
                Jh.current = qh,
                Xh) {
                    for (var S = hn.memoizedState; S !== null; ) {
                        var b = S.queue;
                        b !== null && (b.pending = null),
                        S = S.next
                    }
                    Xh = !1
                }
                if (jl = 0,
                zn = qn = hn = null,
                Uc = !1,
                zc = 0,
                Xv.current = null,
                g === null || g.return === null) {
                    Pn = 1,
                    Yc = f,
                    Mn = null;
                    break
                }
                e: {
                    var T = u
                      , N = g.return
                      , J = g
                      , fe = f;
                    if (f = jn,
                    J.flags |= 32768,
                    fe !== null && typeof fe == "object" && typeof fe.then == "function") {
                        var Ee = fe
                          , We = J
                          , lt = We.tag;
                        if (!(We.mode & 1) && (lt === 0 || lt === 11 || lt === 15)) {
                            var nt = We.alternate;
                            nt ? (We.updateQueue = nt.updateQueue,
                            We.memoizedState = nt.memoizedState,
                            We.lanes = nt.lanes) : (We.updateQueue = null,
                            We.memoizedState = null)
                        }
                        var Ht = GM(N);
                        if (Ht !== null) {
                            Ht.flags &= -257,
                            HM(Ht, N, J, T, f),
                            Ht.mode & 1 && zM(T, Ee, f),
                            f = Ht,
                            fe = Ee;
                            var qe = f.updateQueue;
                            if (qe === null) {
                                var ti = new Set;
                                ti.add(fe),
                                f.updateQueue = ti
                            } else
                                qe.add(fe);
                            break e
                        } else {
                            if (!(f & 1)) {
                                zM(T, Ee, f),
                                ny();
                                break e
                            }
                            fe = Error(o(426))
                        }
                    } else if (qt && J.mode & 1) {
                        var fr = GM(N);
                        if (fr !== null) {
                            !(fr.flags & 65536) && (fr.flags |= 256),
                            HM(fr, N, J, T, f),
                            Av(fe);
                            break e
                        }
                    }
                    T = fe,
                    Pn !== 4 && (Pn = 2),
                    Kc === null ? Kc = [T] : Kc.push(T),
                    fe = Iv(fe, J),
                    J = N;
                    do {
                        switch (J.tag) {
                        case 3:
                            J.flags |= 65536,
                            f &= -f,
                            J.lanes |= f;
                            var te = OM(J, fe, f);
                            oM(J, te);
                            break e;
                        case 1:
                            T = fe;
                            var Q = J.type
                              , ue = J.stateNode;
                            if (!(J.flags & 128) && (typeof Q.getDerivedStateFromError == "function" || ue !== null && typeof ue.componentDidCatch == "function" && (fo === null || !fo.has(ue)))) {
                                J.flags |= 65536,
                                f &= -f,
                                J.lanes |= f;
                                var Fe = UM(J, T, f);
                                oM(J, Fe);
                                break e
                            }
                        }
                        J = J.return
                    } while (J !== null)
                }
                Sb(g)
            } catch (Qe) {
                f = Qe,
                Mn === g && g !== null && (Mn = g = g.return);
                continue
            }
            break
        } while (1)
    }
    function Ab() {
        var u = dp.current;
        return dp.current = qh,
        u === null ? qh : u
    }
    function ny() {
        (Pn === 0 || Pn === 3 || Pn === 2) && (Pn = 4),
        Sn === null || !(Xl & 268435455) && !(hp & 268435455) || mo(Sn, jn)
    }
    function _p(u, f) {
        var g = xt;
        xt |= 2;
        var S = Ab();
        Sn === u && jn === f || ba(u, f);
        do
            try {
                zk();
                break
            } catch (b) {
                _b(u, b)
            }
        while (1);
        if (fv(),
        xt = g,
        dp.current = S,
        Mn !== null)
            throw Error(o(261));
        return Sn = null,
        jn = 0,
        Pn
    }
    function zk() {
        for (; Mn !== null; )
            wb(Mn)
    }
    function Gk() {
        for (; Mn !== null && !hk(); )
            wb(Mn)
    }
    function wb(u) {
        var f = Cb(u.alternate, u, Oi);
        u.memoizedProps = u.pendingProps,
        f === null ? Sb(u) : Mn = f,
        Xv.current = null
    }
    function Sb(u) {
        var f = u;
        do {
            var g = f.alternate;
            if (u = f.return,
            f.flags & 32768) {
                if (g = Lk(g, f),
                g !== null) {
                    g.flags &= 32767,
                    Mn = g;
                    return
                }
                if (u !== null)
                    u.flags |= 32768,
                    u.subtreeFlags = 0,
                    u.deletions = null;
                else {
                    Pn = 6,
                    Mn = null;
                    return
                }
            } else if (g = Bk(g, f, Oi),
            g !== null) {
                Mn = g;
                return
            }
            if (f = f.sibling,
            f !== null) {
                Mn = f;
                return
            }
            Mn = f = u
        } while (f !== null);
        Pn === 0 && (Pn = 5)
    }
    function Ca(u, f) {
        var g = Dt
          , S = xn.transition;
        try {
            xn.transition = null,
            Dt = 1,
            Hk(u, f, g)
        } finally {
            xn.transition = S,
            Dt = g
        }
        return null
    }
    function Hk(u, f, g) {
        do
            Ea();
        while (ho !== null);
        if (xt & 6)
            throw Error(o(327));
        var S = u.finishedWork
          , b = u.finishedLanes;
        if (S === null)
            return null;
        if (u.finishedWork = null,
        u.finishedLanes = 0,
        S === u.current)
            throw Error(o(177));
        u.callbackNode = null,
        u.callbackPriority = 0;
        var T = S.lanes | S.childLanes;
        if (dk(u, T),
        u === Sn && (Mn = Sn = null,
        jn = 0),
        !(S.subtreeFlags & 2064) && !(S.flags & 2064) || mp || (mp = !0,
        Eb(lv, function() {
            return Ea(),
            null
        })),
        T = (S.flags & 15990) !== 0,
        S.subtreeFlags & 15990 || T) {
            T = xn.transition,
            xn.transition = null;
            var N = Dt;
            Dt = 1;
            var J = xt;
            xt |= 4,
            Xv.current = null,
            kk(u, S),
            Fk(u, S),
            Y(u.containerInfo),
            u.current = S,
            Nk(S),
            pk(),
            xt = J,
            Dt = N,
            xn.transition = T
        } else
            u.current = S;
        if (mp && (mp = !1,
        ho = u,
        gp = b),
        T = u.pendingLanes,
        T === 0 && (fo = null),
        vk(S.stateNode),
        bi(u, Un()),
        f !== null)
            for (g = u.onRecoverableError,
            S = 0; S < f.length; S++)
                g(f[S]);
        if (pp)
            throw pp = !1,
            u = Zv,
            Zv = null,
            u;
        return gp & 1 && u.tag !== 0 && Ea(),
        T = u.pendingLanes,
        T & 1 ? u === qv ? Qc++ : (Qc = 0,
        qv = u) : Qc = 0,
        qr(),
        null
    }
    function Ea() {
        if (ho !== null) {
            var u = tM(gp)
              , f = xn.transition
              , g = Dt;
            try {
                if (xn.transition = null,
                Dt = 16 > u ? 16 : u,
                ho === null)
                    var S = !1;
                else {
                    if (u = ho,
                    ho = null,
                    gp = 0,
                    xt & 6)
                        throw Error(o(331));
                    var b = xt;
                    for (xt |= 4,
                    ke = u.current; ke !== null; ) {
                        var T = ke
                          , N = T.child;
                        if (ke.flags & 16) {
                            var J = T.deletions;
                            if (J !== null) {
                                for (var fe = 0; fe < J.length; fe++) {
                                    var Ee = J[fe];
                                    for (ke = Ee; ke !== null; ) {
                                        var We = ke;
                                        switch (We.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            Ma(8, We, T)
                                        }
                                        var lt = We.child;
                                        if (lt !== null)
                                            lt.return = We,
                                            ke = lt;
                                        else
                                            for (; ke !== null; ) {
                                                We = ke;
                                                var nt = We.sibling
                                                  , Ht = We.return;
                                                if (ab(We),
                                                We === Ee) {
                                                    ke = null;
                                                    break
                                                }
                                                if (nt !== null) {
                                                    nt.return = Ht,
                                                    ke = nt;
                                                    break
                                                }
                                                ke = Ht
                                            }
                                    }
                                }
                                var qe = T.alternate;
                                if (qe !== null) {
                                    var ti = qe.child;
                                    if (ti !== null) {
                                        qe.child = null;
                                        do {
                                            var fr = ti.sibling;
                                            ti.sibling = null,
                                            ti = fr
                                        } while (ti !== null)
                                    }
                                }
                                ke = T
                            }
                        }
                        if (T.subtreeFlags & 2064 && N !== null)
                            N.return = T,
                            ke = N;
                        else
                            e: for (; ke !== null; ) {
                                if (T = ke,
                                T.flags & 2048)
                                    switch (T.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Ma(9, T, T.return)
                                    }
                                var te = T.sibling;
                                if (te !== null) {
                                    te.return = T.return,
                                    ke = te;
                                    break e
                                }
                                ke = T.return
                            }
                    }
                    var Q = u.current;
                    for (ke = Q; ke !== null; ) {
                        N = ke;
                        var ue = N.child;
                        if (N.subtreeFlags & 2064 && ue !== null)
                            ue.return = N,
                            ke = ue;
                        else
                            e: for (N = Q; ke !== null; ) {
                                if (J = ke,
                                J.flags & 2048)
                                    try {
                                        switch (J.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            Jc(9, J)
                                        }
                                    } catch (Qe) {
                                        Ci(J, J.return, Qe)
                                    }
                                if (J === N) {
                                    ke = null;
                                    break e
                                }
                                var Fe = J.sibling;
                                if (Fe !== null) {
                                    Fe.return = J.return,
                                    ke = Fe;
                                    break e
                                }
                                ke = J.return
                            }
                    }
                    if (xt = b,
                    qr(),
                    Qr && typeof Qr.onPostCommitFiberRoot == "function")
                        try {
                            Qr.onPostCommitFiberRoot(Dh, u)
                        } catch {}
                    S = !0
                }
                return S
            } finally {
                Dt = g,
                xn.transition = f
            }
        }
        return !1
    }
    function Mb(u, f, g) {
        f = Iv(g, f),
        f = OM(u, f, 1),
        co(u, f),
        f = fi(),
        u = xp(u, 1),
        u !== null && (Lc(u, 1, f),
        bi(u, f))
    }
    function Ci(u, f, g) {
        if (u.tag === 3)
            Mb(u, u, g);
        else
            for (; f !== null; ) {
                if (f.tag === 3) {
                    Mb(f, u, g);
                    break
                } else if (f.tag === 1) {
                    var S = f.stateNode;
                    if (typeof f.type.getDerivedStateFromError == "function" || typeof S.componentDidCatch == "function" && (fo === null || !fo.has(S))) {
                        u = Iv(g, u),
                        u = UM(f, u, 1),
                        co(f, u),
                        u = fi(),
                        f = xp(f, 1),
                        f !== null && (Lc(f, 1, u),
                        bi(f, u));
                        break
                    }
                }
                f = f.return
            }
    }
    function Vk(u, f, g) {
        var S = u.pingCache;
        S !== null && S.delete(f),
        f = fi(),
        u.pingedLanes |= u.suspendedLanes & g,
        Sn === u && (jn & g) === g && (Pn === 4 || Pn === 3 && (jn & 130023424) === jn && 500 > Un() - Kv ? ba(u, 0) : Yv |= g),
        bi(u, f)
    }
    function bb(u, f) {
        f === 0 && (u.mode & 1 ? (f = Ih,
        Ih <<= 1,
        !(Ih & 130023424) && (Ih = 4194304)) : f = 1);
        var g = fi();
        u = xp(u, f),
        u !== null && (Lc(u, f, g),
        bi(u, g))
    }
    function Wk(u) {
        var f = u.memoizedState
          , g = 0;
        f !== null && (g = f.retryLane),
        bb(u, g)
    }
    function jk(u, f) {
        var g = 0;
        switch (u.tag) {
        case 13:
            var S = u.stateNode
              , b = u.memoizedState;
            b !== null && (g = b.retryLane);
            break;
        case 19:
            S = u.stateNode;
            break;
        default:
            throw Error(o(314))
        }
        S !== null && S.delete(f),
        bb(u, g)
    }
    var Cb;
    Cb = function(u, f, g) {
        if (u !== null)
            if (u.memoizedProps !== f.pendingProps || On.current)
                Ni = !0;
            else {
                if (!(u.lanes & g) && !(f.flags & 128))
                    return Ni = !1,
                    Ik(u, f, g);
                Ni = !!(u.flags & 131072)
            }
        else
            Ni = !1,
            qt && f.flags & 1048576 && dM(f, Vh, f.index);
        switch (f.lanes = 0,
        f.tag) {
        case 2:
            var S = f.type;
            u !== null && (u.alternate = null,
            f.alternate = null,
            f.flags |= 2),
            u = f.pendingProps;
            var b = _s(f, Ot.current);
            Ol(f, g),
            b = Ev(null, f, S, u, b, g);
            var T = Tv();
            return f.flags |= 1,
            typeof b == "object" && b !== null && typeof b.render == "function" && b.$$typeof === void 0 ? (f.tag = 1,
            f.memoizedState = null,
            f.updateQueue = null,
            Si(S) ? (T = !0,
            Bh(f)) : T = !1,
            f.memoizedState = b.state !== null && b.state !== void 0 ? b.state : null,
            pv(f),
            b.updater = Gh,
            f.stateNode = b,
            b._reactInternals = f,
            gv(f, S, u, g),
            f = kv(null, f, S, !0, T, g)) : (f.tag = 0,
            qt && T && vv(f),
            ci(null, f, b, g),
            f = f.child),
            f;
        case 16:
            S = f.elementType;
            e: {
                switch (u !== null && (u.alternate = null,
                f.alternate = null,
                f.flags |= 2),
                u = f.pendingProps,
                b = S._init,
                S = b(S._payload),
                f.type = S,
                b = f.tag = Xk(S),
                u = Er(S, u),
                b) {
                case 0:
                    f = Dv(null, f, S, u, g);
                    break e;
                case 1:
                    f = QM(null, f, S, u, g);
                    break e;
                case 11:
                    f = jM(null, f, S, u, g);
                    break e;
                case 14:
                    f = JM(null, f, S, Er(S.type, u), g);
                    break e
                }
                throw Error(o(306, S, ""))
            }
            return f;
        case 0:
            return S = f.type,
            b = f.pendingProps,
            b = f.elementType === S ? b : Er(S, b),
            Dv(u, f, S, b, g);
        case 1:
            return S = f.type,
            b = f.pendingProps,
            b = f.elementType === S ? b : Er(S, b),
            QM(u, f, S, b, g);
        case 3:
            e: {
                if (ZM(f),
                u === null)
                    throw Error(o(387));
                S = f.pendingProps,
                T = f.memoizedState,
                b = T.element,
                sM(u, f),
                zh(f, S, null, g);
                var N = f.memoizedState;
                if (S = N.element,
                ae && T.isDehydrated)
                    if (T = {
                        element: S,
                        isDehydrated: !1,
                        cache: N.cache,
                        transitions: N.transitions
                    },
                    f.updateQueue.baseState = T,
                    f.memoizedState = T,
                    f.flags & 256) {
                        b = Error(o(423)),
                        f = qM(u, f, S, g, b);
                        break e
                    } else if (S !== b) {
                        b = Error(o(424)),
                        f = qM(u, f, S, g, b);
                        break e
                    } else
                        for (ae && (Fi = Z(f.stateNode.containerInfo),
                        ki = f,
                        qt = !0,
                        Tr = null,
                        Dc = !1),
                        g = yM(f, null, S, g),
                        f.child = g; g; )
                            g.flags = g.flags & -3 | 4096,
                            g = g.sibling;
                else {
                    if (Gl(),
                    S === b) {
                        f = Cs(u, f, g);
                        break e
                    }
                    ci(u, f, S, g)
                }
                f = f.child
            }
            return f;
        case 5:
            return xM(f),
            u === null && _v(f),
            S = f.type,
            b = f.pendingProps,
            T = u !== null ? u.memoizedProps : null,
            N = b.children,
            _e(S, b) ? N = null : T !== null && _e(S, T) && (f.flags |= 32),
            KM(u, f),
            ci(u, f, N, g),
            f.child;
        case 6:
            return u === null && _v(f),
            null;
        case 13:
            return $M(u, f, g);
        case 4:
            return wv(f, f.stateNode.containerInfo),
            S = f.pendingProps,
            u === null ? f.child = Hl(f, null, S, g) : ci(u, f, S, g),
            f.child;
        case 11:
            return S = f.type,
            b = f.pendingProps,
            b = f.elementType === S ? b : Er(S, b),
            jM(u, f, S, b, g);
        case 7:
            return ci(u, f, f.pendingProps, g),
            f.child;
        case 8:
            return ci(u, f, f.pendingProps.children, g),
            f.child;
        case 12:
            return ci(u, f, f.pendingProps.children, g),
            f.child;
        case 10:
            e: {
                if (S = f.type._context,
                b = f.pendingProps,
                T = f.memoizedProps,
                N = b.value,
                rM(f, S, N),
                T !== null)
                    if (Zr(T.value, N)) {
                        if (T.children === b.children && !On.current) {
                            f = Cs(u, f, g);
                            break e
                        }
                    } else
                        for (T = f.child,
                        T !== null && (T.return = f); T !== null; ) {
                            var J = T.dependencies;
                            if (J !== null) {
                                N = T.child;
                                for (var fe = J.firstContext; fe !== null; ) {
                                    if (fe.context === S) {
                                        if (T.tag === 1) {
                                            fe = ws(-1, g & -g),
                                            fe.tag = 2;
                                            var Ee = T.updateQueue;
                                            if (Ee !== null) {
                                                Ee = Ee.shared;
                                                var We = Ee.pending;
                                                We === null ? fe.next = fe : (fe.next = We.next,
                                                We.next = fe),
                                                Ee.pending = fe
                                            }
                                        }
                                        T.lanes |= g,
                                        fe = T.alternate,
                                        fe !== null && (fe.lanes |= g),
                                        hv(T.return, g, f),
                                        J.lanes |= g;
                                        break
                                    }
                                    fe = fe.next
                                }
                            } else if (T.tag === 10)
                                N = T.type === f.type ? null : T.child;
                            else if (T.tag === 18) {
                                if (N = T.return,
                                N === null)
                                    throw Error(o(341));
                                N.lanes |= g,
                                J = N.alternate,
                                J !== null && (J.lanes |= g),
                                hv(N, g, f),
                                N = T.sibling
                            } else
                                N = T.child;
                            if (N !== null)
                                N.return = T;
                            else
                                for (N = T; N !== null; ) {
                                    if (N === f) {
                                        N = null;
                                        break
                                    }
                                    if (T = N.sibling,
                                    T !== null) {
                                        T.return = N.return,
                                        N = T;
                                        break
                                    }
                                    N = N.return
                                }
                            T = N
                        }
                ci(u, f, b.children, g),
                f = f.child
            }
            return f;
        case 9:
            return b = f.type,
            S = f.pendingProps.children,
            Ol(f, g),
            b = rr(b),
            S = S(b),
            f.flags |= 1,
            ci(u, f, S, g),
            f.child;
        case 14:
            return S = f.type,
            b = Er(S, f.pendingProps),
            b = Er(S.type, b),
            JM(u, f, S, b, g);
        case 15:
            return XM(u, f, f.type, f.pendingProps, g);
        case 17:
            return S = f.type,
            b = f.pendingProps,
            b = f.elementType === S ? b : Er(S, b),
            u !== null && (u.alternate = null,
            f.alternate = null,
            f.flags |= 2),
            f.tag = 1,
            Si(S) ? (u = !0,
            Bh(f)) : u = !1,
            Ol(f, g),
            cM(f, S, b),
            gv(f, S, b, g),
            kv(null, f, S, !0, u, g);
        case 19:
            return ib(u, f, g);
        case 22:
            return YM(u, f, g)
        }
        throw Error(o(156, f.tag))
    }
    ;
    function Eb(u, f) {
        return ov(u, f)
    }
    function Jk(u, f, g, S) {
        this.tag = u,
        this.key = g,
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
        this.index = 0,
        this.ref = null,
        this.pendingProps = f,
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
        this.mode = S,
        this.subtreeFlags = this.flags = 0,
        this.deletions = null,
        this.childLanes = this.lanes = 0,
        this.alternate = null
    }
    function cr(u, f, g, S) {
        return new Jk(u,f,g,S)
    }
    function iy(u) {
        return u = u.prototype,
        !(!u || !u.isReactComponent)
    }
    function Xk(u) {
        if (typeof u == "function")
            return iy(u) ? 1 : 0;
        if (u != null) {
            if (u = u.$$typeof,
            u === v)
                return 11;
            if (u === A)
                return 14
        }
        return 2
    }
    function go(u, f) {
        var g = u.alternate;
        return g === null ? (g = cr(u.tag, f, u.key, u.mode),
        g.elementType = u.elementType,
        g.type = u.type,
        g.stateNode = u.stateNode,
        g.alternate = u,
        u.alternate = g) : (g.pendingProps = f,
        g.type = u.type,
        g.flags = 0,
        g.subtreeFlags = 0,
        g.deletions = null),
        g.flags = u.flags & 14680064,
        g.childLanes = u.childLanes,
        g.lanes = u.lanes,
        g.child = u.child,
        g.memoizedProps = u.memoizedProps,
        g.memoizedState = u.memoizedState,
        g.updateQueue = u.updateQueue,
        f = u.dependencies,
        g.dependencies = f === null ? null : {
            lanes: f.lanes,
            firstContext: f.firstContext
        },
        g.sibling = u.sibling,
        g.index = u.index,
        g.ref = u.ref,
        g
    }
    function Ap(u, f, g, S, b, T) {
        var N = 2;
        if (S = u,
        typeof u == "function")
            iy(u) && (N = 1);
        else if (typeof u == "string")
            N = 5;
        else
            e: switch (u) {
            case d:
                return Ta(g.children, b, T, f);
            case h:
                N = 8,
                b |= 8;
                break;
            case p:
                return u = cr(12, g, f, b | 2),
                u.elementType = p,
                u.lanes = T,
                u;
            case x:
                return u = cr(13, g, f, b),
                u.elementType = x,
                u.lanes = T,
                u;
            case _:
                return u = cr(19, g, f, b),
                u.elementType = _,
                u.lanes = T,
                u;
            case M:
                return wp(g, b, T, f);
            default:
                if (typeof u == "object" && u !== null)
                    switch (u.$$typeof) {
                    case m:
                        N = 10;
                        break e;
                    case y:
                        N = 9;
                        break e;
                    case v:
                        N = 11;
                        break e;
                    case A:
                        N = 14;
                        break e;
                    case w:
                        N = 16,
                        S = null;
                        break e
                    }
                throw Error(o(130, u == null ? u : typeof u, ""))
            }
        return f = cr(N, g, f, b),
        f.elementType = u,
        f.type = S,
        f.lanes = T,
        f
    }
    function Ta(u, f, g, S) {
        return u = cr(7, u, S, f),
        u.lanes = g,
        u
    }
    function wp(u, f, g, S) {
        return u = cr(22, u, S, f),
        u.elementType = M,
        u.lanes = g,
        u.stateNode = {},
        u
    }
    function ry(u, f, g) {
        return u = cr(6, u, null, f),
        u.lanes = g,
        u
    }
    function sy(u, f, g) {
        return f = cr(4, u.children !== null ? u.children : [], u.key, f),
        f.lanes = g,
        f.stateNode = {
            containerInfo: u.containerInfo,
            pendingChildren: null,
            implementation: u.implementation
        },
        f
    }
    function Yk(u, f, g, S, b) {
        this.tag = f,
        this.containerInfo = u,
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
        this.timeoutHandle = Ve,
        this.callbackNode = this.pendingContext = this.context = null,
        this.callbackPriority = 0,
        this.eventTimes = rv(0),
        this.expirationTimes = rv(-1),
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
        this.entanglements = rv(0),
        this.identifierPrefix = S,
        this.onRecoverableError = b,
        ae && (this.mutableSourceEagerHydrationData = null)
    }
    function Tb(u, f, g, S, b, T, N, J, fe) {
        return u = new Yk(u,f,g,J,fe),
        f === 1 ? (f = 1,
        T === !0 && (f |= 8)) : f = 0,
        T = cr(3, null, null, f),
        u.current = T,
        T.stateNode = u,
        T.memoizedState = {
            element: S,
            isDehydrated: g,
            cache: null,
            transitions: null
        },
        pv(T),
        u
    }
    function Pb(u) {
        if (!u)
            return ir;
        u = u._reactInternals;
        e: {
            if (B(u) !== u || u.tag !== 1)
                throw Error(o(170));
            var f = u;
            do {
                switch (f.tag) {
                case 3:
                    f = f.stateNode.context;
                    break e;
                case 1:
                    if (Si(f.type)) {
                        f = f.stateNode.__reactInternalMemoizedMergedChildContext;
                        break e
                    }
                }
                f = f.return
            } while (f !== null);
            throw Error(o(171))
        }
        if (u.tag === 1) {
            var g = u.type;
            if (Si(g))
                return $S(u, g, f)
        }
        return f
    }
    function Bb(u) {
        var f = u._reactInternals;
        if (f === void 0)
            throw typeof u.render == "function" ? Error(o(188)) : (u = Object.keys(u).join(","),
            Error(o(268, u)));
        return u = q(f),
        u === null ? null : u.stateNode
    }
    function Rb(u, f) {
        if (u = u.memoizedState,
        u !== null && u.dehydrated !== null) {
            var g = u.retryLane;
            u.retryLane = g !== 0 && g < f ? g : f
        }
    }
    function oy(u, f) {
        Rb(u, f),
        (u = u.alternate) && Rb(u, f)
    }
    function Kk(u) {
        return u = q(u),
        u === null ? null : u.stateNode
    }
    function Qk() {
        return null
    }
    return t.attemptContinuousHydration = function(u) {
        if (u.tag === 13) {
            var f = fi();
            ur(u, 134217728, f),
            oy(u, 134217728)
        }
    }
    ,
    t.attemptHydrationAtCurrentPriority = function(u) {
        if (u.tag === 13) {
            var f = fi()
              , g = po(u);
            ur(u, g, f),
            oy(u, g)
        }
    }
    ,
    t.attemptSynchronousHydration = function(u) {
        switch (u.tag) {
        case 3:
            var f = u.stateNode;
            if (f.current.memoizedState.isDehydrated) {
                var g = Ic(f.pendingLanes);
                g !== 0 && (sv(f, g | 1),
                bi(f, Un()),
                !(xt & 6) && (Yl(),
                qr()))
            }
            break;
        case 13:
            var S = fi();
            xb(function() {
                return ur(u, 1, S)
            }),
            oy(u, 1)
        }
    }
    ,
    t.batchedUpdates = function(u, f) {
        var g = xt;
        xt |= 1;
        try {
            return u(f)
        } finally {
            xt = g,
            xt === 0 && (Yl(),
            kh && qr())
        }
    }
    ,
    t.createComponentSelector = function(u) {
        return {
            $$typeof: ap,
            value: u
        }
    }
    ,
    t.createContainer = function(u, f, g, S, b, T, N) {
        return Tb(u, f, !1, null, g, S, b, T, N)
    }
    ,
    t.createHasPseudoClassSelector = function(u) {
        return {
            $$typeof: lp,
            value: u
        }
    }
    ,
    t.createHydrationContainer = function(u, f, g, S, b, T, N, J, fe) {
        return u = Tb(g, S, !0, u, b, T, N, J, fe),
        u.context = Pb(null),
        g = u.current,
        S = fi(),
        b = po(g),
        T = ws(S, b),
        T.callback = f ?? null,
        co(g, T),
        u.current.lanes = b,
        Lc(u, b, S),
        bi(u, S),
        u
    }
    ,
    t.createPortal = function(u, f, g) {
        var S = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
            $$typeof: c,
            key: S == null ? null : "" + S,
            children: u,
            containerInfo: f,
            implementation: g
        }
    }
    ,
    t.createRoleSelector = function(u) {
        return {
            $$typeof: up,
            value: u
        }
    }
    ,
    t.createTestNameSelector = function(u) {
        return {
            $$typeof: cp,
            value: u
        }
    }
    ,
    t.createTextSelector = function(u) {
        return {
            $$typeof: fp,
            value: u
        }
    }
    ,
    t.deferredUpdates = function(u) {
        var f = Dt
          , g = xn.transition;
        try {
            return xn.transition = null,
            Dt = 16,
            u()
        } finally {
            Dt = f,
            xn.transition = g
        }
    }
    ,
    t.discreteUpdates = function(u, f, g, S, b) {
        var T = Dt
          , N = xn.transition;
        try {
            return xn.transition = null,
            Dt = 1,
            u(f, g, S, b)
        } finally {
            Dt = T,
            xn.transition = N,
            xt === 0 && Yl()
        }
    }
    ,
    t.findAllNodes = Jv,
    t.findBoundingRects = function(u, f) {
        if (!At)
            throw Error(o(363));
        f = Jv(u, f),
        u = [];
        for (var g = 0; g < f.length; g++)
            u.push(O(f[g]));
        for (f = u.length - 1; 0 < f; f--) {
            g = u[f];
            for (var S = g.x, b = S + g.width, T = g.y, N = T + g.height, J = f - 1; 0 <= J; J--)
                if (f !== J) {
                    var fe = u[J]
                      , Ee = fe.x
                      , We = Ee + fe.width
                      , lt = fe.y
                      , nt = lt + fe.height;
                    if (S >= Ee && T >= lt && b <= We && N <= nt) {
                        u.splice(f, 1);
                        break
                    } else if (S !== Ee || g.width !== fe.width || nt < T || lt > N) {
                        if (!(T !== lt || g.height !== fe.height || We < S || Ee > b)) {
                            Ee > S && (fe.width += Ee - S,
                            fe.x = S),
                            We < b && (fe.width = b - Ee),
                            u.splice(f, 1);
                            break
                        }
                    } else {
                        lt > T && (fe.height += lt - T,
                        fe.y = T),
                        nt < N && (fe.height = N - lt),
                        u.splice(f, 1);
                        break
                    }
                }
        }
        return u
    }
    ,
    t.findHostInstance = Bb,
    t.findHostInstanceWithNoPortals = function(u) {
        return u = z(u),
        u = u !== null ? G(u) : null,
        u === null ? null : u.stateNode
    }
    ,
    t.findHostInstanceWithWarning = function(u) {
        return Bb(u)
    }
    ,
    t.flushControlled = function(u) {
        var f = xt;
        xt |= 1;
        var g = xn.transition
          , S = Dt;
        try {
            xn.transition = null,
            Dt = 1,
            u()
        } finally {
            Dt = S,
            xn.transition = g,
            xt = f,
            xt === 0 && (Yl(),
            qr())
        }
    }
    ,
    t.flushPassiveEffects = Ea,
    t.flushSync = xb,
    t.focusWithin = function(u, f) {
        if (!At)
            throw Error(o(363));
        for (u = Vv(u),
        f = gb(u, f),
        f = Array.from(f),
        u = 0; u < f.length; ) {
            var g = f[u++];
            if (!se(g)) {
                if (g.tag === 5 && Ce(g.stateNode))
                    return !0;
                for (g = g.child; g !== null; )
                    f.push(g),
                    g = g.sibling
            }
        }
        return !1
    }
    ,
    t.getCurrentUpdatePriority = function() {
        return Dt
    }
    ,
    t.getFindAllNodesFailureDescription = function(u, f) {
        if (!At)
            throw Error(o(363));
        var g = 0
          , S = [];
        u = [Vv(u), 0];
        for (var b = 0; b < u.length; ) {
            var T = u[b++]
              , N = u[b++]
              , J = f[N];
            if ((T.tag !== 5 || !se(T)) && (Wv(T, J) && (S.push(jv(J)),
            N++,
            N > g && (g = N)),
            N < f.length))
                for (T = T.child; T !== null; )
                    u.push(T, N),
                    T = T.sibling
        }
        if (g < f.length) {
            for (u = []; g < f.length; g++)
                u.push(jv(f[g]));
            return `findAllNodes was able to match part of the selector:
  ` + (S.join(" > ") + `

No matching component was found for:
  `) + u.join(" > ")
        }
        return null
    }
    ,
    t.getPublicRootInstance = function(u) {
        if (u = u.current,
        !u.child)
            return null;
        switch (u.child.tag) {
        case 5:
            return ne(u.child.stateNode);
        default:
            return u.child.stateNode
        }
    }
    ,
    t.injectIntoDevTools = function(u) {
        if (u = {
            bundleType: u.bundleType,
            version: u.version,
            rendererPackageName: u.rendererPackageName,
            rendererConfig: u.rendererConfig,
            overrideHookState: null,
            overrideHookStateDeletePath: null,
            overrideHookStateRenamePath: null,
            overrideProps: null,
            overridePropsDeletePath: null,
            overridePropsRenamePath: null,
            setErrorHandler: null,
            setSuspenseHandler: null,
            scheduleUpdate: null,
            currentDispatcherRef: a.ReactCurrentDispatcher,
            findHostInstanceByFiber: Kk,
            findFiberByHostInstance: u.findFiberByHostInstance || Qk,
            findHostInstancesForRefresh: null,
            scheduleRefresh: null,
            scheduleRoot: null,
            setRefreshHandler: null,
            getCurrentFiber: null,
            reconcilerVersion: "18.0.0-fc46dba67-20220329"
        },
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
            u = !1;
        else {
            var f = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (f.isDisabled || !f.supportsFiber)
                u = !0;
            else {
                try {
                    Dh = f.inject(u),
                    Qr = f
                } catch {}
                u = !!f.checkDCE
            }
        }
        return u
    }
    ,
    t.isAlreadyRendering = function() {
        return !1
    }
    ,
    t.observeVisibleRects = function(u, f, g, S) {
        if (!At)
            throw Error(o(363));
        u = Jv(u, f);
        var b = Pe(u, g, S).disconnect;
        return {
            disconnect: function() {
                b()
            }
        }
    }
    ,
    t.registerMutableSourceForHydration = function(u, f) {
        var g = f._getVersion;
        g = g(f._source),
        u.mutableSourceEagerHydrationData == null ? u.mutableSourceEagerHydrationData = [f, g] : u.mutableSourceEagerHydrationData.push(f, g)
    }
    ,
    t.runWithPriority = function(u, f) {
        var g = Dt;
        try {
            return Dt = u,
            f()
        } finally {
            Dt = g
        }
    }
    ,
    t.shouldError = function() {
        return null
    }
    ,
    t.shouldSuspend = function() {
        return !1
    }
    ,
    t.updateContainer = function(u, f, g, S) {
        var b = f.current
          , T = fi()
          , N = po(b);
        return g = Pb(g),
        f.context === null ? f.context = g : f.pendingContext = g,
        f = ws(T, N),
        f.payload = {
            element: u
        },
        S = S === void 0 ? null : S,
        S !== null && (f.callback = S),
        co(b, f),
        u = ur(b, N, T),
        u !== null && Uh(u, b, N),
        N
    }
    ,
    t
};
(function(n) {
    n.exports = o8
}
)(r8);
const a8 = bP(C_);
function FI(n, e, t=(i,r)=>i === r) {
    if (n === e)
        return !0;
    if (!n || !e)
        return !1;
    const i = n.length;
    if (e.length !== i)
        return !1;
    for (let r = 0; r < i; r++)
        if (!t(n[r], e[r]))
            return !1;
    return !0
}
const Ns = [];
function NI(n, e, t=!1, i={}) {
    for (const s of Ns)
        if (FI(e, s.keys, s.equal)) {
            if (t)
                return;
            if (Object.prototype.hasOwnProperty.call(s, "error"))
                throw s.error;
            if (Object.prototype.hasOwnProperty.call(s, "response"))
                return s.response;
            if (!t)
                throw s.promise
        }
    const r = {
        keys: e,
        equal: i.equal,
        promise: n(...e).then(s=>r.response = s).then(()=>{
            i.lifespan && i.lifespan > 0 && setTimeout(()=>{
                const s = Ns.indexOf(r);
                s !== -1 && Ns.splice(s, 1)
            }
            , i.lifespan)
        }
        ).catch(s=>r.error = s)
    };
    if (Ns.push(r),
    !t)
        throw r.promise
}
const l8 = (n,e,t)=>NI(n, e, !1, t)
  , u8 = (n,e,t)=>void NI(n, e, !0, t)
  , c8 = n=>{
    if (n === void 0 || n.length === 0)
        Ns.splice(0, Ns.length);
    else {
        const e = Ns.find(t=>FI(n, t.keys, t.equal));
        if (e) {
            const t = Ns.indexOf(e);
            t !== -1 && Ns.splice(t, 1)
        }
    }
}
;
var gT, vT;
const f8 = (n,...e)=>e.reduce((t,i)=>t == null ? void 0 : t[i], n)
  , pu = "ColorManagement"in b_ && f8(b_, "ColorManagement") || null
  , OI = n=>n && n.isOrthographicCamera
  , d8 = n=>n && n.hasOwnProperty("current")
  , yh = typeof window < "u" && ((gT = window.document) != null && gT.createElement || ((vT = window.navigator) == null ? void 0 : vT.product) === "ReactNative") ? U.useLayoutEffect : U.useEffect;
function UI(n) {
    const e = U.useRef(n);
    return yh(()=>void (e.current = n), [n]),
    e
}
function h8({set: n}) {
    return yh(()=>(n(new Promise(()=>null)),
    ()=>n(!1)), [n]),
    null
}
class zI extends U.Component {
    constructor(...e) {
        super(...e),
        this.state = {
            error: !1
        }
    }
    componentDidCatch(e) {
        this.props.set(e)
    }
    render() {
        return this.state.error ? null : this.props.children
    }
}
zI.getDerivedStateFromError = ()=>({
    error: !0
});
const GI = "__default"
  , yT = new Map
  , p8 = n=>n && !!n.memoized && !!n.changes;
function HI(n) {
    const e = typeof window < "u" ? window.devicePixelRatio : 1;
    return Array.isArray(n) ? Math.min(Math.max(n[0], e), n[1]) : n
}
const yf = n=>{
    var e;
    return (e = n.__r3f) == null ? void 0 : e.root.getState()
}
  , rn = {
    obj: n=>n === Object(n) && !rn.arr(n) && typeof n != "function",
    fun: n=>typeof n == "function",
    str: n=>typeof n == "string",
    num: n=>typeof n == "number",
    boo: n=>typeof n == "boolean",
    und: n=>n === void 0,
    arr: n=>Array.isArray(n),
    equ(n, e, {arrays: t="shallow", objects: i="reference", strict: r=!0}={}) {
        if (typeof n != typeof e || !!n != !!e)
            return !1;
        if (rn.str(n) || rn.num(n))
            return n === e;
        const s = rn.obj(n);
        if (s && i === "reference")
            return n === e;
        const o = rn.arr(n);
        if (o && t === "reference")
            return n === e;
        if ((o || s) && n === e)
            return !0;
        let a;
        for (a in n)
            if (!(a in e))
                return !1;
        for (a in r ? e : n)
            if (n[a] !== e[a])
                return !1;
        if (rn.und(a)) {
            if (o && n.length === 0 && e.length === 0 || s && Object.keys(n).length === 0 && Object.keys(e).length === 0)
                return !0;
            if (n !== e)
                return !1
        }
        return !0
    }
};
function m8(n) {
    const e = {
        nodes: {},
        materials: {}
    };
    return n && n.traverse(t=>{
        t.name && (e.nodes[t.name] = t),
        t.material && !e.materials[t.material.name] && (e.materials[t.material.name] = t.material)
    }
    ),
    e
}
function g8(n) {
    n.dispose && n.type !== "Scene" && n.dispose();
    for (const e in n)
        e.dispose == null || e.dispose(),
        delete n[e]
}
function mu(n, e) {
    const t = n;
    return (e != null && e.primitive || !t.__r3f) && (t.__r3f = {
        type: "",
        root: null,
        previousAttach: null,
        memoizedProps: {},
        eventCount: 0,
        handlers: {},
        objects: [],
        parent: null,
        ...e
    }),
    n
}
function E_(n, e) {
    let t = n;
    if (e.includes("-")) {
        const i = e.split("-")
          , r = i.pop();
        return t = i.reduce((s,o)=>s[o], n),
        {
            target: t,
            key: r
        }
    } else
        return {
            target: t,
            key: e
        }
}
const xT = /-\d+$/;
function mx(n, e, t) {
    if (rn.str(t)) {
        if (xT.test(t)) {
            const s = t.replace(xT, "")
              , {target: o, key: a} = E_(n, s);
            Array.isArray(o[a]) || (o[a] = [])
        }
        const {target: i, key: r} = E_(n, t);
        e.__r3f.previousAttach = i[r],
        i[r] = e
    } else
        e.__r3f.previousAttach = t(n, e)
}
function _T(n, e, t) {
    var i, r;
    if (rn.str(t)) {
        const {target: s, key: o} = E_(n, t)
          , a = e.__r3f.previousAttach;
        a === void 0 ? delete s[o] : s[o] = a
    } else
        (i = e.__r3f) == null || i.previousAttach == null || i.previousAttach(n, e);
    (r = e.__r3f) == null || delete r.previousAttach
}
function VI(n, {children: e, key: t, ref: i, ...r}, {children: s, key: o, ref: a, ...l}={}, c=!1) {
    var d;
    const h = (d = n == null ? void 0 : n.__r3f) != null ? d : {}
      , p = Object.entries(r)
      , m = [];
    if (c) {
        const v = Object.keys(l);
        for (let x = 0; x < v.length; x++)
            r.hasOwnProperty(v[x]) || p.unshift([v[x], GI + "remove"])
    }
    p.forEach(([v,x])=>{
        var _;
        if ((_ = n.__r3f) != null && _.primitive && v === "object" || rn.equ(x, l[v]))
            return;
        if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(v))
            return m.push([v, x, !0, []]);
        let A = [];
        v.includes("-") && (A = v.split("-")),
        m.push([v, x, !1, A]);
        for (const w in r) {
            const M = r[w];
            w.startsWith(`${v}-`) && m.push([w, M, !1, w.split("-")])
        }
    }
    );
    const y = {
        ...r
    };
    return h.memoizedProps && h.memoizedProps.args && (y.args = h.memoizedProps.args),
    h.memoizedProps && h.memoizedProps.attach && (y.attach = h.memoizedProps.attach),
    {
        memoized: y,
        changes: m
    }
}
function gx(n, e) {
    var t, i, r;
    const s = (t = n.__r3f) != null ? t : {}
      , o = s.root
      , a = (i = o == null || o.getState == null ? void 0 : o.getState()) != null ? i : {}
      , {memoized: l, changes: c} = p8(e) ? e : VI(n, e)
      , d = s.eventCount;
    n.__r3f && (n.__r3f.memoizedProps = l);
    for (let p = 0; p < c.length; p++) {
        let[m,y,v,x] = c[p]
          , _ = n
          , A = _[m];
        if (x.length && (A = x.reduce((w,M)=>w[M], n),
        !(A && A.set))) {
            const [w,...M] = x.reverse();
            _ = M.reverse().reduce((C,P)=>C[P], n),
            m = w
        }
        if (y === GI + "remove")
            if (_.constructor) {
                let w = yT.get(_.constructor);
                w || (w = new _.constructor,
                yT.set(_.constructor, w)),
                y = w[m]
            } else
                y = 0;
        if (v)
            y ? s.handlers[m] = y : delete s.handlers[m],
            s.eventCount = Object.keys(s.handlers).length;
        else if (A && A.set && (A.copy || A instanceof pl)) {
            if (Array.isArray(y))
                A.fromArray ? A.fromArray(y) : A.set(...y);
            else if (A.copy && y && y.constructor && A.constructor === y.constructor)
                A.copy(y);
            else if (y !== void 0) {
                const w = A instanceof Ie;
                !w && A.setScalar ? A.setScalar(y) : A instanceof pl && y instanceof pl ? A.mask = y.mask : A.set(y),
                !pu && !a.linear && w && A.convertSRGBToLinear()
            }
        } else
            _[m] = y,
            !a.linear && _[m]instanceof tn && _[m].format === Ti && _[m].type === qs && (_[m].encoding = Tt);
        gu(n)
    }
    if (s.parent && a.internal && n.raycast && d !== s.eventCount) {
        const p = a.internal.interaction.indexOf(n);
        p > -1 && a.internal.interaction.splice(p, 1),
        s.eventCount && a.internal.interaction.push(n)
    }
    return !(c.length === 1 && c[0][0] === "onUpdate") && c.length && (r = n.__r3f) != null && r.parent && T_(n),
    n
}
function gu(n) {
    var e, t;
    const i = (e = n.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState();
    i && i.internal.frames === 0 && i.invalidate()
}
function T_(n) {
    n.onUpdate == null || n.onUpdate(n)
}
function v8(n, e) {
    n.manual || (OI(n) ? (n.left = e.width / -2,
    n.right = e.width / 2,
    n.top = e.height / 2,
    n.bottom = e.height / -2) : n.aspect = e.width / e.height,
    n.updateProjectionMatrix(),
    n.updateMatrixWorld())
}
function bm(n) {
    return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId
}
function y8() {
    var n;
    const e = typeof self < "u" && self || typeof window < "u" && window;
    if (!e)
        return Oo.DefaultEventPriority;
    switch ((n = e.event) == null ? void 0 : n.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
        return Oo.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
        return Oo.ContinuousEventPriority;
    default:
        return Oo.DefaultEventPriority
    }
}
function WI(n, e, t, i) {
    const r = t.get(e);
    r && (t.delete(e),
    t.size === 0 && (n.delete(i),
    r.target.releasePointerCapture(i)))
}
function x8(n, e) {
    const {internal: t} = n.getState();
    t.interaction = t.interaction.filter(i=>i !== e),
    t.initialHits = t.initialHits.filter(i=>i !== e),
    t.hovered.forEach((i,r)=>{
        (i.eventObject === e || i.object === e) && t.hovered.delete(r)
    }
    ),
    t.capturedMap.forEach((i,r)=>{
        WI(t.capturedMap, e, i, r)
    }
    )
}
function _8(n) {
    function e(l) {
        const {internal: c} = n.getState()
          , d = l.offsetX - c.initialClick[0]
          , h = l.offsetY - c.initialClick[1];
        return Math.round(Math.sqrt(d * d + h * h))
    }
    function t(l) {
        return l.filter(c=>["Move", "Over", "Enter", "Out", "Leave"].some(d=>{
            var h;
            return (h = c.__r3f) == null ? void 0 : h.handlers["onPointer" + d]
        }
        ))
    }
    function i(l, c) {
        const d = n.getState()
          , h = new Set
          , p = []
          , m = c ? c(d.internal.interaction) : d.internal.interaction;
        for (let _ = 0; _ < m.length; _++) {
            const A = yf(m[_]);
            A && (A.raycaster.camera = void 0)
        }
        d.previousRoot || d.events.compute == null || d.events.compute(l, d);
        function y(_) {
            const A = yf(_);
            if (!A || !A.events.enabled || A.raycaster.camera === null)
                return [];
            if (A.raycaster.camera === void 0) {
                var w;
                A.events.compute == null || A.events.compute(l, A, (w = A.previousRoot) == null ? void 0 : w.getState()),
                A.raycaster.camera === void 0 && (A.raycaster.camera = null)
            }
            return A.raycaster.camera ? A.raycaster.intersectObject(_, !0) : []
        }
        let v = m.flatMap(y).sort((_,A)=>{
            const w = yf(_.object)
              , M = yf(A.object);
            return !w || !M ? _.distance - A.distance : M.events.priority - w.events.priority || _.distance - A.distance
        }
        ).filter(_=>{
            const A = bm(_);
            return h.has(A) ? !1 : (h.add(A),
            !0)
        }
        );
        d.events.filter && (v = d.events.filter(v, d));
        for (const _ of v) {
            let A = _.object;
            for (; A; ) {
                var x;
                (x = A.__r3f) != null && x.eventCount && p.push({
                    ..._,
                    eventObject: A
                }),
                A = A.parent
            }
        }
        if ("pointerId"in l && d.internal.capturedMap.has(l.pointerId))
            for (let _ of d.internal.capturedMap.get(l.pointerId).values())
                h.has(bm(_.intersection)) || p.push(_.intersection);
        return p
    }
    function r(l, c, d, h) {
        const p = n.getState();
        if (l.length) {
            const m = {
                stopped: !1
            };
            for (const y of l) {
                const v = yf(y.object) || p
                  , {raycaster: x, pointer: _, camera: A, internal: w} = v
                  , M = new D(_.x,_.y,0).unproject(A)
                  , C = I=>{
                    var z, q;
                    return (z = (q = w.capturedMap.get(I)) == null ? void 0 : q.has(y.eventObject)) != null ? z : !1
                }
                  , P = I=>{
                    const z = {
                        intersection: y,
                        target: c.target
                    };
                    w.capturedMap.has(I) ? w.capturedMap.get(I).set(y.eventObject, z) : w.capturedMap.set(I, new Map([[y.eventObject, z]])),
                    c.target.setPointerCapture(I)
                }
                  , R = I=>{
                    const z = w.capturedMap.get(I);
                    z && WI(w.capturedMap, y.eventObject, z, I)
                }
                ;
                let E = {};
                for (let I in c) {
                    let z = c[I];
                    typeof z != "function" && (E[I] = z)
                }
                let B = {
                    ...y,
                    ...E,
                    pointer: _,
                    intersections: l,
                    stopped: m.stopped,
                    delta: d,
                    unprojectedPoint: M,
                    ray: x.ray,
                    camera: A,
                    stopPropagation() {
                        const I = "pointerId"in c && w.capturedMap.get(c.pointerId);
                        if ((!I || I.has(y.eventObject)) && (B.stopped = m.stopped = !0,
                        w.hovered.size && Array.from(w.hovered.values()).find(z=>z.eventObject === y.eventObject))) {
                            const z = l.slice(0, l.indexOf(y));
                            s([...z, y])
                        }
                    },
                    target: {
                        hasPointerCapture: C,
                        setPointerCapture: P,
                        releasePointerCapture: R
                    },
                    currentTarget: {
                        hasPointerCapture: C,
                        setPointerCapture: P,
                        releasePointerCapture: R
                    },
                    nativeEvent: c
                };
                if (h(B),
                m.stopped === !0)
                    break
            }
        }
        return l
    }
    function s(l) {
        const {internal: c} = n.getState();
        for (const d of c.hovered.values())
            if (!l.length || !l.find(h=>h.object === d.object && h.index === d.index && h.instanceId === d.instanceId)) {
                const p = d.eventObject.__r3f
                  , m = p == null ? void 0 : p.handlers;
                if (c.hovered.delete(bm(d)),
                p != null && p.eventCount) {
                    const y = {
                        ...d,
                        intersections: l
                    };
                    m.onPointerOut == null || m.onPointerOut(y),
                    m.onPointerLeave == null || m.onPointerLeave(y)
                }
            }
    }
    function o(l, c) {
        for (let d = 0; d < c.length; d++) {
            const h = c[d].__r3f;
            h == null || h.handlers.onPointerMissed == null || h.handlers.onPointerMissed(l)
        }
    }
    function a(l) {
        switch (l) {
        case "onPointerLeave":
        case "onPointerCancel":
            return ()=>s([]);
        case "onLostPointerCapture":
            return c=>{
                const {internal: d} = n.getState();
                "pointerId"in c && d.capturedMap.has(c.pointerId) && (d.capturedMap.delete(c.pointerId),
                s([]))
            }
        }
        return function(d) {
            const {onPointerMissed: h, internal: p} = n.getState();
            p.lastEvent.current = d;
            const m = l === "onPointerMove"
              , y = l === "onClick" || l === "onContextMenu" || l === "onDoubleClick"
              , x = i(d, m ? t : void 0)
              , _ = y ? e(d) : 0;
            l === "onPointerDown" && (p.initialClick = [d.offsetX, d.offsetY],
            p.initialHits = x.map(w=>w.eventObject)),
            y && !x.length && _ <= 2 && (o(d, p.interaction),
            h && h(d)),
            m && s(x);
            function A(w) {
                const M = w.eventObject
                  , C = M.__r3f
                  , P = C == null ? void 0 : C.handlers;
                if (C != null && C.eventCount)
                    if (m) {
                        if (P.onPointerOver || P.onPointerEnter || P.onPointerOut || P.onPointerLeave) {
                            const R = bm(w)
                              , E = p.hovered.get(R);
                            E ? E.stopped && w.stopPropagation() : (p.hovered.set(R, w),
                            P.onPointerOver == null || P.onPointerOver(w),
                            P.onPointerEnter == null || P.onPointerEnter(w))
                        }
                        P.onPointerMove == null || P.onPointerMove(w)
                    } else {
                        const R = P[l];
                        R ? (!y || p.initialHits.includes(M)) && (o(d, p.interaction.filter(E=>!p.initialHits.includes(E))),
                        R(w)) : y && p.initialHits.includes(M) && o(d, p.interaction.filter(E=>!p.initialHits.includes(E)))
                    }
            }
            r(x, d, _, A)
        }
    }
    return {
        handlePointer: a
    }
}
let P_ = {}
  , A8 = n=>void (P_ = {
    ...P_,
    ...n
});
function w8(n, e) {
    function t(d, {args: h=[], attach: p, ...m}, y) {
        let v = `${d[0].toUpperCase()}${d.slice(1)}`, x;
        if (d === "primitive") {
            if (m.object === void 0)
                throw new Error("R3F: Primitives without 'object' are invalid!");
            const _ = m.object;
            x = mu(_, {
                type: d,
                root: y,
                attach: p,
                primitive: !0
            })
        } else {
            const _ = P_[v];
            if (!_)
                throw new Error(`R3F: ${v} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
            if (!Array.isArray(h))
                throw new Error("R3F: The args prop must be an array!");
            x = mu(new _(...h), {
                type: d,
                root: y,
                attach: p,
                memoizedProps: {
                    args: h
                }
            })
        }
        return x.__r3f.attach === void 0 && (x instanceof ft ? x.__r3f.attach = "geometry" : x instanceof Tn && (x.__r3f.attach = "material")),
        v !== "inject" && gx(x, m),
        x
    }
    function i(d, h) {
        let p = !1;
        if (h) {
            var m, y;
            (m = h.__r3f) != null && m.attach ? mx(d, h, h.__r3f.attach) : h.isObject3D && d.isObject3D && (d.add(h),
            p = !0),
            p || (y = d.__r3f) == null || y.objects.push(h),
            h.__r3f || mu(h, {}),
            h.__r3f.parent = d,
            T_(h),
            gu(h)
        }
    }
    function r(d, h, p) {
        let m = !1;
        if (h) {
            var y, v;
            if ((y = h.__r3f) != null && y.attach)
                mx(d, h, h.__r3f.attach);
            else if (h.isObject3D && d.isObject3D) {
                h.parent = d,
                h.dispatchEvent({
                    type: "added"
                });
                const x = d.children.filter(A=>A !== h)
                  , _ = x.indexOf(p);
                d.children = [...x.slice(0, _), h, ...x.slice(_)],
                m = !0
            }
            m || (v = d.__r3f) == null || v.objects.push(h),
            h.__r3f || mu(h, {}),
            h.__r3f.parent = d,
            T_(h),
            gu(h)
        }
    }
    function s(d, h, p=!1) {
        d && [...d].forEach(m=>o(h, m, p))
    }
    function o(d, h, p) {
        if (h) {
            var m, y, v;
            if (h.__r3f && (h.__r3f.parent = null),
            (m = d.__r3f) != null && m.objects && (d.__r3f.objects = d.__r3f.objects.filter(M=>M !== h)),
            (y = h.__r3f) != null && y.attach)
                _T(d, h, h.__r3f.attach);
            else if (h.isObject3D && d.isObject3D) {
                var x;
                d.remove(h),
                (x = h.__r3f) != null && x.root && x8(h.__r3f.root, h)
            }
            const A = (v = h.__r3f) == null ? void 0 : v.primitive
              , w = p === void 0 ? h.dispose !== null && !A : p;
            if (!A) {
                var _;
                s((_ = h.__r3f) == null ? void 0 : _.objects, h, w),
                s(h.children, h, w)
            }
            h.__r3f && (delete h.__r3f.root,
            delete h.__r3f.objects,
            delete h.__r3f.handlers,
            delete h.__r3f.memoizedProps,
            A || delete h.__r3f),
            w && h.dispose && h.type !== "Scene" && Ld.unstable_scheduleCallback(Ld.unstable_IdlePriority, ()=>{
                try {
                    h.dispose()
                } catch {}
            }
            ),
            gu(d)
        }
    }
    function a(d, h, p, m) {
        var y;
        const v = (y = d.__r3f) == null ? void 0 : y.parent;
        if (!v)
            return;
        const x = t(h, p, d.__r3f.root);
        if (d.children) {
            for (const _ of d.children)
                _.__r3f && i(x, _);
            d.children = d.children.filter(_=>!_.__r3f)
        }
        d.__r3f.objects.forEach(_=>i(x, _)),
        d.__r3f.objects = [],
        d.__r3f.autoRemovedBeforeAppend || o(v, d),
        x.parent && (x.__r3f.autoRemovedBeforeAppend = !0),
        i(v, x),
        x.raycast && x.__r3f.eventCount && x.__r3f.root.getState().internal.interaction.push(x),
        [m, m.alternate].forEach(_=>{
            _ !== null && (_.stateNode = x,
            _.ref && (typeof _.ref == "function" ? _.ref(x) : _.ref.current = x))
        }
        )
    }
    const l = ()=>console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");
    return {
        reconciler: a8({
            createInstance: t,
            removeChild: o,
            appendChild: i,
            appendInitialChild: i,
            insertBefore: r,
            supportsMutation: !0,
            isPrimaryRenderer: !1,
            supportsPersistence: !1,
            supportsHydration: !1,
            noTimeout: -1,
            appendChildToContainer: (d,h)=>{
                if (!h)
                    return;
                const p = d.getState().scene;
                p.__r3f && (p.__r3f.root = d,
                i(p, h))
            }
            ,
            removeChildFromContainer: (d,h)=>{
                h && o(d.getState().scene, h)
            }
            ,
            insertInContainerBefore: (d,h,p)=>{
                if (!h || !p)
                    return;
                const m = d.getState().scene;
                m.__r3f && r(m, h, p)
            }
            ,
            getRootHostContext: ()=>null,
            getChildHostContext: d=>d,
            finalizeInitialChildren(d) {
                var h;
                const p = (h = d == null ? void 0 : d.__r3f) != null ? h : {};
                return Boolean(p.handlers)
            },
            prepareUpdate(d, h, p, m) {
                if (d.__r3f.primitive && m.object && m.object !== d)
                    return [!0];
                {
                    const {args: y=[], children: v, ...x} = m
                      , {args: _=[], children: A, ...w} = p;
                    if (!Array.isArray(y))
                        throw new Error("R3F: the args prop must be an array!");
                    if (y.some((C,P)=>C !== _[P]))
                        return [!0];
                    const M = VI(d, x, w, !0);
                    return M.changes.length ? [!1, M] : null
                }
            },
            commitUpdate(d, [h,p], m, y, v, x) {
                h ? a(d, m, v, x) : gx(d, p)
            },
            commitMount(d, h, p, m) {
                var y;
                const v = (y = d.__r3f) != null ? y : {};
                d.raycast && v.handlers && v.eventCount && d.__r3f.root.getState().internal.interaction.push(d)
            },
            getPublicInstance: d=>d,
            prepareForCommit: ()=>null,
            preparePortalMount: d=>mu(d.getState().scene),
            resetAfterCommit: ()=>{}
            ,
            shouldSetTextContent: ()=>!1,
            clearContainer: ()=>!1,
            hideInstance(d) {
                var h;
                const {attach: p, parent: m} = (h = d.__r3f) != null ? h : {};
                p && m && _T(m, d, p),
                d.isObject3D && (d.visible = !1),
                gu(d)
            },
            unhideInstance(d, h) {
                var p;
                const {attach: m, parent: y} = (p = d.__r3f) != null ? p : {};
                m && y && mx(y, d, m),
                (d.isObject3D && h.visible == null || h.visible) && (d.visible = !0),
                gu(d)
            },
            createTextInstance: l,
            hideTextInstance: l,
            unhideTextInstance: l,
            getCurrentEventPriority: ()=>e ? e() : Oo.DefaultEventPriority,
            beforeActiveInstanceBlur: ()=>{}
            ,
            afterActiveInstanceBlur: ()=>{}
            ,
            detachDeletedInstance: ()=>{}
            ,
            now: typeof performance < "u" && rn.fun(performance.now) ? performance.now : rn.fun(Date.now) ? Date.now : ()=>0,
            scheduleTimeout: rn.fun(setTimeout) ? setTimeout : void 0,
            cancelTimeout: rn.fun(clearTimeout) ? clearTimeout : void 0
        }),
        applyProps: gx
    }
}
const jI = n=>!!(n != null && n.render)
  , JI = U.createContext(null)
  , S8 = (n,e)=>{
    const t = DI((a,l)=>{
        const c = new D
          , d = new D
          , h = new D;
        function p(_=l().camera, A=d, w=l().size) {
            const {width: M, height: C, top: P, left: R} = w
              , E = M / C;
            A instanceof D ? h.copy(A) : h.set(...A);
            const B = _.getWorldPosition(c).distanceTo(h);
            if (OI(_))
                return {
                    width: M / _.zoom,
                    height: C / _.zoom,
                    top: P,
                    left: R,
                    factor: 1,
                    distance: B,
                    aspect: E
                };
            {
                const I = _.fov * Math.PI / 180
                  , z = 2 * Math.tan(I / 2) * B
                  , q = z * (M / C);
                return {
                    width: q,
                    height: z,
                    top: P,
                    left: R,
                    factor: M / q,
                    distance: B,
                    aspect: E
                }
            }
        }
        let m;
        const y = _=>a(A=>({
            performance: {
                ...A.performance,
                current: _
            }
        }))
          , v = new me;
        return {
            set: a,
            get: l,
            gl: null,
            camera: null,
            raycaster: null,
            events: {
                priority: 1,
                enabled: !0,
                connected: !1
            },
            xr: null,
            invalidate: (_=1)=>n(l(), _),
            advance: (_,A)=>e(_, A, l()),
            legacy: !1,
            linear: !1,
            flat: !1,
            scene: mu(new Iw),
            controls: null,
            clock: new eS,
            pointer: v,
            mouse: v,
            frameloop: "always",
            onPointerMissed: void 0,
            performance: {
                current: 1,
                min: .5,
                max: 1,
                debounce: 200,
                regress: ()=>{
                    const _ = l();
                    m && clearTimeout(m),
                    _.performance.current !== _.performance.min && y(_.performance.min),
                    m = setTimeout(()=>y(l().performance.max), _.performance.debounce)
                }
            },
            size: {
                width: 0,
                height: 0,
                top: 0,
                left: 0,
                updateStyle: !1
            },
            viewport: {
                initialDpr: 0,
                dpr: 0,
                width: 0,
                height: 0,
                top: 0,
                left: 0,
                aspect: 0,
                distance: 0,
                factor: 0,
                getCurrentViewport: p
            },
            setEvents: _=>a(A=>({
                ...A,
                events: {
                    ...A.events,
                    ..._
                }
            })),
            setSize: (_,A,w,M,C)=>{
                const P = l().camera
                  , R = {
                    width: _,
                    height: A,
                    top: M || 0,
                    left: C || 0,
                    updateStyle: w
                };
                a(E=>({
                    size: R,
                    viewport: {
                        ...E.viewport,
                        ...p(P, d, R)
                    }
                }))
            }
            ,
            setDpr: _=>a(A=>{
                const w = HI(_);
                return {
                    viewport: {
                        ...A.viewport,
                        dpr: w,
                        initialDpr: A.viewport.initialDpr || w
                    }
                }
            }
            ),
            setFrameloop: (_="always")=>{
                const A = l().clock;
                A.stop(),
                A.elapsedTime = 0,
                _ !== "never" && (A.start(),
                A.elapsedTime = 0),
                a(()=>({
                    frameloop: _
                }))
            }
            ,
            previousRoot: void 0,
            internal: {
                active: !1,
                priority: 0,
                frames: 0,
                lastEvent: U.createRef(),
                interaction: [],
                hovered: new Map,
                subscribers: [],
                initialClick: [0, 0],
                initialHits: [],
                capturedMap: new Map,
                subscribe: (_,A,w)=>{
                    const M = l().internal;
                    return M.priority = M.priority + (A > 0 ? 1 : 0),
                    M.subscribers.push({
                        ref: _,
                        priority: A,
                        store: w
                    }),
                    M.subscribers = M.subscribers.sort((C,P)=>C.priority - P.priority),
                    ()=>{
                        const C = l().internal;
                        C != null && C.subscribers && (C.priority = C.priority - (A > 0 ? 1 : 0),
                        C.subscribers = C.subscribers.filter(P=>P.ref !== _))
                    }
                }
            }
        }
    }
    )
      , i = t.getState();
    let r = i.size
      , s = i.viewport.dpr
      , o = i.camera;
    return t.subscribe(()=>{
        const {camera: a, size: l, viewport: c, gl: d, set: h} = t.getState();
        if (l !== r || c.dpr !== s) {
            var p;
            r = l,
            s = c.dpr,
            v8(a, l),
            d.setPixelRatio(c.dpr);
            const m = (p = l.updateStyle) != null ? p : typeof HTMLCanvasElement < "u" && d.domElement instanceof HTMLCanvasElement;
            d.setSize(l.width, l.height, m)
        }
        a !== o && (o = a,
        h(m=>({
            viewport: {
                ...m.viewport,
                ...m.viewport.getCurrentViewport(a)
            }
        })))
    }
    ),
    t.subscribe(a=>n(a)),
    t
}
;
let Cm, M8 = new Set, b8 = new Set, C8 = new Set;
function vx(n, e) {
    if (n.size)
        for (const {callback: t} of n.values())
            t(e)
}
function xf(n, e) {
    switch (n) {
    case "before":
        return vx(M8, e);
    case "after":
        return vx(b8, e);
    case "tail":
        return vx(C8, e)
    }
}
let yx, xx;
function _x(n, e, t) {
    let i = e.clock.getDelta();
    for (e.frameloop === "never" && typeof n == "number" && (i = n - e.clock.elapsedTime,
    e.clock.oldTime = e.clock.elapsedTime,
    e.clock.elapsedTime = n),
    yx = e.internal.subscribers,
    Cm = 0; Cm < yx.length; Cm++)
        xx = yx[Cm],
        xx.ref.current(xx.store.getState(), i, t);
    return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    e.internal.frames = Math.max(0, e.internal.frames - 1),
    e.frameloop === "always" ? 1 : e.internal.frames
}
function E8(n) {
    let e = !1, t, i, r;
    function s(l) {
        i = requestAnimationFrame(s),
        e = !0,
        t = 0,
        xf("before", l);
        for (const d of n.values()) {
            var c;
            r = d.store.getState(),
            r.internal.active && (r.frameloop === "always" || r.internal.frames > 0) && !((c = r.gl.xr) != null && c.isPresenting) && (t += _x(l, r))
        }
        if (xf("after", l),
        t === 0)
            return xf("tail", l),
            e = !1,
            cancelAnimationFrame(i)
    }
    function o(l, c=1) {
        var d;
        if (!l)
            return n.forEach(h=>o(h.store.getState()), c);
        (d = l.gl.xr) != null && d.isPresenting || !l.internal.active || l.frameloop === "never" || (l.internal.frames = Math.min(60, l.internal.frames + c),
        e || (e = !0,
        requestAnimationFrame(s)))
    }
    function a(l, c=!0, d, h) {
        if (c && xf("before", l),
        d)
            _x(l, d, h);
        else
            for (const p of n.values())
                _x(l, p.store.getState());
        c && xf("after", l)
    }
    return {
        loop: s,
        invalidate: o,
        advance: a
    }
}
function XI() {
    const n = U.useContext(JI);
    if (!n)
        throw new Error("R3F: Hooks can only be used within the Canvas component!");
    return n
}
function Hi(n=t=>t, e) {
    return XI()(n, e)
}
function Tc(n, e=0) {
    const t = XI()
      , i = t.getState().internal.subscribe
      , r = UI(n);
    return yh(()=>i(r, e, t), [e, i, t]),
    null
}
function YI(n, e) {
    return function(t, ...i) {
        const r = new t;
        return n && n(r),
        Promise.all(i.map(s=>new Promise((o,a)=>r.load(s, l=>{
            l.scene && Object.assign(l, m8(l.scene)),
            o(l)
        }
        , e, l=>a(new Error(`Could not load ${s}: ${l.message})`))))))
    }
}
function va(n, e, t, i) {
    const r = Array.isArray(e) ? e : [e]
      , s = l8(YI(t, i), [n, ...r], {
        equal: rn.equ
    });
    return Array.isArray(e) ? s : s[0]
}
va.preload = function(n, e, t) {
    const i = Array.isArray(e) ? e : [e];
    return u8(YI(t), [n, ...i])
}
;
va.clear = function(n, e) {
    const t = Array.isArray(e) ? e : [e];
    return c8([n, ...t])
}
;
const fc = new Map
  , {invalidate: AT, advance: wT} = E8(fc)
  , {reconciler: Vg, applyProps: Uo} = w8(fc, y8)
  , _f = {
    objects: "shallow",
    strict: !1
}
  , T8 = (n,e)=>{
    const t = typeof n == "function" ? n(e) : n;
    return jI(t) ? t : new Rw({
        powerPreference: "high-performance",
        canvas: e,
        antialias: !0,
        alpha: !0,
        ...n
    })
}
;
function P8(n, e) {
    if (e)
        return e;
    if (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement && n.parentElement) {
        const {width: t, height: i, top: r, left: s} = n.parentElement.getBoundingClientRect();
        return {
            width: t,
            height: i,
            top: r,
            left: s
        }
    } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas)
        return {
            width: n.width,
            height: n.height,
            top: 0,
            left: 0
        };
    return {
        width: 0,
        height: 0,
        top: 0,
        left: 0
    }
}
function B8(n) {
    const e = fc.get(n)
      , t = e == null ? void 0 : e.fiber
      , i = e == null ? void 0 : e.store;
    e && console.warn("R3F.createRoot should only be called once!");
    const r = typeof reportError == "function" ? reportError : console.error
      , s = i || S8(AT, wT)
      , o = t || Vg.createContainer(s, Oo.ConcurrentRoot, null, !1, null, "", r, null);
    e || fc.set(n, {
        fiber: o,
        store: s
    });
    let a, l = !1;
    return {
        configure(c={}) {
            let {gl: d, size: h, events: p, onCreated: m, shadows: y=!1, linear: v=!1, flat: x=!1, legacy: _=!1, orthographic: A=!1, frameloop: w="always", dpr: M=[1, 2], performance: C, raycaster: P, camera: R, onPointerMissed: E} = c
              , B = s.getState()
              , I = B.gl;
            B.gl || B.set({
                gl: I = T8(d, n)
            });
            let z = B.raycaster;
            z || B.set({
                raycaster: z = new II
            });
            const {params: q, ...W} = P || {};
            if (rn.equ(W, z, _f) || Uo(z, {
                ...W
            }),
            rn.equ(q, z.params, _f) || Uo(z, {
                params: {
                    ...z.params,
                    ...q
                }
            }),
            !B.camera) {
                const F = R instanceof eh
                  , V = F ? R : A ? new Vr(0,0,0,0,.1,1e3) : new Wt(75,0,.1,1e3);
                F || (V.position.z = 5,
                R && Uo(V, R),
                R != null && R.rotation || V.lookAt(0, 0, 0)),
                B.set({
                    camera: V
                })
            }
            if (!B.xr) {
                const F = (re,j)=>{
                    const ie = s.getState();
                    ie.frameloop !== "never" && wT(re, !0, ie, j)
                }
                  , V = ()=>{
                    const re = s.getState();
                    re.gl.xr.enabled = re.gl.xr.isPresenting,
                    re.gl.xr.setAnimationLoop(re.gl.xr.isPresenting ? F : null),
                    re.gl.xr.isPresenting || AT(re)
                }
                  , Y = {
                    connect() {
                        const re = s.getState().gl;
                        re.xr.addEventListener("sessionstart", V),
                        re.xr.addEventListener("sessionend", V)
                    },
                    disconnect() {
                        const re = s.getState().gl;
                        re.xr.removeEventListener("sessionstart", V),
                        re.xr.removeEventListener("sessionend", V)
                    }
                };
                I.xr && Y.connect(),
                B.set({
                    xr: Y
                })
            }
            if (I.shadowMap) {
                const F = I.shadowMap.enabled
                  , V = I.shadowMap.type;
                if (I.shadowMap.enabled = !!y,
                rn.boo(y))
                    I.shadowMap.type = Wf;
                else if (rn.str(y)) {
                    var G;
                    const Y = {
                        basic: HB,
                        percentage: S0,
                        soft: Wf,
                        variance: $a
                    };
                    I.shadowMap.type = (G = Y[y]) != null ? G : Wf
                } else
                    rn.obj(y) && Object.assign(I.shadowMap, y);
                (F !== I.shadowMap.enabled || V !== I.shadowMap.type) && (I.shadowMap.needsUpdate = !0)
            }
            pu && ("enabled"in pu ? pu.enabled = !_ : "legacyMode"in pu && (pu.legacyMode = _));
            const K = v ? $s : Tt
              , ne = x ? Hr : gw;
            I.outputEncoding !== K && (I.outputEncoding = K),
            I.toneMapping !== ne && (I.toneMapping = ne),
            B.legacy !== _ && B.set(()=>({
                legacy: _
            })),
            B.linear !== v && B.set(()=>({
                linear: v
            })),
            B.flat !== x && B.set(()=>({
                flat: x
            })),
            d && !rn.fun(d) && !jI(d) && !rn.equ(d, I, _f) && Uo(I, d),
            p && !B.events.handlers && B.set({
                events: p(s)
            });
            const oe = P8(n, h);
            return rn.equ(oe, B.size, _f) || B.setSize(oe.width, oe.height, oe.updateStyle, oe.top, oe.left),
            M && B.viewport.dpr !== HI(M) && B.setDpr(M),
            B.frameloop !== w && B.setFrameloop(w),
            B.onPointerMissed || B.set({
                onPointerMissed: E
            }),
            C && !rn.equ(C, B.performance, _f) && B.set(F=>({
                performance: {
                    ...F.performance,
                    ...C
                }
            })),
            a = m,
            l = !0,
            this
        },
        render(c) {
            return l || this.configure(),
            Vg.updateContainer(U.createElement(R8, {
                store: s,
                children: c,
                onCreated: a,
                rootElement: n
            }), o, null, ()=>{}
            ),
            s
        },
        unmount() {
            KI(n)
        }
    }
}
function R8({store: n, children: e, onCreated: t, rootElement: i}) {
    return yh(()=>{
        const r = n.getState();
        r.set(s=>({
            internal: {
                ...s.internal,
                active: !0
            }
        })),
        t && t(r),
        n.getState().events.connected || r.events.connect == null || r.events.connect(i)
    }
    , []),
    U.createElement(JI.Provider, {
        value: n
    }, e)
}
function KI(n, e) {
    const t = fc.get(n)
      , i = t == null ? void 0 : t.fiber;
    if (i) {
        const r = t == null ? void 0 : t.store.getState();
        r && (r.internal.active = !1),
        Vg.updateContainer(null, i, null, ()=>{
            r && setTimeout(()=>{
                try {
                    var s, o, a, l;
                    r.events.disconnect == null || r.events.disconnect(),
                    (s = r.gl) == null || (o = s.renderLists) == null || o.dispose == null || o.dispose(),
                    (a = r.gl) == null || a.forceContextLoss == null || a.forceContextLoss(),
                    (l = r.gl) != null && l.xr && r.xr.disconnect(),
                    g8(r),
                    fc.delete(n),
                    e && e(n)
                } catch {}
            }
            , 500)
        }
        )
    }
}
Vg.injectIntoDevTools({
    bundleType: 0,
    rendererPackageName: "@react-three/fiber",
    version: U.version
});
function Mr() {
    return Mr = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
        }
        return n
    }
    ,
    Mr.apply(this, arguments)
}
function B_(n, e, t) {
    var i, r, s, o, a;
    e == null && (e = 100);
    function l() {
        var d = Date.now() - o;
        d < e && d >= 0 ? i = setTimeout(l, e - d) : (i = null,
        t || (a = n.apply(s, r),
        s = r = null))
    }
    var c = function() {
        s = this,
        r = arguments,
        o = Date.now();
        var d = t && !i;
        return i || (i = setTimeout(l, e)),
        d && (a = n.apply(s, r),
        s = r = null),
        a
    };
    return c.clear = function() {
        i && (clearTimeout(i),
        i = null)
    }
    ,
    c.flush = function() {
        i && (a = n.apply(s, r),
        s = r = null,
        clearTimeout(i),
        i = null)
    }
    ,
    c
}
B_.debounce = B_;
var ST = B_;
function I8(n) {
    let {debounce: e, scroll: t, polyfill: i, offsetSize: r} = n === void 0 ? {
        debounce: 0,
        scroll: !1,
        offsetSize: !1
    } : n;
    const s = i || (typeof window > "u" ? class {
    }
    : window.ResizeObserver);
    if (!s)
        throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
    const [o,a] = U.useState({
        left: 0,
        top: 0,
        width: 0,
        height: 0,
        bottom: 0,
        right: 0,
        x: 0,
        y: 0
    })
      , l = U.useRef({
        element: null,
        scrollContainers: null,
        resizeObserver: null,
        lastBounds: o
    })
      , c = e ? typeof e == "number" ? e : e.scroll : null
      , d = e ? typeof e == "number" ? e : e.resize : null
      , h = U.useRef(!1);
    U.useEffect(()=>(h.current = !0,
    ()=>void (h.current = !1)));
    const [p,m,y] = U.useMemo(()=>{
        const A = ()=>{
            if (!l.current.element)
                return;
            const {left: w, top: M, width: C, height: P, bottom: R, right: E, x: B, y: I} = l.current.element.getBoundingClientRect()
              , z = {
                left: w,
                top: M,
                width: C,
                height: P,
                bottom: R,
                right: E,
                x: B,
                y: I
            };
            l.current.element instanceof HTMLElement && r && (z.height = l.current.element.offsetHeight,
            z.width = l.current.element.offsetWidth),
            Object.freeze(z),
            h.current && !F8(l.current.lastBounds, z) && a(l.current.lastBounds = z)
        }
        ;
        return [A, d ? ST(A, d) : A, c ? ST(A, c) : A]
    }
    , [a, r, c, d]);
    function v() {
        l.current.scrollContainers && (l.current.scrollContainers.forEach(A=>A.removeEventListener("scroll", y, !0)),
        l.current.scrollContainers = null),
        l.current.resizeObserver && (l.current.resizeObserver.disconnect(),
        l.current.resizeObserver = null)
    }
    function x() {
        l.current.element && (l.current.resizeObserver = new s(y),
        l.current.resizeObserver.observe(l.current.element),
        t && l.current.scrollContainers && l.current.scrollContainers.forEach(A=>A.addEventListener("scroll", y, {
            capture: !0,
            passive: !0
        })))
    }
    const _ = A=>{
        !A || A === l.current.element || (v(),
        l.current.element = A,
        l.current.scrollContainers = QI(A),
        x())
    }
    ;
    return D8(y, Boolean(t)),
    L8(m),
    U.useEffect(()=>{
        v(),
        x()
    }
    , [t, y, m]),
    U.useEffect(()=>v, []),
    [_, o, p]
}
function L8(n) {
    U.useEffect(()=>{
        const e = n;
        return window.addEventListener("resize", e),
        ()=>void window.removeEventListener("resize", e)
    }
    , [n])
}
function D8(n, e) {
    U.useEffect(()=>{
        if (e) {
            const t = n;
            return window.addEventListener("scroll", t, {
                capture: !0,
                passive: !0
            }),
            ()=>void window.removeEventListener("scroll", t, !0)
        }
    }
    , [n, e])
}
function QI(n) {
    const e = [];
    if (!n || n === document.body)
        return e;
    const {overflow: t, overflowX: i, overflowY: r} = window.getComputedStyle(n);
    return [t, i, r].some(s=>s === "auto" || s === "scroll") && e.push(n),
    [...e, ...QI(n.parentElement)]
}
const k8 = ["x", "y", "top", "bottom", "left", "right", "width", "height"]
  , F8 = (n,e)=>k8.every(t=>n[t] === e[t]);
var N8 = Object.defineProperty
  , O8 = Object.defineProperties
  , U8 = Object.getOwnPropertyDescriptors
  , MT = Object.getOwnPropertySymbols
  , z8 = Object.prototype.hasOwnProperty
  , G8 = Object.prototype.propertyIsEnumerable
  , bT = (n,e,t)=>e in n ? N8(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , CT = (n,e)=>{
    for (var t in e || (e = {}))
        z8.call(e, t) && bT(n, t, e[t]);
    if (MT)
        for (var t of MT(e))
            G8.call(e, t) && bT(n, t, e[t]);
    return n
}
  , H8 = (n,e)=>O8(n, U8(e));
function ZI(n, e, t) {
    if (!n)
        return;
    if (t(n) === !0)
        return n;
    let i = e ? n.return : n.child;
    for (; i; ) {
        const r = ZI(i, e, t);
        if (r)
            return r;
        i = e ? null : i.sibling
    }
}
function qI(n) {
    try {
        return Object.defineProperties(n, {
            _currentRenderer: {
                get() {
                    return null
                },
                set() {}
            },
            _currentRenderer2: {
                get() {
                    return null
                },
                set() {}
            }
        })
    } catch {
        return n
    }
}
const rS = qI(U.createContext(null));
class $I extends U.Component {
    render() {
        return U.createElement(rS.Provider, {
            value: this._reactInternals
        }, this.props.children)
    }
}
const {ReactCurrentOwner: V8, ReactCurrentDispatcher: W8} = U.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
function j8() {
    const n = U.useContext(rS);
    if (!n)
        throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
    const e = U.useId();
    return U.useMemo(()=>{
        var i;
        return (i = V8.current) != null ? i : ZI(n, !1, r=>{
            let s = r.memoizedState;
            for (; s; ) {
                if (s.memoizedState === e)
                    return !0;
                s = s.next
            }
        }
        )
    }
    , [n, e])
}
function J8() {
    var n, e;
    const t = j8()
      , [i] = U.useState(()=>new Map);
    i.clear();
    let r = t;
    for (; r; ) {
        const s = (n = r.type) == null ? void 0 : n._context;
        s && s !== rS && !i.has(s) && i.set(s, (e = W8.current) == null ? void 0 : e.readContext(qI(s))),
        r = r.return
    }
    return U.useMemo(()=>Array.from(i.keys()).reduce((s,o)=>a=>U.createElement(s, null, U.createElement(o.Provider, H8(CT({}, a), {
        value: i.get(o)
    }))), s=>U.createElement($I, CT({}, s))), [i])
}
const Ax = {
    onClick: ["click", !1],
    onContextMenu: ["contextmenu", !1],
    onDoubleClick: ["dblclick", !1],
    onWheel: ["wheel", !0],
    onPointerDown: ["pointerdown", !0],
    onPointerUp: ["pointerup", !0],
    onPointerLeave: ["pointerleave", !0],
    onPointerMove: ["pointermove", !0],
    onPointerCancel: ["pointercancel", !0],
    onLostPointerCapture: ["lostpointercapture", !0]
};
function X8(n) {
    const {handlePointer: e} = _8(n);
    return {
        priority: 1,
        enabled: !0,
        compute(t, i, r) {
            i.pointer.set(t.offsetX / i.size.width * 2 - 1, -(t.offsetY / i.size.height) * 2 + 1),
            i.raycaster.setFromCamera(i.pointer, i.camera)
        },
        connected: void 0,
        handlers: Object.keys(Ax).reduce((t,i)=>({
            ...t,
            [i]: e(i)
        }), {}),
        update: ()=>{
            var t;
            const {events: i, internal: r} = n.getState();
            (t = r.lastEvent) != null && t.current && i.handlers && i.handlers.onPointerMove(r.lastEvent.current)
        }
        ,
        connect: t=>{
            var i;
            const {set: r, events: s} = n.getState();
            s.disconnect == null || s.disconnect(),
            r(o=>({
                events: {
                    ...o.events,
                    connected: t
                }
            })),
            Object.entries((i = s.handlers) != null ? i : []).forEach(([o,a])=>{
                const [l,c] = Ax[o];
                t.addEventListener(l, a, {
                    passive: c
                })
            }
            )
        }
        ,
        disconnect: ()=>{
            const {set: t, events: i} = n.getState();
            if (i.connected) {
                var r;
                Object.entries((r = i.handlers) != null ? r : []).forEach(([s,o])=>{
                    if (i && i.connected instanceof HTMLElement) {
                        const [a] = Ax[s];
                        i.connected.removeEventListener(a, o)
                    }
                }
                ),
                t(s=>({
                    events: {
                        ...s.events,
                        connected: void 0
                    }
                }))
            }
        }
    }
}
const Y8 = U.forwardRef(function({children: e, fallback: t, resize: i, style: r, gl: s, events: o=X8, eventSource: a, eventPrefix: l, shadows: c, linear: d, flat: h, legacy: p, orthographic: m, frameloop: y, dpr: v, performance: x, raycaster: _, camera: A, onPointerMissed: w, onCreated: M, ...C}, P) {
    U.useMemo(()=>A8(b_), []);
    const R = J8()
      , [E,B] = I8({
        scroll: !0,
        debounce: {
            scroll: 50,
            resize: 0
        },
        ...i
    })
      , I = U.useRef(null)
      , z = U.useRef(null)
      , [q,W] = U.useState(null);
    U.useImperativeHandle(P, ()=>I.current);
    const G = UI(w)
      , [K,ne] = U.useState(!1)
      , [oe,F] = U.useState(!1);
    if (K)
        throw K;
    if (oe)
        throw oe;
    const V = U.useRef(null);
    B.width > 0 && B.height > 0 && q && (V.current || (V.current = B8(q)),
    V.current.configure({
        gl: s,
        events: o,
        shadows: c,
        linear: d,
        flat: h,
        legacy: p,
        orthographic: m,
        frameloop: y,
        dpr: v,
        performance: x,
        raycaster: _,
        camera: A,
        size: B,
        onPointerMissed: (...re)=>G.current == null ? void 0 : G.current(...re),
        onCreated: re=>{
            re.events.connect == null || re.events.connect(a ? d8(a) ? a.current : a : z.current),
            l && re.setEvents({
                compute: (j,ie)=>{
                    const ye = j[l + "X"]
                      , _e = j[l + "Y"];
                    ie.pointer.set(ye / ie.size.width * 2 - 1, -(_e / ie.size.height) * 2 + 1),
                    ie.raycaster.setFromCamera(ie.pointer, ie.camera)
                }
            }),
            M == null || M(re)
        }
    }),
    V.current.render(U.createElement(R, null, U.createElement(zI, {
        set: F
    }, U.createElement(U.Suspense, {
        fallback: U.createElement(h8, {
            set: ne
        })
    }, e))))),
    yh(()=>{
        W(I.current)
    }
    , []),
    U.useEffect(()=>{
        if (q)
            return ()=>KI(q)
    }
    , [q]);
    const Y = a ? "none" : "auto";
    return U.createElement("div", Mr({
        ref: z,
        style: {
            position: "relative",
            width: "100%",
            height: "100%",
            overflow: "hidden",
            pointerEvents: Y,
            ...r
        }
    }, C), U.createElement("div", {
        ref: E,
        style: {
            width: "100%",
            height: "100%"
        }
    }, U.createElement("canvas", {
        ref: I,
        style: {
            display: "block"
        }
    }, t)))
})
  , O0 = U.forwardRef(function(e, t) {
    return U.createElement($I, null, U.createElement(Y8, Mr({}, e, {
        ref: t
    })))
})
  , xh = new D
  , sS = new D
  , K8 = new D;
function Q8(n, e, t) {
    const i = xh.setFromMatrixPosition(n.matrixWorld);
    i.project(e);
    const r = t.width / 2
      , s = t.height / 2;
    return [i.x * r + r, -(i.y * s) + s]
}
function Z8(n, e) {
    const t = xh.setFromMatrixPosition(n.matrixWorld)
      , i = sS.setFromMatrixPosition(e.matrixWorld)
      , r = t.sub(i)
      , s = e.getWorldDirection(K8);
    return r.angleTo(s) > Math.PI / 2
}
function q8(n, e, t, i) {
    const r = xh.setFromMatrixPosition(n.matrixWorld)
      , s = r.clone();
    s.project(e),
    t.setFromCamera(s, e);
    const o = t.intersectObjects(i, !0);
    if (o.length) {
        const a = o[0].distance;
        return r.distanceTo(t.ray.origin) < a
    }
    return !0
}
function $8(n, e) {
    if (e instanceof Vr)
        return e.zoom;
    if (e instanceof Wt) {
        const t = xh.setFromMatrixPosition(n.matrixWorld)
          , i = sS.setFromMatrixPosition(e.matrixWorld)
          , r = e.fov * Math.PI / 180
          , s = t.distanceTo(i);
        return 1 / (2 * Math.tan(r / 2) * s)
    } else
        return 1
}
function eV(n, e, t) {
    if (e instanceof Wt || e instanceof Vr) {
        const i = xh.setFromMatrixPosition(n.matrixWorld)
          , r = sS.setFromMatrixPosition(e.matrixWorld)
          , s = i.distanceTo(r)
          , o = (t[1] - t[0]) / (e.far - e.near)
          , a = t[1] - o * e.far;
        return Math.round(o * s + a)
    }
}
const R_ = n=>Math.abs(n) < 1e-10 ? 0 : n;
function eL(n, e, t="") {
    let i = "matrix3d(";
    for (let r = 0; r !== 16; r++)
        i += R_(e[r] * n.elements[r]) + (r !== 15 ? "," : ")");
    return t + i
}
const tV = (n=>e=>eL(e, n))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1])
  , nV = (n=>(e,t)=>eL(e, n(t), "translate(-50%,-50%)"))(n=>[1 / n, 1 / n, 1 / n, 1, -1 / n, -1 / n, -1 / n, -1, 1 / n, 1 / n, 1 / n, 1, 1, 1, 1, 1]);
function iV(n) {
    return n && typeof n == "object" && "current"in n
}
const rV = U.forwardRef(({children: n, eps: e=.001, style: t, className: i, prepend: r, center: s, fullscreen: o, portal: a, distanceFactor: l, sprite: c=!1, transform: d=!1, occlude: h, onOcclude: p, castShadow: m, receiveShadow: y, material: v, geometry: x, zIndexRange: _=[16777271, 0], calculatePosition: A=Q8, as: w="div", wrapperClass: M, pointerEvents: C="auto", ...P},R)=>{
    const {gl: E, camera: B, scene: I, size: z, raycaster: q, events: W, viewport: G} = Hi()
      , [K] = U.useState(()=>document.createElement(w))
      , ne = U.useRef()
      , oe = U.useRef(null)
      , F = U.useRef(0)
      , V = U.useRef([0, 0])
      , Y = U.useRef(null)
      , re = U.useRef(null)
      , j = (a == null ? void 0 : a.current) || W.connected || E.domElement.parentNode
      , ie = U.useRef(null)
      , ye = U.useRef(!1)
      , _e = U.useMemo(()=>h && h !== "blending" || Array.isArray(h) && h.length && iV(h[0]), [h]);
    U.useLayoutEffect(()=>{
        const we = E.domElement;
        h && h === "blending" ? (we.style.zIndex = `${Math.floor(_[0] / 2)}`,
        we.style.position = "absolute",
        we.style.pointerEvents = "none") : (we.style.zIndex = null,
        we.style.position = null,
        we.style.pointerEvents = null)
    }
    , [h]),
    U.useLayoutEffect(()=>{
        if (oe.current) {
            const we = ne.current = DB(K);
            if (I.updateMatrixWorld(),
            d)
                K.style.cssText = "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
            else {
                const Le = A(oe.current, B, z);
                K.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${Le[0]}px,${Le[1]}px,0);transform-origin:0 0;`
            }
            return j && (r ? j.prepend(K) : j.appendChild(K)),
            ()=>{
                j && j.removeChild(K),
                we.unmount()
            }
        }
    }
    , [j, d]),
    U.useLayoutEffect(()=>{
        M && (K.className = M)
    }
    , [M]);
    const $ = U.useMemo(()=>d ? {
        position: "absolute",
        top: 0,
        left: 0,
        width: z.width,
        height: z.height,
        transformStyle: "preserve-3d",
        pointerEvents: "none"
    } : {
        position: "absolute",
        transform: s ? "translate3d(-50%,-50%,0)" : "none",
        ...o && {
            top: -z.height / 2,
            left: -z.width / 2,
            width: z.width,
            height: z.height
        },
        ...t
    }, [t, s, o, z, d])
      , Ne = U.useMemo(()=>({
        position: "absolute",
        pointerEvents: C
    }), [C]);
    U.useLayoutEffect(()=>{
        if (ye.current = !1,
        d) {
            var we;
            (we = ne.current) == null || we.render(U.createElement("div", {
                ref: Y,
                style: $
            }, U.createElement("div", {
                ref: re,
                style: Ne
            }, U.createElement("div", {
                ref: R,
                className: i,
                style: t,
                children: n
            }))))
        } else {
            var Le;
            (Le = ne.current) == null || Le.render(U.createElement("div", {
                ref: R,
                style: $,
                className: i,
                children: n
            }))
        }
    }
    );
    const Oe = U.useRef(!0);
    Tc(we=>{
        if (oe.current) {
            B.updateMatrixWorld(),
            oe.current.updateWorldMatrix(!0, !1);
            const Le = d ? V.current : A(oe.current, B, z);
            if (d || Math.abs(F.current - B.zoom) > e || Math.abs(V.current[0] - Le[0]) > e || Math.abs(V.current[1] - Le[1]) > e) {
                const de = Z8(oe.current, B);
                let ae = !1;
                _e && (h !== "blending" ? ae = [I] : Array.isArray(h) && (ae = h.map($e=>$e.current)));
                const be = Oe.current;
                if (ae) {
                    const $e = q8(oe.current, B, q, ae);
                    Oe.current = $e && !de
                } else
                    Oe.current = !de;
                be !== Oe.current && (p ? p(!Oe.current) : K.style.display = Oe.current ? "block" : "none");
                const Ge = Math.floor(_[0] / 2)
                  , Be = h ? _e ? [_[0], Ge] : [Ge - 1, 0] : _;
                if (K.style.zIndex = `${eV(oe.current, B, Be)}`,
                d) {
                    const [$e,Ye] = [z.width / 2, z.height / 2]
                      , Je = B.projectionMatrix.elements[5] * Ye
                      , {isOrthographicCamera: At, top: Ct, left: O, bottom: L, right: se} = B
                      , Se = tV(B.matrixWorldInverse)
                      , Ce = At ? `scale(${Je})translate(${R_(-(se + O) / 2)}px,${R_((Ct + L) / 2)}px)` : `translateZ(${Je}px)`;
                    let Pe = oe.current.matrixWorld;
                    c && (Pe = B.matrixWorldInverse.clone().transpose().copyPosition(Pe).scale(oe.current.scale),
                    Pe.elements[3] = Pe.elements[7] = Pe.elements[11] = 0,
                    Pe.elements[15] = 1),
                    K.style.width = z.width + "px",
                    K.style.height = z.height + "px",
                    K.style.perspective = At ? "" : `${Je}px`,
                    Y.current && re.current && (Y.current.style.transform = `${Ce}${Se}translate(${$e}px,${Ye}px)`,
                    re.current.style.transform = nV(Pe, 1 / ((l || 10) / 400)))
                } else {
                    const $e = l === void 0 ? 1 : $8(oe.current, B) * l;
                    K.style.transform = `translate3d(${Le[0]}px,${Le[1]}px,0) scale(${$e})`
                }
                V.current = Le,
                F.current = B.zoom
            }
        }
        if (!_e && ie.current && !ye.current)
            if (d) {
                if (Y.current) {
                    const Le = Y.current.children[0];
                    if (Le != null && Le.clientWidth && Le != null && Le.clientHeight) {
                        const {isOrthographicCamera: de} = B;
                        if (de || x)
                            P.scale && (Array.isArray(P.scale) ? P.scale instanceof D ? ie.current.scale.copy(P.scale.clone().divideScalar(1)) : ie.current.scale.set(1 / P.scale[0], 1 / P.scale[1], 1 / P.scale[2]) : ie.current.scale.setScalar(1 / P.scale));
                        else {
                            const ae = (l || 10) / 400
                              , be = Le.clientWidth * ae
                              , Ge = Le.clientHeight * ae;
                            ie.current.scale.set(be, Ge, 1)
                        }
                        ye.current = !0
                    }
                }
            } else {
                const Le = K.children[0];
                if (Le != null && Le.clientWidth && Le != null && Le.clientHeight) {
                    const de = 1 / G.factor
                      , ae = Le.clientWidth * de
                      , be = Le.clientHeight * de;
                    ie.current.scale.set(ae, be, 1),
                    ye.current = !0
                }
                ie.current.lookAt(we.camera.position)
            }
    }
    );
    const Ve = U.useMemo(()=>({
        vertexShader: d ? void 0 : `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,
        fragmentShader: `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `
    }), [d]);
    return U.createElement("group", Mr({}, P, {
        ref: oe
    }), h && !_e && U.createElement("mesh", {
        castShadow: m,
        receiveShadow: y,
        ref: ie
    }, x || U.createElement("planeGeometry", null), v || U.createElement("shaderMaterial", {
        side: Or,
        vertexShader: Ve.vertexShader,
        fragmentShader: Ve.fragmentShader
    })))
}
);
let Af = 0;
const sV = DI(n=>(Iu.onStart = (e,t,i)=>{
    n({
        active: !0,
        item: e,
        loaded: t,
        total: i,
        progress: (t - Af) / (i - Af) * 100
    })
}
,
Iu.onLoad = ()=>{
    n({
        active: !1
    })
}
,
Iu.onError = e=>n(t=>({
    errors: [...t.errors, e]
})),
Iu.onProgress = (e,t,i)=>{
    t === i && (Af = i),
    n({
        active: !0,
        item: e,
        loaded: t,
        total: i,
        progress: (t - Af) / (i - Af) * 100 || 100
    })
}
,
{
    errors: [],
    active: !1,
    progress: 0,
    item: "",
    loaded: 0,
    total: 0
}));
function oS(n) {
    return function(e) {
        n.forEach(function(t) {
            typeof t == "function" ? t(e) : t != null && (t.current = e)
        })
    }
}
function Xu(n, e, t) {
    return e in n ? Object.defineProperty(n, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : n[e] = t,
    n
}
function ET(n, e) {
    var t = Object.keys(n);
    if (Object.getOwnPropertySymbols) {
        var i = Object.getOwnPropertySymbols(n);
        e && (i = i.filter(function(r) {
            return Object.getOwnPropertyDescriptor(n, r).enumerable
        })),
        t.push.apply(t, i)
    }
    return t
}
function TT(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? ET(Object(t), !0).forEach(function(i) {
            Xu(n, i, t[i])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : ET(Object(t)).forEach(function(i) {
            Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i))
        })
    }
    return n
}
new me;
new me;
function tL(n, e) {
    if (!(n instanceof e))
        throw new TypeError("Cannot call a class as a function")
}
var hr = function n(e, t, i) {
    var r = this;
    tL(this, n),
    Xu(this, "dot2", function(s, o) {
        return r.x * s + r.y * o
    }),
    Xu(this, "dot3", function(s, o, a) {
        return r.x * s + r.y * o + r.z * a
    }),
    this.x = e,
    this.y = t,
    this.z = i
}
  , oV = [new hr(1,1,0), new hr(-1,1,0), new hr(1,-1,0), new hr(-1,-1,0), new hr(1,0,1), new hr(-1,0,1), new hr(1,0,-1), new hr(-1,0,-1), new hr(0,1,1), new hr(0,-1,1), new hr(0,1,-1), new hr(0,-1,-1)]
  , PT = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180]
  , BT = new Array(512)
  , RT = new Array(512)
  , aV = function(e) {
    e > 0 && e < 1 && (e *= 65536),
    e = Math.floor(e),
    e < 256 && (e |= e << 8);
    for (var t = 0; t < 256; t++) {
        var i;
        t & 1 ? i = PT[t] ^ e & 255 : i = PT[t] ^ e >> 8 & 255,
        BT[t] = BT[t + 256] = i,
        RT[t] = RT[t + 256] = oV[i % 12]
    }
};
aV(0);
function lV(n) {
    if (typeof n == "number")
        n = Math.abs(n);
    else if (typeof n == "string") {
        var e = n;
        n = 0;
        for (var t = 0; t < e.length; t++)
            n = (n + (t + 1) * (e.charCodeAt(t) % 96)) % 2147483647
    }
    return n === 0 && (n = 311),
    n
}
function IT(n) {
    var e = lV(n);
    return function() {
        var t = e * 48271 % 2147483647;
        return e = t,
        t / 2147483647
    }
}
var uV = function n(e) {
    var t = this;
    tL(this, n),
    Xu(this, "seed", 0),
    Xu(this, "init", function(i) {
        t.seed = i,
        t.value = IT(i)
    }),
    Xu(this, "value", IT(this.seed)),
    this.init(e)
}
  , cV = new uV(Math.random())
  , fV = {
    radius: 1,
    center: [0, 0, 0]
};
function dV(n, e) {
    for (var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : cV, i = TT(TT({}, fV), e), r = i.radius, s = i.center, o = 0; o < n.length; o += 3) {
        var a = Math.pow(t.value(), .3333333333333333)
          , l = t.value() * 2 - 1
          , c = t.value() * 2 - 1
          , d = t.value() * 2 - 1
          , h = Math.sqrt(l * l + c * c + d * d);
        l = a * l / h,
        c = a * c / h,
        d = a * d / h,
        n[o] = l * r + s[0],
        n[o + 1] = c * r + s[1],
        n[o + 2] = d * r + s[2]
    }
    return n
}
function Dd(n) {
    return Dd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    ,
    Dd(n)
}
function hV(n, e) {
    if (Dd(n) !== "object" || n === null)
        return n;
    var t = n[Symbol.toPrimitive];
    if (t !== void 0) {
        var i = t.call(n, e || "default");
        if (Dd(i) !== "object")
            return i;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(n)
}
function pV(n) {
    var e = hV(n, "string");
    return Dd(e) === "symbol" ? e : String(e)
}
function ct(n, e, t) {
    return e = pV(e),
    e in n ? Object.defineProperty(n, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : n[e] = t,
    n
}
const LT = (n,e)=>(n % e + e) % e;
let mV = class extends gs {
    constructor(e, t) {
        super(),
        ct(this, "object", void 0),
        ct(this, "domElement", void 0),
        ct(this, "enabled", !0),
        ct(this, "target", new D),
        ct(this, "minDistance", 0),
        ct(this, "maxDistance", 1 / 0),
        ct(this, "minZoom", 0),
        ct(this, "maxZoom", 1 / 0),
        ct(this, "minPolarAngle", 0),
        ct(this, "maxPolarAngle", Math.PI),
        ct(this, "minAzimuthAngle", -1 / 0),
        ct(this, "maxAzimuthAngle", 1 / 0),
        ct(this, "enableDamping", !1),
        ct(this, "dampingFactor", .05),
        ct(this, "enableZoom", !0),
        ct(this, "zoomSpeed", 1),
        ct(this, "enableRotate", !0),
        ct(this, "rotateSpeed", 1),
        ct(this, "enablePan", !0),
        ct(this, "panSpeed", 1),
        ct(this, "screenSpacePanning", !0),
        ct(this, "keyPanSpeed", 7),
        ct(this, "autoRotate", !1),
        ct(this, "autoRotateSpeed", 2),
        ct(this, "reverseOrbit", !1),
        ct(this, "keys", {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
        }),
        ct(this, "mouseButtons", {
            LEFT: Ga.ROTATE,
            MIDDLE: Ga.DOLLY,
            RIGHT: Ga.PAN
        }),
        ct(this, "touches", {
            ONE: Ha.ROTATE,
            TWO: Ha.DOLLY_PAN
        }),
        ct(this, "target0", void 0),
        ct(this, "position0", void 0),
        ct(this, "zoom0", void 0),
        ct(this, "_domElementKeyEvents", null),
        ct(this, "getPolarAngle", void 0),
        ct(this, "getAzimuthalAngle", void 0),
        ct(this, "setPolarAngle", void 0),
        ct(this, "setAzimuthalAngle", void 0),
        ct(this, "getDistance", void 0),
        ct(this, "listenToKeyEvents", void 0),
        ct(this, "saveState", void 0),
        ct(this, "reset", void 0),
        ct(this, "update", void 0),
        ct(this, "connect", void 0),
        ct(this, "dispose", void 0),
        this.object = e,
        this.domElement = t,
        this.target0 = this.target.clone(),
        this.position0 = this.object.position.clone(),
        this.zoom0 = this.object instanceof Wt ? this.object.zoom : 1,
        this.getPolarAngle = ()=>d.phi,
        this.getAzimuthalAngle = ()=>d.theta,
        this.setPolarAngle = H=>{
            let le = LT(H, 2 * Math.PI)
              , Ae = d.phi;
            Ae < 0 && (Ae += 2 * Math.PI),
            le < 0 && (le += 2 * Math.PI);
            let Te = Math.abs(le - Ae);
            2 * Math.PI - Te < Te && (le < Ae ? le += 2 * Math.PI : Ae += 2 * Math.PI),
            h.phi = le - Ae,
            i.update()
        }
        ,
        this.setAzimuthalAngle = H=>{
            let le = LT(H, 2 * Math.PI)
              , Ae = d.theta;
            Ae < 0 && (Ae += 2 * Math.PI),
            le < 0 && (le += 2 * Math.PI);
            let Te = Math.abs(le - Ae);
            2 * Math.PI - Te < Te && (le < Ae ? le += 2 * Math.PI : Ae += 2 * Math.PI),
            h.theta = le - Ae,
            i.update()
        }
        ,
        this.getDistance = ()=>i.object.position.distanceTo(i.target),
        this.listenToKeyEvents = H=>{
            H.addEventListener("keydown", se),
            this._domElementKeyEvents = H
        }
        ,
        this.saveState = ()=>{
            i.target0.copy(i.target),
            i.position0.copy(i.object.position),
            i.zoom0 = i.object instanceof Wt ? i.object.zoom : 1
        }
        ,
        this.reset = ()=>{
            i.target.copy(i.target0),
            i.object.position.copy(i.position0),
            i.object instanceof Wt && (i.object.zoom = i.zoom0,
            i.object.updateProjectionMatrix()),
            i.dispatchEvent(r),
            i.update(),
            l = a.NONE
        }
        ,
        this.update = (()=>{
            const H = new D
              , le = new Qn().setFromUnitVectors(e.up, new D(0,1,0))
              , Ae = le.clone().invert()
              , Te = new D
              , tt = new Qn
              , _t = 2 * Math.PI;
            return function() {
                const X = i.object.position;
                H.copy(X).sub(i.target),
                H.applyQuaternion(le),
                d.setFromVector3(H),
                i.autoRotate && l === a.NONE && q(I()),
                i.enableDamping ? (d.theta += h.theta * i.dampingFactor,
                d.phi += h.phi * i.dampingFactor) : (d.theta += h.theta,
                d.phi += h.phi);
                let ce = i.minAzimuthAngle
                  , xe = i.maxAzimuthAngle;
                return isFinite(ce) && isFinite(xe) && (ce < -Math.PI ? ce += _t : ce > Math.PI && (ce -= _t),
                xe < -Math.PI ? xe += _t : xe > Math.PI && (xe -= _t),
                ce <= xe ? d.theta = Math.max(ce, Math.min(xe, d.theta)) : d.theta = d.theta > (ce + xe) / 2 ? Math.max(ce, d.theta) : Math.min(xe, d.theta)),
                d.phi = Math.max(i.minPolarAngle, Math.min(i.maxPolarAngle, d.phi)),
                d.makeSafe(),
                d.radius *= p,
                d.radius = Math.max(i.minDistance, Math.min(i.maxDistance, d.radius)),
                i.enableDamping === !0 ? i.target.addScaledVector(m, i.dampingFactor) : i.target.add(m),
                H.setFromSpherical(d),
                H.applyQuaternion(Ae),
                X.copy(i.target).add(H),
                i.object.lookAt(i.target),
                i.enableDamping === !0 ? (h.theta *= 1 - i.dampingFactor,
                h.phi *= 1 - i.dampingFactor,
                m.multiplyScalar(1 - i.dampingFactor)) : (h.set(0, 0, 0),
                m.set(0, 0, 0)),
                p = 1,
                y || Te.distanceToSquared(i.object.position) > c || 8 * (1 - tt.dot(i.object.quaternion)) > c ? (i.dispatchEvent(r),
                Te.copy(i.object.position),
                tt.copy(i.object.quaternion),
                y = !1,
                !0) : !1
            }
        }
        )(),
        this.connect = H=>{
            H === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),
            i.domElement = H,
            i.domElement.style.touchAction = "none",
            i.domElement.addEventListener("contextmenu", Pe),
            i.domElement.addEventListener("pointerdown", $e),
            i.domElement.addEventListener("pointercancel", At),
            i.domElement.addEventListener("wheel", L)
        }
        ,
        this.dispose = ()=>{
            var H, le, Ae, Te, tt, _t;
            (H = i.domElement) === null || H === void 0 || H.removeEventListener("contextmenu", Pe),
            (le = i.domElement) === null || le === void 0 || le.removeEventListener("pointerdown", $e),
            (Ae = i.domElement) === null || Ae === void 0 || Ae.removeEventListener("pointercancel", At),
            (Te = i.domElement) === null || Te === void 0 || Te.removeEventListener("wheel", L),
            (tt = i.domElement) === null || tt === void 0 || tt.ownerDocument.removeEventListener("pointermove", Ye),
            (_t = i.domElement) === null || _t === void 0 || _t.ownerDocument.removeEventListener("pointerup", Je),
            i._domElementKeyEvents !== null && i._domElementKeyEvents.removeEventListener("keydown", se)
        }
        ;
        const i = this
          , r = {
            type: "change"
        }
          , s = {
            type: "start"
        }
          , o = {
            type: "end"
        }
          , a = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_PAN: 4,
            TOUCH_DOLLY_PAN: 5,
            TOUCH_DOLLY_ROTATE: 6
        };
        let l = a.NONE;
        const c = 1e-6
          , d = new M_
          , h = new M_;
        let p = 1;
        const m = new D;
        let y = !1;
        const v = new me
          , x = new me
          , _ = new me
          , A = new me
          , w = new me
          , M = new me
          , C = new me
          , P = new me
          , R = new me
          , E = []
          , B = {};
        function I() {
            return 2 * Math.PI / 60 / 60 * i.autoRotateSpeed
        }
        function z() {
            return Math.pow(.95, i.zoomSpeed)
        }
        function q(H) {
            i.reverseOrbit ? h.theta += H : h.theta -= H
        }
        function W(H) {
            i.reverseOrbit ? h.phi += H : h.phi -= H
        }
        const G = (()=>{
            const H = new D;
            return function(Ae, Te) {
                H.setFromMatrixColumn(Te, 0),
                H.multiplyScalar(-Ae),
                m.add(H)
            }
        }
        )()
          , K = (()=>{
            const H = new D;
            return function(Ae, Te) {
                i.screenSpacePanning === !0 ? H.setFromMatrixColumn(Te, 1) : (H.setFromMatrixColumn(Te, 0),
                H.crossVectors(i.object.up, H)),
                H.multiplyScalar(Ae),
                m.add(H)
            }
        }
        )()
          , ne = (()=>{
            const H = new D;
            return function(Ae, Te) {
                const tt = i.domElement;
                if (tt && i.object instanceof Wt && i.object.isPerspectiveCamera) {
                    const _t = i.object.position;
                    H.copy(_t).sub(i.target);
                    let Jt = H.length();
                    Jt *= Math.tan(i.object.fov / 2 * Math.PI / 180),
                    G(2 * Ae * Jt / tt.clientHeight, i.object.matrix),
                    K(2 * Te * Jt / tt.clientHeight, i.object.matrix)
                } else
                    tt && i.object instanceof Vr && i.object.isOrthographicCamera ? (G(Ae * (i.object.right - i.object.left) / i.object.zoom / tt.clientWidth, i.object.matrix),
                    K(Te * (i.object.top - i.object.bottom) / i.object.zoom / tt.clientHeight, i.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
                    i.enablePan = !1)
            }
        }
        )();
        function oe(H) {
            i.object instanceof Wt && i.object.isPerspectiveCamera ? p /= H : i.object instanceof Vr && i.object.isOrthographicCamera ? (i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom * H)),
            i.object.updateProjectionMatrix(),
            y = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            i.enableZoom = !1)
        }
        function F(H) {
            i.object instanceof Wt && i.object.isPerspectiveCamera ? p *= H : i.object instanceof Vr && i.object.isOrthographicCamera ? (i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom / H)),
            i.object.updateProjectionMatrix(),
            y = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            i.enableZoom = !1)
        }
        function V(H) {
            v.set(H.clientX, H.clientY)
        }
        function Y(H) {
            C.set(H.clientX, H.clientY)
        }
        function re(H) {
            A.set(H.clientX, H.clientY)
        }
        function j(H) {
            x.set(H.clientX, H.clientY),
            _.subVectors(x, v).multiplyScalar(i.rotateSpeed);
            const le = i.domElement;
            le && (q(2 * Math.PI * _.x / le.clientHeight),
            W(2 * Math.PI * _.y / le.clientHeight)),
            v.copy(x),
            i.update()
        }
        function ie(H) {
            P.set(H.clientX, H.clientY),
            R.subVectors(P, C),
            R.y > 0 ? oe(z()) : R.y < 0 && F(z()),
            C.copy(P),
            i.update()
        }
        function ye(H) {
            w.set(H.clientX, H.clientY),
            M.subVectors(w, A).multiplyScalar(i.panSpeed),
            ne(M.x, M.y),
            A.copy(w),
            i.update()
        }
        function _e(H) {
            H.deltaY < 0 ? F(z()) : H.deltaY > 0 && oe(z()),
            i.update()
        }
        function $(H) {
            let le = !1;
            switch (H.code) {
            case i.keys.UP:
                ne(0, i.keyPanSpeed),
                le = !0;
                break;
            case i.keys.BOTTOM:
                ne(0, -i.keyPanSpeed),
                le = !0;
                break;
            case i.keys.LEFT:
                ne(i.keyPanSpeed, 0),
                le = !0;
                break;
            case i.keys.RIGHT:
                ne(-i.keyPanSpeed, 0),
                le = !0;
                break
            }
            le && (H.preventDefault(),
            i.update())
        }
        function Ne() {
            if (E.length == 1)
                v.set(E[0].pageX, E[0].pageY);
            else {
                const H = .5 * (E[0].pageX + E[1].pageX)
                  , le = .5 * (E[0].pageY + E[1].pageY);
                v.set(H, le)
            }
        }
        function Oe() {
            if (E.length == 1)
                A.set(E[0].pageX, E[0].pageY);
            else {
                const H = .5 * (E[0].pageX + E[1].pageX)
                  , le = .5 * (E[0].pageY + E[1].pageY);
                A.set(H, le)
            }
        }
        function Ve() {
            const H = E[0].pageX - E[1].pageX
              , le = E[0].pageY - E[1].pageY
              , Ae = Math.sqrt(H * H + le * le);
            C.set(0, Ae)
        }
        function we() {
            i.enableZoom && Ve(),
            i.enablePan && Oe()
        }
        function Le() {
            i.enableZoom && Ve(),
            i.enableRotate && Ne()
        }
        function de(H) {
            if (E.length == 1)
                x.set(H.pageX, H.pageY);
            else {
                const Ae = Ke(H)
                  , Te = .5 * (H.pageX + Ae.x)
                  , tt = .5 * (H.pageY + Ae.y);
                x.set(Te, tt)
            }
            _.subVectors(x, v).multiplyScalar(i.rotateSpeed);
            const le = i.domElement;
            le && (q(2 * Math.PI * _.x / le.clientHeight),
            W(2 * Math.PI * _.y / le.clientHeight)),
            v.copy(x)
        }
        function ae(H) {
            if (E.length == 1)
                w.set(H.pageX, H.pageY);
            else {
                const le = Ke(H)
                  , Ae = .5 * (H.pageX + le.x)
                  , Te = .5 * (H.pageY + le.y);
                w.set(Ae, Te)
            }
            M.subVectors(w, A).multiplyScalar(i.panSpeed),
            ne(M.x, M.y),
            A.copy(w)
        }
        function be(H) {
            const le = Ke(H)
              , Ae = H.pageX - le.x
              , Te = H.pageY - le.y
              , tt = Math.sqrt(Ae * Ae + Te * Te);
            P.set(0, tt),
            R.set(0, Math.pow(P.y / C.y, i.zoomSpeed)),
            oe(R.y),
            C.copy(P)
        }
        function Ge(H) {
            i.enableZoom && be(H),
            i.enablePan && ae(H)
        }
        function Be(H) {
            i.enableZoom && be(H),
            i.enableRotate && de(H)
        }
        function $e(H) {
            if (i.enabled !== !1) {
                if (E.length === 0) {
                    var le, Ae;
                    (le = i.domElement) === null || le === void 0 || le.ownerDocument.addEventListener("pointermove", Ye),
                    (Ae = i.domElement) === null || Ae === void 0 || Ae.ownerDocument.addEventListener("pointerup", Je)
                }
                rt(H),
                H.pointerType === "touch" ? Se(H) : Ct(H)
            }
        }
        function Ye(H) {
            i.enabled !== !1 && (H.pointerType === "touch" ? Ce(H) : O(H))
        }
        function Je(H) {
            if (De(H),
            E.length === 0) {
                var le, Ae, Te;
                (le = i.domElement) === null || le === void 0 || le.releasePointerCapture(H.pointerId),
                (Ae = i.domElement) === null || Ae === void 0 || Ae.ownerDocument.removeEventListener("pointermove", Ye),
                (Te = i.domElement) === null || Te === void 0 || Te.ownerDocument.removeEventListener("pointerup", Je)
            }
            i.dispatchEvent(o),
            l = a.NONE
        }
        function At(H) {
            De(H)
        }
        function Ct(H) {
            let le;
            switch (H.button) {
            case 0:
                le = i.mouseButtons.LEFT;
                break;
            case 1:
                le = i.mouseButtons.MIDDLE;
                break;
            case 2:
                le = i.mouseButtons.RIGHT;
                break;
            default:
                le = -1
            }
            switch (le) {
            case Ga.DOLLY:
                if (i.enableZoom === !1)
                    return;
                Y(H),
                l = a.DOLLY;
                break;
            case Ga.ROTATE:
                if (H.ctrlKey || H.metaKey || H.shiftKey) {
                    if (i.enablePan === !1)
                        return;
                    re(H),
                    l = a.PAN
                } else {
                    if (i.enableRotate === !1)
                        return;
                    V(H),
                    l = a.ROTATE
                }
                break;
            case Ga.PAN:
                if (H.ctrlKey || H.metaKey || H.shiftKey) {
                    if (i.enableRotate === !1)
                        return;
                    V(H),
                    l = a.ROTATE
                } else {
                    if (i.enablePan === !1)
                        return;
                    re(H),
                    l = a.PAN
                }
                break;
            default:
                l = a.NONE
            }
            l !== a.NONE && i.dispatchEvent(s)
        }
        function O(H) {
            if (i.enabled !== !1)
                switch (l) {
                case a.ROTATE:
                    if (i.enableRotate === !1)
                        return;
                    j(H);
                    break;
                case a.DOLLY:
                    if (i.enableZoom === !1)
                        return;
                    ie(H);
                    break;
                case a.PAN:
                    if (i.enablePan === !1)
                        return;
                    ye(H);
                    break
                }
        }
        function L(H) {
            i.enabled === !1 || i.enableZoom === !1 || l !== a.NONE && l !== a.ROTATE || (H.preventDefault(),
            i.dispatchEvent(s),
            _e(H),
            i.dispatchEvent(o))
        }
        function se(H) {
            i.enabled === !1 || i.enablePan === !1 || $(H)
        }
        function Se(H) {
            switch (ge(H),
            E.length) {
            case 1:
                switch (i.touches.ONE) {
                case Ha.ROTATE:
                    if (i.enableRotate === !1)
                        return;
                    Ne(),
                    l = a.TOUCH_ROTATE;
                    break;
                case Ha.PAN:
                    if (i.enablePan === !1)
                        return;
                    Oe(),
                    l = a.TOUCH_PAN;
                    break;
                default:
                    l = a.NONE
                }
                break;
            case 2:
                switch (i.touches.TWO) {
                case Ha.DOLLY_PAN:
                    if (i.enableZoom === !1 && i.enablePan === !1)
                        return;
                    we(),
                    l = a.TOUCH_DOLLY_PAN;
                    break;
                case Ha.DOLLY_ROTATE:
                    if (i.enableZoom === !1 && i.enableRotate === !1)
                        return;
                    Le(),
                    l = a.TOUCH_DOLLY_ROTATE;
                    break;
                default:
                    l = a.NONE
                }
                break;
            default:
                l = a.NONE
            }
            l !== a.NONE && i.dispatchEvent(s)
        }
        function Ce(H) {
            switch (ge(H),
            l) {
            case a.TOUCH_ROTATE:
                if (i.enableRotate === !1)
                    return;
                de(H),
                i.update();
                break;
            case a.TOUCH_PAN:
                if (i.enablePan === !1)
                    return;
                ae(H),
                i.update();
                break;
            case a.TOUCH_DOLLY_PAN:
                if (i.enableZoom === !1 && i.enablePan === !1)
                    return;
                Ge(H),
                i.update();
                break;
            case a.TOUCH_DOLLY_ROTATE:
                if (i.enableZoom === !1 && i.enableRotate === !1)
                    return;
                Be(H),
                i.update();
                break;
            default:
                l = a.NONE
            }
        }
        function Pe(H) {
            i.enabled !== !1 && H.preventDefault()
        }
        function rt(H) {
            E.push(H)
        }
        function De(H) {
            delete B[H.pointerId];
            for (let le = 0; le < E.length; le++)
                if (E[le].pointerId == H.pointerId) {
                    E.splice(le, 1);
                    return
                }
        }
        function ge(H) {
            let le = B[H.pointerId];
            le === void 0 && (le = new me,
            B[H.pointerId] = le),
            le.set(H.pageX, H.pageY)
        }
        function Ke(H) {
            const le = H.pointerId === E[0].pointerId ? E[1] : E[0];
            return B[le.pointerId]
        }
        t !== void 0 && this.connect(t),
        this.update()
    }
}
;
class aS extends Ai {
    constructor(e) {
        super(e),
        this.dracoLoader = null,
        this.ktx2Loader = null,
        this.meshoptDecoder = null,
        this.pluginCallbacks = [],
        this.register(function(t) {
            return new _V(t)
        }),
        this.register(function(t) {
            return new EV(t)
        }),
        this.register(function(t) {
            return new TV(t)
        }),
        this.register(function(t) {
            return new wV(t)
        }),
        this.register(function(t) {
            return new SV(t)
        }),
        this.register(function(t) {
            return new MV(t)
        }),
        this.register(function(t) {
            return new bV(t)
        }),
        this.register(function(t) {
            return new xV(t)
        }),
        this.register(function(t) {
            return new CV(t)
        }),
        this.register(function(t) {
            return new AV(t)
        }),
        this.register(function(t) {
            return new vV(t)
        }),
        this.register(function(t) {
            return new PV(t)
        })
    }
    load(e, t, i, r) {
        const s = this;
        let o;
        this.resourcePath !== "" ? o = this.resourcePath : this.path !== "" ? o = this.path : o = fs.extractUrlBase(e),
        this.manager.itemStart(e);
        const a = function(c) {
            r ? r(c) : console.error(c),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        }
          , l = new Yi(this.manager);
        l.setPath(this.path),
        l.setResponseType("arraybuffer"),
        l.setRequestHeader(this.requestHeader),
        l.setWithCredentials(this.withCredentials),
        l.load(e, function(c) {
            try {
                s.parse(c, o, function(d) {
                    t(d),
                    s.manager.itemEnd(e)
                }, a)
            } catch (d) {
                a(d)
            }
        }, i, a)
    }
    setDRACOLoader(e) {
        return this.dracoLoader = e,
        this
    }
    setDDSLoader() {
        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
    }
    setKTX2Loader(e) {
        return this.ktx2Loader = e,
        this
    }
    setMeshoptDecoder(e) {
        return this.meshoptDecoder = e,
        this
    }
    register(e) {
        return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
        this
    }
    unregister(e) {
        return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
        this
    }
    parse(e, t, i, r) {
        let s;
        const o = {}
          , a = {};
        if (typeof e == "string")
            s = e;
        else if (fs.decodeText(new Uint8Array(e,0,4)) === nL) {
            try {
                o[wt.KHR_BINARY_GLTF] = new BV(e)
            } catch (h) {
                r && r(h);
                return
            }
            s = o[wt.KHR_BINARY_GLTF].content
        } else
            s = fs.decodeText(new Uint8Array(e));
        const l = JSON.parse(s);
        if (l.asset === void 0 || l.asset.version[0] < 2) {
            r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return
        }
        const c = new VV(l,{
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
        });
        c.fileLoader.setRequestHeader(this.requestHeader);
        for (let d = 0; d < this.pluginCallbacks.length; d++) {
            const h = this.pluginCallbacks[d](c);
            a[h.name] = h,
            o[h.name] = !0
        }
        if (l.extensionsUsed)
            for (let d = 0; d < l.extensionsUsed.length; ++d) {
                const h = l.extensionsUsed[d]
                  , p = l.extensionsRequired || [];
                switch (h) {
                case wt.KHR_MATERIALS_UNLIT:
                    o[h] = new yV;
                    break;
                case wt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                    o[h] = new LV;
                    break;
                case wt.KHR_DRACO_MESH_COMPRESSION:
                    o[h] = new RV(l,this.dracoLoader);
                    break;
                case wt.KHR_TEXTURE_TRANSFORM:
                    o[h] = new IV;
                    break;
                case wt.KHR_MESH_QUANTIZATION:
                    o[h] = new DV;
                    break;
                default:
                    p.indexOf(h) >= 0 && a[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".')
                }
            }
        c.setExtensions(o),
        c.setPlugins(a),
        c.parse(i, r)
    }
    parseAsync(e, t) {
        const i = this;
        return new Promise(function(r, s) {
            i.parse(e, t, r, s)
        }
        )
    }
}
function gV() {
    let n = {};
    return {
        get: function(e) {
            return n[e]
        },
        add: function(e, t) {
            n[e] = t
        },
        remove: function(e) {
            delete n[e]
        },
        removeAll: function() {
            n = {}
        }
    }
}
const wt = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
};
class vV {
    constructor(e) {
        this.parser = e,
        this.name = wt.KHR_LIGHTS_PUNCTUAL,
        this.cache = {
            refs: {},
            uses: {}
        }
    }
    _markDefs() {
        const e = this.parser
          , t = this.parser.json.nodes || [];
        for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light)
        }
    }
    _loadLight(e) {
        const t = this.parser
          , i = "light:" + e;
        let r = t.cache.get(i);
        if (r)
            return r;
        const s = t.json
          , l = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
        let c;
        const d = new Ie(16777215);
        l.color !== void 0 && d.fromArray(l.color);
        const h = l.range !== void 0 ? l.range : 0;
        switch (l.type) {
        case "directional":
            c = new qw(d),
            c.target.position.set(0, 0, -1),
            c.add(c.target);
            break;
        case "point":
            c = new Zw(d),
            c.distance = h;
            break;
        case "spot":
            c = new Qw(d),
            c.distance = h,
            l.spot = l.spot || {},
            l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0,
            l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4,
            c.angle = l.spot.outerConeAngle,
            c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle,
            c.target.position.set(0, 0, -1),
            c.add(c.target);
            break;
        default:
            throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type)
        }
        return c.position.set(0, 0, 0),
        c.decay = 2,
        l.intensity !== void 0 && (c.intensity = l.intensity),
        c.name = t.createUniqueName(l.name || "light_" + e),
        r = Promise.resolve(c),
        t.cache.add(i, r),
        r
    }
    createNodeAttachment(e) {
        const t = this
          , i = this.parser
          , s = i.json.nodes[e]
          , a = (s.extensions && s.extensions[this.name] || {}).light;
        return a === void 0 ? null : this._loadLight(a).then(function(l) {
            return i._getNodeRef(t.cache, a, l)
        })
    }
}
class yV {
    constructor() {
        this.name = wt.KHR_MATERIALS_UNLIT
    }
    getMaterialType() {
        return Wi
    }
    extendParams(e, t, i) {
        const r = [];
        e.color = new Ie(1,1,1),
        e.opacity = 1;
        const s = t.pbrMetallicRoughness;
        if (s) {
            if (Array.isArray(s.baseColorFactor)) {
                const o = s.baseColorFactor;
                e.color.fromArray(o),
                e.opacity = o[3]
            }
            s.baseColorTexture !== void 0 && r.push(i.assignTexture(e, "map", s.baseColorTexture, Tt))
        }
        return Promise.all(r)
    }
}
class xV {
    constructor(e) {
        this.parser = e,
        this.name = wt.KHR_MATERIALS_EMISSIVE_STRENGTH
    }
    extendMaterialParams(e, t) {
        const r = this.parser.json.materials[e];
        if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
        const s = r.extensions[this.name].emissiveStrength;
        return s !== void 0 && (t.emissiveIntensity = s),
        Promise.resolve()
    }
}
class _V {
    constructor(e) {
        this.parser = e,
        this.name = wt.KHR_MATERIALS_CLEARCOAT
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : ao
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = r.extensions[this.name];
        if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
        o.clearcoatTexture !== void 0 && s.push(i.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
        o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
        o.clearcoatRoughnessTexture !== void 0 && s.push(i.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)),
        o.clearcoatNormalTexture !== void 0 && (s.push(i.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)),
        o.clearcoatNormalTexture.scale !== void 0)) {
            const a = o.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new me(a,a)
        }
        return Promise.all(s)
    }
}
class AV {
    constructor(e) {
        this.parser = e,
        this.name = wt.KHR_MATERIALS_IRIDESCENCE
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : ao
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = r.extensions[this.name];
        return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor),
        o.iridescenceTexture !== void 0 && s.push(i.assignTexture(t, "iridescenceMap", o.iridescenceTexture)),
        o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor),
        t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]),
        o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
        o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
        o.iridescenceThicknessTexture !== void 0 && s.push(i.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)),
        Promise.all(s)
    }
}
class wV {
    constructor(e) {
        this.parser = e,
        this.name = wt.KHR_MATERIALS_SHEEN
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : ao
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
        const s = [];
        t.sheenColor = new Ie(0,0,0),
        t.sheenRoughness = 0,
        t.sheen = 1;
        const o = r.extensions[this.name];
        return o.sheenColorFactor !== void 0 && t.sheenColor.fromArray(o.sheenColorFactor),
        o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor),
        o.sheenColorTexture !== void 0 && s.push(i.assignTexture(t, "sheenColorMap", o.sheenColorTexture, Tt)),
        o.sheenRoughnessTexture !== void 0 && s.push(i.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)),
        Promise.all(s)
    }
}
class SV {
    constructor(e) {
        this.parser = e,
        this.name = wt.KHR_MATERIALS_TRANSMISSION
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : ao
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = r.extensions[this.name];
        return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor),
        o.transmissionTexture !== void 0 && s.push(i.assignTexture(t, "transmissionMap", o.transmissionTexture)),
        Promise.all(s)
    }
}
class MV {
    constructor(e) {
        this.parser = e,
        this.name = wt.KHR_MATERIALS_VOLUME
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : ao
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = r.extensions[this.name];
        t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0,
        o.thicknessTexture !== void 0 && s.push(i.assignTexture(t, "thicknessMap", o.thicknessTexture)),
        t.attenuationDistance = o.attenuationDistance || 1 / 0;
        const a = o.attenuationColor || [1, 1, 1];
        return t.attenuationColor = new Ie(a[0],a[1],a[2]),
        Promise.all(s)
    }
}
class bV {
    constructor(e) {
        this.parser = e,
        this.name = wt.KHR_MATERIALS_IOR
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : ao
    }
    extendMaterialParams(e, t) {
        const r = this.parser.json.materials[e];
        if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
        const s = r.extensions[this.name];
        return t.ior = s.ior !== void 0 ? s.ior : 1.5,
        Promise.resolve()
    }
}
class CV {
    constructor(e) {
        this.parser = e,
        this.name = wt.KHR_MATERIALS_SPECULAR
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : ao
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = r.extensions[this.name];
        t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1,
        o.specularTexture !== void 0 && s.push(i.assignTexture(t, "specularIntensityMap", o.specularTexture));
        const a = o.specularColorFactor || [1, 1, 1];
        return t.specularColor = new Ie(a[0],a[1],a[2]),
        o.specularColorTexture !== void 0 && s.push(i.assignTexture(t, "specularColorMap", o.specularColorTexture, Tt)),
        Promise.all(s)
    }
}
class EV {
    constructor(e) {
        this.parser = e,
        this.name = wt.KHR_TEXTURE_BASISU
    }
    loadTexture(e) {
        const t = this.parser
          , i = t.json
          , r = i.textures[e];
        if (!r.extensions || !r.extensions[this.name])
            return null;
        const s = r.extensions[this.name]
          , o = t.options.ktx2Loader;
        if (!o) {
            if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
                throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null
        }
        return t.loadTextureImage(e, s.source, o)
    }
}
class TV {
    constructor(e) {
        this.parser = e,
        this.name = wt.EXT_TEXTURE_WEBP,
        this.isSupported = null
    }
    loadTexture(e) {
        const t = this.name
          , i = this.parser
          , r = i.json
          , s = r.textures[e];
        if (!s.extensions || !s.extensions[t])
            return null;
        const o = s.extensions[t]
          , a = r.images[o.source];
        let l = i.textureLoader;
        if (a.uri) {
            const c = i.options.manager.getHandler(a.uri);
            c !== null && (l = c)
        }
        return this.detectSupport().then(function(c) {
            if (c)
                return i.loadTextureImage(e, o.source, l);
            if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
                throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            return i.loadTexture(e)
        })
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function(e) {
            const t = new Image;
            t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
            t.onload = t.onerror = function() {
                e(t.height === 1)
            }
        }
        )),
        this.isSupported
    }
}
class PV {
    constructor(e) {
        this.name = wt.EXT_MESHOPT_COMPRESSION,
        this.parser = e
    }
    loadBufferView(e) {
        const t = this.parser.json
          , i = t.bufferViews[e];
        if (i.extensions && i.extensions[this.name]) {
            const r = i.extensions[this.name]
              , s = this.parser.getDependency("buffer", r.buffer)
              , o = this.parser.options.meshoptDecoder;
            if (!o || !o.supported) {
                if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
                    throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                return null
            }
            return s.then(function(a) {
                const l = r.byteOffset || 0
                  , c = r.byteLength || 0
                  , d = r.count
                  , h = r.byteStride
                  , p = new Uint8Array(a,l,c);
                return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(d, h, p, r.mode, r.filter).then(function(m) {
                    return m.buffer
                }) : o.ready.then(function() {
                    const m = new ArrayBuffer(d * h);
                    return o.decodeGltfBuffer(new Uint8Array(m), d, h, p, r.mode, r.filter),
                    m
                })
            })
        } else
            return null
    }
}
const nL = "glTF"
  , wf = 12
  , DT = {
    JSON: 1313821514,
    BIN: 5130562
};
class BV {
    constructor(e) {
        this.name = wt.KHR_BINARY_GLTF,
        this.content = null,
        this.body = null;
        const t = new DataView(e,0,wf);
        if (this.header = {
            magic: fs.decodeText(new Uint8Array(e.slice(0, 4))),
            version: t.getUint32(4, !0),
            length: t.getUint32(8, !0)
        },
        this.header.magic !== nL)
            throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const i = this.header.length - wf
          , r = new DataView(e,wf);
        let s = 0;
        for (; s < i; ) {
            const o = r.getUint32(s, !0);
            s += 4;
            const a = r.getUint32(s, !0);
            if (s += 4,
            a === DT.JSON) {
                const l = new Uint8Array(e,wf + s,o);
                this.content = fs.decodeText(l)
            } else if (a === DT.BIN) {
                const l = wf + s;
                this.body = e.slice(l, l + o)
            }
            s += o
        }
        if (this.content === null)
            throw new Error("THREE.GLTFLoader: JSON content not found.")
    }
}
class RV {
    constructor(e, t) {
        if (!t)
            throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        this.name = wt.KHR_DRACO_MESH_COMPRESSION,
        this.json = e,
        this.dracoLoader = t,
        this.dracoLoader.preload()
    }
    decodePrimitive(e, t) {
        const i = this.json
          , r = this.dracoLoader
          , s = e.extensions[this.name].bufferView
          , o = e.extensions[this.name].attributes
          , a = {}
          , l = {}
          , c = {};
        for (const d in o) {
            const h = L_[d] || d.toLowerCase();
            a[h] = o[d]
        }
        for (const d in e.attributes) {
            const h = L_[d] || d.toLowerCase();
            if (o[d] !== void 0) {
                const p = i.accessors[e.attributes[d]]
                  , m = kd[p.componentType];
                c[h] = m.name,
                l[h] = p.normalized === !0
            }
        }
        return t.getDependency("bufferView", s).then(function(d) {
            return new Promise(function(h) {
                r.decodeDracoFile(d, function(p) {
                    for (const m in p.attributes) {
                        const y = p.attributes[m]
                          , v = l[m];
                        v !== void 0 && (y.normalized = v)
                    }
                    h(p)
                }, a, c)
            }
            )
        })
    }
}
class IV {
    constructor() {
        this.name = wt.KHR_TEXTURE_TRANSFORM
    }
    extendTexture(e, t) {
        return t.texCoord !== void 0 && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'),
        t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        e.needsUpdate = !0),
        e
    }
}
class I_ extends Cc {
    constructor(e) {
        super(),
        this.isGLTFSpecularGlossinessMaterial = !0;
        const t = ["#ifdef USE_SPECULARMAP", "	uniform sampler2D specularMap;", "#endif"].join(`
`)
          , i = ["#ifdef USE_GLOSSINESSMAP", "	uniform sampler2D glossinessMap;", "#endif"].join(`
`)
          , r = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "	vec4 texelSpecular = texture2D( specularMap, vUv );", "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "	specularFactor *= texelSpecular.rgb;", "#endif"].join(`
`)
          , s = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );", "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "	glossinessFactor *= texelGlossiness.a;", "#endif"].join(`
`)
          , o = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join(`
`)
          , a = {
            specular: {
                value: new Ie().setHex(16777215)
            },
            glossiness: {
                value: 1
            },
            specularMap: {
                value: null
            },
            glossinessMap: {
                value: null
            }
        };
        this._extraUniforms = a,
        this.onBeforeCompile = function(l) {
            for (const c in a)
                l.uniforms[c] = a[c];
            l.fragmentShader = l.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", i).replace("#include <roughnessmap_fragment>", r).replace("#include <metalnessmap_fragment>", s).replace("#include <lights_physical_fragment>", o)
        }
        ,
        Object.defineProperties(this, {
            specular: {
                get: function() {
                    return a.specular.value
                },
                set: function(l) {
                    a.specular.value = l
                }
            },
            specularMap: {
                get: function() {
                    return a.specularMap.value
                },
                set: function(l) {
                    a.specularMap.value = l,
                    l ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                }
            },
            glossiness: {
                get: function() {
                    return a.glossiness.value
                },
                set: function(l) {
                    a.glossiness.value = l
                }
            },
            glossinessMap: {
                get: function() {
                    return a.glossinessMap.value
                },
                set: function(l) {
                    a.glossinessMap.value = l,
                    l ? (this.defines.USE_GLOSSINESSMAP = "",
                    this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP,
                    delete this.defines.USE_UV)
                }
            }
        }),
        delete this.metalness,
        delete this.roughness,
        delete this.metalnessMap,
        delete this.roughnessMap,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.specularMap = e.specularMap,
        this.specular.copy(e.specular),
        this.glossinessMap = e.glossinessMap,
        this.glossiness = e.glossiness,
        delete this.metalness,
        delete this.roughness,
        delete this.metalnessMap,
        delete this.roughnessMap,
        this
    }
}
class LV {
    constructor() {
        this.name = wt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
        this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"]
    }
    getMaterialType() {
        return I_
    }
    extendParams(e, t, i) {
        const r = t.extensions[this.name];
        e.color = new Ie(1,1,1),
        e.opacity = 1;
        const s = [];
        if (Array.isArray(r.diffuseFactor)) {
            const o = r.diffuseFactor;
            e.color.fromArray(o),
            e.opacity = o[3]
        }
        if (r.diffuseTexture !== void 0 && s.push(i.assignTexture(e, "map", r.diffuseTexture, Tt)),
        e.emissive = new Ie(0,0,0),
        e.glossiness = r.glossinessFactor !== void 0 ? r.glossinessFactor : 1,
        e.specular = new Ie(1,1,1),
        Array.isArray(r.specularFactor) && e.specular.fromArray(r.specularFactor),
        r.specularGlossinessTexture !== void 0) {
            const o = r.specularGlossinessTexture;
            s.push(i.assignTexture(e, "glossinessMap", o)),
            s.push(i.assignTexture(e, "specularMap", o, Tt))
        }
        return Promise.all(s)
    }
    createMaterial(e) {
        const t = new I_(e);
        return t.fog = !0,
        t.color = e.color,
        t.map = e.map === void 0 ? null : e.map,
        t.lightMap = null,
        t.lightMapIntensity = 1,
        t.aoMap = e.aoMap === void 0 ? null : e.aoMap,
        t.aoMapIntensity = 1,
        t.emissive = e.emissive,
        t.emissiveIntensity = e.emissiveIntensity === void 0 ? 1 : e.emissiveIntensity,
        t.emissiveMap = e.emissiveMap === void 0 ? null : e.emissiveMap,
        t.bumpMap = e.bumpMap === void 0 ? null : e.bumpMap,
        t.bumpScale = 1,
        t.normalMap = e.normalMap === void 0 ? null : e.normalMap,
        t.normalMapType = so,
        e.normalScale && (t.normalScale = e.normalScale),
        t.displacementMap = null,
        t.displacementScale = 1,
        t.displacementBias = 0,
        t.specularMap = e.specularMap === void 0 ? null : e.specularMap,
        t.specular = e.specular,
        t.glossinessMap = e.glossinessMap === void 0 ? null : e.glossinessMap,
        t.glossiness = e.glossiness,
        t.alphaMap = null,
        t.envMap = e.envMap === void 0 ? null : e.envMap,
        t.envMapIntensity = 1,
        t.refractionRatio = .98,
        t
    }
}
class DV {
    constructor() {
        this.name = wt.KHR_MESH_QUANTIZATION
    }
}
class iL extends Ec {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , i = this.sampleValues
          , r = this.valueSize
          , s = e * r * 3 + r;
        for (let o = 0; o !== r; o++)
            t[o] = i[s + o];
        return t
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = a * 2
          , c = a * 3
          , d = r - t
          , h = (i - t) / d
          , p = h * h
          , m = p * h
          , y = e * c
          , v = y - c
          , x = -2 * m + 3 * p
          , _ = m - p
          , A = 1 - x
          , w = _ - p + h;
        for (let M = 0; M !== a; M++) {
            const C = o[v + M + a]
              , P = o[v + M + l] * d
              , R = o[y + M + a]
              , E = o[y + M] * d;
            s[M] = A * C + w * P + x * R + _ * E
        }
        return s
    }
}
const kV = new Qn;
class FV extends iL {
    interpolate_(e, t, i, r) {
        const s = super.interpolate_(e, t, i, r);
        return kV.fromArray(s).normalize().toArray(s),
        s
    }
}
const Ls = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
}
  , kd = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
}
  , kT = {
    9728: gn,
    9729: on,
    9984: Sd,
    9985: b0,
    9986: ju,
    9987: ps
}
  , FT = {
    33071: Xn,
    33648: nc,
    10497: na
}
  , NT = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
}
  , L_ = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
}
  , Mo = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
}
  , NV = {
    CUBICSPLINE: void 0,
    LINEAR: wl,
    STEP: rc
}
  , wx = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
};
function OV(n) {
    return n.DefaultMaterial === void 0 && (n.DefaultMaterial = new Cc({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: hs
    })),
    n.DefaultMaterial
}
function Sf(n, e, t) {
    for (const i in t.extensions)
        n[i] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {},
        e.userData.gltfExtensions[i] = t.extensions[i])
}
function Wa(n, e) {
    e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(n.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
}
function UV(n, e, t) {
    let i = !1
      , r = !1
      , s = !1;
    for (let c = 0, d = e.length; c < d; c++) {
        const h = e[c];
        if (h.POSITION !== void 0 && (i = !0),
        h.NORMAL !== void 0 && (r = !0),
        h.COLOR_0 !== void 0 && (s = !0),
        i && r && s)
            break
    }
    if (!i && !r && !s)
        return Promise.resolve(n);
    const o = []
      , a = []
      , l = [];
    for (let c = 0, d = e.length; c < d; c++) {
        const h = e[c];
        if (i) {
            const p = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : n.attributes.position;
            o.push(p)
        }
        if (r) {
            const p = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : n.attributes.normal;
            a.push(p)
        }
        if (s) {
            const p = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : n.attributes.color;
            l.push(p)
        }
    }
    return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(function(c) {
        const d = c[0]
          , h = c[1]
          , p = c[2];
        return i && (n.morphAttributes.position = d),
        r && (n.morphAttributes.normal = h),
        s && (n.morphAttributes.color = p),
        n.morphTargetsRelative = !0,
        n
    })
}
function zV(n, e) {
    if (n.updateMorphTargets(),
    e.weights !== void 0)
        for (let t = 0, i = e.weights.length; t < i; t++)
            n.morphTargetInfluences[t] = e.weights[t];
    if (e.extras && Array.isArray(e.extras.targetNames)) {
        const t = e.extras.targetNames;
        if (n.morphTargetInfluences.length === t.length) {
            n.morphTargetDictionary = {};
            for (let i = 0, r = t.length; i < r; i++)
                n.morphTargetDictionary[t[i]] = i
        } else
            console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
    }
}
function GV(n) {
    const e = n.extensions && n.extensions[wt.KHR_DRACO_MESH_COMPRESSION];
    let t;
    return e ? t = "draco:" + e.bufferView + ":" + e.indices + ":" + OT(e.attributes) : t = n.indices + ":" + OT(n.attributes) + ":" + n.mode,
    t
}
function OT(n) {
    let e = "";
    const t = Object.keys(n).sort();
    for (let i = 0, r = t.length; i < r; i++)
        e += t[i] + ":" + n[t[i]] + ";";
    return e
}
function D_(n) {
    switch (n) {
    case Int8Array:
        return 1 / 127;
    case Uint8Array:
        return 1 / 255;
    case Int16Array:
        return 1 / 32767;
    case Uint16Array:
        return 1 / 65535;
    default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
    }
}
function HV(n) {
    return n.search(/\.jpe?g($|\?)/i) > 0 || n.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png"
}
class VV {
    constructor(e={}, t={}) {
        var i, r;
        this.json = e,
        this.extensions = {},
        this.plugins = {},
        this.options = t,
        this.cache = new gV,
        this.associations = new Map,
        this.primitiveCache = {},
        this.meshCache = {
            refs: {},
            uses: {}
        },
        this.cameraCache = {
            refs: {},
            uses: {}
        },
        this.lightCache = {
            refs: {},
            uses: {}
        },
        this.sourceCache = {},
        this.textureCache = {},
        this.nodeNamesUsed = {};
        const s = typeof navigator < "u" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0
          , o = typeof navigator < "u" && ((i = navigator.userAgent) === null || i === void 0 ? void 0 : i.indexOf("Firefox")) > -1
          , a = typeof navigator < "u" && o ? (r = navigator.userAgent) === null || r === void 0 ? void 0 : r.match(/Firefox\/([0-9]+)\./)[1] : -1;
        typeof createImageBitmap > "u" || s || o && a < 98 ? this.textureLoader = new vh(this.options.manager) : this.textureLoader = new PI(this.options.manager),
        this.textureLoader.setCrossOrigin(this.options.crossOrigin),
        this.textureLoader.setRequestHeader(this.options.requestHeader),
        this.fileLoader = new Yi(this.options.manager),
        this.fileLoader.setResponseType("arraybuffer"),
        this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
    }
    setExtensions(e) {
        this.extensions = e
    }
    setPlugins(e) {
        this.plugins = e
    }
    parse(e, t) {
        const i = this
          , r = this.json
          , s = this.extensions;
        this.cache.removeAll(),
        this._invokeAll(function(o) {
            return o._markDefs && o._markDefs()
        }),
        Promise.all(this._invokeAll(function(o) {
            return o.beforeRoot && o.beforeRoot()
        })).then(function() {
            return Promise.all([i.getDependencies("scene"), i.getDependencies("animation"), i.getDependencies("camera")])
        }).then(function(o) {
            const a = {
                scene: o[0][r.scene || 0],
                scenes: o[0],
                animations: o[1],
                cameras: o[2],
                asset: r.asset,
                parser: i,
                userData: {}
            };
            Sf(s, a, r),
            Wa(a, r),
            Promise.all(i._invokeAll(function(l) {
                return l.afterRoot && l.afterRoot(a)
            })).then(function() {
                e(a)
            })
        }).catch(t)
    }
    _markDefs() {
        const e = this.json.nodes || []
          , t = this.json.skins || []
          , i = this.json.meshes || [];
        for (let r = 0, s = t.length; r < s; r++) {
            const o = t[r].joints;
            for (let a = 0, l = o.length; a < l; a++)
                e[o[a]].isBone = !0
        }
        for (let r = 0, s = e.length; r < s; r++) {
            const o = e[r];
            o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh),
            o.skin !== void 0 && (i[o.mesh].isSkinnedMesh = !0)),
            o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera)
        }
    }
    _addNodeRef(e, t) {
        t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0),
        e.refs[t]++)
    }
    _getNodeRef(e, t, i) {
        if (e.refs[t] <= 1)
            return i;
        const r = i.clone()
          , s = (o,a)=>{
            const l = this.associations.get(o);
            l != null && this.associations.set(a, l);
            for (const [c,d] of o.children.entries())
                s(d, a.children[c])
        }
        ;
        return s(i, r),
        r.name += "_instance_" + e.uses[t]++,
        r
    }
    _invokeOne(e) {
        const t = Object.values(this.plugins);
        t.push(this);
        for (let i = 0; i < t.length; i++) {
            const r = e(t[i]);
            if (r)
                return r
        }
        return null
    }
    _invokeAll(e) {
        const t = Object.values(this.plugins);
        t.unshift(this);
        const i = [];
        for (let r = 0; r < t.length; r++) {
            const s = e(t[r]);
            s && i.push(s)
        }
        return i
    }
    getDependency(e, t) {
        const i = e + ":" + t;
        let r = this.cache.get(i);
        if (!r) {
            switch (e) {
            case "scene":
                r = this.loadScene(t);
                break;
            case "node":
                r = this.loadNode(t);
                break;
            case "mesh":
                r = this._invokeOne(function(s) {
                    return s.loadMesh && s.loadMesh(t)
                });
                break;
            case "accessor":
                r = this.loadAccessor(t);
                break;
            case "bufferView":
                r = this._invokeOne(function(s) {
                    return s.loadBufferView && s.loadBufferView(t)
                });
                break;
            case "buffer":
                r = this.loadBuffer(t);
                break;
            case "material":
                r = this._invokeOne(function(s) {
                    return s.loadMaterial && s.loadMaterial(t)
                });
                break;
            case "texture":
                r = this._invokeOne(function(s) {
                    return s.loadTexture && s.loadTexture(t)
                });
                break;
            case "skin":
                r = this.loadSkin(t);
                break;
            case "animation":
                r = this._invokeOne(function(s) {
                    return s.loadAnimation && s.loadAnimation(t)
                });
                break;
            case "camera":
                r = this.loadCamera(t);
                break;
            default:
                throw new Error("Unknown type: " + e)
            }
            this.cache.add(i, r)
        }
        return r
    }
    getDependencies(e) {
        let t = this.cache.get(e);
        if (!t) {
            const i = this
              , r = this.json[e + (e === "mesh" ? "es" : "s")] || [];
            t = Promise.all(r.map(function(s, o) {
                return i.getDependency(e, o)
            })),
            this.cache.add(e, t)
        }
        return t
    }
    loadBuffer(e) {
        const t = this.json.buffers[e]
          , i = this.fileLoader;
        if (t.type && t.type !== "arraybuffer")
            throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
        if (t.uri === void 0 && e === 0)
            return Promise.resolve(this.extensions[wt.KHR_BINARY_GLTF].body);
        const r = this.options;
        return new Promise(function(s, o) {
            i.load(fs.resolveURL(t.uri, r.path), s, void 0, function() {
                o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
            })
        }
        )
    }
    loadBufferView(e) {
        const t = this.json.bufferViews[e];
        return this.getDependency("buffer", t.buffer).then(function(i) {
            const r = t.byteLength || 0
              , s = t.byteOffset || 0;
            return i.slice(s, s + r)
        })
    }
    loadAccessor(e) {
        const t = this
          , i = this.json
          , r = this.json.accessors[e];
        if (r.bufferView === void 0 && r.sparse === void 0)
            return Promise.resolve(null);
        const s = [];
        return r.bufferView !== void 0 ? s.push(this.getDependency("bufferView", r.bufferView)) : s.push(null),
        r.sparse !== void 0 && (s.push(this.getDependency("bufferView", r.sparse.indices.bufferView)),
        s.push(this.getDependency("bufferView", r.sparse.values.bufferView))),
        Promise.all(s).then(function(o) {
            const a = o[0]
              , l = NT[r.type]
              , c = kd[r.componentType]
              , d = c.BYTES_PER_ELEMENT
              , h = d * l
              , p = r.byteOffset || 0
              , m = r.bufferView !== void 0 ? i.bufferViews[r.bufferView].byteStride : void 0
              , y = r.normalized === !0;
            let v, x;
            if (m && m !== h) {
                const _ = Math.floor(p / m)
                  , A = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + _ + ":" + r.count;
                let w = t.cache.get(A);
                w || (v = new c(a,_ * m,r.count * m / d),
                w = new nh(v,m / d),
                t.cache.add(A, w)),
                x = new ia(w,l,p % m / d,y)
            } else
                a === null ? v = new c(r.count * l) : v = new c(a,p,r.count * l),
                x = new Nt(v,l,y);
            if (r.sparse !== void 0) {
                const _ = NT.SCALAR
                  , A = kd[r.sparse.indices.componentType]
                  , w = r.sparse.indices.byteOffset || 0
                  , M = r.sparse.values.byteOffset || 0
                  , C = new A(o[1],w,r.sparse.count * _)
                  , P = new c(o[2],M,r.sparse.count * l);
                a !== null && (x = new Nt(x.array.slice(),x.itemSize,x.normalized));
                for (let R = 0, E = C.length; R < E; R++) {
                    const B = C[R];
                    if (x.setX(B, P[R * l]),
                    l >= 2 && x.setY(B, P[R * l + 1]),
                    l >= 3 && x.setZ(B, P[R * l + 2]),
                    l >= 4 && x.setW(B, P[R * l + 3]),
                    l >= 5)
                        throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                }
            }
            return x
        })
    }
    loadTexture(e) {
        const t = this.json
          , i = this.options
          , s = t.textures[e].source
          , o = t.images[s];
        let a = this.textureLoader;
        if (o.uri) {
            const l = i.manager.getHandler(o.uri);
            l !== null && (a = l)
        }
        return this.loadTextureImage(e, s, a)
    }
    loadTextureImage(e, t, i) {
        const r = this
          , s = this.json
          , o = s.textures[e]
          , a = s.images[t]
          , l = (a.uri || a.bufferView) + ":" + o.sampler;
        if (this.textureCache[l])
            return this.textureCache[l];
        const c = this.loadImageSource(t, i).then(function(d) {
            d.flipY = !1,
            o.name && (d.name = o.name);
            const p = (s.samplers || {})[o.sampler] || {};
            return d.magFilter = kT[p.magFilter] || on,
            d.minFilter = kT[p.minFilter] || ps,
            d.wrapS = FT[p.wrapS] || na,
            d.wrapT = FT[p.wrapT] || na,
            r.associations.set(d, {
                textures: e
            }),
            d
        }).catch(function() {
            return null
        });
        return this.textureCache[l] = c,
        c
    }
    loadImageSource(e, t) {
        const i = this
          , r = this.json
          , s = this.options;
        if (this.sourceCache[e] !== void 0)
            return this.sourceCache[e].then(h=>h.clone());
        const o = r.images[e]
          , a = self.URL || self.webkitURL;
        let l = o.uri || ""
          , c = !1;
        if (o.bufferView !== void 0)
            l = i.getDependency("bufferView", o.bufferView).then(function(h) {
                c = !0;
                const p = new Blob([h],{
                    type: o.mimeType
                });
                return l = a.createObjectURL(p),
                l
            });
        else if (o.uri === void 0)
            throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
        const d = Promise.resolve(l).then(function(h) {
            return new Promise(function(p, m) {
                let y = p;
                t.isImageBitmapLoader === !0 && (y = function(v) {
                    const x = new tn(v);
                    x.needsUpdate = !0,
                    p(x)
                }
                ),
                t.load(fs.resolveURL(h, s.path), y, void 0, m)
            }
            )
        }).then(function(h) {
            return c === !0 && a.revokeObjectURL(l),
            h.userData.mimeType = o.mimeType || HV(o.uri),
            h
        }).catch(function(h) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", l),
            h
        });
        return this.sourceCache[e] = d,
        d
    }
    assignTexture(e, t, i, r) {
        const s = this;
        return this.getDependency("texture", i.index).then(function(o) {
            if (i.texCoord !== void 0 && i.texCoord != 0 && !(t === "aoMap" && i.texCoord == 1) && console.warn("THREE.GLTFLoader: Custom UV set " + i.texCoord + " for texture " + t + " not yet supported."),
            s.extensions[wt.KHR_TEXTURE_TRANSFORM]) {
                const a = i.extensions !== void 0 ? i.extensions[wt.KHR_TEXTURE_TRANSFORM] : void 0;
                if (a) {
                    const l = s.associations.get(o);
                    o = s.extensions[wt.KHR_TEXTURE_TRANSFORM].extendTexture(o, a),
                    s.associations.set(o, l)
                }
            }
            return r !== void 0 && (o.encoding = r),
            e[t] = o,
            o
        })
    }
    assignFinalMaterial(e) {
        const t = e.geometry;
        let i = e.material;
        const r = t.attributes.tangent === void 0
          , s = t.attributes.color !== void 0
          , o = t.attributes.normal === void 0;
        if (e.isPoints) {
            const a = "PointsMaterial:" + i.uuid;
            let l = this.cache.get(a);
            l || (l = new rh,
            Tn.prototype.copy.call(l, i),
            l.color.copy(i.color),
            l.map = i.map,
            l.sizeAttenuation = !1,
            this.cache.add(a, l)),
            i = l
        } else if (e.isLine) {
            const a = "LineBasicMaterial:" + i.uuid;
            let l = this.cache.get(a);
            l || (l = new li,
            Tn.prototype.copy.call(l, i),
            l.color.copy(i.color),
            this.cache.add(a, l)),
            i = l
        }
        if (r || s || o) {
            let a = "ClonedMaterial:" + i.uuid + ":";
            i.isGLTFSpecularGlossinessMaterial && (a += "specular-glossiness:"),
            r && (a += "derivative-tangents:"),
            s && (a += "vertex-colors:"),
            o && (a += "flat-shading:");
            let l = this.cache.get(a);
            l || (l = i.clone(),
            s && (l.vertexColors = !0),
            o && (l.flatShading = !0),
            r && (l.normalScale && (l.normalScale.y *= -1),
            l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
            this.cache.add(a, l),
            this.associations.set(l, this.associations.get(i))),
            i = l
        }
        i.aoMap && t.attributes.uv2 === void 0 && t.attributes.uv !== void 0 && t.setAttribute("uv2", t.attributes.uv),
        e.material = i
    }
    getMaterialType() {
        return Cc
    }
    loadMaterial(e) {
        const t = this
          , i = this.json
          , r = this.extensions
          , s = i.materials[e];
        let o;
        const a = {}
          , l = s.extensions || {}
          , c = [];
        if (l[wt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
            const h = r[wt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
            o = h.getMaterialType(),
            c.push(h.extendParams(a, s, t))
        } else if (l[wt.KHR_MATERIALS_UNLIT]) {
            const h = r[wt.KHR_MATERIALS_UNLIT];
            o = h.getMaterialType(),
            c.push(h.extendParams(a, s, t))
        } else {
            const h = s.pbrMetallicRoughness || {};
            if (a.color = new Ie(1,1,1),
            a.opacity = 1,
            Array.isArray(h.baseColorFactor)) {
                const p = h.baseColorFactor;
                a.color.fromArray(p),
                a.opacity = p[3]
            }
            h.baseColorTexture !== void 0 && c.push(t.assignTexture(a, "map", h.baseColorTexture, Tt)),
            a.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1,
            a.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1,
            h.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(a, "metalnessMap", h.metallicRoughnessTexture)),
            c.push(t.assignTexture(a, "roughnessMap", h.metallicRoughnessTexture))),
            o = this._invokeOne(function(p) {
                return p.getMaterialType && p.getMaterialType(e)
            }),
            c.push(Promise.all(this._invokeAll(function(p) {
                return p.extendMaterialParams && p.extendMaterialParams(e, a)
            })))
        }
        s.doubleSided === !0 && (a.side = Or);
        const d = s.alphaMode || wx.OPAQUE;
        if (d === wx.BLEND ? (a.transparent = !0,
        a.depthWrite = !1) : (a.transparent = !1,
        d === wx.MASK && (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : .5)),
        s.normalTexture !== void 0 && o !== Wi && (c.push(t.assignTexture(a, "normalMap", s.normalTexture)),
        a.normalScale = new me(1,1),
        s.normalTexture.scale !== void 0)) {
            const h = s.normalTexture.scale;
            a.normalScale.set(h, h)
        }
        return s.occlusionTexture !== void 0 && o !== Wi && (c.push(t.assignTexture(a, "aoMap", s.occlusionTexture)),
        s.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = s.occlusionTexture.strength)),
        s.emissiveFactor !== void 0 && o !== Wi && (a.emissive = new Ie().fromArray(s.emissiveFactor)),
        s.emissiveTexture !== void 0 && o !== Wi && c.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, Tt)),
        Promise.all(c).then(function() {
            let h;
            return o === I_ ? h = r[wt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : h = new o(a),
            s.name && (h.name = s.name),
            Wa(h, s),
            t.associations.set(h, {
                materials: e
            }),
            s.extensions && Sf(r, h, s),
            h
        })
    }
    createUniqueName(e) {
        const t = Bt.sanitizeNodeName(e || "");
        let i = t;
        for (let r = 1; this.nodeNamesUsed[i]; ++r)
            i = t + "_" + r;
        return this.nodeNamesUsed[i] = !0,
        i
    }
    loadGeometries(e) {
        const t = this
          , i = this.extensions
          , r = this.primitiveCache;
        function s(a) {
            return i[wt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function(l) {
                return UT(l, a, t)
            })
        }
        const o = [];
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a]
              , d = GV(c)
              , h = r[d];
            if (h)
                o.push(h.promise);
            else {
                let p;
                c.extensions && c.extensions[wt.KHR_DRACO_MESH_COMPRESSION] ? p = s(c) : p = UT(new ft, c, t),
                r[d] = {
                    primitive: c,
                    promise: p
                },
                o.push(p)
            }
        }
        return Promise.all(o)
    }
    loadMesh(e) {
        const t = this
          , i = this.json
          , r = this.extensions
          , s = i.meshes[e]
          , o = s.primitives
          , a = [];
        for (let l = 0, c = o.length; l < c; l++) {
            const d = o[l].material === void 0 ? OV(this.cache) : this.getDependency("material", o[l].material);
            a.push(d)
        }
        return a.push(t.loadGeometries(o)),
        Promise.all(a).then(function(l) {
            const c = l.slice(0, l.length - 1)
              , d = l[l.length - 1]
              , h = [];
            for (let m = 0, y = d.length; m < y; m++) {
                const v = d[m]
                  , x = o[m];
                let _;
                const A = c[m];
                if (x.mode === Ls.TRIANGLES || x.mode === Ls.TRIANGLE_STRIP || x.mode === Ls.TRIANGLE_FAN || x.mode === void 0)
                    _ = s.isSkinnedMesh === !0 ? new Dw(v,A) : new Ln(v,A),
                    _.isSkinnedMesh === !0 && !_.geometry.attributes.skinWeight.normalized && _.normalizeSkinWeights(),
                    x.mode === Ls.TRIANGLE_STRIP ? _.geometry = zT(_.geometry, IR) : x.mode === Ls.TRIANGLE_FAN && (_.geometry = zT(_.geometry, xw));
                else if (x.mode === Ls.LINES)
                    _ = new Jr(v,A);
                else if (x.mode === Ls.LINE_STRIP)
                    _ = new eo(v,A);
                else if (x.mode === Ls.LINE_LOOP)
                    _ = new kw(v,A);
                else if (x.mode === Ls.POINTS)
                    _ = new Fw(v,A);
                else
                    throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + x.mode);
                Object.keys(_.geometry.morphAttributes).length > 0 && zV(_, s),
                _.name = t.createUniqueName(s.name || "mesh_" + e),
                Wa(_, s),
                x.extensions && Sf(r, _, x),
                t.assignFinalMaterial(_),
                h.push(_)
            }
            for (let m = 0, y = h.length; m < y; m++)
                t.associations.set(h[m], {
                    meshes: e,
                    primitives: m
                });
            if (h.length === 1)
                return h[0];
            const p = new Hs;
            t.associations.set(p, {
                meshes: e
            });
            for (let m = 0, y = h.length; m < y; m++)
                p.add(h[m]);
            return p
        })
    }
    loadCamera(e) {
        let t;
        const i = this.json.cameras[e]
          , r = i[i.type];
        if (!r) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return
        }
        return i.type === "perspective" ? t = new Wt(Aw.radToDeg(r.yfov),r.aspectRatio || 1,r.znear || 1,r.zfar || 2e6) : i.type === "orthographic" && (t = new Vr(-r.xmag,r.xmag,r.ymag,-r.ymag,r.znear,r.zfar)),
        i.name && (t.name = this.createUniqueName(i.name)),
        Wa(t, i),
        Promise.resolve(t)
    }
    loadSkin(e) {
        const t = this.json.skins[e]
          , i = {
            joints: t.joints
        };
        return t.inverseBindMatrices === void 0 ? Promise.resolve(i) : this.getDependency("accessor", t.inverseBindMatrices).then(function(r) {
            return i.inverseBindMatrices = r,
            i
        })
    }
    loadAnimation(e) {
        const i = this.json.animations[e]
          , r = []
          , s = []
          , o = []
          , a = []
          , l = [];
        for (let c = 0, d = i.channels.length; c < d; c++) {
            const h = i.channels[c]
              , p = i.samplers[h.sampler]
              , m = h.target
              , y = m.node
              , v = i.parameters !== void 0 ? i.parameters[p.input] : p.input
              , x = i.parameters !== void 0 ? i.parameters[p.output] : p.output;
            r.push(this.getDependency("node", y)),
            s.push(this.getDependency("accessor", v)),
            o.push(this.getDependency("accessor", x)),
            a.push(p),
            l.push(m)
        }
        return Promise.all([Promise.all(r), Promise.all(s), Promise.all(o), Promise.all(a), Promise.all(l)]).then(function(c) {
            const d = c[0]
              , h = c[1]
              , p = c[2]
              , m = c[3]
              , y = c[4]
              , v = [];
            for (let _ = 0, A = d.length; _ < A; _++) {
                const w = d[_]
                  , M = h[_]
                  , C = p[_]
                  , P = m[_]
                  , R = y[_];
                if (w === void 0)
                    continue;
                w.updateMatrix();
                let E;
                switch (Mo[R.path]) {
                case Mo.weights:
                    E = lc;
                    break;
                case Mo.rotation:
                    E = ra;
                    break;
                case Mo.position:
                case Mo.scale:
                default:
                    E = uc;
                    break
                }
                const B = w.name ? w.name : w.uuid
                  , I = P.interpolation !== void 0 ? NV[P.interpolation] : wl
                  , z = [];
                Mo[R.path] === Mo.weights ? w.traverse(function(W) {
                    W.morphTargetInfluences && z.push(W.name ? W.name : W.uuid)
                }) : z.push(B);
                let q = C.array;
                if (C.normalized) {
                    const W = D_(q.constructor)
                      , G = new Float32Array(q.length);
                    for (let K = 0, ne = q.length; K < ne; K++)
                        G[K] = q[K] * W;
                    q = G
                }
                for (let W = 0, G = z.length; W < G; W++) {
                    const K = new E(z[W] + "." + Mo[R.path],M.array,q,I);
                    P.interpolation === "CUBICSPLINE" && (K.createInterpolant = function(oe) {
                        const F = this instanceof ra ? FV : iL;
                        return new F(this.times,this.values,this.getValueSize() / 3,oe)
                    }
                    ,
                    K.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0),
                    v.push(K)
                }
            }
            const x = i.name ? i.name : "animation_" + e;
            return new cc(x,void 0,v)
        })
    }
    createNodeMesh(e) {
        const t = this.json
          , i = this
          , r = t.nodes[e];
        return r.mesh === void 0 ? null : i.getDependency("mesh", r.mesh).then(function(s) {
            const o = i._getNodeRef(i.meshCache, r.mesh, s);
            return r.weights !== void 0 && o.traverse(function(a) {
                if (a.isMesh)
                    for (let l = 0, c = r.weights.length; l < c; l++)
                        a.morphTargetInfluences[l] = r.weights[l]
            }),
            o
        })
    }
    loadNode(e) {
        const t = this.json
          , i = this.extensions
          , r = this
          , s = t.nodes[e]
          , o = s.name ? r.createUniqueName(s.name) : "";
        return function() {
            const a = []
              , l = r._invokeOne(function(c) {
                return c.createNodeMesh && c.createNodeMesh(e)
            });
            return l && a.push(l),
            s.camera !== void 0 && a.push(r.getDependency("camera", s.camera).then(function(c) {
                return r._getNodeRef(r.cameraCache, s.camera, c)
            })),
            r._invokeAll(function(c) {
                return c.createNodeAttachment && c.createNodeAttachment(e)
            }).forEach(function(c) {
                a.push(c)
            }),
            Promise.all(a)
        }().then(function(a) {
            let l;
            if (s.isBone === !0 ? l = new I0 : a.length > 1 ? l = new Hs : a.length === 1 ? l = a[0] : l = new Rt,
            l !== a[0])
                for (let c = 0, d = a.length; c < d; c++)
                    l.add(a[c]);
            if (s.name && (l.userData.name = s.name,
            l.name = o),
            Wa(l, s),
            s.extensions && Sf(i, l, s),
            s.matrix !== void 0) {
                const c = new ot;
                c.fromArray(s.matrix),
                l.applyMatrix4(c)
            } else
                s.translation !== void 0 && l.position.fromArray(s.translation),
                s.rotation !== void 0 && l.quaternion.fromArray(s.rotation),
                s.scale !== void 0 && l.scale.fromArray(s.scale);
            return r.associations.has(l) || r.associations.set(l, {}),
            r.associations.get(l).nodes = e,
            l
        })
    }
    loadScene(e) {
        const t = this.json
          , i = this.extensions
          , r = this.json.scenes[e]
          , s = this
          , o = new Hs;
        r.name && (o.name = s.createUniqueName(r.name)),
        Wa(o, r),
        r.extensions && Sf(i, o, r);
        const a = r.nodes || []
          , l = [];
        for (let c = 0, d = a.length; c < d; c++)
            l.push(rL(a[c], o, t, s));
        return Promise.all(l).then(function() {
            const c = d=>{
                const h = new Map;
                for (const [p,m] of s.associations)
                    (p instanceof Tn || p instanceof tn) && h.set(p, m);
                return d.traverse(p=>{
                    const m = s.associations.get(p);
                    m != null && h.set(p, m)
                }
                ),
                h
            }
            ;
            return s.associations = c(o),
            o
        })
    }
}
function rL(n, e, t, i) {
    const r = t.nodes[n];
    return i.getDependency("node", n).then(function(s) {
        if (r.skin === void 0)
            return s;
        let o;
        return i.getDependency("skin", r.skin).then(function(a) {
            o = a;
            const l = [];
            for (let c = 0, d = o.joints.length; c < d; c++)
                l.push(i.getDependency("node", o.joints[c]));
            return Promise.all(l)
        }).then(function(a) {
            return s.traverse(function(l) {
                if (!l.isMesh)
                    return;
                const c = []
                  , d = [];
                for (let h = 0, p = a.length; h < p; h++) {
                    const m = a[h];
                    if (m) {
                        c.push(m);
                        const y = new ot;
                        o.inverseBindMatrices !== void 0 && y.fromArray(o.inverseBindMatrices.array, h * 16),
                        d.push(y)
                    } else
                        console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', o.joints[h])
                }
                l.bind(new ih(c,d), l.matrixWorld)
            }),
            s
        })
    }).then(function(s) {
        e.add(s);
        const o = [];
        if (r.children) {
            const a = r.children;
            for (let l = 0, c = a.length; l < c; l++) {
                const d = a[l];
                o.push(rL(d, s, t, i))
            }
        }
        return Promise.all(o)
    })
}
function WV(n, e, t) {
    const i = e.attributes
      , r = new ha;
    if (i.POSITION !== void 0) {
        const a = t.json.accessors[i.POSITION]
          , l = a.min
          , c = a.max;
        if (l !== void 0 && c !== void 0) {
            if (r.set(new D(l[0],l[1],l[2]), new D(c[0],c[1],c[2])),
            a.normalized) {
                const d = D_(kd[a.componentType]);
                r.min.multiplyScalar(d),
                r.max.multiplyScalar(d)
            }
        } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return
        }
    } else
        return;
    const s = e.targets;
    if (s !== void 0) {
        const a = new D
          , l = new D;
        for (let c = 0, d = s.length; c < d; c++) {
            const h = s[c];
            if (h.POSITION !== void 0) {
                const p = t.json.accessors[h.POSITION]
                  , m = p.min
                  , y = p.max;
                if (m !== void 0 && y !== void 0) {
                    if (l.setX(Math.max(Math.abs(m[0]), Math.abs(y[0]))),
                    l.setY(Math.max(Math.abs(m[1]), Math.abs(y[1]))),
                    l.setZ(Math.max(Math.abs(m[2]), Math.abs(y[2]))),
                    p.normalized) {
                        const v = D_(kd[p.componentType]);
                        l.multiplyScalar(v)
                    }
                    a.max(l)
                } else
                    console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
            }
        }
        r.expandByVector(a)
    }
    n.boundingBox = r;
    const o = new pa;
    r.getCenter(o.center),
    o.radius = r.min.distanceTo(r.max) / 2,
    n.boundingSphere = o
}
function UT(n, e, t) {
    const i = e.attributes
      , r = [];
    function s(o, a) {
        return t.getDependency("accessor", o).then(function(l) {
            n.setAttribute(a, l)
        })
    }
    for (const o in i) {
        const a = L_[o] || o.toLowerCase();
        a in n.attributes || r.push(s(i[o], a))
    }
    if (e.indices !== void 0 && !n.index) {
        const o = t.getDependency("accessor", e.indices).then(function(a) {
            n.setIndex(a)
        });
        r.push(o)
    }
    return Wa(n, e),
    WV(n, e, t),
    Promise.all(r).then(function() {
        return e.targets !== void 0 ? UV(n, e.targets, t) : n
    })
}
function zT(n, e) {
    let t = n.getIndex();
    if (t === null) {
        const o = []
          , a = n.getAttribute("position");
        if (a !== void 0) {
            for (let l = 0; l < a.count; l++)
                o.push(l);
            n.setIndex(o),
            t = n.getIndex()
        } else
            return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
            n
    }
    const i = t.count - 2
      , r = [];
    if (e === xw)
        for (let o = 1; o <= i; o++)
            r.push(t.getX(0)),
            r.push(t.getX(o)),
            r.push(t.getX(o + 1));
    else
        for (let o = 0; o < i; o++)
            o % 2 === 0 ? (r.push(t.getX(o)),
            r.push(t.getX(o + 1)),
            r.push(t.getX(o + 2))) : (r.push(t.getX(o + 2)),
            r.push(t.getX(o + 1)),
            r.push(t.getX(o)));
    r.length / 3 !== i && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const s = n.clone();
    return s.setIndex(r),
    s
}
class jV extends ft {
    constructor(e, t, i, r) {
        super();
        const s = []
          , o = []
          , a = []
          , l = new D
          , c = new ot;
        c.makeRotationFromEuler(i),
        c.setPosition(t);
        const d = new ot;
        d.copy(c).invert(),
        h(),
        this.setAttribute("position", new je(s,3)),
        this.setAttribute("normal", new je(o,3)),
        this.setAttribute("uv", new je(a,2));
        function h() {
            let v, x = [];
            const _ = new D
              , A = new D;
            if (e.geometry.isGeometry === !0) {
                console.error("THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead.");
                return
            }
            const w = e.geometry
              , M = w.attributes.position
              , C = w.attributes.normal;
            if (w.index !== null) {
                const P = w.index;
                for (v = 0; v < P.count; v++)
                    _.fromBufferAttribute(M, P.getX(v)),
                    A.fromBufferAttribute(C, P.getX(v)),
                    p(x, _, A)
            } else
                for (v = 0; v < M.count; v++)
                    _.fromBufferAttribute(M, v),
                    A.fromBufferAttribute(C, v),
                    p(x, _, A);
            for (x = m(x, l.set(1, 0, 0)),
            x = m(x, l.set(-1, 0, 0)),
            x = m(x, l.set(0, 1, 0)),
            x = m(x, l.set(0, -1, 0)),
            x = m(x, l.set(0, 0, 1)),
            x = m(x, l.set(0, 0, -1)),
            v = 0; v < x.length; v++) {
                const P = x[v];
                a.push(.5 + P.position.x / r.x, .5 + P.position.y / r.y),
                P.position.applyMatrix4(c),
                s.push(P.position.x, P.position.y, P.position.z),
                o.push(P.normal.x, P.normal.y, P.normal.z)
            }
        }
        function p(v, x, _) {
            x.applyMatrix4(e.matrixWorld),
            x.applyMatrix4(d),
            _.transformDirection(e.matrixWorld),
            v.push(new GT(x.clone(),_.clone()))
        }
        function m(v, x) {
            const _ = []
              , A = .5 * Math.abs(r.dot(x));
            for (let w = 0; w < v.length; w += 3) {
                let M, C, P, R = 0, E, B, I, z;
                const q = v[w + 0].position.dot(x) - A
                  , W = v[w + 1].position.dot(x) - A
                  , G = v[w + 2].position.dot(x) - A;
                switch (M = q > 0,
                C = W > 0,
                P = G > 0,
                R = (M ? 1 : 0) + (C ? 1 : 0) + (P ? 1 : 0),
                R) {
                case 0:
                    {
                        _.push(v[w]),
                        _.push(v[w + 1]),
                        _.push(v[w + 2]);
                        break
                    }
                case 1:
                    {
                        if (M && (E = v[w + 1],
                        B = v[w + 2],
                        I = y(v[w], E, x, A),
                        z = y(v[w], B, x, A)),
                        C) {
                            E = v[w],
                            B = v[w + 2],
                            I = y(v[w + 1], E, x, A),
                            z = y(v[w + 1], B, x, A),
                            _.push(I),
                            _.push(B.clone()),
                            _.push(E.clone()),
                            _.push(B.clone()),
                            _.push(I.clone()),
                            _.push(z);
                            break
                        }
                        P && (E = v[w],
                        B = v[w + 1],
                        I = y(v[w + 2], E, x, A),
                        z = y(v[w + 2], B, x, A)),
                        _.push(E.clone()),
                        _.push(B.clone()),
                        _.push(I),
                        _.push(z),
                        _.push(I.clone()),
                        _.push(B.clone());
                        break
                    }
                case 2:
                    {
                        M || (E = v[w].clone(),
                        B = y(E, v[w + 1], x, A),
                        I = y(E, v[w + 2], x, A),
                        _.push(E),
                        _.push(B),
                        _.push(I)),
                        C || (E = v[w + 1].clone(),
                        B = y(E, v[w + 2], x, A),
                        I = y(E, v[w], x, A),
                        _.push(E),
                        _.push(B),
                        _.push(I)),
                        P || (E = v[w + 2].clone(),
                        B = y(E, v[w], x, A),
                        I = y(E, v[w + 1], x, A),
                        _.push(E),
                        _.push(B),
                        _.push(I));
                        break
                    }
                }
            }
            return _
        }
        function y(v, x, _, A) {
            const w = v.position.dot(_) - A
              , M = x.position.dot(_) - A
              , C = w / (w - M);
            return new GT(new D(v.position.x + C * (x.position.x - v.position.x),v.position.y + C * (x.position.y - v.position.y),v.position.z + C * (x.position.z - v.position.z)),new D(v.normal.x + C * (x.normal.x - v.normal.x),v.normal.y + C * (x.normal.y - v.normal.y),v.normal.z + C * (x.normal.z - v.normal.z)))
        }
    }
}
class GT {
    constructor(e, t) {
        this.position = e,
        this.normal = t
    }
    clone() {
        return new this.constructor(this.position.clone(),this.normal.clone())
    }
}
const Sx = new WeakMap;
class JV extends Ai {
    constructor(e) {
        super(e),
        this.decoderPath = "",
        this.decoderConfig = {},
        this.decoderBinary = null,
        this.decoderPending = null,
        this.workerLimit = 4,
        this.workerPool = [],
        this.workerNextTaskID = 1,
        this.workerSourceURL = "",
        this.defaultAttributeIDs = {
            position: "POSITION",
            normal: "NORMAL",
            color: "COLOR",
            uv: "TEX_COORD"
        },
        this.defaultAttributeTypes = {
            position: "Float32Array",
            normal: "Float32Array",
            color: "Float32Array",
            uv: "Float32Array"
        }
    }
    setDecoderPath(e) {
        return this.decoderPath = e,
        this
    }
    setDecoderConfig(e) {
        return this.decoderConfig = e,
        this
    }
    setWorkerLimit(e) {
        return this.workerLimit = e,
        this
    }
    load(e, t, i, r) {
        const s = new Yi(this.manager);
        s.setPath(this.path),
        s.setResponseType("arraybuffer"),
        s.setRequestHeader(this.requestHeader),
        s.setWithCredentials(this.withCredentials),
        s.load(e, o=>{
            const a = {
                attributeIDs: this.defaultAttributeIDs,
                attributeTypes: this.defaultAttributeTypes,
                useUniqueIDs: !1
            };
            this.decodeGeometry(o, a).then(t).catch(r)
        }
        , i, r)
    }
    decodeDracoFile(e, t, i, r) {
        const s = {
            attributeIDs: i || this.defaultAttributeIDs,
            attributeTypes: r || this.defaultAttributeTypes,
            useUniqueIDs: !!i
        };
        this.decodeGeometry(e, s).then(t)
    }
    decodeGeometry(e, t) {
        for (const l in t.attributeTypes) {
            const c = t.attributeTypes[l];
            c.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[l] = c.name)
        }
        const i = JSON.stringify(t);
        if (Sx.has(e)) {
            const l = Sx.get(e);
            if (l.key === i)
                return l.promise;
            if (e.byteLength === 0)
                throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
        }
        let r;
        const s = this.workerNextTaskID++
          , o = e.byteLength
          , a = this._getWorker(s, o).then(l=>(r = l,
        new Promise((c,d)=>{
            r._callbacks[s] = {
                resolve: c,
                reject: d
            },
            r.postMessage({
                type: "decode",
                id: s,
                taskConfig: t,
                buffer: e
            }, [e])
        }
        ))).then(l=>this._createGeometry(l.geometry));
        return a.catch(()=>!0).then(()=>{
            r && s && this._releaseTask(r, s)
        }
        ),
        Sx.set(e, {
            key: i,
            promise: a
        }),
        a
    }
    _createGeometry(e) {
        const t = new ft;
        e.index && t.setIndex(new Nt(e.index.array,1));
        for (let i = 0; i < e.attributes.length; i++) {
            const r = e.attributes[i]
              , s = r.name
              , o = r.array
              , a = r.itemSize;
            t.setAttribute(s, new Nt(o,a))
        }
        return t
    }
    _loadLibrary(e, t) {
        const i = new Yi(this.manager);
        return i.setPath(this.decoderPath),
        i.setResponseType(t),
        i.setWithCredentials(this.withCredentials),
        new Promise((r,s)=>{
            i.load(e, r, void 0, s)
        }
        )
    }
    preload() {
        return this._initDecoder(),
        this
    }
    _initDecoder() {
        if (this.decoderPending)
            return this.decoderPending;
        const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js"
          , t = [];
        return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
        t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
        this.decoderPending = Promise.all(t).then(i=>{
            const r = i[0];
            e || (this.decoderConfig.wasmBinary = i[1]);
            const s = XV.toString()
              , o = ["/* draco decoder */", r, "", "/* worker */", s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))].join(`
`);
            this.workerSourceURL = URL.createObjectURL(new Blob([o]))
        }
        ),
        this.decoderPending
    }
    _getWorker(e, t) {
        return this._initDecoder().then(()=>{
            if (this.workerPool.length < this.workerLimit) {
                const r = new Worker(this.workerSourceURL);
                r._callbacks = {},
                r._taskCosts = {},
                r._taskLoad = 0,
                r.postMessage({
                    type: "init",
                    decoderConfig: this.decoderConfig
                }),
                r.onmessage = function(s) {
                    const o = s.data;
                    switch (o.type) {
                    case "decode":
                        r._callbacks[o.id].resolve(o);
                        break;
                    case "error":
                        r._callbacks[o.id].reject(o);
                        break;
                    default:
                        console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"')
                    }
                }
                ,
                this.workerPool.push(r)
            } else
                this.workerPool.sort(function(r, s) {
                    return r._taskLoad > s._taskLoad ? -1 : 1
                });
            const i = this.workerPool[this.workerPool.length - 1];
            return i._taskCosts[e] = t,
            i._taskLoad += t,
            i
        }
        )
    }
    _releaseTask(e, t) {
        e._taskLoad -= e._taskCosts[t],
        delete e._callbacks[t],
        delete e._taskCosts[t]
    }
    debug() {
        console.log("Task load: ", this.workerPool.map(e=>e._taskLoad))
    }
    dispose() {
        for (let e = 0; e < this.workerPool.length; ++e)
            this.workerPool[e].terminate();
        return this.workerPool.length = 0,
        this
    }
}
function XV() {
    let n, e;
    onmessage = function(o) {
        const a = o.data;
        switch (a.type) {
        case "init":
            n = a.decoderConfig,
            e = new Promise(function(d) {
                n.onModuleLoaded = function(h) {
                    d({
                        draco: h
                    })
                }
                ,
                DracoDecoderModule(n)
            }
            );
            break;
        case "decode":
            const l = a.buffer
              , c = a.taskConfig;
            e.then(d=>{
                const h = d.draco
                  , p = new h.Decoder
                  , m = new h.DecoderBuffer;
                m.Init(new Int8Array(l), l.byteLength);
                try {
                    const y = t(h, p, m, c)
                      , v = y.attributes.map(x=>x.array.buffer);
                    y.index && v.push(y.index.array.buffer),
                    self.postMessage({
                        type: "decode",
                        id: a.id,
                        geometry: y
                    }, v)
                } catch (y) {
                    console.error(y),
                    self.postMessage({
                        type: "error",
                        id: a.id,
                        error: y.message
                    })
                } finally {
                    h.destroy(m),
                    h.destroy(p)
                }
            }
            );
            break
        }
    }
    ;
    function t(o, a, l, c) {
        const d = c.attributeIDs
          , h = c.attributeTypes;
        let p, m;
        const y = a.GetEncodedGeometryType(l);
        if (y === o.TRIANGULAR_MESH)
            p = new o.Mesh,
            m = a.DecodeBufferToMesh(l, p);
        else if (y === o.POINT_CLOUD)
            p = new o.PointCloud,
            m = a.DecodeBufferToPointCloud(l, p);
        else
            throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
        if (!m.ok() || p.ptr === 0)
            throw new Error("THREE.DRACOLoader: Decoding failed: " + m.error_msg());
        const v = {
            index: null,
            attributes: []
        };
        for (const x in d) {
            const _ = self[h[x]];
            let A, w;
            if (c.useUniqueIDs)
                w = d[x],
                A = a.GetAttributeByUniqueId(p, w);
            else {
                if (w = a.GetAttributeId(p, o[d[x]]),
                w === -1)
                    continue;
                A = a.GetAttribute(p, w)
            }
            v.attributes.push(r(o, a, p, x, _, A))
        }
        return y === o.TRIANGULAR_MESH && (v.index = i(o, a, p)),
        o.destroy(p),
        v
    }
    function i(o, a, l) {
        const d = l.num_faces() * 3
          , h = d * 4
          , p = o._malloc(h);
        a.GetTrianglesUInt32Array(l, h, p);
        const m = new Uint32Array(o.HEAPF32.buffer,p,d).slice();
        return o._free(p),
        {
            array: m,
            itemSize: 1
        }
    }
    function r(o, a, l, c, d, h) {
        const p = h.num_components()
          , y = l.num_points() * p
          , v = y * d.BYTES_PER_ELEMENT
          , x = s(o, d)
          , _ = o._malloc(v);
        a.GetAttributeDataArrayForAllPoints(l, h, x, v, _);
        const A = new d(o.HEAPF32.buffer,_,y).slice();
        return o._free(_),
        {
            name: c,
            array: A,
            itemSize: p
        }
    }
    function s(o, a) {
        switch (a) {
        case Float32Array:
            return o.DT_FLOAT32;
        case Int8Array:
            return o.DT_INT8;
        case Int16Array:
            return o.DT_INT16;
        case Int32Array:
            return o.DT_INT32;
        case Uint8Array:
            return o.DT_UINT8;
        case Uint16Array:
            return o.DT_UINT16;
        case Uint32Array:
            return o.DT_UINT32
        }
    }
}
let Em;
const Mx = ()=>{
    if (Em)
        return Em;
    const n = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB"
      , e = "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB"
      , t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11])
      , i = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]);
    if (typeof WebAssembly != "object")
        return {
            supported: !1
        };
    let r = n;
    WebAssembly.validate(t) && (r = e);
    let s;
    const o = WebAssembly.instantiate(a(r), {}).then(h=>{
        s = h.instance,
        s.exports.__wasm_call_ctors()
    }
    );
    function a(h) {
        const p = new Uint8Array(h.length);
        for (let y = 0; y < h.length; ++y) {
            const v = h.charCodeAt(y);
            p[y] = v > 96 ? v - 71 : v > 64 ? v - 65 : v > 47 ? v + 4 : v > 46 ? 63 : 62
        }
        let m = 0;
        for (let y = 0; y < h.length; ++y)
            p[m++] = p[y] < 60 ? i[p[y]] : (p[y] - 60) * 64 + p[++y];
        return p.buffer.slice(0, m)
    }
    function l(h, p, m, y, v, x) {
        const _ = s.exports.sbrk
          , A = m + 3 & -4
          , w = _(A * y)
          , M = _(v.length)
          , C = new Uint8Array(s.exports.memory.buffer);
        C.set(v, M);
        const P = h(w, m, y, M, v.length);
        if (P === 0 && x && x(w, A, y),
        p.set(C.subarray(w, w + m * y)),
        _(w - _(0)),
        P !== 0)
            throw new Error(`Malformed buffer data: ${P}`)
    }
    const c = {
        0: "",
        1: "meshopt_decodeFilterOct",
        2: "meshopt_decodeFilterQuat",
        3: "meshopt_decodeFilterExp",
        NONE: "",
        OCTAHEDRAL: "meshopt_decodeFilterOct",
        QUATERNION: "meshopt_decodeFilterQuat",
        EXPONENTIAL: "meshopt_decodeFilterExp"
    }
      , d = {
        0: "meshopt_decodeVertexBuffer",
        1: "meshopt_decodeIndexBuffer",
        2: "meshopt_decodeIndexSequence",
        ATTRIBUTES: "meshopt_decodeVertexBuffer",
        TRIANGLES: "meshopt_decodeIndexBuffer",
        INDICES: "meshopt_decodeIndexSequence"
    };
    return Em = {
        ready: o,
        supported: !0,
        decodeVertexBuffer(h, p, m, y, v) {
            l(s.exports.meshopt_decodeVertexBuffer, h, p, m, y, s.exports[c[v]])
        },
        decodeIndexBuffer(h, p, m, y) {
            l(s.exports.meshopt_decodeIndexBuffer, h, p, m, y)
        },
        decodeIndexSequence(h, p, m, y) {
            l(s.exports.meshopt_decodeIndexSequence, h, p, m, y)
        },
        decodeGltfBuffer(h, p, m, y, v, x) {
            l(s.exports[d[v]], h, p, m, y, s.exports[c[x]])
        }
    },
    Em
}
  , HT = n=>n === Object(n) && !Array.isArray(n) && typeof n != "function";
function lS(n, e) {
    const t = Hi(r=>r.gl)
      , i = va(vh, HT(n) ? Object.values(n) : n);
    if (U.useLayoutEffect(()=>{
        e == null || e(i)
    }
    , [e]),
    U.useEffect(()=>{
        (Array.isArray(i) ? i : [i]).forEach(t.initTexture)
    }
    , [t, i]),
    HT(n)) {
        const r = Object.keys(n)
          , s = {};
        return r.forEach(o=>Object.assign(s, {
            [o]: i[r.indexOf(o)]
        })),
        s
    } else
        return i
}
lS.preload = n=>va.preload(vh, n);
lS.clear = n=>va.clear(vh, n);
function YV(n) {
    return Array.isArray(n)
}
function bx(n=[0, 0, 0]) {
    return YV(n) ? n : n instanceof D || n instanceof Pl ? [n.x, n.y, n.z] : [n, n, n]
}
function KV({debug: n, mesh: e, children: t, position: i, rotation: r, scale: s, ...o}) {
    const a = U.useRef(null)
      , l = U.useRef(null);
    return U.useLayoutEffect(()=>{
        const c = (e == null ? void 0 : e.current) || a.current.parent
          , d = a.current;
        if (!(c instanceof Ln))
            throw new Error('Decal must have a Mesh as parent or specify its "mesh" prop');
        const h = {
            position: new D,
            rotation: new Pl,
            scale: new D(1,1,1)
        };
        if (c) {
            Uo(h, {
                position: i,
                scale: s
            });
            const p = c.matrixWorld.clone();
            if (c.matrixWorld.identity(),
            !r || typeof r == "number") {
                const m = new Rt;
                m.position.copy(h.position),
                m.lookAt(c.position),
                typeof r == "number" && m.rotateZ(r),
                Uo(h, {
                    rotation: m.rotation
                })
            } else
                Uo(h, {
                    rotation: r
                });
            return d.geometry = new jV(c,h.position,h.rotation,h.scale),
            l.current && Uo(l.current, h),
            c.matrixWorld = p,
            ()=>{
                d.geometry.dispose()
            }
        }
    }
    , [e, ...bx(i), ...bx(s), ...bx(r)]),
    U.createElement("mesh", {
        ref: a
    }, t || U.createElement("meshStandardMaterial", Mr({
        transparent: !0,
        polygonOffset: !0,
        polygonOffsetFactor: -10
    }, o)), n && U.createElement("mesh", {
        ref: l
    }, U.createElement("boxGeometry", null), U.createElement("meshNormalMaterial", {
        wireframe: !0
    }), U.createElement("axesHelper", null)))
}
let Tm = null;
function sL(n, e, t) {
    return i=>{
        t && t(i),
        n && (Tm || (Tm = new JV),
        Tm.setDecoderPath(typeof n == "string" ? n : "https://www.gstatic.com/draco/versioned/decoders/1.5.5/"),
        i.setDRACOLoader(Tm)),
        e && i.setMeshoptDecoder(typeof Mx == "function" ? Mx() : Mx)
    }
}
function U0(n, e=!0, t=!0, i) {
    return va(aS, n, sL(e, t, i))
}
U0.preload = (n,e=!0,t=!0,i)=>va.preload(aS, n, sL(e, t, i));
U0.clear = n=>va.clear(aS, n);
const uS = U.forwardRef(({makeDefault: n, camera: e, regress: t, domElement: i, enableDamping: r=!0, onChange: s, onStart: o, onEnd: a, ...l},c)=>{
    const d = Hi(C=>C.invalidate)
      , h = Hi(C=>C.camera)
      , p = Hi(C=>C.gl)
      , m = Hi(C=>C.events)
      , y = Hi(C=>C.setEvents)
      , v = Hi(C=>C.set)
      , x = Hi(C=>C.get)
      , _ = Hi(C=>C.performance)
      , A = e || h
      , w = i || m.connected || p.domElement
      , M = U.useMemo(()=>new mV(A), [A]);
    return Tc(()=>{
        M.enabled && M.update()
    }
    , -1),
    U.useEffect(()=>(M.connect(w),
    ()=>void M.dispose()), [w, t, M, d]),
    U.useEffect(()=>{
        const C = E=>{
            d(),
            t && _.regress(),
            s && s(E)
        }
          , P = E=>{
            o && o(E)
        }
          , R = E=>{
            a && a(E)
        }
        ;
        return M.addEventListener("change", C),
        M.addEventListener("start", P),
        M.addEventListener("end", R),
        ()=>{
            M.removeEventListener("start", P),
            M.removeEventListener("end", R),
            M.removeEventListener("change", C)
        }
    }
    , [s, o, a, M, d, y]),
    U.useEffect(()=>{
        if (n) {
            const C = x().controls;
            return v({
                controls: M
            }),
            ()=>v({
                controls: C
            })
        }
    }
    , [n, M]),
    U.createElement("primitive", Mr({
        ref: c,
        object: M,
        enableDamping: r
    }, l))
}
);
class QV extends rh {
    constructor(e) {
        super(e),
        this.onBeforeCompile = (t,i)=>{
            const {isWebGL2: r} = i.capabilities;
            t.fragmentShader = t.fragmentShader.replace("#include <output_fragment>", `
        ${r ? "#include <output_fragment>" : `#extension GL_OES_standard_derivatives : enable
#include <output_fragment>`}
      vec2 cxy = 2.0 * gl_PointCoord - 1.0;
      float r = dot(cxy, cxy);
      float delta = fwidth(r);     
      float mask = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);
      gl_FragColor = vec4(gl_FragColor.rgb, mask * gl_FragColor.a );
      #include <tonemapping_fragment>
      #include <encodings_fragment>
      `)
        }
    }
}
const ZV = U.forwardRef((n,e)=>{
    const [t] = U.useState(()=>new QV(null));
    return U.createElement("primitive", Mr({}, n, {
        object: t,
        ref: e,
        attach: "material"
    }))
}
)
  , qV = U.forwardRef(({children: n, speed: e=1, rotationIntensity: t=1, floatIntensity: i=1, floatingRange: r=[-.1, .1], ...s},o)=>{
    const a = U.useRef(null)
      , l = U.useRef(Math.random() * 1e4);
    return Tc(c=>{
        var d, h;
        const p = l.current + c.clock.getElapsedTime();
        a.current.rotation.x = Math.cos(p / 4 * e) / 8 * t,
        a.current.rotation.y = Math.sin(p / 4 * e) / 8 * t,
        a.current.rotation.z = Math.sin(p / 4 * e) / 20 * t;
        let m = Math.sin(p / 4 * e) / 10;
        m = Aw.mapLinear(m, -.1, .1, (d = r == null ? void 0 : r[0]) !== null && d !== void 0 ? d : -.1, (h = r == null ? void 0 : r[1]) !== null && h !== void 0 ? h : .1),
        a.current.position.y = m * i
    }
    ),
    U.createElement("group", s, U.createElement("group", {
        ref: oS([a, o])
    }, n))
}
);
let Na, Mf;
const $V = U.createContext(null)
  , VT = new ot
  , WT = new D
  , eW = U.forwardRef(({children: n, range: e, limit: t=1e3, ...i},r)=>{
    const s = U.useRef(null)
      , [o,a] = U.useState([])
      , [[l,c,d]] = U.useState(()=>[new Float32Array(t * 3), Float32Array.from({
        length: t * 3
    }, ()=>1), Float32Array.from({
        length: t
    }, ()=>1)]);
    U.useEffect(()=>{
        s.current.geometry.attributes.position.needsUpdate = !0
    }
    ),
    Tc(()=>{
        for (s.current.updateMatrix(),
        s.current.updateMatrixWorld(),
        VT.copy(s.current.matrixWorld).invert(),
        s.current.geometry.drawRange.count = Math.min(t, e !== void 0 ? e : t, o.length),
        Na = 0; Na < o.length; Na++)
            Mf = o[Na].current,
            Mf.getWorldPosition(WT).applyMatrix4(VT),
            WT.toArray(l, Na * 3),
            s.current.geometry.attributes.position.needsUpdate = !0,
            Mf.matrixWorldNeedsUpdate = !0,
            Mf.color.toArray(c, Na * 3),
            s.current.geometry.attributes.color.needsUpdate = !0,
            d.set([Mf.size], Na),
            s.current.geometry.attributes.size.needsUpdate = !0
    }
    );
    const h = U.useMemo(()=>({
        getParent: ()=>s,
        subscribe: p=>(a(m=>[...m, p]),
        ()=>a(m=>m.filter(y=>y.current !== p.current)))
    }), []);
    return U.createElement("points", Mr({
        userData: {
            instances: o
        },
        matrixAutoUpdate: !1,
        ref: oS([r, s]),
        raycast: ()=>null
    }, i), U.createElement("bufferGeometry", null, U.createElement("bufferAttribute", {
        attach: "attributes-position",
        count: l.length / 3,
        array: l,
        itemSize: 3,
        usage: fl
    }), U.createElement("bufferAttribute", {
        attach: "attributes-color",
        count: c.length / 3,
        array: c,
        itemSize: 3,
        usage: fl
    }), U.createElement("bufferAttribute", {
        attach: "attributes-size",
        count: d.length,
        array: d,
        itemSize: 1,
        usage: fl
    })), U.createElement($V.Provider, {
        value: h
    }, n))
}
)
  , tW = U.forwardRef(({children: n, positions: e, colors: t, sizes: i, stride: r=3, ...s},o)=>{
    const a = U.useRef(null);
    return Tc(()=>{
        const l = a.current.geometry.attributes;
        l.position.needsUpdate = !0,
        t && (l.color.needsUpdate = !0),
        i && (l.size.needsUpdate = !0)
    }
    ),
    U.createElement("points", Mr({
        ref: oS([o, a])
    }, s), U.createElement("bufferGeometry", null, U.createElement("bufferAttribute", {
        attach: "attributes-position",
        count: e.length / r,
        array: e,
        itemSize: r,
        usage: fl
    }), t && U.createElement("bufferAttribute", {
        attach: "attributes-color",
        count: t.length / r,
        array: t,
        itemSize: 3,
        usage: fl
    }), i && U.createElement("bufferAttribute", {
        attach: "attributes-size",
        count: i.length / r,
        array: i,
        itemSize: 1,
        usage: fl
    })), n)
}
)
  , nW = U.forwardRef((n,e)=>n.positions instanceof Float32Array ? U.createElement(tW, Mr({}, n, {
    ref: e
})) : U.createElement(eW, Mr({}, n, {
    ref: e
})));
var ht = {}
  , iW = {
    get exports() {
        return ht
    },
    set exports(n) {
        ht = n
    }
}
  , rW = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
  , sW = rW
  , oW = sW;
function oL() {}
function aL() {}
aL.resetWarningCache = oL;
var aW = function() {
    function n(i, r, s, o, a, l) {
        if (l !== oW) {
            var c = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
            throw c.name = "Invariant Violation",
            c
        }
    }
    n.isRequired = n;
    function e() {
        return n
    }
    var t = {
        array: n,
        bigint: n,
        bool: n,
        func: n,
        number: n,
        object: n,
        string: n,
        symbol: n,
        any: n,
        arrayOf: e,
        element: n,
        elementType: n,
        instanceOf: e,
        node: n,
        objectOf: e,
        oneOf: e,
        oneOfType: e,
        shape: e,
        exact: e,
        checkPropTypes: aL,
        resetWarningCache: oL
    };
    return t.PropTypes = t,
    t
};
iW.exports = aW();
function z0({all: n, scene: e, camera: t}) {
    const i = Hi(({gl: o})=>o)
      , r = Hi(({camera: o})=>o)
      , s = Hi(({scene: o})=>o);
    return U.useLayoutEffect(()=>{
        const o = [];
        n && (e || s).traverse(c=>{
            c.visible === !1 && (o.push(c),
            c.visible = !0)
        }
        ),
        i.compile(e || s, t || r);
        const a = new Ew(128);
        new Cw(.01,1e5,a).update(i, e || s),
        a.dispose(),
        o.forEach(c=>c.visible = !1)
    }
    , []),
    null
}
const cS = ()=>{
    const {progress: n} = sV();
    return it(rV, {
        as: "div",
        center: !0,
        style: {
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            flexDirection: "column"
        },
        children: [he("span", {
            className: "canvas-loader"
        }), it("p", {
            style: {
                fontSize: 14,
                color: "#F1F1F1",
                fontWeight: 800,
                marginTop: 40
            },
            children: [n.toFixed(2), "%"]
        })]
    })
}
  , lW = ()=>{
    const n = U0("./assets/scene.gltf");
    return he("primitive", {
        object: n.scene,
        scale: 2.5,
        "position-y": 0,
        "rotation-y": 0
    })
}
  , uW = ()=>he(O0, {
    shadows: !0,
    frameloop: "demand",
    dpr: [1, 2],
    gl: {
        preserveDrawingBuffer: !0
    },
    camera: {
        fov: 45,
        near: .1,
        far: 200,
        position: [-4, 3, 6]
    },
    children: it(U.Suspense, {
        fallback: he(cS, {}),
        children: [he(uS, {
            autoRotate: !0,
            enableZoom: !1,
            maxPolarAngle: Math.PI / 2,
            minPolarAngle: Math.PI / 2
        }), he(lW, {}), he(z0, {
            all: !0
        })]
    })
})
  , cW = n=>{
    const [e] = lS([n.imgUrl]);
    return it(qV, {
        speed: 1.75,
        rotationIntensity: 1,
        floatIntensity: 2,
        children: [he("ambientLight", {
            intensity: .25
        }), he("directionalLight", {
            position: [0, 0, .05]
        }), it("mesh", {
            castShadow: !0,
            receiveShadow: !0,
            scale: 2.75,
            children: [he("icosahedronGeometry", {
                args: [1, 1]
            }), he("meshStandardMaterial", {
                color: "#fff8eb",
                polygonOffset: !0,
                polygonOffsetFactor: -5,
                flatShading: !0
            }), he(KV, {
                position: [0, 0, 1],
                rotation: [2 * Math.PI, 0, 6.25],
                scale: 1,
                map: e,
                flatShading: !0
            })]
        })]
    })
}
  , fW = ({icon: n})=>it(O0, {
    frameloop: "demand",
    dpr: [1, 2],
    gl: {
        preserveDrawingBuffer: !0
    },
    children: [it(U.Suspense, {
        fallback: he(cS, {}),
        children: [he(uS, {
            enableZoom: !1
        }), he(cW, {
            imgUrl: n
        })]
    }), he(z0, {
        all: !0
    })]
})
  , dW = ({isMobile: n})=>{
    const e = U0("./assets/desktop.gltf");
    return it("mesh", {
        children: [he("hemisphereLight", {
            intensity: .15,
            groundColor: "black"
        }), he("spotLight", {
            position: [-20, 50, 10],
            angle: .12,
            penumbra: 1,
            intensity: 1,
            castShadow: !0,
            "shadow-mapSize": 1024
        }), he("pointLight", {
            intensity: 1
        }), he("primitive", {
            object: e.scene,
            scale: n ? .7 : .75,
            position: n ? [0, -3, -2.2] : [0, -3.25, -1.5],
            rotation: [-.01, -.2, -.1]
        })]
    })
}
  , hW = ()=>{
    const [n,e] = U.useState(!1);
    return U.useEffect(()=>{
        const t = window.matchMedia("(max-width: 500px)");
        e(t.matches);
        const i = r=>{
            e(r.matches)
        }
        ;
        return t.addEventListener("change", i),
        ()=>{
            t.removeEventListener("change", i)
        }
    }
    , []),
    it(O0, {
        frameloop: "demand",
        shadows: !0,
        dpr: [1, 2],
        camera: {
            position: [20, 3, 5],
            fov: 25
        },
        gl: {
            preserveDrawingBuffer: !0
        },
        children: [it(U.Suspense, {
            fallback: he(cS, {}),
            children: [he(uS, {
                enableZoom: !1,
                maxPolarAngle: Math.PI / 2,
                minPolarAngle: Math.PI / 2
            }), he(dW, {
                isMobile: n
            })]
        }), he(z0, {
            all: !0
        })]
    })
}
  , pW = n=>{
    const e = U.useRef()
      , [t] = U.useState(()=>dV(new Float32Array(5e3), {
        radius: 1.2
    }));
    return Tc((i,r)=>{
        e.current.rotation.x -= r / 10,
        e.current.rotation.y -= r / 15
    }
    ),
    he("group", {
        rotation: [0, 0, Math.PI / 4],
        children: he(nW, {
            ref: e,
            positions: t,
            stride: 3,
            frustumCulled: !0,
            ...n,
            children: he(ZV, {
                transparent: !0,
                color: "#f272c8",
                size: .002,
                sizeAttenuation: !0,
                depthWrite: !1
            })
        })
    })
}
  , mW = ()=>he("div", {
    className: "w-full h-auto absolute inset-0 z-[-1]",
    children: it(O0, {
        camera: {
            position: [0, 0, 1]
        },
        children: [he(U.Suspense, {
            fallback: null,
            children: he(pW, {})
        }), he(z0, {
            all: !0
        })]
    })
})
  , lL = U.createContext({
    transformPagePoint: n=>n,
    isStatic: !1,
    reducedMotion: "never"
})
  , G0 = U.createContext({});
function gW() {
    return U.useContext(G0).visualElement
}
const fS = U.createContext(null)
  , H0 = typeof document < "u"
  , jT = H0 ? U.useLayoutEffect : U.useEffect
  , uL = U.createContext({
    strict: !1
});
function vW(n, e, t, i) {
    const r = gW()
      , s = U.useContext(uL)
      , o = U.useContext(fS)
      , a = U.useContext(lL).reducedMotion
      , l = U.useRef();
    i = i || s.renderer,
    !l.current && i && (l.current = i(n, {
        visualState: e,
        parent: r,
        props: t,
        presenceContext: o,
        blockInitialAnimation: o ? o.initial === !1 : !1,
        reducedMotionConfig: a
    }));
    const c = l.current;
    return U.useInsertionEffect(()=>{
        c && c.update(t, o)
    }
    ),
    jT(()=>{
        c && c.render()
    }
    ),
    U.useEffect(()=>{
        c && c.updateFeatures()
    }
    ),
    (window.HandoffAppearAnimations ? jT : U.useEffect)(()=>{
        c && c.animationState && c.animationState.animateChanges()
    }
    ),
    c
}
function Lu(n) {
    return typeof n == "object" && Object.prototype.hasOwnProperty.call(n, "current")
}
function yW(n, e, t) {
    return U.useCallback(i=>{
        i && n.mount && n.mount(i),
        e && (i ? e.mount(i) : e.unmount()),
        t && (typeof t == "function" ? t(i) : Lu(t) && (t.current = i))
    }
    , [e])
}
function Fd(n) {
    return typeof n == "string" || Array.isArray(n)
}
function V0(n) {
    return typeof n == "object" && typeof n.start == "function"
}
const dS = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"]
  , hS = ["initial", ...dS];
function W0(n) {
    return V0(n.animate) || hS.some(e=>Fd(n[e]))
}
function cL(n) {
    return Boolean(W0(n) || n.variants)
}
function xW(n, e) {
    if (W0(n)) {
        const {initial: t, animate: i} = n;
        return {
            initial: t === !1 || Fd(t) ? t : void 0,
            animate: Fd(i) ? i : void 0
        }
    }
    return n.inherit !== !1 ? e : {}
}
function _W(n) {
    const {initial: e, animate: t} = xW(n, U.useContext(G0));
    return U.useMemo(()=>({
        initial: e,
        animate: t
    }), [JT(e), JT(t)])
}
function JT(n) {
    return Array.isArray(n) ? n.join(" ") : n
}
const XT = {
    animation: ["animate", "exit", "variants", "whileHover", "whileTap", "whileFocus", "whileDrag", "whileInView"],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
}
  , Nd = {};
for (const n in XT)
    Nd[n] = {
        isEnabled: e=>XT[n].some(t=>!!e[t])
    };
function AW(n) {
    for (const e in n)
        Nd[e] = {
            ...Nd[e],
            ...n[e]
        }
}
function fL(n) {
    const e = U.useRef(null);
    return e.current === null && (e.current = n()),
    e.current
}
const Yf = {
    hasAnimatedSinceResize: !0,
    hasEverUpdated: !1
};
let wW = 1;
function SW() {
    return fL(()=>{
        if (Yf.hasEverUpdated)
            return wW++
    }
    )
}
const dL = U.createContext({})
  , hL = U.createContext({})
  , MW = Symbol.for("motionComponentSymbol");
function bW({preloadedFeatures: n, createVisualElement: e, useRender: t, useVisualState: i, Component: r}) {
    n && AW(n);
    function s(a, l) {
        let c;
        const d = {
            ...U.useContext(lL),
            ...a,
            layoutId: CW(a)
        }
          , {isStatic: h} = d
          , p = _W(a)
          , m = h ? void 0 : SW()
          , y = i(a, h);
        if (!h && H0) {
            p.visualElement = vW(r, y, d, e);
            const v = U.useContext(hL)
              , x = U.useContext(uL).strict;
            p.visualElement && (c = p.visualElement.loadFeatures(d, x, n, m, v))
        }
        return U.createElement(G0.Provider, {
            value: p
        }, c && p.visualElement ? U.createElement(c, {
            visualElement: p.visualElement,
            ...d
        }) : null, t(r, a, m, yW(y, p.visualElement, l), y, h, p.visualElement))
    }
    const o = U.forwardRef(s);
    return o[MW] = r,
    o
}
function CW({layoutId: n}) {
    const e = U.useContext(dL).id;
    return e && n !== void 0 ? e + "-" + n : n
}
function EW(n) {
    function e(i, r={}) {
        return bW(n(i, r))
    }
    if (typeof Proxy > "u")
        return e;
    const t = new Map;
    return new Proxy(e,{
        get: (i,r)=>(t.has(r) || t.set(r, e(r)),
        t.get(r))
    })
}
const TW = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];
function pS(n) {
    return typeof n != "string" || n.includes("-") ? !1 : !!(TW.indexOf(n) > -1 || /[A-Z]/.test(n))
}
const Wg = {};
function PW(n) {
    Object.assign(Wg, n)
}
const j0 = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"]
  , Dl = new Set(j0);
function pL(n, {layout: e, layoutId: t}) {
    return Dl.has(n) || n.startsWith("origin") || (e || t !== void 0) && (!!Wg[n] || n === "opacity")
}
const Di = n=>Boolean(n && n.getVelocity)
  , BW = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
}
  , RW = j0.length;
function IW(n, {enableHardwareAcceleration: e=!0, allowTransformNone: t=!0}, i, r) {
    let s = "";
    for (let o = 0; o < RW; o++) {
        const a = j0[o];
        if (n[a] !== void 0) {
            const l = BW[a] || a;
            s += `${l}(${n[a]}) `
        }
    }
    return e && !n.z && (s += "translateZ(0)"),
    s = s.trim(),
    r ? s = r(n, i ? "" : s) : t && i && (s = "none"),
    s
}
const mL = n=>e=>typeof e == "string" && e.startsWith(n)
  , gL = mL("--")
  , k_ = mL("var(--")
  , LW = (n,e)=>e && typeof n == "number" ? e.transform(n) : n
  , dc = (n,e,t)=>Math.min(Math.max(t, n), e)
  , kl = {
    test: n=>typeof n == "number",
    parse: parseFloat,
    transform: n=>n
}
  , Kf = {
    ...kl,
    transform: n=>dc(0, 1, n)
}
  , Pm = {
    ...kl,
    default: 1
}
  , Qf = n=>Math.round(n * 1e5) / 1e5
  , Od = /(-)?([\d]*\.?[\d])+/g
  , F_ = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi
  , DW = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function _h(n) {
    return typeof n == "string"
}
const Ah = n=>({
    test: e=>_h(e) && e.endsWith(n) && e.split(" ").length === 1,
    parse: parseFloat,
    transform: e=>`${e}${n}`
})
  , To = Ah("deg")
  , ds = Ah("%")
  , st = Ah("px")
  , kW = Ah("vh")
  , FW = Ah("vw")
  , YT = {
    ...ds,
    parse: n=>ds.parse(n) / 100,
    transform: n=>ds.transform(n * 100)
}
  , KT = {
    ...kl,
    transform: Math.round
}
  , vL = {
    borderWidth: st,
    borderTopWidth: st,
    borderRightWidth: st,
    borderBottomWidth: st,
    borderLeftWidth: st,
    borderRadius: st,
    radius: st,
    borderTopLeftRadius: st,
    borderTopRightRadius: st,
    borderBottomRightRadius: st,
    borderBottomLeftRadius: st,
    width: st,
    maxWidth: st,
    height: st,
    maxHeight: st,
    size: st,
    top: st,
    right: st,
    bottom: st,
    left: st,
    padding: st,
    paddingTop: st,
    paddingRight: st,
    paddingBottom: st,
    paddingLeft: st,
    margin: st,
    marginTop: st,
    marginRight: st,
    marginBottom: st,
    marginLeft: st,
    rotate: To,
    rotateX: To,
    rotateY: To,
    rotateZ: To,
    scale: Pm,
    scaleX: Pm,
    scaleY: Pm,
    scaleZ: Pm,
    skew: To,
    skewX: To,
    skewY: To,
    distance: st,
    translateX: st,
    translateY: st,
    translateZ: st,
    x: st,
    y: st,
    z: st,
    perspective: st,
    transformPerspective: st,
    opacity: Kf,
    originX: YT,
    originY: YT,
    originZ: st,
    zIndex: KT,
    fillOpacity: Kf,
    strokeOpacity: Kf,
    numOctaves: KT
};
function mS(n, e, t, i) {
    const {style: r, vars: s, transform: o, transformOrigin: a} = n;
    let l = !1
      , c = !1
      , d = !0;
    for (const h in e) {
        const p = e[h];
        if (gL(h)) {
            s[h] = p;
            continue
        }
        const m = vL[h]
          , y = LW(p, m);
        if (Dl.has(h)) {
            if (l = !0,
            o[h] = y,
            !d)
                continue;
            p !== (m.default || 0) && (d = !1)
        } else
            h.startsWith("origin") ? (c = !0,
            a[h] = y) : r[h] = y
    }
    if (e.transform || (l || i ? r.transform = IW(n.transform, t, d, i) : r.transform && (r.transform = "none")),
    c) {
        const {originX: h="50%", originY: p="50%", originZ: m=0} = a;
        r.transformOrigin = `${h} ${p} ${m}`
    }
}
const gS = ()=>({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
});
function yL(n, e, t) {
    for (const i in e)
        !Di(e[i]) && !pL(i, t) && (n[i] = e[i])
}
function NW({transformTemplate: n}, e, t) {
    return U.useMemo(()=>{
        const i = gS();
        return mS(i, e, {
            enableHardwareAcceleration: !t
        }, n),
        Object.assign({}, i.vars, i.style)
    }
    , [e])
}
function OW(n, e, t) {
    const i = n.style || {}
      , r = {};
    return yL(r, i, n),
    Object.assign(r, NW(n, e, t)),
    n.transformValues ? n.transformValues(r) : r
}
function UW(n, e, t) {
    const i = {}
      , r = OW(n, e, t);
    return n.drag && n.dragListener !== !1 && (i.draggable = !1,
    r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none",
    r.touchAction = n.drag === !0 ? "none" : `pan-${n.drag === "x" ? "y" : "x"}`),
    n.tabIndex === void 0 && (n.onTap || n.onTapStart || n.whileTap) && (i.tabIndex = 0),
    i.style = r,
    i
}
const zW = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "transformValues", "custom", "inherit", "onLayoutAnimationStart", "onLayoutAnimationComplete", "onLayoutMeasure", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "ignoreStrict", "viewport"]);
function jg(n) {
    return n.startsWith("while") || n.startsWith("drag") && n !== "draggable" || n.startsWith("layout") || n.startsWith("onTap") || n.startsWith("onPan") || zW.has(n)
}
let xL = n=>!jg(n);
function GW(n) {
    n && (xL = e=>e.startsWith("on") ? !jg(e) : n(e))
}
try {
    GW(require("@emotion/is-prop-valid").default)
} catch {}
function HW(n, e, t) {
    const i = {};
    for (const r in n)
        r === "values" && typeof n.values == "object" || (xL(r) || t === !0 && jg(r) || !e && !jg(r) || n.draggable && r.startsWith("onDrag")) && (i[r] = n[r]);
    return i
}
function QT(n, e, t) {
    return typeof n == "string" ? n : st.transform(e + t * n)
}
function VW(n, e, t) {
    const i = QT(e, n.x, n.width)
      , r = QT(t, n.y, n.height);
    return `${i} ${r}`
}
const WW = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
}
  , jW = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
};
function JW(n, e, t=1, i=0, r=!0) {
    n.pathLength = 1;
    const s = r ? WW : jW;
    n[s.offset] = st.transform(-i);
    const o = st.transform(e)
      , a = st.transform(t);
    n[s.array] = `${o} ${a}`
}
function vS(n, {attrX: e, attrY: t, originX: i, originY: r, pathLength: s, pathSpacing: o=1, pathOffset: a=0, ...l}, c, d, h) {
    if (mS(n, l, c, h),
    d) {
        n.style.viewBox && (n.attrs.viewBox = n.style.viewBox);
        return
    }
    n.attrs = n.style,
    n.style = {};
    const {attrs: p, style: m, dimensions: y} = n;
    p.transform && (y && (m.transform = p.transform),
    delete p.transform),
    y && (i !== void 0 || r !== void 0 || m.transform) && (m.transformOrigin = VW(y, i !== void 0 ? i : .5, r !== void 0 ? r : .5)),
    e !== void 0 && (p.x = e),
    t !== void 0 && (p.y = t),
    s !== void 0 && JW(p, s, o, a, !1)
}
const _L = ()=>({
    ...gS(),
    attrs: {}
})
  , yS = n=>typeof n == "string" && n.toLowerCase() === "svg";
function XW(n, e, t, i) {
    const r = U.useMemo(()=>{
        const s = _L();
        return vS(s, e, {
            enableHardwareAcceleration: !1
        }, yS(i), n.transformTemplate),
        {
            ...s.attrs,
            style: {
                ...s.style
            }
        }
    }
    , [e]);
    if (n.style) {
        const s = {};
        yL(s, n.style, n),
        r.style = {
            ...s,
            ...r.style
        }
    }
    return r
}
function YW(n=!1) {
    return (t,i,r,s,{latestValues: o},a)=>{
        const c = (pS(t) ? XW : UW)(i, o, a, t)
          , h = {
            ...HW(i, typeof t == "string", n),
            ...c,
            ref: s
        }
          , {children: p} = i
          , m = U.useMemo(()=>Di(p) ? p.get() : p, [p]);
        return r && (h["data-projection-id"] = r),
        U.createElement(t, {
            ...h,
            children: m
        })
    }
}
const xS = n=>n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
function AL(n, {style: e, vars: t}, i, r) {
    Object.assign(n.style, e, r && r.getProjectionStyles(i));
    for (const s in t)
        n.style.setProperty(s, t[s])
}
const wL = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);
function SL(n, e, t, i) {
    AL(n, e, void 0, i);
    for (const r in e.attrs)
        n.setAttribute(wL.has(r) ? r : xS(r), e.attrs[r])
}
function _S(n, e) {
    const {style: t} = n
      , i = {};
    for (const r in t)
        (Di(t[r]) || e.style && Di(e.style[r]) || pL(r, n)) && (i[r] = t[r]);
    return i
}
function ML(n, e) {
    const t = _S(n, e);
    for (const i in n)
        if (Di(n[i]) || Di(e[i])) {
            const r = i === "x" || i === "y" ? "attr" + i.toUpperCase() : i;
            t[r] = n[i]
        }
    return t
}
function AS(n, e, t, i={}, r={}) {
    return typeof e == "function" && (e = e(t !== void 0 ? t : n.custom, i, r)),
    typeof e == "string" && (e = n.variants && n.variants[e]),
    typeof e == "function" && (e = e(t !== void 0 ? t : n.custom, i, r)),
    e
}
const Jg = n=>Array.isArray(n)
  , KW = n=>Boolean(n && typeof n == "object" && n.mix && n.toValue)
  , QW = n=>Jg(n) ? n[n.length - 1] || 0 : n;
function cg(n) {
    const e = Di(n) ? n.get() : n;
    return KW(e) ? e.toValue() : e
}
function ZW({scrapeMotionValuesFromProps: n, createRenderState: e, onMount: t}, i, r, s) {
    const o = {
        latestValues: qW(i, r, s, n),
        renderState: e()
    };
    return t && (o.mount = a=>t(i, a, o)),
    o
}
const bL = n=>(e,t)=>{
    const i = U.useContext(G0)
      , r = U.useContext(fS)
      , s = ()=>ZW(n, e, i, r);
    return t ? s() : fL(s)
}
;
function qW(n, e, t, i) {
    const r = {}
      , s = i(n, {});
    for (const p in s)
        r[p] = cg(s[p]);
    let {initial: o, animate: a} = n;
    const l = W0(n)
      , c = cL(n);
    e && c && !l && n.inherit !== !1 && (o === void 0 && (o = e.initial),
    a === void 0 && (a = e.animate));
    let d = t ? t.initial === !1 : !1;
    d = d || o === !1;
    const h = d ? a : o;
    return h && typeof h != "boolean" && !V0(h) && (Array.isArray(h) ? h : [h]).forEach(m=>{
        const y = AS(n, m);
        if (!y)
            return;
        const {transitionEnd: v, transition: x, ..._} = y;
        for (const A in _) {
            let w = _[A];
            if (Array.isArray(w)) {
                const M = d ? w.length - 1 : 0;
                w = w[M]
            }
            w !== null && (r[A] = w)
        }
        for (const A in v)
            r[A] = v[A]
    }
    ),
    r
}
const $W = {
    useVisualState: bL({
        scrapeMotionValuesFromProps: ML,
        createRenderState: _L,
        onMount: (n,e,{renderState: t, latestValues: i})=>{
            try {
                t.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect()
            } catch {
                t.dimensions = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                }
            }
            vS(t, i, {
                enableHardwareAcceleration: !1
            }, yS(e.tagName), n.transformTemplate),
            SL(e, t)
        }
    })
}
  , e7 = {
    useVisualState: bL({
        scrapeMotionValuesFromProps: _S,
        createRenderState: gS
    })
};
function t7(n, {forwardMotionProps: e=!1}, t, i) {
    return {
        ...pS(n) ? $W : e7,
        preloadedFeatures: t,
        useRender: YW(e),
        createVisualElement: i,
        Component: n
    }
}
function Vs(n, e, t, i={
    passive: !0
}) {
    return n.addEventListener(e, t, i),
    ()=>n.removeEventListener(e, t)
}
const CL = n=>n.pointerType === "mouse" ? typeof n.button != "number" || n.button <= 0 : n.isPrimary !== !1;
function J0(n, e="page") {
    return {
        point: {
            x: n[e + "X"],
            y: n[e + "Y"]
        }
    }
}
const n7 = n=>e=>CL(e) && n(e, J0(e));
function Js(n, e, t, i) {
    return Vs(n, e, n7(t), i)
}
const i7 = (n,e)=>t=>e(n(t))
  , Zo = (...n)=>n.reduce(i7);
function EL(n) {
    let e = null;
    return ()=>{
        const t = ()=>{
            e = null
        }
        ;
        return e === null ? (e = n,
        t) : !1
    }
}
const ZT = EL("dragHorizontal")
  , qT = EL("dragVertical");
function TL(n) {
    let e = !1;
    if (n === "y")
        e = qT();
    else if (n === "x")
        e = ZT();
    else {
        const t = ZT()
          , i = qT();
        t && i ? e = ()=>{
            t(),
            i()
        }
        : (t && t(),
        i && i())
    }
    return e
}
function PL() {
    const n = TL(!0);
    return n ? (n(),
    !1) : !0
}
class ya {
    constructor(e) {
        this.isMounted = !1,
        this.node = e
    }
    update() {}
}
function $T(n, e) {
    const t = "pointer" + (e ? "enter" : "leave")
      , i = "onHover" + (e ? "Start" : "End")
      , r = (s,o)=>{
        if (s.type === "touch" || PL())
            return;
        const a = n.getProps();
        n.animationState && a.whileHover && n.animationState.setActive("whileHover", e),
        a[i] && a[i](s, o)
    }
    ;
    return Js(n.current, t, r, {
        passive: !n.getProps()[i]
    })
}
class r7 extends ya {
    mount() {
        this.unmount = Zo($T(this.node, !0), $T(this.node, !1))
    }
    unmount() {}
}
class s7 extends ya {
    constructor() {
        super(...arguments),
        this.isActive = !1
    }
    onFocus() {
        let e = !1;
        try {
            e = this.node.current.matches(":focus-visible")
        } catch {
            e = !0
        }
        !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0),
        this.isActive = !0)
    }
    onBlur() {
        !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1),
        this.isActive = !1)
    }
    mount() {
        this.unmount = Zo(Vs(this.node.current, "focus", ()=>this.onFocus()), Vs(this.node.current, "blur", ()=>this.onBlur()))
    }
    unmount() {}
}
const BL = (n,e)=>e ? n === e ? !0 : BL(n, e.parentElement) : !1
  , Ar = n=>n;
function Cx(n, e) {
    if (!e)
        return;
    const t = new PointerEvent("pointer" + n);
    e(t, J0(t))
}
class o7 extends ya {
    constructor() {
        super(...arguments),
        this.removeStartListeners = Ar,
        this.removeEndListeners = Ar,
        this.removeAccessibleListeners = Ar,
        this.startPointerPress = (e,t)=>{
            if (this.removeEndListeners(),
            this.isPressing)
                return;
            const i = this.node.getProps()
              , s = Js(window, "pointerup", (a,l)=>{
                if (!this.checkPressEnd())
                    return;
                const {onTap: c, onTapCancel: d} = this.node.getProps();
                BL(this.node.current, a.target) ? c && c(a, l) : d && d(a, l)
            }
            , {
                passive: !(i.onTap || i.onPointerUp)
            })
              , o = Js(window, "pointercancel", (a,l)=>this.cancelPress(a, l), {
                passive: !(i.onTapCancel || i.onPointerCancel)
            });
            this.removeEndListeners = Zo(s, o),
            this.startPress(e, t)
        }
        ,
        this.startAccessiblePress = ()=>{
            const e = s=>{
                if (s.key !== "Enter" || this.isPressing)
                    return;
                const o = a=>{
                    a.key !== "Enter" || !this.checkPressEnd() || Cx("up", this.node.getProps().onTap)
                }
                ;
                this.removeEndListeners(),
                this.removeEndListeners = Vs(this.node.current, "keyup", o),
                Cx("down", (a,l)=>{
                    this.startPress(a, l)
                }
                )
            }
              , t = Vs(this.node.current, "keydown", e)
              , i = ()=>{
                this.isPressing && Cx("cancel", (s,o)=>this.cancelPress(s, o))
            }
              , r = Vs(this.node.current, "blur", i);
            this.removeAccessibleListeners = Zo(t, r)
        }
    }
    startPress(e, t) {
        this.isPressing = !0;
        const {onTapStart: i, whileTap: r} = this.node.getProps();
        r && this.node.animationState && this.node.animationState.setActive("whileTap", !0),
        i && i(e, t)
    }
    checkPressEnd() {
        return this.removeEndListeners(),
        this.isPressing = !1,
        this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1),
        !PL()
    }
    cancelPress(e, t) {
        if (!this.checkPressEnd())
            return;
        const {onTapCancel: i} = this.node.getProps();
        i && i(e, t)
    }
    mount() {
        const e = this.node.getProps()
          , t = Js(this.node.current, "pointerdown", this.startPointerPress, {
            passive: !(e.onTapStart || e.onPointerStart)
        })
          , i = Vs(this.node.current, "focus", this.startAccessiblePress);
        this.removeStartListeners = Zo(t, i)
    }
    unmount() {
        this.removeStartListeners(),
        this.removeEndListeners(),
        this.removeAccessibleListeners()
    }
}
const N_ = new WeakMap
  , Ex = new WeakMap
  , a7 = n=>{
    const e = N_.get(n.target);
    e && e(n)
}
  , l7 = n=>{
    n.forEach(a7)
}
;
function u7({root: n, ...e}) {
    const t = n || document;
    Ex.has(t) || Ex.set(t, {});
    const i = Ex.get(t)
      , r = JSON.stringify(e);
    return i[r] || (i[r] = new IntersectionObserver(l7,{
        root: n,
        ...e
    })),
    i[r]
}
function c7(n, e, t) {
    const i = u7(e);
    return N_.set(n, t),
    i.observe(n),
    ()=>{
        N_.delete(n),
        i.unobserve(n)
    }
}
const f7 = {
    some: 0,
    all: 1
};
class d7 extends ya {
    constructor() {
        super(...arguments),
        this.hasEnteredView = !1,
        this.isInView = !1
    }
    viewportFallback() {
        requestAnimationFrame(()=>{
            this.hasEnteredView = !0;
            const {onViewportEnter: e} = this.node.getProps();
            e && e(null),
            this.node.animationState && this.node.animationState.setActive("whileInView", !0)
        }
        )
    }
    startObserver() {
        this.unmount();
        const {viewport: e={}} = this.node.getProps()
          , {root: t, margin: i, amount: r="some", once: s, fallback: o=!0} = e;
        if (typeof IntersectionObserver > "u") {
            o && this.viewportFallback();
            return
        }
        const a = {
            root: t ? t.current : void 0,
            rootMargin: i,
            threshold: typeof r == "number" ? r : f7[r]
        }
          , l = c=>{
            const {isIntersecting: d} = c;
            if (this.isInView === d || (this.isInView = d,
            s && !d && this.hasEnteredView))
                return;
            d && (this.hasEnteredView = !0),
            this.node.animationState && this.node.animationState.setActive("whileInView", d);
            const {onViewportEnter: h, onViewportLeave: p} = this.node.getProps()
              , m = d ? h : p;
            m && m(c)
        }
        ;
        return c7(this.node.current, a, l)
    }
    mount() {
        this.startObserver()
    }
    update() {
        if (typeof IntersectionObserver > "u")
            return;
        const {props: e, prevProps: t} = this.node;
        ["amount", "margin", "root"].some(h7(e, t)) && this.startObserver()
    }
    unmount() {}
}
function h7({viewport: n={}}, {viewport: e={}}={}) {
    return t=>n[t] !== e[t]
}
const p7 = {
    inView: {
        Feature: d7
    },
    tap: {
        Feature: o7
    },
    focus: {
        Feature: s7
    },
    hover: {
        Feature: r7
    }
};
function RL(n, e) {
    if (!Array.isArray(e))
        return !1;
    const t = e.length;
    if (t !== n.length)
        return !1;
    for (let i = 0; i < t; i++)
        if (e[i] !== n[i])
            return !1;
    return !0
}
const m7 = n=>/^\-?\d*\.?\d+$/.test(n)
  , g7 = n=>/^0[^.\s]+$/.test(n)
  , Xs = {
    delta: 0,
    timestamp: 0
}
  , IL = 1 / 60 * 1e3
  , v7 = typeof performance < "u" ? ()=>performance.now() : ()=>Date.now()
  , LL = typeof window < "u" ? n=>window.requestAnimationFrame(n) : n=>setTimeout(()=>n(v7()), IL);
function y7(n) {
    let e = []
      , t = []
      , i = 0
      , r = !1
      , s = !1;
    const o = new WeakSet
      , a = {
        schedule: (l,c=!1,d=!1)=>{
            const h = d && r
              , p = h ? e : t;
            return c && o.add(l),
            p.indexOf(l) === -1 && (p.push(l),
            h && r && (i = e.length)),
            l
        }
        ,
        cancel: l=>{
            const c = t.indexOf(l);
            c !== -1 && t.splice(c, 1),
            o.delete(l)
        }
        ,
        process: l=>{
            if (r) {
                s = !0;
                return
            }
            if (r = !0,
            [e,t] = [t, e],
            t.length = 0,
            i = e.length,
            i)
                for (let c = 0; c < i; c++) {
                    const d = e[c];
                    d(l),
                    o.has(d) && (a.schedule(d),
                    n())
                }
            r = !1,
            s && (s = !1,
            a.process(l))
        }
    };
    return a
}
const x7 = 40;
let O_ = !0
  , Ud = !1
  , U_ = !1;
const wh = ["read", "update", "preRender", "render", "postRender"]
  , X0 = wh.reduce((n,e)=>(n[e] = y7(()=>Ud = !0),
n), {})
  , yi = wh.reduce((n,e)=>{
    const t = X0[e];
    return n[e] = (i,r=!1,s=!1)=>(Ud || A7(),
    t.schedule(i, r, s)),
    n
}
, {})
  , sa = wh.reduce((n,e)=>(n[e] = X0[e].cancel,
n), {})
  , Tx = wh.reduce((n,e)=>(n[e] = ()=>X0[e].process(Xs),
n), {})
  , _7 = n=>X0[n].process(Xs)
  , DL = n=>{
    Ud = !1,
    Xs.delta = O_ ? IL : Math.max(Math.min(n - Xs.timestamp, x7), 1),
    Xs.timestamp = n,
    U_ = !0,
    wh.forEach(_7),
    U_ = !1,
    Ud && (O_ = !1,
    LL(DL))
}
  , A7 = ()=>{
    Ud = !0,
    O_ = !0,
    U_ || LL(DL)
}
;
function wS(n, e) {
    n.indexOf(e) === -1 && n.push(e)
}
function SS(n, e) {
    const t = n.indexOf(e);
    t > -1 && n.splice(t, 1)
}
class MS {
    constructor() {
        this.subscriptions = []
    }
    add(e) {
        return wS(this.subscriptions, e),
        ()=>SS(this.subscriptions, e)
    }
    notify(e, t, i) {
        const r = this.subscriptions.length;
        if (r)
            if (r === 1)
                this.subscriptions[0](e, t, i);
            else
                for (let s = 0; s < r; s++) {
                    const o = this.subscriptions[s];
                    o && o(e, t, i)
                }
    }
    getSize() {
        return this.subscriptions.length
    }
    clear() {
        this.subscriptions.length = 0
    }
}
function bS(n, e) {
    return e ? n * (1e3 / e) : 0
}
const w7 = n=>!isNaN(parseFloat(n));
class S7 {
    constructor(e, t={}) {
        this.version = "9.1.7",
        this.timeDelta = 0,
        this.lastUpdated = 0,
        this.canTrackVelocity = !1,
        this.events = {},
        this.updateAndNotify = (i,r=!0)=>{
            this.prev = this.current,
            this.current = i;
            const {delta: s, timestamp: o} = Xs;
            this.lastUpdated !== o && (this.timeDelta = s,
            this.lastUpdated = o,
            yi.postRender(this.scheduleVelocityCheck)),
            this.prev !== this.current && this.events.change && this.events.change.notify(this.current),
            this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()),
            r && this.events.renderRequest && this.events.renderRequest.notify(this.current)
        }
        ,
        this.scheduleVelocityCheck = ()=>yi.postRender(this.velocityCheck),
        this.velocityCheck = ({timestamp: i})=>{
            i !== this.lastUpdated && (this.prev = this.current,
            this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()))
        }
        ,
        this.hasAnimated = !1,
        this.prev = this.current = e,
        this.canTrackVelocity = w7(this.current),
        this.owner = t.owner
    }
    onChange(e) {
        return this.on("change", e)
    }
    on(e, t) {
        this.events[e] || (this.events[e] = new MS);
        const i = this.events[e].add(t);
        return e === "change" ? ()=>{
            i(),
            yi.read(()=>{
                this.events.change.getSize() || this.stop()
            }
            )
        }
        : i
    }
    clearListeners() {
        for (const e in this.events)
            this.events[e].clear()
    }
    attach(e, t) {
        this.passiveEffect = e,
        this.stopPassiveEffect = t
    }
    set(e, t=!0) {
        !t || !this.passiveEffect ? this.updateAndNotify(e, t) : this.passiveEffect(e, this.updateAndNotify)
    }
    setWithVelocity(e, t, i) {
        this.set(t),
        this.prev = e,
        this.timeDelta = i
    }
    jump(e) {
        this.updateAndNotify(e),
        this.prev = e,
        this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
    get() {
        return this.current
    }
    getPrevious() {
        return this.prev
    }
    getVelocity() {
        return this.canTrackVelocity ? bS(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0
    }
    start(e) {
        return this.stop(),
        new Promise(t=>{
            this.hasAnimated = !0,
            this.animation = e(t) || null,
            this.events.animationStart && this.events.animationStart.notify()
        }
        ).then(()=>{
            this.events.animationComplete && this.events.animationComplete.notify(),
            this.clearAnimation()
        }
        )
    }
    stop() {
        this.animation && (this.animation.stop(),
        this.events.animationCancel && this.events.animationCancel.notify()),
        this.clearAnimation()
    }
    isAnimating() {
        return !!this.animation
    }
    clearAnimation() {
        this.animation = null
    }
    destroy() {
        this.clearListeners(),
        this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
}
function hc(n, e) {
    return new S7(n,e)
}
const CS = (n,e)=>t=>Boolean(_h(t) && DW.test(t) && t.startsWith(n) || e && Object.prototype.hasOwnProperty.call(t, e))
  , kL = (n,e,t)=>i=>{
    if (!_h(i))
        return i;
    const [r,s,o,a] = i.match(Od);
    return {
        [n]: parseFloat(r),
        [e]: parseFloat(s),
        [t]: parseFloat(o),
        alpha: a !== void 0 ? parseFloat(a) : 1
    }
}
  , M7 = n=>dc(0, 255, n)
  , Px = {
    ...kl,
    transform: n=>Math.round(M7(n))
}
  , rl = {
    test: CS("rgb", "red"),
    parse: kL("red", "green", "blue"),
    transform: ({red: n, green: e, blue: t, alpha: i=1})=>"rgba(" + Px.transform(n) + ", " + Px.transform(e) + ", " + Px.transform(t) + ", " + Qf(Kf.transform(i)) + ")"
};
function b7(n) {
    let e = ""
      , t = ""
      , i = ""
      , r = "";
    return n.length > 5 ? (e = n.substring(1, 3),
    t = n.substring(3, 5),
    i = n.substring(5, 7),
    r = n.substring(7, 9)) : (e = n.substring(1, 2),
    t = n.substring(2, 3),
    i = n.substring(3, 4),
    r = n.substring(4, 5),
    e += e,
    t += t,
    i += i,
    r += r),
    {
        red: parseInt(e, 16),
        green: parseInt(t, 16),
        blue: parseInt(i, 16),
        alpha: r ? parseInt(r, 16) / 255 : 1
    }
}
const z_ = {
    test: CS("#"),
    parse: b7,
    transform: rl.transform
}
  , Du = {
    test: CS("hsl", "hue"),
    parse: kL("hue", "saturation", "lightness"),
    transform: ({hue: n, saturation: e, lightness: t, alpha: i=1})=>"hsla(" + Math.round(n) + ", " + ds.transform(Qf(e)) + ", " + ds.transform(Qf(t)) + ", " + Qf(Kf.transform(i)) + ")"
}
  , pi = {
    test: n=>rl.test(n) || z_.test(n) || Du.test(n),
    parse: n=>rl.test(n) ? rl.parse(n) : Du.test(n) ? Du.parse(n) : z_.parse(n),
    transform: n=>_h(n) ? n : n.hasOwnProperty("red") ? rl.transform(n) : Du.transform(n)
}
  , FL = "${c}"
  , NL = "${n}";
function C7(n) {
    var e, t;
    return isNaN(n) && _h(n) && (((e = n.match(Od)) === null || e === void 0 ? void 0 : e.length) || 0) + (((t = n.match(F_)) === null || t === void 0 ? void 0 : t.length) || 0) > 0
}
function Xg(n) {
    typeof n == "number" && (n = `${n}`);
    const e = [];
    let t = 0
      , i = 0;
    const r = n.match(F_);
    r && (t = r.length,
    n = n.replace(F_, FL),
    e.push(...r.map(pi.parse)));
    const s = n.match(Od);
    return s && (i = s.length,
    n = n.replace(Od, NL),
    e.push(...s.map(kl.parse))),
    {
        values: e,
        numColors: t,
        numNumbers: i,
        tokenised: n
    }
}
function OL(n) {
    return Xg(n).values
}
function UL(n) {
    const {values: e, numColors: t, tokenised: i} = Xg(n)
      , r = e.length;
    return s=>{
        let o = i;
        for (let a = 0; a < r; a++)
            o = o.replace(a < t ? FL : NL, a < t ? pi.transform(s[a]) : Qf(s[a]));
        return o
    }
}
const E7 = n=>typeof n == "number" ? 0 : n;
function T7(n) {
    const e = OL(n);
    return UL(n)(e.map(E7))
}
const oa = {
    test: C7,
    parse: OL,
    createTransformer: UL,
    getAnimatableNone: T7
}
  , P7 = new Set(["brightness", "contrast", "saturate", "opacity"]);
function B7(n) {
    const [e,t] = n.slice(0, -1).split("(");
    if (e === "drop-shadow")
        return n;
    const [i] = t.match(Od) || [];
    if (!i)
        return n;
    const r = t.replace(i, "");
    let s = P7.has(e) ? 1 : 0;
    return i !== t && (s *= 100),
    e + "(" + s + r + ")"
}
const R7 = /([a-z-]*)\(.*?\)/g
  , G_ = {
    ...oa,
    getAnimatableNone: n=>{
        const e = n.match(R7);
        return e ? e.map(B7).join(" ") : n
    }
}
  , I7 = {
    ...vL,
    color: pi,
    backgroundColor: pi,
    outlineColor: pi,
    fill: pi,
    stroke: pi,
    borderColor: pi,
    borderTopColor: pi,
    borderRightColor: pi,
    borderBottomColor: pi,
    borderLeftColor: pi,
    filter: G_,
    WebkitFilter: G_
}
  , ES = n=>I7[n];
function TS(n, e) {
    let t = ES(n);
    return t !== G_ && (t = oa),
    t.getAnimatableNone ? t.getAnimatableNone(e) : void 0
}
const zL = n=>e=>e.test(n)
  , L7 = {
    test: n=>n === "auto",
    parse: n=>n
}
  , GL = [kl, st, ds, To, FW, kW, L7]
  , bf = n=>GL.find(zL(n))
  , D7 = [...GL, pi, oa]
  , k7 = n=>D7.find(zL(n));
function F7(n) {
    const e = {};
    return n.values.forEach((t,i)=>e[i] = t.get()),
    e
}
function N7(n) {
    const e = {};
    return n.values.forEach((t,i)=>e[i] = t.getVelocity()),
    e
}
function Y0(n, e, t) {
    const i = n.getProps();
    return AS(i, e, t !== void 0 ? t : i.custom, F7(n), N7(n))
}
function O7(n, e, t) {
    n.hasValue(e) ? n.getValue(e).set(t) : n.addValue(e, hc(t))
}
function U7(n, e) {
    const t = Y0(n, e);
    let {transitionEnd: i={}, transition: r={}, ...s} = t ? n.makeTargetAnimatable(t, !1) : {};
    s = {
        ...s,
        ...i
    };
    for (const o in s) {
        const a = QW(s[o]);
        O7(n, o, a)
    }
}
function z7(n, e, t) {
    var i, r;
    const s = Object.keys(e).filter(a=>!n.hasValue(a))
      , o = s.length;
    if (o)
        for (let a = 0; a < o; a++) {
            const l = s[a]
              , c = e[l];
            let d = null;
            Array.isArray(c) && (d = c[0]),
            d === null && (d = (r = (i = t[l]) !== null && i !== void 0 ? i : n.readValue(l)) !== null && r !== void 0 ? r : e[l]),
            d != null && (typeof d == "string" && (m7(d) || g7(d)) ? d = parseFloat(d) : !k7(d) && oa.test(c) && (d = TS(l, c)),
            n.addValue(l, hc(d, {
                owner: n
            })),
            t[l] === void 0 && (t[l] = d),
            d !== null && n.setBaseTarget(l, d))
        }
}
function G7(n, e) {
    return e ? (e[n] || e.default || e).from : void 0
}
function H7(n, e, t) {
    const i = {};
    for (const r in n) {
        const s = G7(r, e);
        if (s !== void 0)
            i[r] = s;
        else {
            const o = t.getValue(r);
            o && (i[r] = o.get())
        }
    }
    return i
}
function Yg(n) {
    return Boolean(Di(n) && n.add)
}
const V7 = "framerAppearId"
  , W7 = "data-" + xS(V7);
let j7 = Ar
  , Kg = Ar;
const fg = n=>n * 1e3
  , J7 = {
    current: !1
}
  , PS = n=>e=>e <= .5 ? n(2 * e) / 2 : (2 - n(2 * (1 - e))) / 2
  , BS = n=>e=>1 - n(1 - e)
  , RS = n=>n * n
  , X7 = BS(RS)
  , IS = PS(RS)
  , ln = (n,e,t)=>-t * n + t * e + n;
function Bx(n, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * (2 / 3 - t) * 6 : n
}
function Y7({hue: n, saturation: e, lightness: t, alpha: i}) {
    n /= 360,
    e /= 100,
    t /= 100;
    let r = 0
      , s = 0
      , o = 0;
    if (!e)
        r = s = o = t;
    else {
        const a = t < .5 ? t * (1 + e) : t + e - t * e
          , l = 2 * t - a;
        r = Bx(l, a, n + 1 / 3),
        s = Bx(l, a, n),
        o = Bx(l, a, n - 1 / 3)
    }
    return {
        red: Math.round(r * 255),
        green: Math.round(s * 255),
        blue: Math.round(o * 255),
        alpha: i
    }
}
const Rx = (n,e,t)=>{
    const i = n * n;
    return Math.sqrt(Math.max(0, t * (e * e - i) + i))
}
  , K7 = [z_, rl, Du]
  , Q7 = n=>K7.find(e=>e.test(n));
function e2(n) {
    const e = Q7(n);
    let t = e.parse(n);
    return e === Du && (t = Y7(t)),
    t
}
const HL = (n,e)=>{
    const t = e2(n)
      , i = e2(e)
      , r = {
        ...t
    };
    return s=>(r.red = Rx(t.red, i.red, s),
    r.green = Rx(t.green, i.green, s),
    r.blue = Rx(t.blue, i.blue, s),
    r.alpha = ln(t.alpha, i.alpha, s),
    rl.transform(r))
}
;
function VL(n, e) {
    return typeof n == "number" ? t=>ln(n, e, t) : pi.test(n) ? HL(n, e) : jL(n, e)
}
const WL = (n,e)=>{
    const t = [...n]
      , i = t.length
      , r = n.map((s,o)=>VL(s, e[o]));
    return s=>{
        for (let o = 0; o < i; o++)
            t[o] = r[o](s);
        return t
    }
}
  , Z7 = (n,e)=>{
    const t = {
        ...n,
        ...e
    }
      , i = {};
    for (const r in t)
        n[r] !== void 0 && e[r] !== void 0 && (i[r] = VL(n[r], e[r]));
    return r=>{
        for (const s in i)
            t[s] = i[s](r);
        return t
    }
}
  , jL = (n,e)=>{
    const t = oa.createTransformer(e)
      , i = Xg(n)
      , r = Xg(e);
    return i.numColors === r.numColors && i.numNumbers >= r.numNumbers ? Zo(WL(i.values, r.values), t) : o=>`${o > 0 ? e : n}`
}
  , zd = (n,e,t)=>{
    const i = e - n;
    return i === 0 ? 1 : (t - n) / i
}
  , t2 = (n,e)=>t=>ln(n, e, t);
function q7(n) {
    return typeof n == "number" ? t2 : typeof n == "string" ? pi.test(n) ? HL : jL : Array.isArray(n) ? WL : typeof n == "object" ? Z7 : t2
}
function $7(n, e, t) {
    const i = []
      , r = t || q7(n[0])
      , s = n.length - 1;
    for (let o = 0; o < s; o++) {
        let a = r(n[o], n[o + 1]);
        if (e) {
            const l = Array.isArray(e) ? e[o] : e;
            a = Zo(l, a)
        }
        i.push(a)
    }
    return i
}
function JL(n, e, {clamp: t=!0, ease: i, mixer: r}={}) {
    const s = n.length;
    Kg(s === e.length),
    Kg(!i || !Array.isArray(i) || i.length === s - 1),
    n[0] > n[s - 1] && (n = [...n].reverse(),
    e = [...e].reverse());
    const o = $7(e, i, r)
      , a = o.length
      , l = c=>{
        let d = 0;
        if (a > 1)
            for (; d < n.length - 2 && !(c < n[d + 1]); d++)
                ;
        const h = zd(n[d], n[d + 1], c);
        return o[d](h)
    }
    ;
    return t ? c=>l(dc(n[0], n[s - 1], c)) : l
}
function ej(n, e) {
    const t = n[n.length - 1];
    for (let i = 1; i <= e; i++) {
        const r = zd(0, e, i);
        n.push(ln(t, 1, r))
    }
}
function tj(n) {
    const e = [0];
    return ej(e, n.length - 1),
    e
}
function nj(n, e) {
    return n.map(t=>t * e)
}
const XL = (n,e,t)=>(((1 - 3 * t + 3 * e) * n + (3 * t - 6 * e)) * n + 3 * e) * n
  , ij = 1e-7
  , rj = 12;
function sj(n, e, t, i, r) {
    let s, o, a = 0;
    do
        o = e + (t - e) / 2,
        s = XL(o, i, r) - n,
        s > 0 ? t = o : e = o;
    while (Math.abs(s) > ij && ++a < rj);
    return o
}
function YL(n, e, t, i) {
    if (n === e && t === i)
        return Ar;
    const r = s=>sj(s, 0, 1, n, t);
    return s=>s === 0 || s === 1 ? s : XL(r(s), e, i)
}
const KL = n=>1 - Math.sin(Math.acos(n))
  , LS = BS(KL)
  , oj = PS(LS)
  , QL = YL(.33, 1.53, .69, .99)
  , DS = BS(QL)
  , aj = PS(DS)
  , lj = n=>(n *= 2) < 1 ? .5 * DS(n) : .5 * (2 - Math.pow(2, -10 * (n - 1)))
  , uj = {
    linear: Ar,
    easeIn: RS,
    easeInOut: IS,
    easeOut: X7,
    circIn: KL,
    circInOut: oj,
    circOut: LS,
    backIn: DS,
    backInOut: aj,
    backOut: QL,
    anticipate: lj
}
  , n2 = n=>{
    if (Array.isArray(n)) {
        Kg(n.length === 4);
        const [e,t,i,r] = n;
        return YL(e, t, i, r)
    } else if (typeof n == "string")
        return uj[n];
    return n
}
  , cj = n=>Array.isArray(n) && typeof n[0] != "number";
function fj(n, e) {
    return n.map(()=>e || IS).splice(0, n.length - 1)
}
function H_({keyframes: n, ease: e=IS, times: t, duration: i=300}) {
    n = [...n];
    const r = cj(e) ? e.map(n2) : n2(e)
      , s = {
        done: !1,
        value: n[0]
    }
      , o = nj(t && t.length === n.length ? t : tj(n), i);
    function a() {
        return JL(o, n, {
            ease: Array.isArray(r) ? r : fj(n, r)
        })
    }
    let l = a();
    return {
        next: c=>(s.value = l(c),
        s.done = c >= i,
        s),
        flipTarget: ()=>{
            n.reverse(),
            l = a()
        }
    }
}
const Ix = .001
  , dj = .01
  , i2 = 10
  , hj = .05
  , pj = 1;
function mj({duration: n=800, bounce: e=.25, velocity: t=0, mass: i=1}) {
    let r, s;
    j7(n <= i2 * 1e3);
    let o = 1 - e;
    o = dc(hj, pj, o),
    n = dc(dj, i2, n / 1e3),
    o < 1 ? (r = c=>{
        const d = c * o
          , h = d * n
          , p = d - t
          , m = V_(c, o)
          , y = Math.exp(-h);
        return Ix - p / m * y
    }
    ,
    s = c=>{
        const h = c * o * n
          , p = h * t + t
          , m = Math.pow(o, 2) * Math.pow(c, 2) * n
          , y = Math.exp(-h)
          , v = V_(Math.pow(c, 2), o);
        return (-r(c) + Ix > 0 ? -1 : 1) * ((p - m) * y) / v
    }
    ) : (r = c=>{
        const d = Math.exp(-c * n)
          , h = (c - t) * n + 1;
        return -Ix + d * h
    }
    ,
    s = c=>{
        const d = Math.exp(-c * n)
          , h = (t - c) * (n * n);
        return d * h
    }
    );
    const a = 5 / n
      , l = vj(r, s, a);
    if (n = n * 1e3,
    isNaN(l))
        return {
            stiffness: 100,
            damping: 10,
            duration: n
        };
    {
        const c = Math.pow(l, 2) * i;
        return {
            stiffness: c,
            damping: o * 2 * Math.sqrt(i * c),
            duration: n
        }
    }
}
const gj = 12;
function vj(n, e, t) {
    let i = t;
    for (let r = 1; r < gj; r++)
        i = i - n(i) / e(i);
    return i
}
function V_(n, e) {
    return n * Math.sqrt(1 - e * e)
}
const yj = ["duration", "bounce"]
  , xj = ["stiffness", "damping", "mass"];
function r2(n, e) {
    return e.some(t=>n[t] !== void 0)
}
function _j(n) {
    let e = {
        velocity: 0,
        stiffness: 100,
        damping: 10,
        mass: 1,
        isResolvedFromDuration: !1,
        ...n
    };
    if (!r2(n, xj) && r2(n, yj)) {
        const t = mj(n);
        e = {
            ...e,
            ...t,
            velocity: 0,
            mass: 1
        },
        e.isResolvedFromDuration = !0
    }
    return e
}
const Aj = 5;
function ZL({keyframes: n, restDelta: e, restSpeed: t, ...i}) {
    let r = n[0]
      , s = n[n.length - 1];
    const o = {
        done: !1,
        value: r
    }
      , {stiffness: a, damping: l, mass: c, velocity: d, duration: h, isResolvedFromDuration: p} = _j(i);
    let m = wj
      , y = d ? -(d / 1e3) : 0;
    const v = l / (2 * Math.sqrt(a * c));
    function x() {
        const _ = s - r
          , A = Math.sqrt(a / c) / 1e3
          , w = Math.abs(_) < 5;
        if (t || (t = w ? .01 : 2),
        e || (e = w ? .005 : .5),
        v < 1) {
            const M = V_(A, v);
            m = C=>{
                const P = Math.exp(-v * A * C);
                return s - P * ((y + v * A * _) / M * Math.sin(M * C) + _ * Math.cos(M * C))
            }
        } else if (v === 1)
            m = M=>s - Math.exp(-A * M) * (_ + (y + A * _) * M);
        else {
            const M = A * Math.sqrt(v * v - 1);
            m = C=>{
                const P = Math.exp(-v * A * C)
                  , R = Math.min(M * C, 300);
                return s - P * ((y + v * A * _) * Math.sinh(R) + M * _ * Math.cosh(R)) / M
            }
        }
    }
    return x(),
    {
        next: _=>{
            const A = m(_);
            if (p)
                o.done = _ >= h;
            else {
                let w = y;
                if (_ !== 0)
                    if (v < 1) {
                        const P = Math.max(0, _ - Aj);
                        w = bS(A - m(P), _ - P)
                    } else
                        w = 0;
                const M = Math.abs(w) <= t
                  , C = Math.abs(s - A) <= e;
                o.done = M && C
            }
            return o.value = o.done ? s : A,
            o
        }
        ,
        flipTarget: ()=>{
            y = -y,
            [r,s] = [s, r],
            x()
        }
    }
}
ZL.needsInterpolation = (n,e)=>typeof n == "string" || typeof e == "string";
const wj = n=>0;
function Sj({keyframes: n=[0], velocity: e=0, power: t=.8, timeConstant: i=350, restDelta: r=.5, modifyTarget: s}) {
    const o = n[0]
      , a = {
        done: !1,
        value: o
    };
    let l = t * e;
    const c = o + l
      , d = s === void 0 ? c : s(c);
    return d !== c && (l = d - o),
    {
        next: h=>{
            const p = -l * Math.exp(-h / i);
            return a.done = !(p > r || p < -r),
            a.value = a.done ? d : d + p,
            a
        }
        ,
        flipTarget: ()=>{}
    }
}
const Mj = {
    decay: Sj,
    keyframes: H_,
    tween: H_,
    spring: ZL
};
function qL(n, e, t=0) {
    return n - e - t
}
function bj(n, e=0, t=0, i=!0) {
    return i ? qL(e + -n, e, t) : e - (n - e) + t
}
function Cj(n, e, t, i) {
    return i ? n >= e + t : n <= -t
}
const Ej = n=>{
    const e = ({delta: t})=>n(t);
    return {
        start: ()=>yi.update(e, !0),
        stop: ()=>sa.update(e)
    }
}
;
function Qg({duration: n, driver: e=Ej, elapsed: t=0, repeat: i=0, repeatType: r="loop", repeatDelay: s=0, keyframes: o, autoplay: a=!0, onPlay: l, onStop: c, onComplete: d, onRepeat: h, onUpdate: p, type: m="keyframes", ...y}) {
    const v = t;
    let x, _ = 0, A = n, w = !1, M = !0, C;
    const P = Mj[o.length > 2 ? "keyframes" : m] || H_
      , R = o[0]
      , E = o[o.length - 1];
    let B = {
        done: !1,
        value: R
    };
    const {needsInterpolation: I} = P;
    I && I(R, E) && (C = JL([0, 100], [R, E], {
        clamp: !1
    }),
    o = [0, 100]);
    const z = P({
        ...y,
        duration: n,
        keyframes: o
    });
    function q() {
        _++,
        r === "reverse" ? (M = _ % 2 === 0,
        t = bj(t, A, s, M)) : (t = qL(t, A, s),
        r === "mirror" && z.flipTarget()),
        w = !1,
        h && h()
    }
    function W() {
        x && x.stop(),
        d && d()
    }
    function G(ne) {
        M || (ne = -ne),
        t += ne,
        w || (B = z.next(Math.max(0, t)),
        C && (B.value = C(B.value)),
        w = M ? B.done : t <= 0),
        p && p(B.value),
        w && (_ === 0 && (A = A !== void 0 ? A : t),
        _ < i ? Cj(t, A, s, M) && q() : W())
    }
    function K() {
        l && l(),
        x = e(G),
        x.start()
    }
    return a && K(),
    {
        stop: ()=>{
            c && c(),
            x && x.stop()
        }
        ,
        set currentTime(ne) {
            t = v,
            G(ne)
        },
        sample: ne=>{
            t = v;
            const oe = n && typeof n == "number" ? Math.max(n * .5, 50) : 50;
            let F = 0;
            for (G(0); F <= ne; ) {
                const V = ne - F;
                G(Math.min(V, oe)),
                F += oe
            }
            return B
        }
    }
}
function Tj(n) {
    return !n || Array.isArray(n) || typeof n == "string" && $L[n]
}
const Lf = ([n,e,t,i])=>`cubic-bezier(${n}, ${e}, ${t}, ${i})`
  , $L = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: Lf([0, .65, .55, 1]),
    circOut: Lf([.55, 0, 1, .45]),
    backIn: Lf([.31, .01, .66, -.59]),
    backOut: Lf([.33, 1.53, .69, .99])
};
function Pj(n) {
    if (n)
        return Array.isArray(n) ? Lf(n) : $L[n]
}
function Bj(n, e, t, {delay: i=0, duration: r, repeat: s=0, repeatType: o="loop", ease: a, times: l}={}) {
    return n.animate({
        [e]: t,
        offset: l
    }, {
        delay: i,
        duration: r,
        easing: Pj(a),
        fill: "both",
        iterations: s + 1,
        direction: o === "reverse" ? "alternate" : "normal"
    })
}
const s2 = {
    waapi: ()=>Object.hasOwnProperty.call(Element.prototype, "animate")
}
  , Lx = {}
  , eD = {};
for (const n in s2)
    eD[n] = ()=>(Lx[n] === void 0 && (Lx[n] = s2[n]()),
    Lx[n]);
function Rj(n, {repeat: e, repeatType: t="loop"}) {
    const i = e && t !== "loop" && e % 2 === 1 ? 0 : n.length - 1;
    return n[i]
}
const Ij = new Set(["opacity", "clipPath", "filter", "transform"])
  , Bm = 10;
function Lj(n, e, {onUpdate: t, onComplete: i, ...r}) {
    if (!(eD.waapi() && Ij.has(e) && !r.repeatDelay && r.repeatType !== "mirror" && r.damping !== 0))
        return !1;
    let {keyframes: o, duration: a=300, elapsed: l=0, ease: c} = r;
    if (r.type === "spring" || !Tj(r.ease)) {
        if (r.repeat === 1 / 0)
            return;
        const h = Qg({
            ...r,
            elapsed: 0
        });
        let p = {
            done: !1,
            value: o[0]
        };
        const m = [];
        let y = 0;
        for (; !p.done && y < 2e4; )
            p = h.sample(y),
            m.push(p.value),
            y += Bm;
        o = m,
        a = y - Bm,
        c = "linear"
    }
    const d = Bj(n.owner.current, e, o, {
        ...r,
        delay: -l,
        duration: a,
        ease: c
    });
    return d.onfinish = ()=>{
        n.set(Rj(o, r)),
        yi.update(()=>d.cancel()),
        i && i()
    }
    ,
    {
        get currentTime() {
            return d.currentTime || 0
        },
        set currentTime(h) {
            d.currentTime = h
        },
        stop: ()=>{
            const {currentTime: h} = d;
            if (h) {
                const p = Qg({
                    ...r,
                    autoplay: !1
                });
                n.setWithVelocity(p.sample(h - Bm).value, p.sample(h).value, Bm)
            }
            yi.update(()=>d.cancel())
        }
    }
}
function tD(n, e) {
    const t = performance.now()
      , i = ({timestamp: r})=>{
        const s = r - t;
        s >= e && (sa.read(i),
        n(s - e))
    }
    ;
    return yi.read(i, !0),
    ()=>sa.read(i)
}
function Dj({keyframes: n, elapsed: e, onUpdate: t, onComplete: i}) {
    const r = ()=>{
        t && t(n[n.length - 1]),
        i && i()
    }
    ;
    return e ? {
        stop: tD(r, -e)
    } : r()
}
function kj({keyframes: n, velocity: e=0, min: t, max: i, power: r=.8, timeConstant: s=750, bounceStiffness: o=500, bounceDamping: a=10, restDelta: l=1, modifyTarget: c, driver: d, onUpdate: h, onComplete: p, onStop: m}) {
    const y = n[0];
    let v;
    function x(M) {
        return t !== void 0 && M < t || i !== void 0 && M > i
    }
    function _(M) {
        return t === void 0 ? i : i === void 0 || Math.abs(t - M) < Math.abs(i - M) ? t : i
    }
    function A(M) {
        v && v.stop(),
        v = Qg({
            keyframes: [0, 1],
            velocity: 0,
            ...M,
            driver: d,
            onUpdate: C=>{
                h && h(C),
                M.onUpdate && M.onUpdate(C)
            }
            ,
            onComplete: p,
            onStop: m
        })
    }
    function w(M) {
        A({
            type: "spring",
            stiffness: o,
            damping: a,
            restDelta: l,
            ...M
        })
    }
    if (x(y))
        w({
            velocity: e,
            keyframes: [y, _(y)]
        });
    else {
        let M = r * e + y;
        typeof c < "u" && (M = c(M));
        const C = _(M)
          , P = C === t ? -1 : 1;
        let R, E;
        const B = I=>{
            R = E,
            E = I,
            e = bS(I - R, Xs.delta),
            (P === 1 && I > C || P === -1 && I < C) && w({
                keyframes: [I, C],
                velocity: e
            })
        }
        ;
        A({
            type: "decay",
            keyframes: [y, 0],
            velocity: e,
            timeConstant: s,
            power: r,
            restDelta: l,
            modifyTarget: c,
            onUpdate: x(M) ? B : void 0
        })
    }
    return {
        stop: ()=>v && v.stop()
    }
}
const Fj = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
}
  , Nj = n=>({
    type: "spring",
    stiffness: 550,
    damping: n === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
})
  , Oj = {
    type: "keyframes",
    duration: .8
}
  , Uj = {
    type: "keyframes",
    ease: [.25, .1, .35, 1],
    duration: .3
}
  , zj = (n,{keyframes: e})=>e.length > 2 ? Oj : Dl.has(n) ? n.startsWith("scale") ? Nj(e[1]) : Fj : Uj
  , W_ = (n,e)=>n === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && oa.test(e) && !e.startsWith("url("));
function Gj({when: n, delay: e, delayChildren: t, staggerChildren: i, staggerDirection: r, repeat: s, repeatType: o, repeatDelay: a, from: l, elapsed: c, ...d}) {
    return !!Object.keys(d).length
}
function o2(n) {
    return n === 0 || typeof n == "string" && parseFloat(n) === 0 && n.indexOf(" ") === -1
}
function a2(n) {
    return typeof n == "number" ? 0 : TS("", n)
}
function nD(n, e) {
    return n[e] || n.default || n
}
function Hj(n, e, t, i) {
    const r = W_(e, t);
    let s = i.from !== void 0 ? i.from : n.get();
    return s === "none" && r && typeof t == "string" ? s = TS(e, t) : o2(s) && typeof t == "string" ? s = a2(t) : !Array.isArray(t) && o2(t) && typeof s == "string" && (t = a2(s)),
    Array.isArray(t) ? (t[0] === null && (t[0] = s),
    t) : [s, t]
}
const kS = (n,e,t,i={})=>r=>{
    const s = nD(i, n) || {}
      , o = s.delay || i.delay || 0;
    let {elapsed: a=0} = i;
    a = a - fg(o);
    const l = Hj(e, n, t, s)
      , c = l[0]
      , d = l[l.length - 1]
      , h = W_(n, c)
      , p = W_(n, d);
    let m = {
        keyframes: l,
        velocity: e.getVelocity(),
        ...s,
        elapsed: a,
        onUpdate: y=>{
            e.set(y),
            s.onUpdate && s.onUpdate(y)
        }
        ,
        onComplete: ()=>{
            r(),
            s.onComplete && s.onComplete()
        }
    };
    if (!h || !p || J7.current || s.type === !1)
        return Dj(m);
    if (s.type === "inertia")
        return kj(m);
    if (Gj(s) || (m = {
        ...m,
        ...zj(n, m)
    }),
    m.duration && (m.duration = fg(m.duration)),
    m.repeatDelay && (m.repeatDelay = fg(m.repeatDelay)),
    e.owner && e.owner.current instanceof HTMLElement && !e.owner.getProps().onUpdate) {
        const y = Lj(e, n, m);
        if (y)
            return y
    }
    return Qg(m)
}
;
function Vj(n, e, t={}) {
    n.notify("AnimationStart", e);
    let i;
    if (Array.isArray(e)) {
        const r = e.map(s=>j_(n, s, t));
        i = Promise.all(r)
    } else if (typeof e == "string")
        i = j_(n, e, t);
    else {
        const r = typeof e == "function" ? Y0(n, e, t.custom) : e;
        i = iD(n, r, t)
    }
    return i.then(()=>n.notify("AnimationComplete", e))
}
function j_(n, e, t={}) {
    const i = Y0(n, e, t.custom);
    let {transition: r=n.getDefaultTransition() || {}} = i || {};
    t.transitionOverride && (r = t.transitionOverride);
    const s = i ? ()=>iD(n, i, t) : ()=>Promise.resolve()
      , o = n.variantChildren && n.variantChildren.size ? (l=0)=>{
        const {delayChildren: c=0, staggerChildren: d, staggerDirection: h} = r;
        return Wj(n, e, c + l, d, h, t)
    }
    : ()=>Promise.resolve()
      , {when: a} = r;
    if (a) {
        const [l,c] = a === "beforeChildren" ? [s, o] : [o, s];
        return l().then(c)
    } else
        return Promise.all([s(), o(t.delay)])
}
function iD(n, e, {delay: t=0, transitionOverride: i, type: r}={}) {
    let {transition: s=n.getDefaultTransition(), transitionEnd: o, ...a} = n.makeTargetAnimatable(e);
    const l = n.getValue("willChange");
    i && (s = i);
    const c = []
      , d = r && n.animationState && n.animationState.getState()[r];
    for (const h in a) {
        const p = n.getValue(h)
          , m = a[h];
        if (!p || m === void 0 || d && Jj(d, h))
            continue;
        const y = {
            delay: t,
            elapsed: 0,
            ...s
        };
        if (window.HandoffAppearAnimations && !p.hasAnimated) {
            const x = n.getProps()[W7];
            x && (y.elapsed = window.HandoffAppearAnimations(x, h, p, yi))
        }
        let v = p.start(kS(h, p, m, n.shouldReduceMotion && Dl.has(h) ? {
            type: !1
        } : y));
        Yg(l) && (l.add(h),
        v = v.then(()=>l.remove(h))),
        c.push(v)
    }
    return Promise.all(c).then(()=>{
        o && U7(n, o)
    }
    )
}
function Wj(n, e, t=0, i=0, r=1, s) {
    const o = []
      , a = (n.variantChildren.size - 1) * i
      , l = r === 1 ? (c=0)=>c * i : (c=0)=>a - c * i;
    return Array.from(n.variantChildren).sort(jj).forEach((c,d)=>{
        c.notify("AnimationStart", e),
        o.push(j_(c, e, {
            ...s,
            delay: t + l(d)
        }).then(()=>c.notify("AnimationComplete", e)))
    }
    ),
    Promise.all(o)
}
function jj(n, e) {
    return n.sortNodePosition(e)
}
function Jj({protectedKeys: n, needsAnimating: e}, t) {
    const i = n.hasOwnProperty(t) && e[t] !== !0;
    return e[t] = !1,
    i
}
const Xj = [...dS].reverse()
  , Yj = dS.length;
function Kj(n) {
    return e=>Promise.all(e.map(({animation: t, options: i})=>Vj(n, t, i)))
}
function Qj(n) {
    let e = Kj(n);
    const t = qj();
    let i = !0;
    const r = (l,c)=>{
        const d = Y0(n, c);
        if (d) {
            const {transition: h, transitionEnd: p, ...m} = d;
            l = {
                ...l,
                ...m,
                ...p
            }
        }
        return l
    }
    ;
    function s(l) {
        e = l(n)
    }
    function o(l, c) {
        const d = n.getProps()
          , h = n.getVariantContext(!0) || {}
          , p = []
          , m = new Set;
        let y = {}
          , v = 1 / 0;
        for (let _ = 0; _ < Yj; _++) {
            const A = Xj[_]
              , w = t[A]
              , M = d[A] !== void 0 ? d[A] : h[A]
              , C = Fd(M)
              , P = A === c ? w.isActive : null;
            P === !1 && (v = _);
            let R = M === h[A] && M !== d[A] && C;
            if (R && i && n.manuallyAnimateOnMount && (R = !1),
            w.protectedKeys = {
                ...y
            },
            !w.isActive && P === null || !M && !w.prevProp || V0(M) || typeof M == "boolean")
                continue;
            const E = Zj(w.prevProp, M);
            let B = E || A === c && w.isActive && !R && C || _ > v && C;
            const I = Array.isArray(M) ? M : [M];
            let z = I.reduce(r, {});
            P === !1 && (z = {});
            const {prevResolvedValues: q={}} = w
              , W = {
                ...q,
                ...z
            }
              , G = K=>{
                B = !0,
                m.delete(K),
                w.needsAnimating[K] = !0
            }
            ;
            for (const K in W) {
                const ne = z[K]
                  , oe = q[K];
                y.hasOwnProperty(K) || (ne !== oe ? Jg(ne) && Jg(oe) ? !RL(ne, oe) || E ? G(K) : w.protectedKeys[K] = !0 : ne !== void 0 ? G(K) : m.add(K) : ne !== void 0 && m.has(K) ? G(K) : w.protectedKeys[K] = !0)
            }
            w.prevProp = M,
            w.prevResolvedValues = z,
            w.isActive && (y = {
                ...y,
                ...z
            }),
            i && n.blockInitialAnimation && (B = !1),
            B && !R && p.push(...I.map(K=>({
                animation: K,
                options: {
                    type: A,
                    ...l
                }
            })))
        }
        if (m.size) {
            const _ = {};
            m.forEach(A=>{
                const w = n.getBaseTarget(A);
                w !== void 0 && (_[A] = w)
            }
            ),
            p.push({
                animation: _
            })
        }
        let x = Boolean(p.length);
        return i && d.initial === !1 && !n.manuallyAnimateOnMount && (x = !1),
        i = !1,
        x ? e(p) : Promise.resolve()
    }
    function a(l, c, d) {
        var h;
        if (t[l].isActive === c)
            return Promise.resolve();
        (h = n.variantChildren) === null || h === void 0 || h.forEach(m=>{
            var y;
            return (y = m.animationState) === null || y === void 0 ? void 0 : y.setActive(l, c)
        }
        ),
        t[l].isActive = c;
        const p = o(d, l);
        for (const m in t)
            t[m].protectedKeys = {};
        return p
    }
    return {
        animateChanges: o,
        setActive: a,
        setAnimateFunction: s,
        getState: ()=>t
    }
}
function Zj(n, e) {
    return typeof e == "string" ? e !== n : Array.isArray(e) ? !RL(e, n) : !1
}
function Oa(n=!1) {
    return {
        isActive: n,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {}
    }
}
function qj() {
    return {
        animate: Oa(!0),
        whileInView: Oa(),
        whileHover: Oa(),
        whileTap: Oa(),
        whileDrag: Oa(),
        whileFocus: Oa(),
        exit: Oa()
    }
}
class $j extends ya {
    constructor(e) {
        super(e),
        e.animationState || (e.animationState = Qj(e))
    }
    updateAnimationControlsSubscription() {
        const {animate: e} = this.node.getProps();
        this.unmount(),
        V0(e) && (this.unmount = e.subscribe(this.node))
    }
    mount() {
        this.updateAnimationControlsSubscription()
    }
    update() {
        const {animate: e} = this.node.getProps()
          , {animate: t} = this.node.prevProps || {};
        e !== t && this.updateAnimationControlsSubscription()
    }
    unmount() {}
}
let eJ = 0;
class tJ extends ya {
    constructor() {
        super(...arguments),
        this.id = eJ++
    }
    update() {
        if (!this.node.presenceContext)
            return;
        const {isPresent: e, onExitComplete: t, custom: i} = this.node.presenceContext
          , {isPresent: r} = this.node.prevPresenceContext || {};
        if (!this.node.animationState || e === r)
            return;
        const s = this.node.animationState.setActive("exit", !e, {
            custom: i ?? this.node.getProps().custom
        });
        t && !e && s.then(()=>t(this.id))
    }
    mount() {
        const {register: e} = this.node.presenceContext || {};
        e && (this.unmount = e(this.id))
    }
    unmount() {}
}
const nJ = {
    animation: {
        Feature: $j
    },
    exit: {
        Feature: tJ
    }
}
  , l2 = (n,e)=>Math.abs(n - e);
function iJ(n, e) {
    const t = l2(n.x, e.x)
      , i = l2(n.y, e.y);
    return Math.sqrt(t ** 2 + i ** 2)
}
class rD {
    constructor(e, t, {transformPagePoint: i}={}) {
        if (this.startEvent = null,
        this.lastMoveEvent = null,
        this.lastMoveEventInfo = null,
        this.handlers = {},
        this.updatePoint = ()=>{
            if (!(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const c = kx(this.lastMoveEventInfo, this.history)
              , d = this.startEvent !== null
              , h = iJ(c.offset, {
                x: 0,
                y: 0
            }) >= 3;
            if (!d && !h)
                return;
            const {point: p} = c
              , {timestamp: m} = Xs;
            this.history.push({
                ...p,
                timestamp: m
            });
            const {onStart: y, onMove: v} = this.handlers;
            d || (y && y(this.lastMoveEvent, c),
            this.startEvent = this.lastMoveEvent),
            v && v(this.lastMoveEvent, c)
        }
        ,
        this.handlePointerMove = (c,d)=>{
            this.lastMoveEvent = c,
            this.lastMoveEventInfo = Dx(d, this.transformPagePoint),
            yi.update(this.updatePoint, !0)
        }
        ,
        this.handlePointerUp = (c,d)=>{
            if (this.end(),
            !(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const {onEnd: h, onSessionEnd: p} = this.handlers
              , m = kx(c.type === "pointercancel" ? this.lastMoveEventInfo : Dx(d, this.transformPagePoint), this.history);
            this.startEvent && h && h(c, m),
            p && p(c, m)
        }
        ,
        !CL(e))
            return;
        this.handlers = t,
        this.transformPagePoint = i;
        const r = J0(e)
          , s = Dx(r, this.transformPagePoint)
          , {point: o} = s
          , {timestamp: a} = Xs;
        this.history = [{
            ...o,
            timestamp: a
        }];
        const {onSessionStart: l} = t;
        l && l(e, kx(s, this.history)),
        this.removeListeners = Zo(Js(window, "pointermove", this.handlePointerMove), Js(window, "pointerup", this.handlePointerUp), Js(window, "pointercancel", this.handlePointerUp))
    }
    updateHandlers(e) {
        this.handlers = e
    }
    end() {
        this.removeListeners && this.removeListeners(),
        sa.update(this.updatePoint)
    }
}
function Dx(n, e) {
    return e ? {
        point: e(n.point)
    } : n
}
function u2(n, e) {
    return {
        x: n.x - e.x,
        y: n.y - e.y
    }
}
function kx({point: n}, e) {
    return {
        point: n,
        delta: u2(n, sD(e)),
        offset: u2(n, rJ(e)),
        velocity: sJ(e, .1)
    }
}
function rJ(n) {
    return n[0]
}
function sD(n) {
    return n[n.length - 1]
}
function sJ(n, e) {
    if (n.length < 2)
        return {
            x: 0,
            y: 0
        };
    let t = n.length - 1
      , i = null;
    const r = sD(n);
    for (; t >= 0 && (i = n[t],
    !(r.timestamp - i.timestamp > fg(e))); )
        t--;
    if (!i)
        return {
            x: 0,
            y: 0
        };
    const s = (r.timestamp - i.timestamp) / 1e3;
    if (s === 0)
        return {
            x: 0,
            y: 0
        };
    const o = {
        x: (r.x - i.x) / s,
        y: (r.y - i.y) / s
    };
    return o.x === 1 / 0 && (o.x = 0),
    o.y === 1 / 0 && (o.y = 0),
    o
}
function Ki(n) {
    return n.max - n.min
}
function J_(n, e=0, t=.01) {
    return Math.abs(n - e) <= t
}
function c2(n, e, t, i=.5) {
    n.origin = i,
    n.originPoint = ln(e.min, e.max, n.origin),
    n.scale = Ki(t) / Ki(e),
    (J_(n.scale, 1, 1e-4) || isNaN(n.scale)) && (n.scale = 1),
    n.translate = ln(t.min, t.max, n.origin) - n.originPoint,
    (J_(n.translate) || isNaN(n.translate)) && (n.translate = 0)
}
function Zf(n, e, t, i) {
    c2(n.x, e.x, t.x, i ? i.originX : void 0),
    c2(n.y, e.y, t.y, i ? i.originY : void 0)
}
function f2(n, e, t) {
    n.min = t.min + e.min,
    n.max = n.min + Ki(e)
}
function oJ(n, e, t) {
    f2(n.x, e.x, t.x),
    f2(n.y, e.y, t.y)
}
function d2(n, e, t) {
    n.min = e.min - t.min,
    n.max = n.min + Ki(e)
}
function qf(n, e, t) {
    d2(n.x, e.x, t.x),
    d2(n.y, e.y, t.y)
}
function aJ(n, {min: e, max: t}, i) {
    return e !== void 0 && n < e ? n = i ? ln(e, n, i.min) : Math.max(n, e) : t !== void 0 && n > t && (n = i ? ln(t, n, i.max) : Math.min(n, t)),
    n
}
function h2(n, e, t) {
    return {
        min: e !== void 0 ? n.min + e : void 0,
        max: t !== void 0 ? n.max + t - (n.max - n.min) : void 0
    }
}
function lJ(n, {top: e, left: t, bottom: i, right: r}) {
    return {
        x: h2(n.x, t, r),
        y: h2(n.y, e, i)
    }
}
function p2(n, e) {
    let t = e.min - n.min
      , i = e.max - n.max;
    return e.max - e.min < n.max - n.min && ([t,i] = [i, t]),
    {
        min: t,
        max: i
    }
}
function uJ(n, e) {
    return {
        x: p2(n.x, e.x),
        y: p2(n.y, e.y)
    }
}
function cJ(n, e) {
    let t = .5;
    const i = Ki(n)
      , r = Ki(e);
    return r > i ? t = zd(e.min, e.max - i, n.min) : i > r && (t = zd(n.min, n.max - r, e.min)),
    dc(0, 1, t)
}
function fJ(n, e) {
    const t = {};
    return e.min !== void 0 && (t.min = e.min - n.min),
    e.max !== void 0 && (t.max = e.max - n.min),
    t
}
const X_ = .35;
function dJ(n=X_) {
    return n === !1 ? n = 0 : n === !0 && (n = X_),
    {
        x: m2(n, "left", "right"),
        y: m2(n, "top", "bottom")
    }
}
function m2(n, e, t) {
    return {
        min: g2(n, e),
        max: g2(n, t)
    }
}
function g2(n, e) {
    return typeof n == "number" ? n : n[e] || 0
}
const v2 = ()=>({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
})
  , $f = ()=>({
    x: v2(),
    y: v2()
})
  , y2 = ()=>({
    min: 0,
    max: 0
})
  , Cn = ()=>({
    x: y2(),
    y: y2()
});
function ss(n) {
    return [n("x"), n("y")]
}
function oD({top: n, left: e, right: t, bottom: i}) {
    return {
        x: {
            min: e,
            max: t
        },
        y: {
            min: n,
            max: i
        }
    }
}
function hJ({x: n, y: e}) {
    return {
        top: e.min,
        right: n.max,
        bottom: e.max,
        left: n.min
    }
}
function pJ(n, e) {
    if (!e)
        return n;
    const t = e({
        x: n.left,
        y: n.top
    })
      , i = e({
        x: n.right,
        y: n.bottom
    });
    return {
        top: t.y,
        left: t.x,
        bottom: i.y,
        right: i.x
    }
}
function Fx(n) {
    return n === void 0 || n === 1
}
function Y_({scale: n, scaleX: e, scaleY: t}) {
    return !Fx(n) || !Fx(e) || !Fx(t)
}
function ja(n) {
    return Y_(n) || aD(n) || n.z || n.rotate || n.rotateX || n.rotateY
}
function aD(n) {
    return x2(n.x) || x2(n.y)
}
function x2(n) {
    return n && n !== "0%"
}
function Zg(n, e, t) {
    const i = n - t
      , r = e * i;
    return t + r
}
function _2(n, e, t, i, r) {
    return r !== void 0 && (n = Zg(n, r, i)),
    Zg(n, t, i) + e
}
function K_(n, e=0, t=1, i, r) {
    n.min = _2(n.min, e, t, i, r),
    n.max = _2(n.max, e, t, i, r)
}
function lD(n, {x: e, y: t}) {
    K_(n.x, e.translate, e.scale, e.originPoint),
    K_(n.y, t.translate, t.scale, t.originPoint)
}
function mJ(n, e, t, i=!1) {
    const r = t.length;
    if (!r)
        return;
    e.x = e.y = 1;
    let s, o;
    for (let a = 0; a < r; a++) {
        s = t[a],
        o = s.projectionDelta;
        const l = s.instance;
        l && l.style && l.style.display === "contents" || (i && s.options.layoutScroll && s.scroll && s !== s.root && ku(n, {
            x: -s.scroll.offset.x,
            y: -s.scroll.offset.y
        }),
        o && (e.x *= o.x.scale,
        e.y *= o.y.scale,
        lD(n, o)),
        i && ja(s.latestValues) && ku(n, s.latestValues))
    }
    e.x = A2(e.x),
    e.y = A2(e.y)
}
function A2(n) {
    return Number.isInteger(n) || n > 1.0000000000001 || n < .999999999999 ? n : 1
}
function Io(n, e) {
    n.min = n.min + e,
    n.max = n.max + e
}
function w2(n, e, [t,i,r]) {
    const s = e[r] !== void 0 ? e[r] : .5
      , o = ln(n.min, n.max, s);
    K_(n, e[t], e[i], o, e.scale)
}
const gJ = ["x", "scaleX", "originX"]
  , vJ = ["y", "scaleY", "originY"];
function ku(n, e) {
    w2(n.x, e, gJ),
    w2(n.y, e, vJ)
}
function uD(n, e) {
    return oD(pJ(n.getBoundingClientRect(), e))
}
function yJ(n, e, t) {
    const i = uD(n, t)
      , {scroll: r} = e;
    return r && (Io(i.x, r.offset.x),
    Io(i.y, r.offset.y)),
    i
}
const xJ = new WeakMap;
class _J {
    constructor(e) {
        this.openGlobalLock = null,
        this.isDragging = !1,
        this.currentDirection = null,
        this.originPoint = {
            x: 0,
            y: 0
        },
        this.constraints = !1,
        this.hasMutatedConstraints = !1,
        this.elastic = Cn(),
        this.visualElement = e
    }
    start(e, {snapToCursor: t=!1}={}) {
        const {presenceContext: i} = this.visualElement;
        if (i && i.isPresent === !1)
            return;
        const r = l=>{
            this.stopAnimation(),
            t && this.snapToCursor(J0(l, "page").point)
        }
          , s = (l,c)=>{
            const {drag: d, dragPropagation: h, onDragStart: p} = this.getProps();
            if (d && !h && (this.openGlobalLock && this.openGlobalLock(),
            this.openGlobalLock = TL(d),
            !this.openGlobalLock))
                return;
            this.isDragging = !0,
            this.currentDirection = null,
            this.resolveConstraints(),
            this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0,
            this.visualElement.projection.target = void 0),
            ss(y=>{
                let v = this.getAxisMotionValue(y).get() || 0;
                if (ds.test(v)) {
                    const {projection: x} = this.visualElement;
                    if (x && x.layout) {
                        const _ = x.layout.layoutBox[y];
                        _ && (v = Ki(_) * (parseFloat(v) / 100))
                    }
                }
                this.originPoint[y] = v
            }
            ),
            p && p(l, c);
            const {animationState: m} = this.visualElement;
            m && m.setActive("whileDrag", !0)
        }
          , o = (l,c)=>{
            const {dragPropagation: d, dragDirectionLock: h, onDirectionLock: p, onDrag: m} = this.getProps();
            if (!d && !this.openGlobalLock)
                return;
            const {offset: y} = c;
            if (h && this.currentDirection === null) {
                this.currentDirection = AJ(y),
                this.currentDirection !== null && p && p(this.currentDirection);
                return
            }
            this.updateAxis("x", c.point, y),
            this.updateAxis("y", c.point, y),
            this.visualElement.render(),
            m && m(l, c)
        }
          , a = (l,c)=>this.stop(l, c);
        this.panSession = new rD(e,{
            onSessionStart: r,
            onStart: s,
            onMove: o,
            onSessionEnd: a
        },{
            transformPagePoint: this.visualElement.getTransformPagePoint()
        })
    }
    stop(e, t) {
        const i = this.isDragging;
        if (this.cancel(),
        !i)
            return;
        const {velocity: r} = t;
        this.startAnimation(r);
        const {onDragEnd: s} = this.getProps();
        s && s(e, t)
    }
    cancel() {
        this.isDragging = !1;
        const {projection: e, animationState: t} = this.visualElement;
        e && (e.isAnimationBlocked = !1),
        this.panSession && this.panSession.end(),
        this.panSession = void 0;
        const {dragPropagation: i} = this.getProps();
        !i && this.openGlobalLock && (this.openGlobalLock(),
        this.openGlobalLock = null),
        t && t.setActive("whileDrag", !1)
    }
    updateAxis(e, t, i) {
        const {drag: r} = this.getProps();
        if (!i || !Rm(e, r, this.currentDirection))
            return;
        const s = this.getAxisMotionValue(e);
        let o = this.originPoint[e] + i[e];
        this.constraints && this.constraints[e] && (o = aJ(o, this.constraints[e], this.elastic[e])),
        s.set(o)
    }
    resolveConstraints() {
        const {dragConstraints: e, dragElastic: t} = this.getProps()
          , {layout: i} = this.visualElement.projection || {}
          , r = this.constraints;
        e && Lu(e) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : e && i ? this.constraints = lJ(i.layoutBox, e) : this.constraints = !1,
        this.elastic = dJ(t),
        r !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && ss(s=>{
            this.getAxisMotionValue(s) && (this.constraints[s] = fJ(i.layoutBox[s], this.constraints[s]))
        }
        )
    }
    resolveRefConstraints() {
        const {dragConstraints: e, onMeasureDragConstraints: t} = this.getProps();
        if (!e || !Lu(e))
            return !1;
        const i = e.current
          , {projection: r} = this.visualElement;
        if (!r || !r.layout)
            return !1;
        const s = yJ(i, r.root, this.visualElement.getTransformPagePoint());
        let o = uJ(r.layout.layoutBox, s);
        if (t) {
            const a = t(hJ(o));
            this.hasMutatedConstraints = !!a,
            a && (o = oD(a))
        }
        return o
    }
    startAnimation(e) {
        const {drag: t, dragMomentum: i, dragElastic: r, dragTransition: s, dragSnapToOrigin: o, onDragTransitionEnd: a} = this.getProps()
          , l = this.constraints || {}
          , c = ss(d=>{
            if (!Rm(d, t, this.currentDirection))
                return;
            let h = l && l[d] || {};
            o && (h = {
                min: 0,
                max: 0
            });
            const p = r ? 200 : 1e6
              , m = r ? 40 : 1e7
              , y = {
                type: "inertia",
                velocity: i ? e[d] : 0,
                bounceStiffness: p,
                bounceDamping: m,
                timeConstant: 750,
                restDelta: 1,
                restSpeed: 10,
                ...s,
                ...h
            };
            return this.startAxisValueAnimation(d, y)
        }
        );
        return Promise.all(c).then(a)
    }
    startAxisValueAnimation(e, t) {
        const i = this.getAxisMotionValue(e);
        return i.start(kS(e, i, 0, t))
    }
    stopAnimation() {
        ss(e=>this.getAxisMotionValue(e).stop())
    }
    getAxisMotionValue(e) {
        const t = "_drag" + e.toUpperCase()
          , i = this.visualElement.getProps()
          , r = i[t];
        return r || this.visualElement.getValue(e, (i.initial ? i.initial[e] : void 0) || 0)
    }
    snapToCursor(e) {
        ss(t=>{
            const {drag: i} = this.getProps();
            if (!Rm(t, i, this.currentDirection))
                return;
            const {projection: r} = this.visualElement
              , s = this.getAxisMotionValue(t);
            if (r && r.layout) {
                const {min: o, max: a} = r.layout.layoutBox[t];
                s.set(e[t] - ln(o, a, .5))
            }
        }
        )
    }
    scalePositionWithinConstraints() {
        if (!this.visualElement.current)
            return;
        const {drag: e, dragConstraints: t} = this.getProps()
          , {projection: i} = this.visualElement;
        if (!Lu(t) || !i || !this.constraints)
            return;
        this.stopAnimation();
        const r = {
            x: 0,
            y: 0
        };
        ss(o=>{
            const a = this.getAxisMotionValue(o);
            if (a) {
                const l = a.get();
                r[o] = cJ({
                    min: l,
                    max: l
                }, this.constraints[o])
            }
        }
        );
        const {transformTemplate: s} = this.visualElement.getProps();
        this.visualElement.current.style.transform = s ? s({}, "") : "none",
        i.root && i.root.updateScroll(),
        i.updateLayout(),
        this.resolveConstraints(),
        ss(o=>{
            if (!Rm(o, e, null))
                return;
            const a = this.getAxisMotionValue(o)
              , {min: l, max: c} = this.constraints[o];
            a.set(ln(l, c, r[o]))
        }
        )
    }
    addListeners() {
        if (!this.visualElement.current)
            return;
        xJ.set(this.visualElement, this);
        const e = this.visualElement.current
          , t = Js(e, "pointerdown", l=>{
            const {drag: c, dragListener: d=!0} = this.getProps();
            c && d && this.start(l)
        }
        )
          , i = ()=>{
            const {dragConstraints: l} = this.getProps();
            Lu(l) && (this.constraints = this.resolveRefConstraints())
        }
          , {projection: r} = this.visualElement
          , s = r.addEventListener("measure", i);
        r && !r.layout && (r.root && r.root.updateScroll(),
        r.updateLayout()),
        i();
        const o = Vs(window, "resize", ()=>this.scalePositionWithinConstraints())
          , a = r.addEventListener("didUpdate", ({delta: l, hasLayoutChanged: c})=>{
            this.isDragging && c && (ss(d=>{
                const h = this.getAxisMotionValue(d);
                h && (this.originPoint[d] += l[d].translate,
                h.set(h.get() + l[d].translate))
            }
            ),
            this.visualElement.render())
        }
        );
        return ()=>{
            o(),
            t(),
            s(),
            a && a()
        }
    }
    getProps() {
        const e = this.visualElement.getProps()
          , {drag: t=!1, dragDirectionLock: i=!1, dragPropagation: r=!1, dragConstraints: s=!1, dragElastic: o=X_, dragMomentum: a=!0} = e;
        return {
            ...e,
            drag: t,
            dragDirectionLock: i,
            dragPropagation: r,
            dragConstraints: s,
            dragElastic: o,
            dragMomentum: a
        }
    }
}
function Rm(n, e, t) {
    return (e === !0 || e === n) && (t === null || t === n)
}
function AJ(n, e=10) {
    let t = null;
    return Math.abs(n.y) > e ? t = "y" : Math.abs(n.x) > e && (t = "x"),
    t
}
class wJ extends ya {
    constructor(e) {
        super(e),
        this.removeGroupControls = Ar,
        this.removeListeners = Ar,
        this.controls = new _J(e)
    }
    mount() {
        const {dragControls: e} = this.node.getProps();
        e && (this.removeGroupControls = e.subscribe(this.controls)),
        this.removeListeners = this.controls.addListeners() || Ar
    }
    unmount() {
        this.removeGroupControls(),
        this.removeListeners()
    }
}
class SJ extends ya {
    constructor() {
        super(...arguments),
        this.removePointerDownListener = Ar
    }
    onPointerDown(e) {
        this.session = new rD(e,this.createPanHandlers(),{
            transformPagePoint: this.node.getTransformPagePoint()
        })
    }
    createPanHandlers() {
        const {onPanSessionStart: e, onPanStart: t, onPan: i, onPanEnd: r} = this.node.getProps();
        return {
            onSessionStart: e,
            onStart: t,
            onMove: i,
            onEnd: (s,o)=>{
                delete this.session,
                r && r(s, o)
            }
        }
    }
    mount() {
        this.removePointerDownListener = Js(this.node.current, "pointerdown", e=>this.onPointerDown(e))
    }
    update() {
        this.session && this.session.updateHandlers(this.createPanHandlers())
    }
    unmount() {
        this.removePointerDownListener(),
        this.session && this.session.end()
    }
}
function MJ() {
    const n = U.useContext(fS);
    if (n === null)
        return [!0, null];
    const {isPresent: e, onExitComplete: t, register: i} = n
      , r = U.useId();
    return U.useEffect(()=>i(r), []),
    !e && t ? [!1, ()=>t && t(r)] : [!0]
}
function S2(n, e) {
    return e.max === e.min ? 0 : n / (e.max - e.min) * 100
}
const Cf = {
    correct: (n,e)=>{
        if (!e.target)
            return n;
        if (typeof n == "string")
            if (st.test(n))
                n = parseFloat(n);
            else
                return n;
        const t = S2(n, e.target.x)
          , i = S2(n, e.target.y);
        return `${t}% ${i}%`
    }
}
  , cD = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function bJ(n) {
    const e = cD.exec(n);
    if (!e)
        return [, ];
    const [,t,i] = e;
    return [t, i]
}
function Q_(n, e, t=1) {
    const [i,r] = bJ(n);
    if (!i)
        return;
    const s = window.getComputedStyle(e).getPropertyValue(i);
    return s ? s.trim() : k_(r) ? Q_(r, e, t + 1) : r
}
function CJ(n, {...e}, t) {
    const i = n.current;
    if (!(i instanceof Element))
        return {
            target: e,
            transitionEnd: t
        };
    t && (t = {
        ...t
    }),
    n.values.forEach(r=>{
        const s = r.get();
        if (!k_(s))
            return;
        const o = Q_(s, i);
        o && r.set(o)
    }
    );
    for (const r in e) {
        const s = e[r];
        if (!k_(s))
            continue;
        const o = Q_(s, i);
        o && (e[r] = o,
        t && t[r] === void 0 && (t[r] = s))
    }
    return {
        target: e,
        transitionEnd: t
    }
}
const M2 = "_$css"
  , EJ = {
    correct: (n,{treeScale: e, projectionDelta: t})=>{
        const i = n
          , r = n.includes("var(")
          , s = [];
        r && (n = n.replace(cD, m=>(s.push(m),
        M2)));
        const o = oa.parse(n);
        if (o.length > 5)
            return i;
        const a = oa.createTransformer(n)
          , l = typeof o[0] != "number" ? 1 : 0
          , c = t.x.scale * e.x
          , d = t.y.scale * e.y;
        o[0 + l] /= c,
        o[1 + l] /= d;
        const h = ln(c, d, .5);
        typeof o[2 + l] == "number" && (o[2 + l] /= h),
        typeof o[3 + l] == "number" && (o[3 + l] /= h);
        let p = a(o);
        if (r) {
            let m = 0;
            p = p.replace(M2, ()=>{
                const y = s[m];
                return m++,
                y
            }
            )
        }
        return p
    }
};
class TJ extends vc.Component {
    componentDidMount() {
        const {visualElement: e, layoutGroup: t, switchLayoutGroup: i, layoutId: r} = this.props
          , {projection: s} = e;
        PW(PJ),
        s && (t.group && t.group.add(s),
        i && i.register && r && i.register(s),
        s.root.didUpdate(),
        s.addEventListener("animationComplete", ()=>{
            this.safeToRemove()
        }
        ),
        s.setOptions({
            ...s.options,
            onExitComplete: ()=>this.safeToRemove()
        })),
        Yf.hasEverUpdated = !0
    }
    getSnapshotBeforeUpdate(e) {
        const {layoutDependency: t, visualElement: i, drag: r, isPresent: s} = this.props
          , o = i.projection;
        return o && (o.isPresent = s,
        r || e.layoutDependency !== t || t === void 0 ? o.willUpdate() : this.safeToRemove(),
        e.isPresent !== s && (s ? o.promote() : o.relegate() || yi.postRender(()=>{
            const a = o.getStack();
            (!a || !a.members.length) && this.safeToRemove()
        }
        ))),
        null
    }
    componentDidUpdate() {
        const {projection: e} = this.props.visualElement;
        e && (e.root.didUpdate(),
        !e.currentAnimation && e.isLead() && this.safeToRemove())
    }
    componentWillUnmount() {
        const {visualElement: e, layoutGroup: t, switchLayoutGroup: i} = this.props
          , {projection: r} = e;
        r && (r.scheduleCheckAfterUnmount(),
        t && t.group && t.group.remove(r),
        i && i.deregister && i.deregister(r))
    }
    safeToRemove() {
        const {safeToRemove: e} = this.props;
        e && e()
    }
    render() {
        return null
    }
}
function fD(n) {
    const [e,t] = MJ()
      , i = U.useContext(dL);
    return vc.createElement(TJ, {
        ...n,
        layoutGroup: i,
        switchLayoutGroup: U.useContext(hL),
        isPresent: e,
        safeToRemove: t
    })
}
const PJ = {
    borderRadius: {
        ...Cf,
        applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
    },
    borderTopLeftRadius: Cf,
    borderTopRightRadius: Cf,
    borderBottomLeftRadius: Cf,
    borderBottomRightRadius: Cf,
    boxShadow: EJ
};
function BJ(n, e, t={}) {
    const i = Di(n) ? n : hc(n);
    return i.start(kS("", i, e, t)),
    {
        stop: ()=>i.stop(),
        isAnimating: ()=>i.isAnimating()
    }
}
const dD = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"]
  , RJ = dD.length
  , b2 = n=>typeof n == "string" ? parseFloat(n) : n
  , C2 = n=>typeof n == "number" || st.test(n);
function IJ(n, e, t, i, r, s) {
    r ? (n.opacity = ln(0, t.opacity !== void 0 ? t.opacity : 1, LJ(i)),
    n.opacityExit = ln(e.opacity !== void 0 ? e.opacity : 1, 0, DJ(i))) : s && (n.opacity = ln(e.opacity !== void 0 ? e.opacity : 1, t.opacity !== void 0 ? t.opacity : 1, i));
    for (let o = 0; o < RJ; o++) {
        const a = `border${dD[o]}Radius`;
        let l = E2(e, a)
          , c = E2(t, a);
        if (l === void 0 && c === void 0)
            continue;
        l || (l = 0),
        c || (c = 0),
        l === 0 || c === 0 || C2(l) === C2(c) ? (n[a] = Math.max(ln(b2(l), b2(c), i), 0),
        (ds.test(c) || ds.test(l)) && (n[a] += "%")) : n[a] = c
    }
    (e.rotate || t.rotate) && (n.rotate = ln(e.rotate || 0, t.rotate || 0, i))
}
function E2(n, e) {
    return n[e] !== void 0 ? n[e] : n.borderRadius
}
const LJ = hD(0, .5, LS)
  , DJ = hD(.5, .95, Ar);
function hD(n, e, t) {
    return i=>i < n ? 0 : i > e ? 1 : t(zd(n, e, i))
}
function T2(n, e) {
    n.min = e.min,
    n.max = e.max
}
function pr(n, e) {
    T2(n.x, e.x),
    T2(n.y, e.y)
}
function P2(n, e, t, i, r) {
    return n -= e,
    n = Zg(n, 1 / t, i),
    r !== void 0 && (n = Zg(n, 1 / r, i)),
    n
}
function kJ(n, e=0, t=1, i=.5, r, s=n, o=n) {
    if (ds.test(e) && (e = parseFloat(e),
    e = ln(o.min, o.max, e / 100) - o.min),
    typeof e != "number")
        return;
    let a = ln(s.min, s.max, i);
    n === s && (a -= e),
    n.min = P2(n.min, e, t, a, r),
    n.max = P2(n.max, e, t, a, r)
}
function B2(n, e, [t,i,r], s, o) {
    kJ(n, e[t], e[i], e[r], e.scale, s, o)
}
const FJ = ["x", "scaleX", "originX"]
  , NJ = ["y", "scaleY", "originY"];
function R2(n, e, t, i) {
    B2(n.x, e, FJ, t ? t.x : void 0, i ? i.x : void 0),
    B2(n.y, e, NJ, t ? t.y : void 0, i ? i.y : void 0)
}
function I2(n) {
    return n.translate === 0 && n.scale === 1
}
function pD(n) {
    return I2(n.x) && I2(n.y)
}
function Z_(n, e) {
    return n.x.min === e.x.min && n.x.max === e.x.max && n.y.min === e.y.min && n.y.max === e.y.max
}
function L2(n) {
    return Ki(n.x) / Ki(n.y)
}
class OJ {
    constructor() {
        this.members = []
    }
    add(e) {
        wS(this.members, e),
        e.scheduleRender()
    }
    remove(e) {
        if (SS(this.members, e),
        e === this.prevLead && (this.prevLead = void 0),
        e === this.lead) {
            const t = this.members[this.members.length - 1];
            t && this.promote(t)
        }
    }
    relegate(e) {
        const t = this.members.findIndex(r=>e === r);
        if (t === 0)
            return !1;
        let i;
        for (let r = t; r >= 0; r--) {
            const s = this.members[r];
            if (s.isPresent !== !1) {
                i = s;
                break
            }
        }
        return i ? (this.promote(i),
        !0) : !1
    }
    promote(e, t) {
        const i = this.lead;
        if (e !== i && (this.prevLead = i,
        this.lead = e,
        e.show(),
        i)) {
            i.instance && i.scheduleRender(),
            e.scheduleRender(),
            e.resumeFrom = i,
            t && (e.resumeFrom.preserveOpacity = !0),
            i.snapshot && (e.snapshot = i.snapshot,
            e.snapshot.latestValues = i.animationValues || i.latestValues),
            e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
            const {crossfade: r} = e.options;
            r === !1 && i.hide()
        }
    }
    exitAnimationComplete() {
        this.members.forEach(e=>{
            const {options: t, resumingFrom: i} = e;
            t.onExitComplete && t.onExitComplete(),
            i && i.options.onExitComplete && i.options.onExitComplete()
        }
        )
    }
    scheduleRender() {
        this.members.forEach(e=>{
            e.instance && e.scheduleRender(!1)
        }
        )
    }
    removeLeadSnapshot() {
        this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
    }
}
function D2(n, e, t) {
    let i = "";
    const r = n.x.translate / e.x
      , s = n.y.translate / e.y;
    if ((r || s) && (i = `translate3d(${r}px, ${s}px, 0) `),
    (e.x !== 1 || e.y !== 1) && (i += `scale(${1 / e.x}, ${1 / e.y}) `),
    t) {
        const {rotate: l, rotateX: c, rotateY: d} = t;
        l && (i += `rotate(${l}deg) `),
        c && (i += `rotateX(${c}deg) `),
        d && (i += `rotateY(${d}deg) `)
    }
    const o = n.x.scale * e.x
      , a = n.y.scale * e.y;
    return (o !== 1 || a !== 1) && (i += `scale(${o}, ${a})`),
    i || "none"
}
const UJ = (n,e)=>n.depth - e.depth;
class zJ {
    constructor() {
        this.children = [],
        this.isDirty = !1
    }
    add(e) {
        wS(this.children, e),
        this.isDirty = !0
    }
    remove(e) {
        SS(this.children, e),
        this.isDirty = !0
    }
    forEach(e) {
        this.isDirty && this.children.sort(UJ),
        this.isDirty = !1,
        this.children.forEach(e)
    }
}
function GJ(n) {
    window.MotionDebug && window.MotionDebug.record(n)
}
const k2 = ["", "X", "Y", "Z"]
  , F2 = 1e3;
let HJ = 0;
const Ja = {
    type: "projectionFrame",
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0
};
function mD({attachResizeListener: n, defaultParent: e, measureScroll: t, checkIsScrollRoot: i, resetTransform: r}) {
    return class {
        constructor(o, a={}, l=e == null ? void 0 : e()) {
            this.id = HJ++,
            this.animationId = 0,
            this.children = new Set,
            this.options = {},
            this.isTreeAnimating = !1,
            this.isAnimationBlocked = !1,
            this.isLayoutDirty = !1,
            this.isProjectionDirty = !1,
            this.isSharedProjectionDirty = !1,
            this.isTransformDirty = !1,
            this.updateManuallyBlocked = !1,
            this.updateBlockedByResize = !1,
            this.isUpdating = !1,
            this.isSVG = !1,
            this.needsReset = !1,
            this.shouldResetTransform = !1,
            this.treeScale = {
                x: 1,
                y: 1
            },
            this.eventHandlers = new Map,
            this.potentialNodes = new Map,
            this.checkUpdateFailed = ()=>{
                this.isUpdating && (this.isUpdating = !1,
                this.clearAllSnapshots())
            }
            ,
            this.updateProjection = ()=>{
                Ja.totalNodes = Ja.resolvedTargetDeltas = Ja.recalculatedProjection = 0,
                this.nodes.forEach(jJ),
                this.nodes.forEach(KJ),
                this.nodes.forEach(QJ),
                this.nodes.forEach(JJ),
                GJ(Ja)
            }
            ,
            this.hasProjected = !1,
            this.isVisible = !0,
            this.animationProgress = 0,
            this.sharedNodes = new Map,
            this.elementId = o,
            this.latestValues = a,
            this.root = l ? l.root || l : this,
            this.path = l ? [...l.path, l] : [],
            this.parent = l,
            this.depth = l ? l.depth + 1 : 0,
            o && this.root.registerPotentialNode(o, this);
            for (let c = 0; c < this.path.length; c++)
                this.path[c].shouldResetTransform = !0;
            this.root === this && (this.nodes = new zJ)
        }
        addEventListener(o, a) {
            return this.eventHandlers.has(o) || this.eventHandlers.set(o, new MS),
            this.eventHandlers.get(o).add(a)
        }
        notifyListeners(o, ...a) {
            const l = this.eventHandlers.get(o);
            l && l.notify(...a)
        }
        hasListeners(o) {
            return this.eventHandlers.has(o)
        }
        registerPotentialNode(o, a) {
            this.potentialNodes.set(o, a)
        }
        mount(o, a=!1) {
            if (this.instance)
                return;
            this.isSVG = o instanceof SVGElement && o.tagName !== "svg",
            this.instance = o;
            const {layoutId: l, layout: c, visualElement: d} = this.options;
            if (d && !d.current && d.mount(o),
            this.root.nodes.add(this),
            this.parent && this.parent.children.add(this),
            this.elementId && this.root.potentialNodes.delete(this.elementId),
            a && (c || l) && (this.isLayoutDirty = !0),
            n) {
                let h;
                const p = ()=>this.root.updateBlockedByResize = !1;
                n(o, ()=>{
                    this.root.updateBlockedByResize = !0,
                    h && h(),
                    h = tD(p, 250),
                    Yf.hasAnimatedSinceResize && (Yf.hasAnimatedSinceResize = !1,
                    this.nodes.forEach(O2))
                }
                )
            }
            l && this.root.registerSharedNode(l, this),
            this.options.animate !== !1 && d && (l || c) && this.addEventListener("didUpdate", ({delta: h, hasLayoutChanged: p, hasRelativeTargetChanged: m, layout: y})=>{
                if (this.isTreeAnimationBlocked()) {
                    this.target = void 0,
                    this.relativeTarget = void 0;
                    return
                }
                const v = this.options.transition || d.getDefaultTransition() || tX
                  , {onLayoutAnimationStart: x, onLayoutAnimationComplete: _} = d.getProps()
                  , A = !this.targetLayout || !Z_(this.targetLayout, y) || m
                  , w = !p && m;
                if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || w || p && (A || !this.currentAnimation)) {
                    this.resumeFrom && (this.resumingFrom = this.resumeFrom,
                    this.resumingFrom.resumingFrom = void 0),
                    this.setAnimationOrigin(h, w);
                    const M = {
                        ...nD(v, "layout"),
                        onPlay: x,
                        onComplete: _
                    };
                    (d.shouldReduceMotion || this.options.layoutRoot) && (M.delay = 0,
                    M.type = !1),
                    this.startAnimation(M)
                } else
                    !p && this.animationProgress === 0 && O2(this),
                    this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                this.targetLayout = y
            }
            )
        }
        unmount() {
            this.options.layoutId && this.willUpdate(),
            this.root.nodes.remove(this);
            const o = this.getStack();
            o && o.remove(this),
            this.parent && this.parent.children.delete(this),
            this.instance = void 0,
            sa.preRender(this.updateProjection)
        }
        blockUpdate() {
            this.updateManuallyBlocked = !0
        }
        unblockUpdate() {
            this.updateManuallyBlocked = !1
        }
        isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize
        }
        isTreeAnimationBlocked() {
            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
        }
        startUpdate() {
            this.isUpdateBlocked() || (this.isUpdating = !0,
            this.nodes && this.nodes.forEach(ZJ),
            this.animationId++)
        }
        getTransformTemplate() {
            const {visualElement: o} = this.options;
            return o && o.getProps().transformTemplate
        }
        willUpdate(o=!0) {
            if (this.root.isUpdateBlocked()) {
                this.options.onExitComplete && this.options.onExitComplete();
                return
            }
            if (!this.root.isUpdating && this.root.startUpdate(),
            this.isLayoutDirty)
                return;
            this.isLayoutDirty = !0;
            for (let d = 0; d < this.path.length; d++) {
                const h = this.path[d];
                h.shouldResetTransform = !0,
                h.updateScroll("snapshot"),
                h.options.layoutRoot && h.willUpdate(!1)
            }
            const {layoutId: a, layout: l} = this.options;
            if (a === void 0 && !l)
                return;
            const c = this.getTransformTemplate();
            this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0,
            this.updateSnapshot(),
            o && this.notifyListeners("willUpdate")
        }
        didUpdate() {
            if (this.isUpdateBlocked()) {
                this.unblockUpdate(),
                this.clearAllSnapshots(),
                this.nodes.forEach(N2);
                return
            }
            this.isUpdating && (this.isUpdating = !1,
            this.potentialNodes.size && (this.potentialNodes.forEach(nX),
            this.potentialNodes.clear()),
            this.nodes.forEach(YJ),
            this.nodes.forEach(VJ),
            this.nodes.forEach(WJ),
            this.clearAllSnapshots(),
            Tx.update(),
            Tx.preRender(),
            Tx.render())
        }
        clearAllSnapshots() {
            this.nodes.forEach(XJ),
            this.sharedNodes.forEach(qJ)
        }
        scheduleUpdateProjection() {
            yi.preRender(this.updateProjection, !1, !0)
        }
        scheduleCheckAfterUnmount() {
            yi.postRender(()=>{
                this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
            }
            )
        }
        updateSnapshot() {
            this.snapshot || !this.instance || (this.snapshot = this.measure())
        }
        updateLayout() {
            if (!this.instance || (this.updateScroll(),
            !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
                return;
            if (this.resumeFrom && !this.resumeFrom.instance)
                for (let l = 0; l < this.path.length; l++)
                    this.path[l].updateScroll();
            const o = this.layout;
            this.layout = this.measure(!1),
            this.layoutCorrected = Cn(),
            this.isLayoutDirty = !1,
            this.projectionDelta = void 0,
            this.notifyListeners("measure", this.layout.layoutBox);
            const {visualElement: a} = this.options;
            a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0)
        }
        updateScroll(o="measure") {
            let a = Boolean(this.options.layoutScroll && this.instance);
            this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1),
            a && (this.scroll = {
                animationId: this.root.animationId,
                phase: o,
                isRoot: i(this.instance),
                offset: t(this.instance)
            })
        }
        resetTransform() {
            if (!r)
                return;
            const o = this.isLayoutDirty || this.shouldResetTransform
              , a = this.projectionDelta && !pD(this.projectionDelta)
              , l = this.getTransformTemplate()
              , c = l ? l(this.latestValues, "") : void 0
              , d = c !== this.prevTransformTemplateValue;
            o && (a || ja(this.latestValues) || d) && (r(this.instance, c),
            this.shouldResetTransform = !1,
            this.scheduleRender())
        }
        measure(o=!0) {
            const a = this.measurePageBox();
            let l = this.removeElementScroll(a);
            return o && (l = this.removeTransform(l)),
            iX(l),
            {
                animationId: this.root.animationId,
                measuredBox: a,
                layoutBox: l,
                latestValues: {},
                source: this.id
            }
        }
        measurePageBox() {
            const {visualElement: o} = this.options;
            if (!o)
                return Cn();
            const a = o.measureViewportBox()
              , {scroll: l} = this.root;
            return l && (Io(a.x, l.offset.x),
            Io(a.y, l.offset.y)),
            a
        }
        removeElementScroll(o) {
            const a = Cn();
            pr(a, o);
            for (let l = 0; l < this.path.length; l++) {
                const c = this.path[l]
                  , {scroll: d, options: h} = c;
                if (c !== this.root && d && h.layoutScroll) {
                    if (d.isRoot) {
                        pr(a, o);
                        const {scroll: p} = this.root;
                        p && (Io(a.x, -p.offset.x),
                        Io(a.y, -p.offset.y))
                    }
                    Io(a.x, d.offset.x),
                    Io(a.y, d.offset.y)
                }
            }
            return a
        }
        applyTransform(o, a=!1) {
            const l = Cn();
            pr(l, o);
            for (let c = 0; c < this.path.length; c++) {
                const d = this.path[c];
                !a && d.options.layoutScroll && d.scroll && d !== d.root && ku(l, {
                    x: -d.scroll.offset.x,
                    y: -d.scroll.offset.y
                }),
                ja(d.latestValues) && ku(l, d.latestValues)
            }
            return ja(this.latestValues) && ku(l, this.latestValues),
            l
        }
        removeTransform(o) {
            const a = Cn();
            pr(a, o);
            for (let l = 0; l < this.path.length; l++) {
                const c = this.path[l];
                if (!c.instance || !ja(c.latestValues))
                    continue;
                Y_(c.latestValues) && c.updateSnapshot();
                const d = Cn()
                  , h = c.measurePageBox();
                pr(d, h),
                R2(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, d)
            }
            return ja(this.latestValues) && R2(a, this.latestValues),
            a
        }
        setTargetDelta(o) {
            this.targetDelta = o,
            this.root.scheduleUpdateProjection(),
            this.isProjectionDirty = !0
        }
        setOptions(o) {
            this.options = {
                ...this.options,
                ...o,
                crossfade: o.crossfade !== void 0 ? o.crossfade : !0
            }
        }
        clearMeasurements() {
            this.scroll = void 0,
            this.layout = void 0,
            this.snapshot = void 0,
            this.prevTransformTemplateValue = void 0,
            this.targetDelta = void 0,
            this.target = void 0,
            this.isLayoutDirty = !1
        }
        resolveTargetDelta() {
            var o;
            const a = this.getLead();
            if (this.isProjectionDirty || (this.isProjectionDirty = a.isProjectionDirty),
            this.isTransformDirty || (this.isTransformDirty = a.isTransformDirty),
            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = a.isSharedProjectionDirty),
            !((Boolean(this.resumingFrom) || this !== a) && this.isSharedProjectionDirty || this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty || this.attemptToResolveRelativeTarget))
                return;
            const {layout: d, layoutId: h} = this.options;
            if (!(!this.layout || !(d || h))) {
                if (!this.targetDelta && !this.relativeTarget) {
                    const p = this.getClosestProjectingParent();
                    p && p.layout ? (this.relativeParent = p,
                    this.relativeTarget = Cn(),
                    this.relativeTargetOrigin = Cn(),
                    qf(this.relativeTargetOrigin, this.layout.layoutBox, p.layout.layoutBox),
                    pr(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
                if (!(!this.relativeTarget && !this.targetDelta)) {
                    if (this.target || (this.target = Cn(),
                    this.targetWithTransforms = Cn()),
                    this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? oJ(this.target, this.relativeTarget, this.relativeParent.target) : this.targetDelta ? (Boolean(this.resumingFrom) ? this.target = this.applyTransform(this.layout.layoutBox) : pr(this.target, this.layout.layoutBox),
                    lD(this.target, this.targetDelta)) : pr(this.target, this.layout.layoutBox),
                    this.attemptToResolveRelativeTarget) {
                        this.attemptToResolveRelativeTarget = !1;
                        const p = this.getClosestProjectingParent();
                        p && Boolean(p.resumingFrom) === Boolean(this.resumingFrom) && !p.options.layoutScroll && p.target ? (this.relativeParent = p,
                        this.relativeTarget = Cn(),
                        this.relativeTargetOrigin = Cn(),
                        qf(this.relativeTargetOrigin, this.target, p.target),
                        pr(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                    }
                    Ja.resolvedTargetDeltas++
                }
            }
        }
        getClosestProjectingParent() {
            if (!(!this.parent || Y_(this.parent.latestValues) || aD(this.parent.latestValues)))
                return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
        }
        isProjecting() {
            return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
        }
        calcProjection() {
            var o;
            const a = this.getLead()
              , l = Boolean(this.resumingFrom) || this !== a;
            let c = !0;
            if ((this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty) && (c = !1),
            l && (this.isSharedProjectionDirty || this.isTransformDirty) && (c = !1),
            c)
                return;
            const {layout: d, layoutId: h} = this.options;
            if (this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation),
            this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
            !this.layout || !(d || h))
                return;
            pr(this.layoutCorrected, this.layout.layoutBox),
            mJ(this.layoutCorrected, this.treeScale, this.path, l);
            const {target: p} = a;
            if (!p)
                return;
            this.projectionDelta || (this.projectionDelta = $f(),
            this.projectionDeltaWithTransform = $f());
            const m = this.treeScale.x
              , y = this.treeScale.y
              , v = this.projectionTransform;
            Zf(this.projectionDelta, this.layoutCorrected, p, this.latestValues),
            this.projectionTransform = D2(this.projectionDelta, this.treeScale),
            (this.projectionTransform !== v || this.treeScale.x !== m || this.treeScale.y !== y) && (this.hasProjected = !0,
            this.scheduleRender(),
            this.notifyListeners("projectionUpdate", p)),
            Ja.recalculatedProjection++
        }
        hide() {
            this.isVisible = !1
        }
        show() {
            this.isVisible = !0
        }
        scheduleRender(o=!0) {
            if (this.options.scheduleRender && this.options.scheduleRender(),
            o) {
                const a = this.getStack();
                a && a.scheduleRender()
            }
            this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
        }
        setAnimationOrigin(o, a=!1) {
            const l = this.snapshot
              , c = l ? l.latestValues : {}
              , d = {
                ...this.latestValues
            }
              , h = $f();
            (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0),
            this.attemptToResolveRelativeTarget = !a;
            const p = Cn()
              , m = l ? l.source : void 0
              , y = this.layout ? this.layout.source : void 0
              , v = m !== y
              , x = this.getStack()
              , _ = !x || x.members.length <= 1
              , A = Boolean(v && !_ && this.options.crossfade === !0 && !this.path.some(eX));
            this.animationProgress = 0;
            let w;
            this.mixTargetDelta = M=>{
                const C = M / 1e3;
                U2(h.x, o.x, C),
                U2(h.y, o.y, C),
                this.setTargetDelta(h),
                this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (qf(p, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
                $J(this.relativeTarget, this.relativeTargetOrigin, p, C),
                w && Z_(this.relativeTarget, w) && (this.isProjectionDirty = !1),
                w || (w = Cn()),
                pr(w, this.relativeTarget)),
                v && (this.animationValues = d,
                IJ(d, c, this.latestValues, C, A, _)),
                this.root.scheduleUpdateProjection(),
                this.scheduleRender(),
                this.animationProgress = C
            }
            ,
            this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
        }
        startAnimation(o) {
            this.notifyListeners("animationStart"),
            this.currentAnimation && this.currentAnimation.stop(),
            this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(),
            this.pendingAnimation && (sa.update(this.pendingAnimation),
            this.pendingAnimation = void 0),
            this.pendingAnimation = yi.update(()=>{
                Yf.hasAnimatedSinceResize = !0,
                this.currentAnimation = BJ(0, F2, {
                    ...o,
                    onUpdate: a=>{
                        this.mixTargetDelta(a),
                        o.onUpdate && o.onUpdate(a)
                    }
                    ,
                    onComplete: ()=>{
                        o.onComplete && o.onComplete(),
                        this.completeAnimation()
                    }
                }),
                this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
                this.pendingAnimation = void 0
            }
            )
        }
        completeAnimation() {
            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0,
            this.resumingFrom.preserveOpacity = void 0);
            const o = this.getStack();
            o && o.exitAnimationComplete(),
            this.resumingFrom = this.currentAnimation = this.animationValues = void 0,
            this.notifyListeners("animationComplete")
        }
        finishAnimation() {
            this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(F2),
            this.currentAnimation.stop()),
            this.completeAnimation()
        }
        applyTransformsToTarget() {
            const o = this.getLead();
            let {targetWithTransforms: a, target: l, layout: c, latestValues: d} = o;
            if (!(!a || !l || !c)) {
                if (this !== o && this.layout && c && gD(this.options.animationType, this.layout.layoutBox, c.layoutBox)) {
                    l = this.target || Cn();
                    const h = Ki(this.layout.layoutBox.x);
                    l.x.min = o.target.x.min,
                    l.x.max = l.x.min + h;
                    const p = Ki(this.layout.layoutBox.y);
                    l.y.min = o.target.y.min,
                    l.y.max = l.y.min + p
                }
                pr(a, l),
                ku(a, d),
                Zf(this.projectionDeltaWithTransform, this.layoutCorrected, a, d)
            }
        }
        registerSharedNode(o, a) {
            this.sharedNodes.has(o) || this.sharedNodes.set(o, new OJ),
            this.sharedNodes.get(o).add(a);
            const c = a.options.initialPromotionConfig;
            a.promote({
                transition: c ? c.transition : void 0,
                preserveFollowOpacity: c && c.shouldPreserveFollowOpacity ? c.shouldPreserveFollowOpacity(a) : void 0
            })
        }
        isLead() {
            const o = this.getStack();
            return o ? o.lead === this : !0
        }
        getLead() {
            var o;
            const {layoutId: a} = this.options;
            return a ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) || this : this
        }
        getPrevLead() {
            var o;
            const {layoutId: a} = this.options;
            return a ? (o = this.getStack()) === null || o === void 0 ? void 0 : o.prevLead : void 0
        }
        getStack() {
            const {layoutId: o} = this.options;
            if (o)
                return this.root.sharedNodes.get(o)
        }
        promote({needsReset: o, transition: a, preserveFollowOpacity: l}={}) {
            const c = this.getStack();
            c && c.promote(this, l),
            o && (this.projectionDelta = void 0,
            this.needsReset = !0),
            a && this.setOptions({
                transition: a
            })
        }
        relegate() {
            const o = this.getStack();
            return o ? o.relegate(this) : !1
        }
        resetRotation() {
            const {visualElement: o} = this.options;
            if (!o)
                return;
            let a = !1;
            const {latestValues: l} = o;
            if ((l.rotate || l.rotateX || l.rotateY || l.rotateZ) && (a = !0),
            !a)
                return;
            const c = {};
            for (let d = 0; d < k2.length; d++) {
                const h = "rotate" + k2[d];
                l[h] && (c[h] = l[h],
                o.setStaticValue(h, 0))
            }
            o.render();
            for (const d in c)
                o.setStaticValue(d, c[d]);
            o.scheduleRender()
        }
        getProjectionStyles(o={}) {
            var a, l;
            const c = {};
            if (!this.instance || this.isSVG)
                return c;
            if (this.isVisible)
                c.visibility = "";
            else
                return {
                    visibility: "hidden"
                };
            const d = this.getTransformTemplate();
            if (this.needsReset)
                return this.needsReset = !1,
                c.opacity = "",
                c.pointerEvents = cg(o.pointerEvents) || "",
                c.transform = d ? d(this.latestValues, "") : "none",
                c;
            const h = this.getLead();
            if (!this.projectionDelta || !this.layout || !h.target) {
                const v = {};
                return this.options.layoutId && (v.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1,
                v.pointerEvents = cg(o.pointerEvents) || ""),
                this.hasProjected && !ja(this.latestValues) && (v.transform = d ? d({}, "") : "none",
                this.hasProjected = !1),
                v
            }
            const p = h.animationValues || h.latestValues;
            this.applyTransformsToTarget(),
            c.transform = D2(this.projectionDeltaWithTransform, this.treeScale, p),
            d && (c.transform = d(p, c.transform));
            const {x: m, y} = this.projectionDelta;
            c.transformOrigin = `${m.origin * 100}% ${y.origin * 100}% 0`,
            h.animationValues ? c.opacity = h === this ? (l = (a = p.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : p.opacityExit : c.opacity = h === this ? p.opacity !== void 0 ? p.opacity : "" : p.opacityExit !== void 0 ? p.opacityExit : 0;
            for (const v in Wg) {
                if (p[v] === void 0)
                    continue;
                const {correct: x, applyTo: _} = Wg[v]
                  , A = c.transform === "none" ? p[v] : x(p[v], h);
                if (_) {
                    const w = _.length;
                    for (let M = 0; M < w; M++)
                        c[_[M]] = A
                } else
                    c[v] = A
            }
            return this.options.layoutId && (c.pointerEvents = h === this ? cg(o.pointerEvents) || "" : "none"),
            c
        }
        clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0
        }
        resetTree() {
            this.root.nodes.forEach(o=>{
                var a;
                return (a = o.currentAnimation) === null || a === void 0 ? void 0 : a.stop()
            }
            ),
            this.root.nodes.forEach(N2),
            this.root.sharedNodes.clear()
        }
    }
}
function VJ(n) {
    n.updateLayout()
}
function WJ(n) {
    var e;
    const t = ((e = n.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || n.snapshot;
    if (n.isLead() && n.layout && t && n.hasListeners("didUpdate")) {
        const {layoutBox: i, measuredBox: r} = n.layout
          , {animationType: s} = n.options
          , o = t.source !== n.layout.source;
        s === "size" ? ss(h=>{
            const p = o ? t.measuredBox[h] : t.layoutBox[h]
              , m = Ki(p);
            p.min = i[h].min,
            p.max = p.min + m
        }
        ) : gD(s, t.layoutBox, i) && ss(h=>{
            const p = o ? t.measuredBox[h] : t.layoutBox[h]
              , m = Ki(i[h]);
            p.max = p.min + m
        }
        );
        const a = $f();
        Zf(a, i, t.layoutBox);
        const l = $f();
        o ? Zf(l, n.applyTransform(r, !0), t.measuredBox) : Zf(l, i, t.layoutBox);
        const c = !pD(a);
        let d = !1;
        if (!n.resumeFrom) {
            const h = n.getClosestProjectingParent();
            if (h && !h.resumeFrom) {
                const {snapshot: p, layout: m} = h;
                if (p && m) {
                    const y = Cn();
                    qf(y, t.layoutBox, p.layoutBox);
                    const v = Cn();
                    qf(v, i, m.layoutBox),
                    Z_(y, v) || (d = !0),
                    h.options.layoutRoot && (n.relativeTarget = v,
                    n.relativeTargetOrigin = y,
                    n.relativeParent = h)
                }
            }
        }
        n.notifyListeners("didUpdate", {
            layout: i,
            snapshot: t,
            delta: l,
            layoutDelta: a,
            hasLayoutChanged: c,
            hasRelativeTargetChanged: d
        })
    } else if (n.isLead()) {
        const {onExitComplete: i} = n.options;
        i && i()
    }
    n.options.transition = void 0
}
function jJ(n) {
    Ja.totalNodes++,
    n.parent && (n.isProjecting() || (n.isProjectionDirty = n.parent.isProjectionDirty),
    n.isSharedProjectionDirty || (n.isSharedProjectionDirty = Boolean(n.isProjectionDirty || n.parent.isProjectionDirty || n.parent.isSharedProjectionDirty)),
    n.isTransformDirty || (n.isTransformDirty = n.parent.isTransformDirty))
}
function JJ(n) {
    n.isProjectionDirty = n.isSharedProjectionDirty = n.isTransformDirty = !1
}
function XJ(n) {
    n.clearSnapshot()
}
function N2(n) {
    n.clearMeasurements()
}
function YJ(n) {
    const {visualElement: e} = n.options;
    e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"),
    n.resetTransform()
}
function O2(n) {
    n.finishAnimation(),
    n.targetDelta = n.relativeTarget = n.target = void 0
}
function KJ(n) {
    n.resolveTargetDelta()
}
function QJ(n) {
    n.calcProjection()
}
function ZJ(n) {
    n.resetRotation()
}
function qJ(n) {
    n.removeLeadSnapshot()
}
function U2(n, e, t) {
    n.translate = ln(e.translate, 0, t),
    n.scale = ln(e.scale, 1, t),
    n.origin = e.origin,
    n.originPoint = e.originPoint
}
function z2(n, e, t, i) {
    n.min = ln(e.min, t.min, i),
    n.max = ln(e.max, t.max, i)
}
function $J(n, e, t, i) {
    z2(n.x, e.x, t.x, i),
    z2(n.y, e.y, t.y, i)
}
function eX(n) {
    return n.animationValues && n.animationValues.opacityExit !== void 0
}
const tX = {
    duration: .45,
    ease: [.4, 0, .1, 1]
};
function nX(n, e) {
    let t = n.root;
    for (let s = n.path.length - 1; s >= 0; s--)
        if (Boolean(n.path[s].instance)) {
            t = n.path[s];
            break
        }
    const r = (t && t !== n.root ? t.instance : document).querySelector(`[data-projection-id="${e}"]`);
    r && n.mount(r, !0)
}
function G2(n) {
    n.min = Math.round(n.min),
    n.max = Math.round(n.max)
}
function iX(n) {
    G2(n.x),
    G2(n.y)
}
function gD(n, e, t) {
    return n === "position" || n === "preserve-aspect" && !J_(L2(e), L2(t), .2)
}
const rX = mD({
    attachResizeListener: (n,e)=>Vs(n, "resize", e),
    measureScroll: ()=>({
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: ()=>!0
})
  , Nx = {
    current: void 0
}
  , vD = mD({
    measureScroll: n=>({
        x: n.scrollLeft,
        y: n.scrollTop
    }),
    defaultParent: ()=>{
        if (!Nx.current) {
            const n = new rX(0,{});
            n.mount(window),
            n.setOptions({
                layoutScroll: !0
            }),
            Nx.current = n
        }
        return Nx.current
    }
    ,
    resetTransform: (n,e)=>{
        n.style.transform = e !== void 0 ? e : "none"
    }
    ,
    checkIsScrollRoot: n=>Boolean(window.getComputedStyle(n).position === "fixed")
})
  , sX = {
    pan: {
        Feature: SJ
    },
    drag: {
        Feature: wJ,
        ProjectionNode: vD,
        MeasureLayout: fD
    }
}
  , oX = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y"])
  , yD = n=>oX.has(n)
  , aX = n=>Object.keys(n).some(yD)
  , H2 = n=>n === kl || n === st
  , V2 = (n,e)=>parseFloat(n.split(", ")[e])
  , W2 = (n,e)=>(t,{transform: i})=>{
    if (i === "none" || !i)
        return 0;
    const r = i.match(/^matrix3d\((.+)\)$/);
    if (r)
        return V2(r[1], e);
    {
        const s = i.match(/^matrix\((.+)\)$/);
        return s ? V2(s[1], n) : 0
    }
}
  , lX = new Set(["x", "y", "z"])
  , uX = j0.filter(n=>!lX.has(n));
function cX(n) {
    const e = [];
    return uX.forEach(t=>{
        const i = n.getValue(t);
        i !== void 0 && (e.push([t, i.get()]),
        i.set(t.startsWith("scale") ? 1 : 0))
    }
    ),
    e.length && n.render(),
    e
}
const j2 = {
    width: ({x: n},{paddingLeft: e="0", paddingRight: t="0"})=>n.max - n.min - parseFloat(e) - parseFloat(t),
    height: ({y: n},{paddingTop: e="0", paddingBottom: t="0"})=>n.max - n.min - parseFloat(e) - parseFloat(t),
    top: (n,{top: e})=>parseFloat(e),
    left: (n,{left: e})=>parseFloat(e),
    bottom: ({y: n},{top: e})=>parseFloat(e) + (n.max - n.min),
    right: ({x: n},{left: e})=>parseFloat(e) + (n.max - n.min),
    x: W2(4, 13),
    y: W2(5, 14)
}
  , fX = (n,e,t)=>{
    const i = e.measureViewportBox()
      , r = e.current
      , s = getComputedStyle(r)
      , {display: o} = s
      , a = {};
    o === "none" && e.setStaticValue("display", n.display || "block"),
    t.forEach(c=>{
        a[c] = j2[c](i, s)
    }
    ),
    e.render();
    const l = e.measureViewportBox();
    return t.forEach(c=>{
        const d = e.getValue(c);
        d && d.jump(a[c]),
        n[c] = j2[c](l, s)
    }
    ),
    n
}
  , dX = (n,e,t={},i={})=>{
    e = {
        ...e
    },
    i = {
        ...i
    };
    const r = Object.keys(e).filter(yD);
    let s = []
      , o = !1;
    const a = [];
    if (r.forEach(l=>{
        const c = n.getValue(l);
        if (!n.hasValue(l))
            return;
        let d = t[l]
          , h = bf(d);
        const p = e[l];
        let m;
        if (Jg(p)) {
            const y = p.length
              , v = p[0] === null ? 1 : 0;
            d = p[v],
            h = bf(d);
            for (let x = v; x < y; x++)
                m ? Kg(bf(p[x]) === m) : m = bf(p[x])
        } else
            m = bf(p);
        if (h !== m)
            if (H2(h) && H2(m)) {
                const y = c.get();
                typeof y == "string" && c.set(parseFloat(y)),
                typeof p == "string" ? e[l] = parseFloat(p) : Array.isArray(p) && m === st && (e[l] = p.map(parseFloat))
            } else
                h != null && h.transform && (m != null && m.transform) && (d === 0 || p === 0) ? d === 0 ? c.set(m.transform(d)) : e[l] = h.transform(p) : (o || (s = cX(n),
                o = !0),
                a.push(l),
                i[l] = i[l] !== void 0 ? i[l] : e[l],
                c.jump(p))
    }
    ),
    a.length) {
        const l = a.indexOf("height") >= 0 ? window.pageYOffset : null
          , c = fX(e, n, a);
        return s.length && s.forEach(([d,h])=>{
            n.getValue(d).set(h)
        }
        ),
        n.render(),
        H0 && l !== null && window.scrollTo({
            top: l
        }),
        {
            target: c,
            transitionEnd: i
        }
    } else
        return {
            target: e,
            transitionEnd: i
        }
}
;
function hX(n, e, t, i) {
    return aX(e) ? dX(n, e, t, i) : {
        target: e,
        transitionEnd: i
    }
}
const pX = (n,e,t,i)=>{
    const r = CJ(n, e, i);
    return e = r.target,
    i = r.transitionEnd,
    hX(n, e, t, i)
}
  , q_ = {
    current: null
}
  , xD = {
    current: !1
};
function mX() {
    if (xD.current = !0,
    !!H0)
        if (window.matchMedia) {
            const n = window.matchMedia("(prefers-reduced-motion)")
              , e = ()=>q_.current = n.matches;
            n.addListener(e),
            e()
        } else
            q_.current = !1
}
function gX(n, e, t) {
    const {willChange: i} = e;
    for (const r in e) {
        const s = e[r]
          , o = t[r];
        if (Di(s))
            n.addValue(r, s),
            Yg(i) && i.add(r);
        else if (Di(o))
            n.addValue(r, hc(s, {
                owner: n
            })),
            Yg(i) && i.remove(r);
        else if (o !== s)
            if (n.hasValue(r)) {
                const a = n.getValue(r);
                !a.hasAnimated && a.set(s)
            } else {
                const a = n.getStaticValue(r);
                n.addValue(r, hc(a !== void 0 ? a : s, {
                    owner: n
                }))
            }
    }
    for (const r in t)
        e[r] === void 0 && n.removeValue(r);
    return e
}
const _D = Object.keys(Nd)
  , vX = _D.length
  , J2 = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]
  , yX = hS.length;
class xX {
    constructor({parent: e, props: t, presenceContext: i, reducedMotionConfig: r, visualState: s}, o={}) {
        this.current = null,
        this.children = new Set,
        this.isVariantNode = !1,
        this.isControllingVariants = !1,
        this.shouldReduceMotion = null,
        this.values = new Map,
        this.features = {},
        this.valueSubscriptions = new Map,
        this.prevMotionValues = {},
        this.events = {},
        this.propEventSubscriptions = {},
        this.notifyUpdate = ()=>this.notify("Update", this.latestValues),
        this.render = ()=>{
            this.current && (this.triggerBuild(),
            this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
        }
        ,
        this.scheduleRender = ()=>yi.render(this.render, !1, !0);
        const {latestValues: a, renderState: l} = s;
        this.latestValues = a,
        this.baseTarget = {
            ...a
        },
        this.initialValues = t.initial ? {
            ...a
        } : {},
        this.renderState = l,
        this.parent = e,
        this.props = t,
        this.presenceContext = i,
        this.depth = e ? e.depth + 1 : 0,
        this.reducedMotionConfig = r,
        this.options = o,
        this.isControllingVariants = W0(t),
        this.isVariantNode = cL(t),
        this.isVariantNode && (this.variantChildren = new Set),
        this.manuallyAnimateOnMount = Boolean(e && e.current);
        const {willChange: c, ...d} = this.scrapeMotionValuesFromProps(t, {});
        for (const h in d) {
            const p = d[h];
            a[h] !== void 0 && Di(p) && (p.set(a[h], !1),
            Yg(c) && c.add(h))
        }
    }
    scrapeMotionValuesFromProps(e, t) {
        return {}
    }
    mount(e) {
        this.current = e,
        this.projection && this.projection.mount(e),
        this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)),
        this.values.forEach((t,i)=>this.bindToMotionValue(i, t)),
        xD.current || mX(),
        this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : q_.current,
        this.parent && this.parent.children.add(this),
        this.update(this.props, this.presenceContext)
    }
    unmount() {
        this.projection && this.projection.unmount(),
        sa.update(this.notifyUpdate),
        sa.render(this.render),
        this.valueSubscriptions.forEach(e=>e()),
        this.removeFromVariantTree && this.removeFromVariantTree(),
        this.parent && this.parent.children.delete(this);
        for (const e in this.events)
            this.events[e].clear();
        for (const e in this.features)
            this.features[e].unmount();
        this.current = null
    }
    bindToMotionValue(e, t) {
        const i = Dl.has(e)
          , r = t.on("change", o=>{
            this.latestValues[e] = o,
            this.props.onUpdate && yi.update(this.notifyUpdate, !1, !0),
            i && this.projection && (this.projection.isTransformDirty = !0)
        }
        )
          , s = t.on("renderRequest", this.scheduleRender);
        this.valueSubscriptions.set(e, ()=>{
            r(),
            s()
        }
        )
    }
    sortNodePosition(e) {
        return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current)
    }
    loadFeatures({children: e, ...t}, i, r, s, o) {
        let a, l;
        for (let c = 0; c < vX; c++) {
            const d = _D[c]
              , {isEnabled: h, Feature: p, ProjectionNode: m, MeasureLayout: y} = Nd[d];
            m && (a = m),
            h(t) && (!this.features[d] && p && (this.features[d] = new p(this)),
            y && (l = y))
        }
        if (!this.projection && a) {
            this.projection = new a(s,this.latestValues,this.parent && this.parent.projection);
            const {layoutId: c, layout: d, drag: h, dragConstraints: p, layoutScroll: m, layoutRoot: y} = t;
            this.projection.setOptions({
                layoutId: c,
                layout: d,
                alwaysMeasureLayout: Boolean(h) || p && Lu(p),
                visualElement: this,
                scheduleRender: ()=>this.scheduleRender(),
                animationType: typeof d == "string" ? d : "both",
                initialPromotionConfig: o,
                layoutScroll: m,
                layoutRoot: y
            })
        }
        return l
    }
    updateFeatures() {
        for (const e in this.features) {
            const t = this.features[e];
            t.isMounted ? t.update(this.props, this.prevProps) : (t.mount(),
            t.isMounted = !0)
        }
    }
    triggerBuild() {
        this.build(this.renderState, this.latestValues, this.options, this.props)
    }
    measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Cn()
    }
    getStaticValue(e) {
        return this.latestValues[e]
    }
    setStaticValue(e, t) {
        this.latestValues[e] = t
    }
    makeTargetAnimatable(e, t=!0) {
        return this.makeTargetAnimatableFromInstance(e, this.props, t)
    }
    update(e, t) {
        (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
        this.prevProps = this.props,
        this.props = e,
        this.prevPresenceContext = this.presenceContext,
        this.presenceContext = t;
        for (let i = 0; i < J2.length; i++) {
            const r = J2[i];
            this.propEventSubscriptions[r] && (this.propEventSubscriptions[r](),
            delete this.propEventSubscriptions[r]);
            const s = e["on" + r];
            s && (this.propEventSubscriptions[r] = this.on(r, s))
        }
        this.prevMotionValues = gX(this, this.scrapeMotionValuesFromProps(e, this.prevProps), this.prevMotionValues),
        this.handleChildMotionValue && this.handleChildMotionValue()
    }
    getProps() {
        return this.props
    }
    getVariant(e) {
        return this.props.variants ? this.props.variants[e] : void 0
    }
    getDefaultTransition() {
        return this.props.transition
    }
    getTransformPagePoint() {
        return this.props.transformPagePoint
    }
    getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
    }
    getVariantContext(e=!1) {
        if (e)
            return this.parent ? this.parent.getVariantContext() : void 0;
        if (!this.isControllingVariants) {
            const i = this.parent ? this.parent.getVariantContext() || {} : {};
            return this.props.initial !== void 0 && (i.initial = this.props.initial),
            i
        }
        const t = {};
        for (let i = 0; i < yX; i++) {
            const r = hS[i]
              , s = this.props[r];
            (Fd(s) || s === !1) && (t[r] = s)
        }
        return t
    }
    addVariantChild(e) {
        const t = this.getClosestVariantNode();
        if (t)
            return t.variantChildren && t.variantChildren.add(e),
            ()=>t.variantChildren.delete(e)
    }
    addValue(e, t) {
        t !== this.values.get(e) && (this.removeValue(e),
        this.bindToMotionValue(e, t)),
        this.values.set(e, t),
        this.latestValues[e] = t.get()
    }
    removeValue(e) {
        this.values.delete(e);
        const t = this.valueSubscriptions.get(e);
        t && (t(),
        this.valueSubscriptions.delete(e)),
        delete this.latestValues[e],
        this.removeValueFromRenderState(e, this.renderState)
    }
    hasValue(e) {
        return this.values.has(e)
    }
    getValue(e, t) {
        if (this.props.values && this.props.values[e])
            return this.props.values[e];
        let i = this.values.get(e);
        return i === void 0 && t !== void 0 && (i = hc(t, {
            owner: this
        }),
        this.addValue(e, i)),
        i
    }
    readValue(e) {
        return this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : this.readValueFromInstance(this.current, e, this.options)
    }
    setBaseTarget(e, t) {
        this.baseTarget[e] = t
    }
    getBaseTarget(e) {
        var t;
        const {initial: i} = this.props
          , r = typeof i == "string" || typeof i == "object" ? (t = AS(this.props, i)) === null || t === void 0 ? void 0 : t[e] : void 0;
        if (i && r !== void 0)
            return r;
        const s = this.getBaseTargetFromProps(this.props, e);
        return s !== void 0 && !Di(s) ? s : this.initialValues[e] !== void 0 && r === void 0 ? void 0 : this.baseTarget[e]
    }
    on(e, t) {
        return this.events[e] || (this.events[e] = new MS),
        this.events[e].add(t)
    }
    notify(e, ...t) {
        this.events[e] && this.events[e].notify(...t)
    }
}
class AD extends xX {
    sortInstanceNodePosition(e, t) {
        return e.compareDocumentPosition(t) & 2 ? 1 : -1
    }
    getBaseTargetFromProps(e, t) {
        return e.style ? e.style[t] : void 0
    }
    removeValueFromRenderState(e, {vars: t, style: i}) {
        delete t[e],
        delete i[e]
    }
    makeTargetAnimatableFromInstance({transition: e, transitionEnd: t, ...i}, {transformValues: r}, s) {
        let o = H7(i, e || {}, this);
        if (r && (t && (t = r(t)),
        i && (i = r(i)),
        o && (o = r(o))),
        s) {
            z7(this, i, o);
            const a = pX(this, i, o, t);
            t = a.transitionEnd,
            i = a.target
        }
        return {
            transition: e,
            transitionEnd: t,
            ...i
        }
    }
}
function _X(n) {
    return window.getComputedStyle(n)
}
class AX extends AD {
    readValueFromInstance(e, t) {
        if (Dl.has(t)) {
            const i = ES(t);
            return i && i.default || 0
        } else {
            const i = _X(e)
              , r = (gL(t) ? i.getPropertyValue(t) : i[t]) || 0;
            return typeof r == "string" ? r.trim() : r
        }
    }
    measureInstanceViewportBox(e, {transformPagePoint: t}) {
        return uD(e, t)
    }
    build(e, t, i, r) {
        mS(e, t, i, r.transformTemplate)
    }
    scrapeMotionValuesFromProps(e, t) {
        return _S(e, t)
    }
    handleChildMotionValue() {
        this.childSubscription && (this.childSubscription(),
        delete this.childSubscription);
        const {children: e} = this.props;
        Di(e) && (this.childSubscription = e.on("change", t=>{
            this.current && (this.current.textContent = `${t}`)
        }
        ))
    }
    renderInstance(e, t, i, r) {
        AL(e, t, i, r)
    }
}
class wX extends AD {
    constructor() {
        super(...arguments),
        this.isSVGTag = !1
    }
    getBaseTargetFromProps(e, t) {
        return e[t]
    }
    readValueFromInstance(e, t) {
        if (Dl.has(t)) {
            const i = ES(t);
            return i && i.default || 0
        }
        return t = wL.has(t) ? t : xS(t),
        e.getAttribute(t)
    }
    measureInstanceViewportBox() {
        return Cn()
    }
    scrapeMotionValuesFromProps(e, t) {
        return ML(e, t)
    }
    build(e, t, i, r) {
        vS(e, t, i, this.isSVGTag, r.transformTemplate)
    }
    renderInstance(e, t, i, r) {
        SL(e, t, i, r)
    }
    mount(e) {
        this.isSVGTag = yS(e.tagName),
        super.mount(e)
    }
}
const SX = (n,e)=>pS(n) ? new wX(e,{
    enableHardwareAcceleration: !1
}) : new AX(e,{
    enableHardwareAcceleration: !0
})
  , MX = {
    layout: {
        ProjectionNode: vD,
        MeasureLayout: fD
    }
}
  , bX = {
    ...nJ,
    ...p7,
    ...sX,
    ...MX
}
  , Qi = EW((n,e)=>t7(n, e, bX, SX))
  , Yn = {
    paddingX: "sm:px-16 px-6",
    paddingY: "sm:py-16 py-6",
    padding: "sm:px-16 px-6 sm:py-16 py-10",
    heroHeadText: "font-black text-white lg:text-[80px] sm:text-[60px] xs:text-[50px] text-[40px] lg:leading-[98px] mt-2",
    heroSubText: "text-[#dfd9ff] font-medium lg:text-[30px] sm:text-[26px] xs:text-[20px] text-[16px] lg:leading-[40px]",
    sectionHeadText: "text-white font-black md:text-[60px] sm:text-[50px] xs:text-[40px] text-[30px]",
    sectionSubText: "sm:text-[18px] text-[14px] text-secondary uppercase tracking-wider"
}
  , CX = ()=>it("section", {
    className: "relative w-full h-screen mx-auto",
    children: [it("div", {
        className: `absolute inset-0 top-[120px]  max-w-7xl mx-auto ${Yn.paddingX} flex flex-row items-start gap-5`,
        children: [it("div", {
            className: "flex flex-col justify-center items-center mt-5",
            children: [he("div", {
                className: "w-5 h-5 rounded-full bg-[#915EFF]"
            }), he("div", {
                className: "w-1 sm:h-80 h-40 violet-gradient"
            })]
        }), it("div", {
            children: [it("h1", {
                className: `${Yn.heroHeadText} text-white hero-container aos-init aos-animate`,
                children: ["Hi, I'm ", he("span", {
                    className: "text-[#915EFF]",
                    children: "Daniel"
                })]
            }), it("span", {
                className: `${Yn.heroSubText} mt-2 text-white-100 typed`,
                "data-typed-items": ", Developer, Ethical Hacker, Designer",
                children: [" ", he("br", {
                    className: "sm:block hidden"
                }), ""]
            })]
        })]
    }), he(hW, {}), he("div", {
        className: "absolute xs:bottom-10 bottom-32 w-full flex justify-center items-center",
        children: he("a", {
            href: "#about",
            children: he("div", {
                className: "w-[35px] h-[64px] rounded-3xl border-4 border-secondary flex justify-center items-start p-2",
                children: he(Qi.div, {
                    animate: {
                        y: [0, 24, 0]
                    },
                    transition: {
                        duration: 1.5,
                        repeat: 1 / 0,
                        repeatType: "loop"
                    },
                    className: "w-3 h-3 rounded-full bg-secondary mb-1"
                })
            })
        })
    })]
})
  , EX = "/assets/logo.jpg"
  , TX = "/assets/backend.png"
  , PX = "/assets/creator.png"
  , BX = "/assets/mobile.png"
  , RX = "/assets/web.png"
  , IX = "/assets/github.png"
  , LX = "/assets/menu.svg"
  , DX = "/assets/close.svg"
  , kX = "/assets/security.png"
  , FX = "/assets/docker.png"
  , NX = "/assets/figma.png"
  , OX = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAYAAAA+VemSAAAACXBIWXMAAAsTAAALEwEAmpwYAAANG0lEQVR4nO2dX6xcRR2AD9QYgpYElEDv3fltqdUSHtSISNWIiIE09vbuzMKa+GBq4p/4hoIGEx/qSxOiL1T62Adj4kN90gegSXnQxAdCIiYkloQKSKKQpo3c7szeikrXzPZCW3r39uzdc2bOzPm+5Jc0t7t7dn4z386cc+bMFAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQFs415cdVqtHrJZjzqgTToudhFEn/N/8//nXxP6eAHAJIy13Oi3HnZFxqdBy3L+HJAJEZLy/e5016og1cr60vGvh3+Pf6z+DSgQIzGhZLVgjz80q7hUia/XC6mCHUIEAgfDCWS2vzCvvJRK/zrkxQILyIjFA4vIiMUDi8iIxQOLyIjFA4vIiMUDi8iIxQOLyIjFA4vIiMUDi8iIxQOLyIjFA4vIiMUDi8iIxQOLyIjFA4vIiMbSe1OVFYmgtuciLxNBKnJE/xJaucomNeu1cr7s9dm4Baie3HpieGFoHEgMkDhIDJA4SAyQOEgMkDhIDNASn5YDV8vis70NigMg4LT++eFsFibnFBMngjPzoynujSIzE0Hhsv/vo9AkOSIzE0Fj8vrtXn6WExEgMjcMa9cPyUw2RGImhMVijfjD7fGEkRmKIjtXq4c1P+kdiJIZojLR8z+9wP9+TO0iMxBAcp+W788qLxDyKCBFwRr5TlbxIjMQQENeTb1st71QpLxIjMSQ2bJ4qsVE/m/V7+SVs/FI2l/8YqDeslmecVof9ebYPp9Uhq9VTTqtTdZahwlywPA80v+etSmJn5EVn5Aln5DPjorhm2mvHB4prR8uLd1stB61Wb8YWFYmhVlxPfSuUvPNcnd4M46Vt1zsjjzmj3oot6/RcqNfP9WVHiHxAZjit9oeWN7TEntGgs2i1PB9bViSGynB9+WYseecZTs/ZGx+NLesGueCcGMphtfq6NfLfRjTcgD3xeFBssUY9HbvM03PBcBqugjUyaIq8MSRe2Ss3Oi0vxy4zEsPMDI081DR5Y0g87KkvxS4vEkOyw+ZpMdTdfqhqndxHbkCZp/6gcU4MKfS8lzTYf9t9t90SqtZGpnNX7DIjMVwV36tZrf7T/MYqvwtdnc7IycbnRXNhq7WMTNekIK+PkVbfD50fp9UvY5e73I+b4hZT2xhp1bNavR278ZUWeHnx7tA5clqWYpcbieEKRj21LyV5fQwHt94cuipX9nV2xi43EsNlONPZY7U6F7uxzRrjwR0fDF2Vp5d3bY1d7pkl1pwTZ4vrd7/mr+bGbmSbEnhp2/Wh8+VnZsUu96YkNpwTZ4fT6oEUe953Y7W3oELn7MyenTfELvemJdb0xNmQurwTgXX386Hz5h/ji13uuSQ29MTJY42632pZjd2Y5m6MWj0S42Jf7HIjcYuxPflqDvJeEFh+Hzx/Wv0idrmRuKXYfvcr1sgoduOpTmD1dsiplH5ZnhRmYrmy+WM4nQ621703J3nfC61+GvJ2W/TyInH7GPbli06Ljd1Y6gl11hnZFiKPq4MdYrW8Er/M1Ybl6nRzmTzHmq28a6HVb0Llc70la3MIy3C6eZztyRecUcPYjSNIA9Tq4VB5pSeG2mmTvBcElv9Z3flGqKZFTwy1MTLd3WvnhtHFCiqx3yVCq59stIh7lSAxVI7fhcAZ+VdsmaKGlj8Ol+WOEM2L4TRUvORLc3cUCH6PWKtfj3Tnc3U3MXpimJvRg+qzyLu+zGVz6Iz81hn1Vy/krPlHYtg0rtf9tDNyJnav19Qoncc59x5iOA0zg7zVC4zEst4pCRuqVY0z2z9Fz1uPwEgsSFwn9sHFTzojp2MPT3MWGIkFietg2O/e3vSNqHMRGIkFiZE3bYGRWJC4Cs4ub99ltXojdo/WRoGRWJAYedMWGIkFiTfV8+qFT1gj/4zdk6UaVQqMxILEM8nbX/w48jZLYCQWJEbedHvgeR+CX2/apb+2Mdl/WKvDfuNyH06rQ1arp5xWp2KPYlyN+cgSvweP1fKP2JWSQ5TNechG69/jjLzojDzhnyDb6BHI8YHiWr+Rm9VysOm3Dy0SF8Vqf3s3x2VbchQ49DRDv52MM/JYkx9csW2edom86Qkco9GOBp1Fq+X52LK6huSjEZzbJ7f5gsdOfm5RNv+pDR/XeuOjsfPrGpKPqIyW1QLD5rQFjiLxl4sPOC3HY8vqNsiHb9tFzoz3d6+zRp6Lnexco2w9pDp8XNkrNzotL8fOs5uejz/H2Ao2GNaoI7GTnHOUrYdKG23gntjvvBE7z27jfBwpcn0g32p5J3aCc47SdVF1ow3cE0/uIzcg3269XBg5P9JyZ5EbTT5/ySVK10Utx+/sKYIuahg/31NDy/EiJ1LfLDqVKFsfNRz7ZKg1qt/FGvVq7HxvFFndWrL97qOxE9qGKFsfVR/XGvXzelvQOmXQ6lDsfDdtU/basFqOxU5oG6JsfVR93FFP7au3Ba1TBi1LsfO9Ufg2X+SC0+ql2AltQ5SujwyGi34OvWtAzqeGVi8VudCmzcdiRvn6qPa4p5d3bS0C44/pGpDz6aGGRS4gcN4CjwfFliIw/pguuqRtEZghdN4C33/Lh4rAJNADnyhygYtYeQvMObDkfRHLX1KP/4uYf5StjxqOvbfeFpTiVWiVz22ktVUZoic19yhbH5UfW6tD9bag9cqgnoyd79ZM5PAwlTJfgf2sqCIwjZ6JpTObSunxE7z9RO/oyc04ytZFHcf285OLQDR5LrTN9WEGD48T5iuwf0KoCESzn0ZSeT5O6OGB/nwFXut97qt/w7vOPbEldW19oN/Dkjr5CuyfSloZdG6qq+34z3ZG/hZbVNfWJXXeZXWwQ6yWV2InPbcom/96v4d61q9fVcfMK2vU07Fz7NaJdq5Muc6q/UQOAk/iaJVDySavSmnbtCLl+6EnrrYxlc17oIb9F7/2d87rQts29rzvB4nzFHgSWqzf++jMnp03zNou/PzqJu/MYJH3IgynMxX4YmN/0+93NDLd3X7/ow33RjLd3U3fG8m2edg8DSTOV+DLQqtTk4tRl+9OeHjtb43fndAi73QYTrdA4ITDMmy+OkiMwLFFdcg7H0hMDxxbWEfPi8ShG1rZjMcWIqWwDJvpiRE4vogOeePAcJoeGHkTB4kZQtPzJg4Scw7MsDlxkJiLWJzzJg4ScxWaC1aJw7TL99/qkHesVk+VzZ9/LZuty8X8MT0yPEh8YQE1a+RXK1p9bNb8+ff497Z9oUGLvPFos8RWq7/bXvfeeXPoP8N/VuzyIG9LaeM58eQB90H31qpyOFza9lGn1Z/alUPFw/hNoU09sV/p4tTg5g9XnUP/mf6zW5LD13iet2G0QWL/kPtqb0HVlUP/2U1+kB55Myf34fTQyEN159AaGWQrr2bY3Hiy7YkD7reT4z5WlmFzOuTYE1uj7g+VP6fVA1nlTtPzJkdmPfHJcVFcEyp3/lj+mFnIa7hglSwZ9cRPhM6d3/M3eXk1PW/y5CDxsCcPhs6bv2AWu9zIC1kMp4f97u2hq9IfM3a5NxuWYXN+pNwTn9ULHwmdr8nsrBTl1QybsyXVnriO3f6uhj9mcvIaLlhlT4o9sd8nKHSeTi/v2pqUvJqetzWk1hPH2AFvZV9nZzLyGnre1pGYxHtD58dpWWpAuZEXMhhOa3UodD06o56MXu6rhGXYDClI7B+4D11T1qhXY5cbeSGb4fTIdO4KVZ3+WI2Wl3NeSK0ntlqeCVVrVsux5uaBq82QqsRG7qu78ob9zj2xy4m8kKXE/rzUz5Cqq3pXBp2bmvoUEj0vZCGxM+rZOmZmjQfFFmvU0/HLh7yQ/4Wto+OlbddXVdH+s/xnNqBcVwQXrCDLntivILna396dt3pHg87iZJnaJpaRC1aQs8ROi7VaHj+zZ+cNs5bLz692Rh5zRr0VvRzICy0eTk+Wm7VaDo5Md/f4QHHttHL4//Ov8a9t8vKxDJuhdRK/F1qdmlyM0uqw7519TP594W+non8/5IVYNHo4nUFwzgu1g8TIC4mDxPS8kDhIzLAZEgeJOeeFxEFiLlhB4iAxV5shcZCYW0WQOEjMfV5IHCRmkgYkDhIzwwoSB4mZHgmJ03aJmdsMydNWiZEXsqFtEiMvZEdbJEZeyJbcJUZeyJ5cJUZeaA25SYy80DpykRh5obWkLjHyQutJVWLkBUhUYuQFSFRi5AVIVGLkBUhUYuQFSFRi5AVIVGLkBUhUYuQFSFRi5AVIVGLkBUhUYuQFSFRi5AVIVGLkBUhUYuQFCMxoWS1YI89VIO8L/geBCgQIzHh/9zpr1BFr5PzM4ho579/rP4OKA4jISMudTsvx0gJrOe7fQ6UBNIhzfdlhtXrEajnmjDrhtNhJGHXC/83/n39N7O8JAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFCE4v/t8177cNMPugAAAABJRU5ErkJggg=="
  , UX = "/assets/CASP.png"
  , zX = "/assets/Cysa.png"
  , GX = "/assets/mongodb.png"
  , HX = "/assets/nodejs.png"
  , VX = "/assets/Linux.png"
  , WX = "/assets/a+.png"
  , jX = "/assets/tailwind.png"
  , JX = "/assets/pentest.png"
  , XX = "/assets/threejs.svg"
  , YX = "/assets/meta.png"
  , KX = "/assets/shopify.png"
  , QX = "/assets/army.jpg"
  , ZX = "/assets/Hydro.png"
  , qX = "/assets/arbitrage.jpg"
  , $X = "/assets/bsf.webp"
  , eY = "/assets/cognitive.webp"
  , X2 = [{
    id: "about",
    title: "About"
}, {
    id: "work",
    title: "Work"
}, {
    id: "work",
    title: "Github"
}, {
    id: "contact",
    title: "Contact"
}]
  , tY = [{
    title: "Front-end Developer",
    icon: RX
}, {
    title: "Systems Administrator",
    icon: BX
}, {
    title: "Software Engineer",
    icon: TX
}, {
    title: "Ethical Hacker",
    icon: PX
}]
  , nY = [{
    name: "HTML 5",
    icon: UX
}, {
    name: "CSS 3",
    icon: kX
}, {
    name: "JavaScript",
    icon: zX
}, {
    name: "TypeScript",
    icon: JX
}, {
    name: "React JS",
    icon: VX
}, {
    name: "Redux Toolkit",
    icon: WX
}, {
    name: "Tailwind CSS",
    icon: jX
}, {
    name: "Node JS",
    icon: HX
}, {
    name: "MongoDB",
    icon: GX
}, {
    name: "Three JS",
    icon: XX
}, {
    name: "git",
    icon: OX
}, {
    name: "figma",
    icon: NX
}, {
    name: "docker",
    icon: FX
}]
  , iY = [{
    title: "US Army",
    company_name: "25B Info. Tech Specialist",
    icon: QX,
    iconBg: "#383E56",
    date: "March 2009 - Dec 2011",
    points: ["Led deployment and management of BnCPN equipment.", "Revolutionized Network Operations (NETOPS) with a holistic Service Desk Management framework.", "Integrated COTS equipment and managed WAN surveillance and management."]
}, {
    title: "Hydro Engineering",
    company_name: "Systems Administrator",
    icon: ZX,
    iconBg: "#E6DEDD",
    date: "December 2011 - Feb 2020",
    points: ["Enhanced IT infrastructure to achieve 99.9% uptime.", "Developed software for wireless heatmap analysis, improving network performance.", "Managed and upgraded Netgate & Cisco Firewalls, implementing advanced security protocols."]
}, {
    title: "Hydro Engineering",
    company_name: "Junior Software Engineer",
    icon: ZX,
    iconBg: "#383E56",
    date: "February 2021 - Present",
    points: ["Developed custom file attachment executable in Java to enhance bug tracking system.", "Created proprietary software to identify network vulnerabilities using NMAP NSE scripts.", "Automated server shutdown processes using Python and SNMP protocol."]
}]
  , rY = [
    {
        testimonial: "Daniels holistic view of IT has been paramount to solving a number of the challenges we have come across in our near three years working together. Whether its improving project management with the latest work flow software, fortifying application design with acute knowledge of the latest threat vectors, or streamlining development of applications with a DRY paradigm; I can always count on Daniel to deliver a well thought out plan of attack to get the job done right and securely.",
        name: "Kyler Peek",
        designation: "Co-Worker",
        company: "Hydro Engineering",
        image: "/assets/kyler.jpg"
    },
    {
    testimonial: "I have worked with River for the past 2 years at Hydro Engineering and he has done a very good job at IT Support, systems/network administration and programming. He has the ability to come up with creative out of box solutions due to his knowledge in all three areas. River supports our cyber security processes too ensuring our software and network vulerabilities are patched and up to date. He has added several services within our application to assist with redunancy and automation using different scripts and hardware configuration. I would recommend River for a programming or system administration based role.",
    name: "Michael Martinez",
    designation: "Co-Worker",
    company: "Hydro Engineering",
    image: "/assets/mike.jpg"
},]
  , sY = [{
    name: "Currency Arbritrage",
    description: "Developed a sophisticated software tool designed to exploit price discrepancies in different currency exchange markets. This project involved creating algorithms to identify arbitrage opportunities, automating trade executions, and optimizing profit margins through real-time data analysis and swift transaction handling. The solution was built with a focus on accuracy, speed, and security to ensure reliable and profitable arbitrage operations in the dynamic world of currency trading.",
    tags: [{
        name: "python",
        color: "blue-text-gradient"
    }, {
        name: "api",
        color: "green-text-gradient"
    }, {
        name: "bellman-ford algorithm",
        color: "pink-text-gradient"
    }],
    image: qX,
    source_code_link: "https://github.com/dbrooks228"
}, {
    name: "Directory Cleanup Using Breadth First Search (BSF)",
    description: "Developed a directory cleanup tool using the Breadth First Search (BFS) algorithm to efficiently traverse and manage file systems. This project aimed to optimize disk space usage and improve system performance by systematically identifying and removing unnecessary or obsolete files. The tool was designed to handle large and complex directory structures, ensuring thorough and effective cleanup operations while maintaining data integrity.",
    tags: [{
        name: "python",
        color: "blue-text-gradient"
    }, {
        name: "depth first search",
        color: "green-text-gradient"
    }, {
        name: "algorithms",
        color: "pink-text-gradient"
    }],
    image: $X,
    source_code_link: "https://github.com/dbrooks228"
}, {
    name: "Cognitive Tests",
    description: "Created a comprehensive platform for administering and evaluating cognitive tests. This project involved developing various interactive tests to measure cognitive functions such as memory, attention, and problem-solving skills. The platform was designed to provide detailed insights into individual cognitive abilities, offering customized reports and analysis to support research and personal development. Emphasis was placed on user-friendly interfaces and accurate, reliable assessment methodologies.",
    tags: [{
        name: "python",
        color: "blue-text-gradient"
    }, {
        name: "PSAT",
        color: "green-text-gradient"
    }, {
        name: "Digit Span",
        color: "pink-text-gradient"
    }],
    image: eY,
    source_code_link: "https://github.com/dbrooks228"
}]
  , oY = ()=>{
    const [n,e] = U.useState("")
      , [t,i] = U.useState(!1)
      , [r,s] = U.useState(!1);
    return U.useEffect(()=>{
        const o = ()=>{
            window.scrollY > 100 ? s(!0) : s(!1)
        }
        ;
        return window.addEventListener("scroll", o),
        ()=>window.removeEventListener("scroll", o)
    }
    , []),
    he("nav", {
        className: `${Yn.paddingX} w-full flex items-center py-5 fixed top-0 z-20 ${r ? "bg-primary" : "bg-transparent"}`,
        children: it("div", {
            className: "w-full flex justify-between items-center max-w-7xl mx-auto",
            children: [it(n4, {
                to: "/",
                className: "flex items-center gap-2",
                onClick: ()=>{
                    e(""),
                    window.scrollTo(0, 0)
                }
                ,
                children: [
                    he("img", {
                        src: EX,
                        alt: "logo",
                        className: "w-9 h-9 object-contain rounded-full" // Added rounded-full class for border radius
                    }), 
                    he("p", {
                        className: "text-white text-[18px] font-bold cursor-pointer flex",
                        children: he("span", {
                            className: "sm:block hidden",
                            children: "Daniel G. Brooks"
                        })
                    })
                ]
            }), he("ul", {
                className: "list-none hidden sm:flex flex-row gap-10",
                children: X2.map(o=>he("li", {
                    className: `${n === o.title ? "text-white" : "text-secondary"} hover:text-white text-[18px] font-medium cursor-pointer`,
                    onClick: ()=>e(o.title),
                    children: o.title === "Github" ? he("a", {
                        href: o.title === "Github" ? "https://github.com/dbrooks228" : "#",
                        target: "_blank",
                        rel: "noopener noreferrer",
                        children: o.title
                    }) : he("a", {
                        href: `#${o.id}`,
                        children: o.title
                    })
                }, o.id))
            }), it("div", {
                className: "sm:hidden flex flex-1 justify-end items-center",
                children: [he("img", {
                    src: t ? DX : LX,
                    alt: "menu",
                    className: "w-[28px] h-[28px] object-contain",
                    onClick: ()=>i(!t)
                }), he("div", {
                    className: `${t ? "flex" : "hidden"} p-6 black-gradient absolute top-20 right-0 mx-4 my-2 min-w-[140px] z-10 rounded-xl`,
                    children: he("ul", {
                        className: "list-none flex justify-end items-start flex-1 flex-col gap-4",
                        children: X2.map(o=>he("li", {
                            className: `font-poppins font-medium cursor-pointer text-[16px] ${n === o.title ? "text-white" : "text-secondary"}`,
                            onClick: ()=>{
                                i(!t),
                                e(o.title)
                            }
                            ,
                            children: o.title === "Github" ? he("a", {
                                href: o.title === "Github" ? "https://github.com/dbrooks228" : "#",
                                target: "_blank",
                                rel: "noopener noreferrer",
                                children: o.title
                            }) : he("a", {
                                href: `#${o.id}`,
                                children: o.title
                            })
                        }, o.id))
                    })
                })]
            })]
        })
    })
}
;
var wD = {};
Object.defineProperty(wD, "__esModule", {
    value: !0
});
var Ef = Object.assign || function(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var i in t)
            Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
    }
    return n
}
  , aY = function() {
    function n(e, t) {
        for (var i = 0; i < t.length; i++) {
            var r = t[i];
            r.enumerable = r.enumerable || !1,
            r.configurable = !0,
            "value"in r && (r.writable = !0),
            Object.defineProperty(e, r.key, r)
        }
    }
    return function(e, t, i) {
        return t && n(e.prototype, t),
        i && n(e, i),
        e
    }
}()
  , SD = U
  , lY = cY(SD)
  , uY = pg;
function cY(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
function fY(n, e) {
    if (!(n instanceof e))
        throw new TypeError("Cannot call a class as a function")
}
function dY(n, e) {
    if (!n)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : n
}
function hY(n, e) {
    if (typeof e != "function" && e !== null)
        throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    n.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: n,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }),
    e && (Object.setPrototypeOf ? Object.setPrototypeOf(n, e) : n.__proto__ = e)
}
var pY = function(n) {
    hY(e, n);
    function e(t) {
        fY(this, e);
        var i = dY(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t));
        i.state = {
            style: {}
        };
        var r = {
            reverse: !1,
            max: 35,
            perspective: 1e3,
            easing: "cubic-bezier(.03,.98,.52,.99)",
            scale: "1.1",
            speed: "1000",
            transition: !0,
            axis: null,
            reset: !0
        };
        return i.width = null,
        i.height = null,
        i.left = null,
        i.top = null,
        i.transitionTimeout = null,
        i.updateCall = null,
        i.element = null,
        i.settings = Object.assign({}, r, i.props.options),
        i.reverse = i.settings.reverse ? -1 : 1,
        i.onMouseEnter = i.onMouseEnter.bind(i, i.props.onMouseEnter),
        i.onMouseMove = i.onMouseMove.bind(i, i.props.onMouseMove),
        i.onMouseLeave = i.onMouseLeave.bind(i, i.props.onMouseLeave),
        i
    }
    return aY(e, [{
        key: "componentDidMount",
        value: function() {
            this.element = (0,
            uY.findDOMNode)(this)
        }
    }, {
        key: "componentWillUnmount",
        value: function() {
            clearTimeout(this.transitionTimeout),
            cancelAnimationFrame(this.updateCall)
        }
    }, {
        key: "onMouseEnter",
        value: function() {
            var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {}
              , r = arguments[1];
            return this.updateElementPosition(),
            this.setState(Object.assign({}, this.state, {
                style: Ef({}, this.state.style, {
                    willChange: "transform"
                })
            })),
            this.setTransition(),
            i(r)
        }
    }, {
        key: "reset",
        value: function() {
            var i = this;
            window.requestAnimationFrame(function() {
                i.setState(Object.assign({}, i.state, {
                    style: Ef({}, i.state.style, {
                        transform: "perspective(" + i.settings.perspective + "px) rotateX(0deg) rotateY(0deg) scale3d(1, 1, 1)"
                    })
                }))
            })
        }
    }, {
        key: "onMouseMove",
        value: function() {
            var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {}
              , r = arguments[1];
            return r.persist(),
            this.updateCall !== null && window.cancelAnimationFrame(this.updateCall),
            this.event = r,
            this.updateCall = requestAnimationFrame(this.update.bind(this, r)),
            i(r)
        }
    }, {
        key: "setTransition",
        value: function() {
            var i = this;
            clearTimeout(this.transitionTimeout),
            this.setState(Object.assign({}, this.state, {
                style: Ef({}, this.state.style, {
                    transition: this.settings.speed + "ms " + this.settings.easing
                })
            })),
            this.transitionTimeout = setTimeout(function() {
                i.setState(Object.assign({}, i.state, {
                    style: Ef({}, i.state.style, {
                        transition: ""
                    })
                }))
            }, this.settings.speed)
        }
    }, {
        key: "onMouseLeave",
        value: function() {
            var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {}
              , r = arguments[1];
            return this.setTransition(),
            this.settings.reset && this.reset(),
            i(r)
        }
    }, {
        key: "getValues",
        value: function(i) {
            var r = (i.nativeEvent.clientX - this.left) / this.width
              , s = (i.nativeEvent.clientY - this.top) / this.height
              , o = Math.min(Math.max(r, 0), 1)
              , a = Math.min(Math.max(s, 0), 1)
              , l = (this.reverse * (this.settings.max / 2 - o * this.settings.max)).toFixed(2)
              , c = (this.reverse * (a * this.settings.max - this.settings.max / 2)).toFixed(2)
              , d = o * 100
              , h = a * 100;
            return {
                tiltX: l,
                tiltY: c,
                percentageX: d,
                percentageY: h
            }
        }
    }, {
        key: "updateElementPosition",
        value: function() {
            var i = this.element.getBoundingClientRect();
            this.width = this.element.offsetWidth,
            this.height = this.element.offsetHeight,
            this.left = i.left,
            this.top = i.top
        }
    }, {
        key: "update",
        value: function(i) {
            var r = this.getValues(i);
            this.setState(Object.assign({}, this.state, {
                style: Ef({}, this.state.style, {
                    transform: "perspective(" + this.settings.perspective + "px) rotateX(" + (this.settings.axis === "x" ? 0 : r.tiltY) + "deg) rotateY(" + (this.settings.axis === "y" ? 0 : r.tiltX) + "deg) scale3d(" + this.settings.scale + ", " + this.settings.scale + ", " + this.settings.scale + ")"
                })
            })),
            this.updateCall = null
        }
    }, {
        key: "render",
        value: function() {
            var i = Object.assign({}, this.props.style, this.state.style);
            return lY.default.createElement("div", {
                style: i,
                className: this.props.className,
                onMouseEnter: this.onMouseEnter,
                onMouseMove: this.onMouseMove,
                onMouseLeave: this.onMouseLeave
            }, this.props.children)
        }
    }]),
    e
}(SD.Component)
  , MD = wD.default = pY;
const K0 = n=>({
    hidden: {
        y: -50,
        opacity: 0
    },
    show: {
        y: 0,
        opacity: 1,
        transition: {
            type: "spring",
            duration: 1.25,
            delay: n
        }
    }
})
  , Sh = (n,e,t,i)=>({
    hidden: {
        x: n === "left" ? 100 : n === "right" ? -100 : 0,
        y: n === "up" ? 100 : n === "down" ? -100 : 0,
        opacity: 0
    },
    show: {
        x: 0,
        y: 0,
        opacity: 1,
        transition: {
            type: e,
            delay: t,
            duration: i,
            ease: "easeOut"
        }
    }
})
  , Y2 = (n,e,t,i)=>({
    hidden: {
        x: n === "left" ? "-100%" : n === "right" ? "100%" : 0,
        y: n === "up" || n === "down" ? "100%" : 0
    },
    show: {
        x: 0,
        y: 0,
        transition: {
            type: e,
            delay: t,
            duration: i,
            ease: "easeOut"
        }
    }
})
  , mY = (n,e)=>({
    hidden: {},
    show: {
        transition: {
            staggerChildren: n,
            delayChildren: e || 0
        }
    }
})
  , Pc = (n,e)=>function() {
    return it(Qi.section, {
        variants: mY(),
        initial: "hidden",
        whileInView: "show",
        viewport: {
            once: !0,
            amount: .25
        },
        className: `${Yn.padding} max-w-7xl mx-auto relative z-0`,
        children: [he("span", {
            className: "hash-span",
            id: e,
            children: ""
        }), he(n, {})]
    })
}
  , gY = ({index: n, title: e, icon: t})=>he(MD, {
    className: "xs:w-[250px] w-full",
    children: he(Qi.div, {
        variants: Sh("right", "spring", n * .5, .75),
        className: "w-full green-pink-gradient p-[1px] rounded-[20px] shadow-card",
        children: it("div", {
            options: {
                max: 45,
                scale: 1,
                speed: 450
            },
            className: "bg-tertiary rounded-[20px] py-5 px-12 min-h-[280px] flex justify-evenly items-center flex-col",
            children: [he("img", {
                src: t,
                alt: "web-development",
                className: "w-16 h-16 object-contain"
            }), he("h3", {
                className: "text-white text-[20px] font-bold text-center",
                children: e
            })]
        })
    })
})
  , vY = ()=>it(_A, {
    children: [it(Qi.div, {
        variants: K0(),
        children: [he("p", {
            className: Yn.sectionSubText,
            children: "Introduction"
        }), he("h2", {
            className: Yn.sectionHeadText,
            children: "Overview."
        })]
    }), he(Qi.p, {
        variants: Sh("", "", .1, 1),
        className: "mt-4 text-secondary text-[17px] max-w-3xl leading-[30px]",
        children: "As a dedicated Junior Software Engineer at Hydro Engineering Inc., I specialize in crafting solutions that preemptively identify and address security vulnerabilities, leveraging Agile methodologies. My role focuses on developing proprietary software to enhance network security and safeguard our infrastructure. Concurrently, my position as an Information Technology Specialist with the U.S. Army emphasizes strategic communication and network operations, setting benchmarks in service desk management. I am committed to merging foundational knowledge with advanced cybersecurity practices, actively enhancing my skills through Hack The Box challenges and pursuing a Bachelor's in Computer Science and Cybersecurity at Western Governors University."
    }), he("div", {
        className: "mt-20 flex flex-wrap gap-10",
        children: tY.map((n,e)=>he(gY, {
            index: e,
            ...n
        }, n.title))
    })]
})
  , yY = Pc(vY, "about")
  , xY = ()=>he("div", {
    className: "flex flex-row flex-wrap justify-center gap-10",
    children: nY.map(n=>he("div", {
        className: "w-28 h-28",
        children: he(fW, {
            icon: n.icon
        })
    }, n.name))
})
  , _Y = Pc(xY, "");
var Q0 = {}
  , qg = {}
  , AY = {
    get exports() {
        return qg
    },
    set exports(n) {
        qg = n
    }
};
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(n) {
    (function() {
        var e = {}.hasOwnProperty;
        function t() {
            for (var i = [], r = 0; r < arguments.length; r++) {
                var s = arguments[r];
                if (s) {
                    var o = typeof s;
                    if (o === "string" || o === "number")
                        i.push(s);
                    else if (Array.isArray(s)) {
                        if (s.length) {
                            var a = t.apply(null, s);
                            a && i.push(a)
                        }
                    } else if (o === "object") {
                        if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]")) {
                            i.push(s.toString());
                            continue
                        }
                        for (var l in s)
                            e.call(s, l) && s[l] && i.push(l)
                    }
                }
            }
            return i.join(" ")
        }
        n.exports ? (t.default = t,
        n.exports = t) : window.classNames = t
    }
    )()
}
)(AY);
Q0.__esModule = !0;
Q0.default = void 0;
var wY = FS(U)
  , bo = FS(ht)
  , SY = FS(qg);
function FS(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
const bD = ({animate: n=!0, className: e="", layout: t="2-columns", lineColor: i="#FFF", children: r})=>(typeof window == "object" && document.documentElement.style.setProperty("--line-color", i),
wY.default.createElement("div", {
    className: (0,
    SY.default)(e, "vertical-timeline", {
        "vertical-timeline--animate": n,
        "vertical-timeline--two-columns": t === "2-columns",
        "vertical-timeline--one-column-left": t === "1-column" || t === "1-column-left",
        "vertical-timeline--one-column-right": t === "1-column-right"
    })
}, r));
bD.propTypes = {
    children: bo.default.oneOfType([bo.default.arrayOf(bo.default.node), bo.default.node]).isRequired,
    className: bo.default.string,
    animate: bo.default.bool,
    layout: bo.default.oneOf(["1-column-left", "1-column", "2-columns", "1-column-right"]),
    lineColor: bo.default.string
};
var MY = bD;
Q0.default = MY;
var Z0 = {};
function $_() {
    return $_ = Object.assign || function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
        }
        return n
    }
    ,
    $_.apply(this, arguments)
}
function bY(n, e) {
    n.prototype = Object.create(e.prototype),
    n.prototype.constructor = n,
    eA(n, e)
}
function eA(n, e) {
    return eA = Object.setPrototypeOf || function(i, r) {
        return i.__proto__ = r,
        i
    }
    ,
    eA(n, e)
}
function CY(n, e) {
    if (n == null)
        return {};
    var t = {}, i = Object.keys(n), r, s;
    for (s = 0; s < i.length; s++)
        r = i[s],
        !(e.indexOf(r) >= 0) && (t[r] = n[r]);
    return t
}
var tA = new Map
  , Im = new WeakMap
  , K2 = 0
  , CD = void 0;
function EY(n) {
    CD = n
}
function TY(n) {
    return n ? (Im.has(n) || (K2 += 1,
    Im.set(n, K2.toString())),
    Im.get(n)) : "0"
}
function PY(n) {
    return Object.keys(n).sort().filter(function(e) {
        return n[e] !== void 0
    }).map(function(e) {
        return e + "_" + (e === "root" ? TY(n.root) : n[e])
    }).toString()
}
function BY(n) {
    var e = PY(n)
      , t = tA.get(e);
    if (!t) {
        var i = new Map, r, s = new IntersectionObserver(function(o) {
            o.forEach(function(a) {
                var l, c = a.isIntersecting && r.some(function(d) {
                    return a.intersectionRatio >= d
                });
                n.trackVisibility && typeof a.isVisible > "u" && (a.isVisible = c),
                (l = i.get(a.target)) == null || l.forEach(function(d) {
                    d(c, a)
                })
            })
        }
        ,n);
        r = s.thresholds || (Array.isArray(n.threshold) ? n.threshold : [n.threshold || 0]),
        t = {
            id: e,
            observer: s,
            elements: i
        },
        tA.set(e, t)
    }
    return t
}
function NS(n, e, t, i) {
    if (t === void 0 && (t = {}),
    i === void 0 && (i = CD),
    typeof window.IntersectionObserver > "u" && i !== void 0) {
        var r = n.getBoundingClientRect();
        return e(i, {
            isIntersecting: i,
            target: n,
            intersectionRatio: typeof t.threshold == "number" ? t.threshold : 0,
            time: 0,
            boundingClientRect: r,
            intersectionRect: r,
            rootBounds: r
        }),
        function() {}
    }
    var s = BY(t)
      , o = s.id
      , a = s.observer
      , l = s.elements
      , c = l.get(n) || [];
    return l.has(n) || l.set(n, c),
    c.push(e),
    a.observe(n),
    function() {
        c.splice(c.indexOf(e), 1),
        c.length === 0 && (l.delete(n),
        a.unobserve(n)),
        l.size === 0 && (a.disconnect(),
        tA.delete(o))
    }
}
var RY = ["children", "as", "triggerOnce", "threshold", "root", "rootMargin", "onChange", "skip", "trackVisibility", "delay", "initialInView", "fallbackInView"];
function Q2(n) {
    return typeof n.children != "function"
}
var $g = function(n) {
    bY(e, n);
    function e(i) {
        var r;
        return r = n.call(this, i) || this,
        r.node = null,
        r._unobserveCb = null,
        r.handleNode = function(s) {
            r.node && (r.unobserve(),
            !s && !r.props.triggerOnce && !r.props.skip && r.setState({
                inView: !!r.props.initialInView,
                entry: void 0
            })),
            r.node = s || null,
            r.observeNode()
        }
        ,
        r.handleChange = function(s, o) {
            s && r.props.triggerOnce && r.unobserve(),
            Q2(r.props) || r.setState({
                inView: s,
                entry: o
            }),
            r.props.onChange && r.props.onChange(s, o)
        }
        ,
        r.state = {
            inView: !!i.initialInView,
            entry: void 0
        },
        r
    }
    var t = e.prototype;
    return t.componentDidUpdate = function(r) {
        (r.rootMargin !== this.props.rootMargin || r.root !== this.props.root || r.threshold !== this.props.threshold || r.skip !== this.props.skip || r.trackVisibility !== this.props.trackVisibility || r.delay !== this.props.delay) && (this.unobserve(),
        this.observeNode())
    }
    ,
    t.componentWillUnmount = function() {
        this.unobserve(),
        this.node = null
    }
    ,
    t.observeNode = function() {
        if (!(!this.node || this.props.skip)) {
            var r = this.props
              , s = r.threshold
              , o = r.root
              , a = r.rootMargin
              , l = r.trackVisibility
              , c = r.delay
              , d = r.fallbackInView;
            this._unobserveCb = NS(this.node, this.handleChange, {
                threshold: s,
                root: o,
                rootMargin: a,
                trackVisibility: l,
                delay: c
            }, d)
        }
    }
    ,
    t.unobserve = function() {
        this._unobserveCb && (this._unobserveCb(),
        this._unobserveCb = null)
    }
    ,
    t.render = function() {
        if (!Q2(this.props)) {
            var r = this.state
              , s = r.inView
              , o = r.entry;
            return this.props.children({
                inView: s,
                entry: o,
                ref: this.handleNode
            })
        }
        var a = this.props
          , l = a.children
          , c = a.as
          , d = CY(a, RY);
        return U.createElement(c || "div", $_({
            ref: this.handleNode
        }, d), l)
    }
    ,
    e
}(U.Component);
$g.displayName = "InView";
$g.defaultProps = {
    threshold: 0,
    triggerOnce: !1,
    initialInView: !1
};
function IY(n) {
    var e = n === void 0 ? {} : n
      , t = e.threshold
      , i = e.delay
      , r = e.trackVisibility
      , s = e.rootMargin
      , o = e.root
      , a = e.triggerOnce
      , l = e.skip
      , c = e.initialInView
      , d = e.fallbackInView
      , h = U.useRef()
      , p = U.useState({
        inView: !!c
    })
      , m = p[0]
      , y = p[1]
      , v = U.useCallback(function(_) {
        h.current !== void 0 && (h.current(),
        h.current = void 0),
        !l && _ && (h.current = NS(_, function(A, w) {
            y({
                inView: A,
                entry: w
            }),
            w.isIntersecting && a && h.current && (h.current(),
            h.current = void 0)
        }, {
            root: o,
            rootMargin: s,
            threshold: t,
            trackVisibility: r,
            delay: i
        }, d))
    }, [Array.isArray(t) ? t.toString() : t, o, s, a, l, r, d, i]);
    U.useEffect(function() {
        !h.current && m.entry && !a && !l && y({
            inView: !!c
        })
    });
    var x = [v, m.inView, m.entry];
    return x.ref = x[0],
    x.inView = x[1],
    x.entry = x[2],
    x
}
const LY = Object.freeze(Object.defineProperty({
    __proto__: null,
    InView: $g,
    default: $g,
    defaultFallbackInView: EY,
    observe: NS,
    useInView: IY
}, Symbol.toStringTag, {
    value: "Module"
}))
  , DY = $k(LY);
Z0.__esModule = !0;
Z0.default = void 0;
var Co = OS(U)
  , $t = OS(ht)
  , Lm = OS(qg)
  , kY = DY;
function OS(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
const ED = ({children: n="", className: e="", contentArrowStyle: t=null, contentStyle: i=null, date: r="", dateClassName: s="", icon: o=null, iconClassName: a="", iconOnClick: l=null, onTimelineElementClick: c=null, iconStyle: d=null, id: h="", position: p="", style: m=null, textClassName: y="", intersectionObserverProps: v={
    rootMargin: "0px 0px -40px 0px",
    triggerOnce: !0
}, visible: x=!1})=>Co.default.createElement(kY.InView, v, ({inView: _, ref: A})=>Co.default.createElement("div", {
    ref: A,
    id: h,
    className: (0,
    Lm.default)(e, "vertical-timeline-element", {
        "vertical-timeline-element--left": p === "left",
        "vertical-timeline-element--right": p === "right",
        "vertical-timeline-element--no-children": n === ""
    }),
    style: m
}, Co.default.createElement(Co.default.Fragment, null, Co.default.createElement("span", {
    style: d,
    onClick: l,
    className: (0,
    Lm.default)(a, "vertical-timeline-element-icon", {
        "bounce-in": _ || x,
        "is-hidden": !(_ || x)
    })
}, o), Co.default.createElement("div", {
    style: i,
    onClick: c,
    className: (0,
    Lm.default)(y, "vertical-timeline-element-content", {
        "bounce-in": _ || x,
        "is-hidden": !(_ || x)
    })
}, Co.default.createElement("div", {
    style: t,
    className: "vertical-timeline-element-content-arrow"
}), n, Co.default.createElement("span", {
    className: (0,
    Lm.default)(s, "vertical-timeline-element-date")
}, r)))));
ED.propTypes = {
    children: $t.default.oneOfType([$t.default.arrayOf($t.default.node), $t.default.node]),
    className: $t.default.string,
    contentArrowStyle: $t.default.shape({}),
    contentStyle: $t.default.shape({}),
    date: $t.default.node,
    dateClassName: $t.default.string,
    icon: $t.default.element,
    iconClassName: $t.default.string,
    iconStyle: $t.default.shape({}),
    iconOnClick: $t.default.func,
    onTimelineElementClick: $t.default.func,
    id: $t.default.string,
    position: $t.default.string,
    style: $t.default.shape({}),
    textClassName: $t.default.string,
    visible: $t.default.bool,
    intersectionObserverProps: $t.default.shape({
        root: $t.default.object,
        rootMargin: $t.default.string,
        threshold: $t.default.number,
        triggerOnce: $t.default.bool
    })
};
var FY = ED;
Z0.default = FY;
var TD = {
    VerticalTimeline: Q0.default,
    VerticalTimelineElement: Z0.default
};
const NY = ({experience: n})=>it(TD.VerticalTimelineElement, {
    contentStyle: {
        background: "#1d1836",
        color: "#fff"
    },
    contentArrowStyle: {
        borderRight: "7px solid  #232631"
    },
    date: n.date,
    iconStyle: {
        background: n.iconBg
    },
    icon: he("div", {
        className: "flex justify-center items-center w-full h-full",
        children: he("img", {
            src: n.icon,
            alt: n.company_name,
            className: "w-[60%] h-[60%] object-contain"
        })
    }),
    children: [it("div", {
        children: [he("h3", {
            className: "text-white text-[24px] font-bold",
            children: n.title
        }), he("p", {
            className: "text-secondary text-[16px] font-semibold",
            style: {
                margin: 0
            },
            children: n.company_name
        })]
    }), he("ul", {
        className: "mt-5 list-disc ml-5 space-y-2",
        children: n.points.map((e,t)=>he("li", {
            className: "text-white-100 text-[14px] pl-1 tracking-wider",
            children: e
        }, `experience-point-${t}`))
    })]
})
  , OY = ()=>it(_A, {
    children: [it(Qi.div, {
        variants: K0(),
        children: [he("p", {
            className: `${Yn.sectionSubText} text-center`,
            children: "What I have done so far"
        }), he("h2", {
            className: `${Yn.sectionHeadText} text-center`,
            children: "Work Experience."
        })]
    }), he("div", {
        className: "mt-20 flex flex-col",
        children: he(TD.VerticalTimeline, {
            children: iY.map((n,e)=>he(NY, {
                experience: n
            }, `experience-${e}`))
        })
    })]
})
  , UY = Pc(OY, "work")
  , zY = ({index: n, name: e, description: t, tags: i, image: r, source_code_link: s})=>he(Qi.div, {
    variants: Sh("up", "spring", n * .5, .75),
    children: it(MD, {
        options: {
            max: 45,
            scale: 1,
            speed: 450
        },
        className: "bg-tertiary p-5 rounded-2xl sm:w-[360px] w-full",
        children: [it("div", {
            className: "relative w-full h-[230px]",
            children: [he("img", {
                src: r,
                alt: "project_image",
                className: "w-full h-full object-cover rounded-2xl"
            }), he("div", {
                className: "absolute inset-0 flex justify-end m-3 card-img_hover",
                children: he("div", {
                    onClick: ()=>window.open(s, "_blank"),
                    className: "black-gradient w-10 h-10 rounded-full flex justify-center items-center cursor-pointer",
                    children: he("img", {
                        src: IX,
                        alt: "source code",
                        className: "w-1/2 h-1/2 object-contain"
                    })
                })
            })]
        }), it("div", {
            className: "mt-5",
            children: [he("h3", {
                className: "text-white font-bold text-[24px]",
                children: e
            }), he("p", {
                className: "mt-2 text-secondary text-[14px]",
                children: t
            })]
        }), he("div", {
            className: "mt-4 flex flex-wrap gap-2",
            children: i.map(o=>it("p", {
                className: `text-[14px] ${o.color}`,
                children: ["#", o.name]
            }, `${e}-${o.name}`))
        })]
    })
})
  , GY = ()=>{
    const n = ()=>{
        window.open("https://github.com/dbrooks228", "_blank")
    }
    ;
    return it(_A, {
        children: [it(Qi.div, {
            variants: K0(),
            children: [he("p", {
                className: `${Yn.sectionSubText} `,
                children: "My work"
            }), he("h2", {
                className: `${Yn.sectionHeadText}`,
                children: "Projects."
            })]
        }), he("div", {
            className: "w-full flex",
            children: he(Qi.p, {
                variants: Sh("", "", .1, 1),
                className: "mt-3 text-secondary text-[17px] max-w-3xl leading-[30px]",
                children: "Following projects showcases my skills and experience through real-world examples of my work. Each project is briefly described with links to code repositories. It reflects my ability to solve complex problems, work with different technologies, and manage projects effectively."
            })
        }), he("div", {
            className: "mt-20 flex flex-wrap gap-7",
            children: sY.map((e,t)=>he(zY, {
                index: t,
                ...e
            }, `project-${t}`))
        }), he("div", {
            style: {
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                marginTop: "50px"
            },
        })]
    })
}
  , HY = Pc(GY, "")
  , VY = ({index: n, testimonial: e, name: t, designation: i, company: r, image: s})=>it(Qi.div, {
    variants: Sh("", "spring", n * .5, .75),
    className: "bg-black-200 p-10 rounded-3xl xs:w-[320px] w-full",
    children: [he("p", {
        className: "text-white font-black text-[48px]",
        children: '"'
    }), it("div", {
        className: "mt-1",
        children: [he("p", {
            className: "text-white tracking-wider text-[18px]",
            children: e
        }), it("div", {
            className: "mt-7 flex justify-between items-center gap-1",
            children: [it("div", {
                className: "flex-1 flex flex-col",
                children: [it("p", {
                    className: "text-white font-medium text-[16px]",
                    children: [he("span", {
                        className: "blue-text-gradient",
                        children: "@"
                    }), " ", t]
                }), it("p", {
                    className: "mt-1 text-secondary text-[12px]",
                    children: [i, " from ", r]
                })]
            }), he("img", {
                src: s,
                alt: `feedback_by-${t}`,
                className: "w-10 h-10 rounded-full object-cover"
            })]
        })]
    })]
})
  , WY = ()=>it("div", {
    className: "mt-12 bg-black-100 rounded-[20px]",
    children: [he("div", {
        className: `bg-tertiary rounded-2xl ${Yn.padding} min-h-[300px]`,
        children: it(Qi.div, {
            variants: K0(),
            children: [he("p", {
                className: Yn.sectionSubText,
                children: "What others say"
            }), he("h2", {
                className: Yn.sectionHeadText,
                children: "Recommendations."
            })]
        })
    }), he("div", {
        className: `-mt-20 pb-14 ${Yn.paddingX} flex flex-wrap gap-7`,
        children: rY.map((n,e)=>he(VY, {
            index: e,
            ...n
        }, n.name))
    })]
})
  , jY = Pc(WY, "")
  , Gd = {
    _origin: "https://api.emailjs.com"
}
  , JY = (n,e="https://api.emailjs.com")=>{
    Gd._userID = n,
    Gd._origin = e
}
  , PD = (n,e,t)=>{
    if (!n)
        throw "The public key is required. Visit https://dashboard.emailjs.com/admin/account";
    if (!e)
        throw "The service ID is required. Visit https://dashboard.emailjs.com/admin";
    if (!t)
        throw "The template ID is required. Visit https://dashboard.emailjs.com/admin/templates";
    return !0
}
;
class Z2 {
    constructor(e) {
        this.status = e ? e.status : 0,
        this.text = e ? e.responseText : "Network Error"
    }
}
const BD = (n,e,t={})=>new Promise((i,r)=>{
    const s = new XMLHttpRequest;
    s.addEventListener("load", ({target: o})=>{
        const a = new Z2(o);
        a.status === 200 || a.text === "OK" ? i(a) : r(a)
    }
    ),
    s.addEventListener("error", ({target: o})=>{
        r(new Z2(o))
    }
    ),
    s.open("POST", Gd._origin + n, !0),
    Object.keys(t).forEach(o=>{
        s.setRequestHeader(o, t[o])
    }
    ),
    s.send(e)
}
)
  , XY = (n,e,t,i)=>{
    const r = i || Gd._userID;
    return PD(r, n, e),
    BD("/api/v1.0/email/send", JSON.stringify({
        lib_version: "3.10.0",
        user_id: r,
        service_id: n,
        template_id: e,
        template_params: t
    }), {
        "Content-type": "application/json"
    })
}
  , YY = n=>{
    let e;
    if (typeof n == "string" ? e = document.querySelector(n) : e = n,
    !e || e.nodeName !== "FORM")
        throw "The 3rd parameter is expected to be the HTML form element or the style selector of form";
    return e
}
  , KY = (n,e,t,i)=>{
    const r = i || Gd._userID
      , s = YY(t);
    PD(r, n, e);
    const o = new FormData(s);
    return o.append("lib_version", "3.10.0"),
    o.append("service_id", n),
    o.append("template_id", e),
    o.append("user_id", r),
    BD("/api/v1.0/email/send-form", o)
}
  , QY = {
    init: JY,
    send: XY,
    sendForm: KY
};
function q2(n, e) {
    var t = Object.keys(n);
    if (Object.getOwnPropertySymbols) {
        var i = Object.getOwnPropertySymbols(n);
        e && (i = i.filter(function(r) {
            return Object.getOwnPropertyDescriptor(n, r).enumerable
        })),
        t.push.apply(t, i)
    }
    return t
}
function ze(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? q2(Object(t), !0).forEach(function(i) {
            Fn(n, i, t[i])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : q2(Object(t)).forEach(function(i) {
            Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i))
        })
    }
    return n
}
function e0(n) {
    return e0 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    ,
    e0(n)
}
function ZY(n, e) {
    if (!(n instanceof e))
        throw new TypeError("Cannot call a class as a function")
}
function $2(n, e) {
    for (var t = 0; t < e.length; t++) {
        var i = e[t];
        i.enumerable = i.enumerable || !1,
        i.configurable = !0,
        "value"in i && (i.writable = !0),
        Object.defineProperty(n, i.key, i)
    }
}
function qY(n, e, t) {
    return e && $2(n.prototype, e),
    t && $2(n, t),
    Object.defineProperty(n, "prototype", {
        writable: !1
    }),
    n
}
function Fn(n, e, t) {
    return e in n ? Object.defineProperty(n, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : n[e] = t,
    n
}
function US(n, e) {
    return eK(n) || nK(n, e) || RD(n, e) || rK()
}
function Mh(n) {
    return $Y(n) || tK(n) || RD(n) || iK()
}
function $Y(n) {
    if (Array.isArray(n))
        return nA(n)
}
function eK(n) {
    if (Array.isArray(n))
        return n
}
function tK(n) {
    if (typeof Symbol < "u" && n[Symbol.iterator] != null || n["@@iterator"] != null)
        return Array.from(n)
}
function nK(n, e) {
    var t = n == null ? null : typeof Symbol < "u" && n[Symbol.iterator] || n["@@iterator"];
    if (t != null) {
        var i = [], r = !0, s = !1, o, a;
        try {
            for (t = t.call(n); !(r = (o = t.next()).done) && (i.push(o.value),
            !(e && i.length === e)); r = !0)
                ;
        } catch (l) {
            s = !0,
            a = l
        } finally {
            try {
                !r && t.return != null && t.return()
            } finally {
                if (s)
                    throw a
            }
        }
        return i
    }
}
function RD(n, e) {
    if (n) {
        if (typeof n == "string")
            return nA(n, e);
        var t = Object.prototype.toString.call(n).slice(8, -1);
        if (t === "Object" && n.constructor && (t = n.constructor.name),
        t === "Map" || t === "Set")
            return Array.from(n);
        if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
            return nA(n, e)
    }
}
function nA(n, e) {
    (e == null || e > n.length) && (e = n.length);
    for (var t = 0, i = new Array(e); t < e; t++)
        i[t] = n[t];
    return i
}
function iK() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function rK() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
var eP = function() {}
  , zS = {}
  , ID = {}
  , LD = null
  , DD = {
    mark: eP,
    measure: eP
};
try {
    typeof window < "u" && (zS = window),
    typeof document < "u" && (ID = document),
    typeof MutationObserver < "u" && (LD = MutationObserver),
    typeof performance < "u" && (DD = performance)
} catch {}
var sK = zS.navigator || {}
  , tP = sK.userAgent
  , nP = tP === void 0 ? "" : tP
  , aa = zS
  , Qt = ID
  , iP = LD
  , Dm = DD;
aa.document;
var lo = !!Qt.documentElement && !!Qt.head && typeof Qt.addEventListener == "function" && typeof Qt.createElement == "function", kD = ~nP.indexOf("MSIE") || ~nP.indexOf("Trident/"), km, Fm, Nm, Om, Um, to = "___FONT_AWESOME___", iA = 16, FD = "fa", ND = "svg-inline--fa", bl = "data-fa-i2svg", rA = "data-fa-pseudo-element", oK = "data-fa-pseudo-element-pending", GS = "data-prefix", HS = "data-icon", rP = "fontawesome-i2svg", aK = "async", lK = ["HTML", "HEAD", "STYLE", "SCRIPT"], OD = function() {
    try {
        return !0
    } catch {
        return !1
    }
}(), Yt = "classic", vn = "sharp", VS = [Yt, vn];
function bh(n) {
    return new Proxy(n,{
        get: function(t, i) {
            return i in t ? t[i] : t[Yt]
        }
    })
}
var Hd = bh((km = {},
Fn(km, Yt, {
    fa: "solid",
    fas: "solid",
    "fa-solid": "solid",
    far: "regular",
    "fa-regular": "regular",
    fal: "light",
    "fa-light": "light",
    fat: "thin",
    "fa-thin": "thin",
    fad: "duotone",
    "fa-duotone": "duotone",
    fab: "brands",
    "fa-brands": "brands",
    fak: "kit",
    "fa-kit": "kit"
}),
Fn(km, vn, {
    fa: "solid",
    fass: "solid",
    "fa-solid": "solid",
    fasr: "regular",
    "fa-regular": "regular",
    fasl: "light",
    "fa-light": "light"
}),
km))
  , Vd = bh((Fm = {},
Fn(Fm, Yt, {
    solid: "fas",
    regular: "far",
    light: "fal",
    thin: "fat",
    duotone: "fad",
    brands: "fab",
    kit: "fak"
}),
Fn(Fm, vn, {
    solid: "fass",
    regular: "fasr",
    light: "fasl"
}),
Fm))
  , Wd = bh((Nm = {},
Fn(Nm, Yt, {
    fab: "fa-brands",
    fad: "fa-duotone",
    fak: "fa-kit",
    fal: "fa-light",
    far: "fa-regular",
    fas: "fa-solid",
    fat: "fa-thin"
}),
Fn(Nm, vn, {
    fass: "fa-solid",
    fasr: "fa-regular",
    fasl: "fa-light"
}),
Nm))
  , uK = bh((Om = {},
Fn(Om, Yt, {
    "fa-brands": "fab",
    "fa-duotone": "fad",
    "fa-kit": "fak",
    "fa-light": "fal",
    "fa-regular": "far",
    "fa-solid": "fas",
    "fa-thin": "fat"
}),
Fn(Om, vn, {
    "fa-solid": "fass",
    "fa-regular": "fasr",
    "fa-light": "fasl"
}),
Om))
  , cK = /fa(s|r|l|t|d|b|k|ss|sr|sl)?[\-\ ]/
  , UD = "fa-layers-text"
  , fK = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp|Kit)?.*/i
  , dK = bh((Um = {},
Fn(Um, Yt, {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
}),
Fn(Um, vn, {
    900: "fass",
    400: "fasr",
    300: "fasl"
}),
Um))
  , zD = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  , hK = zD.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20])
  , pK = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"]
  , sl = {
    GROUP: "duotone-group",
    SWAP_OPACITY: "swap-opacity",
    PRIMARY: "primary",
    SECONDARY: "secondary"
}
  , jd = new Set;
Object.keys(Vd[Yt]).map(jd.add.bind(jd));
Object.keys(Vd[vn]).map(jd.add.bind(jd));
var mK = [].concat(VS, Mh(jd), ["2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", sl.GROUP, sl.SWAP_OPACITY, sl.PRIMARY, sl.SECONDARY]).concat(zD.map(function(n) {
    return "".concat(n, "x")
})).concat(hK.map(function(n) {
    return "w-".concat(n)
}))
  , ed = aa.FontAwesomeConfig || {};
function gK(n) {
    var e = Qt.querySelector("script[" + n + "]");
    if (e)
        return e.getAttribute(n)
}
function vK(n) {
    return n === "" ? !0 : n === "false" ? !1 : n === "true" ? !0 : n
}
if (Qt && typeof Qt.querySelector == "function") {
    var yK = [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]];
    yK.forEach(function(n) {
        var e = US(n, 2)
          , t = e[0]
          , i = e[1]
          , r = vK(gK(t));
        r != null && (ed[i] = r)
    })
}
var GD = {
    styleDefault: "solid",
    familyDefault: "classic",
    cssPrefix: FD,
    replacementClass: ND,
    autoReplaceSvg: !0,
    autoAddCss: !0,
    autoA11y: !0,
    searchPseudoElements: !1,
    observeMutations: !0,
    mutateApproach: "async",
    keepOriginalSource: !0,
    measurePerformance: !1,
    showMissingIcons: !0
};
ed.familyPrefix && (ed.cssPrefix = ed.familyPrefix);
var pc = ze(ze({}, GD), ed);
pc.autoReplaceSvg || (pc.observeMutations = !1);
var Xe = {};
Object.keys(GD).forEach(function(n) {
    Object.defineProperty(Xe, n, {
        enumerable: !0,
        set: function(t) {
            pc[n] = t,
            td.forEach(function(i) {
                return i(Xe)
            })
        },
        get: function() {
            return pc[n]
        }
    })
});
Object.defineProperty(Xe, "familyPrefix", {
    enumerable: !0,
    set: function(e) {
        pc.cssPrefix = e,
        td.forEach(function(t) {
            return t(Xe)
        })
    },
    get: function() {
        return pc.cssPrefix
    }
});
aa.FontAwesomeConfig = Xe;
var td = [];
function xK(n) {
    return td.push(n),
    function() {
        td.splice(td.indexOf(n), 1)
    }
}
var Eo = iA
  , as = {
    size: 16,
    x: 0,
    y: 0,
    rotate: 0,
    flipX: !1,
    flipY: !1
};
function _K(n) {
    if (!(!n || !lo)) {
        var e = Qt.createElement("style");
        e.setAttribute("type", "text/css"),
        e.innerHTML = n;
        for (var t = Qt.head.childNodes, i = null, r = t.length - 1; r > -1; r--) {
            var s = t[r]
              , o = (s.tagName || "").toUpperCase();
            ["STYLE", "LINK"].indexOf(o) > -1 && (i = s)
        }
        return Qt.head.insertBefore(e, i),
        n
    }
}
var AK = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function Jd() {
    for (var n = 12, e = ""; n-- > 0; )
        e += AK[Math.random() * 62 | 0];
    return e
}
function Bc(n) {
    for (var e = [], t = (n || []).length >>> 0; t--; )
        e[t] = n[t];
    return e
}
function WS(n) {
    return n.classList ? Bc(n.classList) : (n.getAttribute("class") || "").split(" ").filter(function(e) {
        return e
    })
}
function HD(n) {
    return "".concat(n).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
}
function wK(n) {
    return Object.keys(n || {}).reduce(function(e, t) {
        return e + "".concat(t, '="').concat(HD(n[t]), '" ')
    }, "").trim()
}
function q0(n) {
    return Object.keys(n || {}).reduce(function(e, t) {
        return e + "".concat(t, ": ").concat(n[t].trim(), ";")
    }, "")
}
function jS(n) {
    return n.size !== as.size || n.x !== as.x || n.y !== as.y || n.rotate !== as.rotate || n.flipX || n.flipY
}
function SK(n) {
    var e = n.transform
      , t = n.containerWidth
      , i = n.iconWidth
      , r = {
        transform: "translate(".concat(t / 2, " 256)")
    }
      , s = "translate(".concat(e.x * 32, ", ").concat(e.y * 32, ") ")
      , o = "scale(".concat(e.size / 16 * (e.flipX ? -1 : 1), ", ").concat(e.size / 16 * (e.flipY ? -1 : 1), ") ")
      , a = "rotate(".concat(e.rotate, " 0 0)")
      , l = {
        transform: "".concat(s, " ").concat(o, " ").concat(a)
    }
      , c = {
        transform: "translate(".concat(i / 2 * -1, " -256)")
    };
    return {
        outer: r,
        inner: l,
        path: c
    }
}
function MK(n) {
    var e = n.transform
      , t = n.width
      , i = t === void 0 ? iA : t
      , r = n.height
      , s = r === void 0 ? iA : r
      , o = n.startCentered
      , a = o === void 0 ? !1 : o
      , l = "";
    return a && kD ? l += "translate(".concat(e.x / Eo - i / 2, "em, ").concat(e.y / Eo - s / 2, "em) ") : a ? l += "translate(calc(-50% + ".concat(e.x / Eo, "em), calc(-50% + ").concat(e.y / Eo, "em)) ") : l += "translate(".concat(e.x / Eo, "em, ").concat(e.y / Eo, "em) "),
    l += "scale(".concat(e.size / Eo * (e.flipX ? -1 : 1), ", ").concat(e.size / Eo * (e.flipY ? -1 : 1), ") "),
    l += "rotate(".concat(e.rotate, "deg) "),
    l
}
var bK = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Solid";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Regular";
  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Light";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Thin";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 6 Sharp";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";
}

svg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {
  overflow: visible;
  box-sizing: content-box;
}

.svg-inline--fa {
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285705em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left {
  margin-right: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-pull-right {
  margin-left: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  top: 0.25em;
}
.svg-inline--fa.fa-fw {
  width: var(--fa-fw-width, 1.25em);
}

.fa-layers svg.svg-inline--fa {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: 1em;
}
.fa-layers svg.svg-inline--fa {
  -webkit-transform-origin: center center;
          transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  -webkit-transform-origin: center center;
          transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  -webkit-transform: scale(var(--fa-counter-scale, 0.25));
          transform: scale(var(--fa-counter-scale, 0.25));
  -webkit-transform-origin: top right;
          transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: bottom right;
          transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: bottom left;
          transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: top right;
          transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: top left;
          transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: 0.625em;
  line-height: 0.1em;
  vertical-align: 0.225em;
}

.fa-xs {
  font-size: 0.75em;
  line-height: 0.0833333337em;
  vertical-align: 0.125em;
}

.fa-sm {
  font-size: 0.875em;
  line-height: 0.0714285718em;
  vertical-align: 0.0535714295em;
}

.fa-lg {
  font-size: 1.25em;
  line-height: 0.05em;
  vertical-align: -0.075em;
}

.fa-xl {
  font-size: 1.5em;
  line-height: 0.0416666682em;
  vertical-align: -0.125em;
}

.fa-2xl {
  font-size: 2em;
  line-height: 0.03125em;
  vertical-align: -0.1875em;
}

.fa-fw {
  text-align: center;
  width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-left: var(--fa-li-margin, 2.5em);
  padding-left: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  left: calc(var(--fa-li-width, 2em) * -1);
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.08em);
  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);
}

.fa-pull-left {
  float: left;
  margin-right: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right {
  float: right;
  margin-left: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  -webkit-animation-name: fa-beat;
          animation-name: fa-beat;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);
          animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  -webkit-animation-name: fa-bounce;
          animation-name: fa-bounce;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  -webkit-animation-name: fa-fade;
          animation-name: fa-fade;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  -webkit-animation-name: fa-beat-fade;
          animation-name: fa-beat-fade;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  -webkit-animation-name: fa-flip;
          animation-name: fa-flip;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);
          animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  -webkit-animation-name: fa-shake;
          animation-name: fa-shake;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, linear);
          animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  -webkit-animation-name: fa-spin;
          animation-name: fa-spin;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 2s);
          animation-duration: var(--fa-animation-duration, 2s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, linear);
          animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  -webkit-animation-name: fa-spin;
          animation-name: fa-spin;
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, steps(8));
          animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
.fa-bounce,
.fa-fade,
.fa-beat-fade,
.fa-flip,
.fa-pulse,
.fa-shake,
.fa-spin,
.fa-spin-pulse {
    -webkit-animation-delay: -1ms;
            animation-delay: -1ms;
    -webkit-animation-duration: 1ms;
            animation-duration: 1ms;
    -webkit-animation-iteration-count: 1;
            animation-iteration-count: 1;
    -webkit-transition-delay: 0s;
            transition-delay: 0s;
    -webkit-transition-duration: 0s;
            transition-duration: 0s;
  }
}
@-webkit-keyframes fa-beat {
  0%, 90% {
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  45% {
    -webkit-transform: scale(var(--fa-beat-scale, 1.25));
            transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-beat {
  0%, 90% {
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  45% {
    -webkit-transform: scale(var(--fa-beat-scale, 1.25));
            transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@-webkit-keyframes fa-bounce {
  0% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  10% {
    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  100% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-bounce {
  0% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  10% {
    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  100% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
}
@-webkit-keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@-webkit-keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  50% {
    opacity: 1;
    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));
            transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  50% {
    opacity: 1;
    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));
            transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@-webkit-keyframes fa-flip {
  50% {
    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-flip {
  50% {
    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@-webkit-keyframes fa-shake {
  0% {
    -webkit-transform: rotate(-15deg);
            transform: rotate(-15deg);
  }
  4% {
    -webkit-transform: rotate(15deg);
            transform: rotate(15deg);
  }
  8%, 24% {
    -webkit-transform: rotate(-18deg);
            transform: rotate(-18deg);
  }
  12%, 28% {
    -webkit-transform: rotate(18deg);
            transform: rotate(18deg);
  }
  16% {
    -webkit-transform: rotate(-22deg);
            transform: rotate(-22deg);
  }
  20% {
    -webkit-transform: rotate(22deg);
            transform: rotate(22deg);
  }
  32% {
    -webkit-transform: rotate(-12deg);
            transform: rotate(-12deg);
  }
  36% {
    -webkit-transform: rotate(12deg);
            transform: rotate(12deg);
  }
  40%, 100% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
}
@keyframes fa-shake {
  0% {
    -webkit-transform: rotate(-15deg);
            transform: rotate(-15deg);
  }
  4% {
    -webkit-transform: rotate(15deg);
            transform: rotate(15deg);
  }
  8%, 24% {
    -webkit-transform: rotate(-18deg);
            transform: rotate(-18deg);
  }
  12%, 28% {
    -webkit-transform: rotate(18deg);
            transform: rotate(18deg);
  }
  16% {
    -webkit-transform: rotate(-22deg);
            transform: rotate(-22deg);
  }
  20% {
    -webkit-transform: rotate(22deg);
            transform: rotate(22deg);
  }
  32% {
    -webkit-transform: rotate(-12deg);
            transform: rotate(-12deg);
  }
  36% {
    -webkit-transform: rotate(12deg);
            transform: rotate(12deg);
  }
  40%, 100% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
}
@-webkit-keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
  }
}
@keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  -webkit-transform: rotate(90deg);
          transform: rotate(90deg);
}

.fa-rotate-180 {
  -webkit-transform: rotate(180deg);
          transform: rotate(180deg);
}

.fa-rotate-270 {
  -webkit-transform: rotate(270deg);
          transform: rotate(270deg);
}

.fa-flip-horizontal {
  -webkit-transform: scale(-1, 1);
          transform: scale(-1, 1);
}

.fa-flip-vertical {
  -webkit-transform: scale(1, -1);
          transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  -webkit-transform: scale(-1, -1);
          transform: scale(-1, -1);
}

.fa-rotate-by {
  -webkit-transform: rotate(var(--fa-rotate-angle, none));
          transform: rotate(var(--fa-rotate-angle, none));
}

.fa-stack {
  display: inline-block;
  vertical-align: middle;
  height: 2em;
  position: relative;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
  z-index: var(--fa-stack-z-index, auto);
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.sr-only,
.fa-sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.sr-only-focusable:not(:focus),
.fa-sr-only-focusable:not(:focus) {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}

.fad.fa-inverse,
.fa-duotone.fa-inverse {
  color: var(--fa-inverse, #fff);
}`;
function VD() {
    var n = FD
      , e = ND
      , t = Xe.cssPrefix
      , i = Xe.replacementClass
      , r = bK;
    if (t !== n || i !== e) {
        var s = new RegExp("\\.".concat(n, "\\-"),"g")
          , o = new RegExp("\\--".concat(n, "\\-"),"g")
          , a = new RegExp("\\.".concat(e),"g");
        r = r.replace(s, ".".concat(t, "-")).replace(o, "--".concat(t, "-")).replace(a, ".".concat(i))
    }
    return r
}
var sP = !1;
function Ox() {
    Xe.autoAddCss && !sP && (_K(VD()),
    sP = !0)
}
var CK = {
    mixout: function() {
        return {
            dom: {
                css: VD,
                insertCss: Ox
            }
        }
    },
    hooks: function() {
        return {
            beforeDOMElementCreation: function() {
                Ox()
            },
            beforeI2svg: function() {
                Ox()
            }
        }
    }
}
  , no = aa || {};
no[to] || (no[to] = {});
no[to].styles || (no[to].styles = {});
no[to].hooks || (no[to].hooks = {});
no[to].shims || (no[to].shims = []);
var Ur = no[to]
  , WD = []
  , EK = function n() {
    Qt.removeEventListener("DOMContentLoaded", n),
    t0 = 1,
    WD.map(function(e) {
        return e()
    })
}
  , t0 = !1;
lo && (t0 = (Qt.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(Qt.readyState),
t0 || Qt.addEventListener("DOMContentLoaded", EK));
function TK(n) {
    lo && (t0 ? setTimeout(n, 0) : WD.push(n))
}
function Ch(n) {
    var e = n.tag
      , t = n.attributes
      , i = t === void 0 ? {} : t
      , r = n.children
      , s = r === void 0 ? [] : r;
    return typeof n == "string" ? HD(n) : "<".concat(e, " ").concat(wK(i), ">").concat(s.map(Ch).join(""), "</").concat(e, ">")
}
function oP(n, e, t) {
    if (n && n[e] && n[e][t])
        return {
            prefix: e,
            iconName: t,
            icon: n[e][t]
        }
}
var PK = function(e, t) {
    return function(i, r, s, o) {
        return e.call(t, i, r, s, o)
    }
}
  , Ux = function(e, t, i, r) {
    var s = Object.keys(e), o = s.length, a = r !== void 0 ? PK(t, r) : t, l, c, d;
    for (i === void 0 ? (l = 1,
    d = e[s[0]]) : (l = 0,
    d = i); l < o; l++)
        c = s[l],
        d = a(d, e[c], c, e);
    return d
};
function BK(n) {
    for (var e = [], t = 0, i = n.length; t < i; ) {
        var r = n.charCodeAt(t++);
        if (r >= 55296 && r <= 56319 && t < i) {
            var s = n.charCodeAt(t++);
            (s & 64512) == 56320 ? e.push(((r & 1023) << 10) + (s & 1023) + 65536) : (e.push(r),
            t--)
        } else
            e.push(r)
    }
    return e
}
function sA(n) {
    var e = BK(n);
    return e.length === 1 ? e[0].toString(16) : null
}
function RK(n, e) {
    var t = n.length, i = n.charCodeAt(e), r;
    return i >= 55296 && i <= 56319 && t > e + 1 && (r = n.charCodeAt(e + 1),
    r >= 56320 && r <= 57343) ? (i - 55296) * 1024 + r - 56320 + 65536 : i
}
function aP(n) {
    return Object.keys(n).reduce(function(e, t) {
        var i = n[t]
          , r = !!i.icon;
        return r ? e[i.iconName] = i.icon : e[t] = i,
        e
    }, {})
}
function oA(n, e) {
    var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
      , i = t.skipHooks
      , r = i === void 0 ? !1 : i
      , s = aP(e);
    typeof Ur.hooks.addPack == "function" && !r ? Ur.hooks.addPack(n, aP(e)) : Ur.styles[n] = ze(ze({}, Ur.styles[n] || {}), s),
    n === "fas" && oA("fa", e)
}
var zm, Gm, Hm, Fu = Ur.styles, IK = Ur.shims, LK = (zm = {},
Fn(zm, Yt, Object.values(Wd[Yt])),
Fn(zm, vn, Object.values(Wd[vn])),
zm), JS = null, jD = {}, JD = {}, XD = {}, YD = {}, KD = {}, DK = (Gm = {},
Fn(Gm, Yt, Object.keys(Hd[Yt])),
Fn(Gm, vn, Object.keys(Hd[vn])),
Gm);
function kK(n) {
    return ~mK.indexOf(n)
}
function FK(n, e) {
    var t = e.split("-")
      , i = t[0]
      , r = t.slice(1).join("-");
    return i === n && r !== "" && !kK(r) ? r : null
}
var QD = function() {
    var e = function(s) {
        return Ux(Fu, function(o, a, l) {
            return o[l] = Ux(a, s, {}),
            o
        }, {})
    };
    jD = e(function(r, s, o) {
        if (s[3] && (r[s[3]] = o),
        s[2]) {
            var a = s[2].filter(function(l) {
                return typeof l == "number"
            });
            a.forEach(function(l) {
                r[l.toString(16)] = o
            })
        }
        return r
    }),
    JD = e(function(r, s, o) {
        if (r[o] = o,
        s[2]) {
            var a = s[2].filter(function(l) {
                return typeof l == "string"
            });
            a.forEach(function(l) {
                r[l] = o
            })
        }
        return r
    }),
    KD = e(function(r, s, o) {
        var a = s[2];
        return r[o] = o,
        a.forEach(function(l) {
            r[l] = o
        }),
        r
    });
    var t = "far"in Fu || Xe.autoFetchSvg
      , i = Ux(IK, function(r, s) {
        var o = s[0]
          , a = s[1]
          , l = s[2];
        return a === "far" && !t && (a = "fas"),
        typeof o == "string" && (r.names[o] = {
            prefix: a,
            iconName: l
        }),
        typeof o == "number" && (r.unicodes[o.toString(16)] = {
            prefix: a,
            iconName: l
        }),
        r
    }, {
        names: {},
        unicodes: {}
    });
    XD = i.names,
    YD = i.unicodes,
    JS = $0(Xe.styleDefault, {
        family: Xe.familyDefault
    })
};
xK(function(n) {
    JS = $0(n.styleDefault, {
        family: Xe.familyDefault
    })
});
QD();
function XS(n, e) {
    return (jD[n] || {})[e]
}
function NK(n, e) {
    return (JD[n] || {})[e]
}
function ol(n, e) {
    return (KD[n] || {})[e]
}
function ZD(n) {
    return XD[n] || {
        prefix: null,
        iconName: null
    }
}
function OK(n) {
    var e = YD[n]
      , t = XS("fas", n);
    return e || (t ? {
        prefix: "fas",
        iconName: t
    } : null) || {
        prefix: null,
        iconName: null
    }
}
function la() {
    return JS
}
var YS = function() {
    return {
        prefix: null,
        iconName: null,
        rest: []
    }
};
function $0(n) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
      , t = e.family
      , i = t === void 0 ? Yt : t
      , r = Hd[i][n]
      , s = Vd[i][n] || Vd[i][r]
      , o = n in Ur.styles ? n : null;
    return s || o || null
}
var lP = (Hm = {},
Fn(Hm, Yt, Object.keys(Wd[Yt])),
Fn(Hm, vn, Object.keys(Wd[vn])),
Hm);
function ev(n) {
    var e, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = t.skipLookups, r = i === void 0 ? !1 : i, s = (e = {},
    Fn(e, Yt, "".concat(Xe.cssPrefix, "-").concat(Yt)),
    Fn(e, vn, "".concat(Xe.cssPrefix, "-").concat(vn)),
    e), o = null, a = Yt;
    (n.includes(s[Yt]) || n.some(function(c) {
        return lP[Yt].includes(c)
    })) && (a = Yt),
    (n.includes(s[vn]) || n.some(function(c) {
        return lP[vn].includes(c)
    })) && (a = vn);
    var l = n.reduce(function(c, d) {
        var h = FK(Xe.cssPrefix, d);
        if (Fu[d] ? (d = LK[a].includes(d) ? uK[a][d] : d,
        o = d,
        c.prefix = d) : DK[a].indexOf(d) > -1 ? (o = d,
        c.prefix = $0(d, {
            family: a
        })) : h ? c.iconName = h : d !== Xe.replacementClass && d !== s[Yt] && d !== s[vn] && c.rest.push(d),
        !r && c.prefix && c.iconName) {
            var p = o === "fa" ? ZD(c.iconName) : {}
              , m = ol(c.prefix, c.iconName);
            p.prefix && (o = null),
            c.iconName = p.iconName || m || c.iconName,
            c.prefix = p.prefix || c.prefix,
            c.prefix === "far" && !Fu.far && Fu.fas && !Xe.autoFetchSvg && (c.prefix = "fas")
        }
        return c
    }, YS());
    return (n.includes("fa-brands") || n.includes("fab")) && (l.prefix = "fab"),
    (n.includes("fa-duotone") || n.includes("fad")) && (l.prefix = "fad"),
    !l.prefix && a === vn && (Fu.fass || Xe.autoFetchSvg) && (l.prefix = "fass",
    l.iconName = ol(l.prefix, l.iconName) || l.iconName),
    (l.prefix === "fa" || o === "fa") && (l.prefix = la() || "fas"),
    l
}
var UK = function() {
    function n() {
        ZY(this, n),
        this.definitions = {}
    }
    return qY(n, [{
        key: "add",
        value: function() {
            for (var t = this, i = arguments.length, r = new Array(i), s = 0; s < i; s++)
                r[s] = arguments[s];
            var o = r.reduce(this._pullDefinitions, {});
            Object.keys(o).forEach(function(a) {
                t.definitions[a] = ze(ze({}, t.definitions[a] || {}), o[a]),
                oA(a, o[a]);
                var l = Wd[Yt][a];
                l && oA(l, o[a]),
                QD()
            })
        }
    }, {
        key: "reset",
        value: function() {
            this.definitions = {}
        }
    }, {
        key: "_pullDefinitions",
        value: function(t, i) {
            var r = i.prefix && i.iconName && i.icon ? {
                0: i
            } : i;
            return Object.keys(r).map(function(s) {
                var o = r[s]
                  , a = o.prefix
                  , l = o.iconName
                  , c = o.icon
                  , d = c[2];
                t[a] || (t[a] = {}),
                d.length > 0 && d.forEach(function(h) {
                    typeof h == "string" && (t[a][h] = c)
                }),
                t[a][l] = c
            }),
            t
        }
    }]),
    n
}()
  , uP = []
  , Nu = {}
  , Yu = {}
  , zK = Object.keys(Yu);
function GK(n, e) {
    var t = e.mixoutsTo;
    return uP = n,
    Nu = {},
    Object.keys(Yu).forEach(function(i) {
        zK.indexOf(i) === -1 && delete Yu[i]
    }),
    uP.forEach(function(i) {
        var r = i.mixout ? i.mixout() : {};
        if (Object.keys(r).forEach(function(o) {
            typeof r[o] == "function" && (t[o] = r[o]),
            e0(r[o]) === "object" && Object.keys(r[o]).forEach(function(a) {
                t[o] || (t[o] = {}),
                t[o][a] = r[o][a]
            })
        }),
        i.hooks) {
            var s = i.hooks();
            Object.keys(s).forEach(function(o) {
                Nu[o] || (Nu[o] = []),
                Nu[o].push(s[o])
            })
        }
        i.provides && i.provides(Yu)
    }),
    t
}
function aA(n, e) {
    for (var t = arguments.length, i = new Array(t > 2 ? t - 2 : 0), r = 2; r < t; r++)
        i[r - 2] = arguments[r];
    var s = Nu[n] || [];
    return s.forEach(function(o) {
        e = o.apply(null, [e].concat(i))
    }),
    e
}
function Cl(n) {
    for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)
        t[i - 1] = arguments[i];
    var r = Nu[n] || [];
    r.forEach(function(s) {
        s.apply(null, t)
    })
}
function io() {
    var n = arguments[0]
      , e = Array.prototype.slice.call(arguments, 1);
    return Yu[n] ? Yu[n].apply(null, e) : void 0
}
function lA(n) {
    n.prefix === "fa" && (n.prefix = "fas");
    var e = n.iconName
      , t = n.prefix || la();
    if (e)
        return e = ol(t, e) || e,
        oP(qD.definitions, t, e) || oP(Ur.styles, t, e)
}
var qD = new UK
  , HK = function() {
    Xe.autoReplaceSvg = !1,
    Xe.observeMutations = !1,
    Cl("noAuto")
}
  , VK = {
    i2svg: function() {
        var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return lo ? (Cl("beforeI2svg", e),
        io("pseudoElements2svg", e),
        io("i2svg", e)) : Promise.reject("Operation requires a DOM of some kind.")
    },
    watch: function() {
        var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
          , t = e.autoReplaceSvgRoot;
        Xe.autoReplaceSvg === !1 && (Xe.autoReplaceSvg = !0),
        Xe.observeMutations = !0,
        TK(function() {
            jK({
                autoReplaceSvgRoot: t
            }),
            Cl("watch", e)
        })
    }
}
  , WK = {
    icon: function(e) {
        if (e === null)
            return null;
        if (e0(e) === "object" && e.prefix && e.iconName)
            return {
                prefix: e.prefix,
                iconName: ol(e.prefix, e.iconName) || e.iconName
            };
        if (Array.isArray(e) && e.length === 2) {
            var t = e[1].indexOf("fa-") === 0 ? e[1].slice(3) : e[1]
              , i = $0(e[0]);
            return {
                prefix: i,
                iconName: ol(i, t) || t
            }
        }
        if (typeof e == "string" && (e.indexOf("".concat(Xe.cssPrefix, "-")) > -1 || e.match(cK))) {
            var r = ev(e.split(" "), {
                skipLookups: !0
            });
            return {
                prefix: r.prefix || la(),
                iconName: ol(r.prefix, r.iconName) || r.iconName
            }
        }
        if (typeof e == "string") {
            var s = la();
            return {
                prefix: s,
                iconName: ol(s, e) || e
            }
        }
    }
}
  , $i = {
    noAuto: HK,
    config: Xe,
    dom: VK,
    parse: WK,
    library: qD,
    findIconDefinition: lA,
    toHtml: Ch
}
  , jK = function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
      , t = e.autoReplaceSvgRoot
      , i = t === void 0 ? Qt : t;
    (Object.keys(Ur.styles).length > 0 || Xe.autoFetchSvg) && lo && Xe.autoReplaceSvg && $i.dom.i2svg({
        node: i
    })
};
function tv(n, e) {
    return Object.defineProperty(n, "abstract", {
        get: e
    }),
    Object.defineProperty(n, "html", {
        get: function() {
            return n.abstract.map(function(i) {
                return Ch(i)
            })
        }
    }),
    Object.defineProperty(n, "node", {
        get: function() {
            if (lo) {
                var i = Qt.createElement("div");
                return i.innerHTML = n.html,
                i.children
            }
        }
    }),
    n
}
function JK(n) {
    var e = n.children
      , t = n.main
      , i = n.mask
      , r = n.attributes
      , s = n.styles
      , o = n.transform;
    if (jS(o) && t.found && !i.found) {
        var a = t.width
          , l = t.height
          , c = {
            x: a / l / 2,
            y: .5
        };
        r.style = q0(ze(ze({}, s), {}, {
            "transform-origin": "".concat(c.x + o.x / 16, "em ").concat(c.y + o.y / 16, "em")
        }))
    }
    return [{
        tag: "svg",
        attributes: r,
        children: e
    }]
}
function XK(n) {
    var e = n.prefix
      , t = n.iconName
      , i = n.children
      , r = n.attributes
      , s = n.symbol
      , o = s === !0 ? "".concat(e, "-").concat(Xe.cssPrefix, "-").concat(t) : s;
    return [{
        tag: "svg",
        attributes: {
            style: "display: none;"
        },
        children: [{
            tag: "symbol",
            attributes: ze(ze({}, r), {}, {
                id: o
            }),
            children: i
        }]
    }]
}
function KS(n) {
    var e = n.icons
      , t = e.main
      , i = e.mask
      , r = n.prefix
      , s = n.iconName
      , o = n.transform
      , a = n.symbol
      , l = n.title
      , c = n.maskId
      , d = n.titleId
      , h = n.extra
      , p = n.watchable
      , m = p === void 0 ? !1 : p
      , y = i.found ? i : t
      , v = y.width
      , x = y.height
      , _ = r === "fak"
      , A = [Xe.replacementClass, s ? "".concat(Xe.cssPrefix, "-").concat(s) : ""].filter(function(B) {
        return h.classes.indexOf(B) === -1
    }).filter(function(B) {
        return B !== "" || !!B
    }).concat(h.classes).join(" ")
      , w = {
        children: [],
        attributes: ze(ze({}, h.attributes), {}, {
            "data-prefix": r,
            "data-icon": s,
            class: A,
            role: h.attributes.role || "img",
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 ".concat(v, " ").concat(x)
        })
    }
      , M = _ && !~h.classes.indexOf("fa-fw") ? {
        width: "".concat(v / x * 16 * .0625, "em")
    } : {};
    m && (w.attributes[bl] = ""),
    l && (w.children.push({
        tag: "title",
        attributes: {
            id: w.attributes["aria-labelledby"] || "title-".concat(d || Jd())
        },
        children: [l]
    }),
    delete w.attributes.title);
    var C = ze(ze({}, w), {}, {
        prefix: r,
        iconName: s,
        main: t,
        mask: i,
        maskId: c,
        transform: o,
        symbol: a,
        styles: ze(ze({}, M), h.styles)
    })
      , P = i.found && t.found ? io("generateAbstractMask", C) || {
        children: [],
        attributes: {}
    } : io("generateAbstractIcon", C) || {
        children: [],
        attributes: {}
    }
      , R = P.children
      , E = P.attributes;
    return C.children = R,
    C.attributes = E,
    a ? XK(C) : JK(C)
}
function cP(n) {
    var e = n.content
      , t = n.width
      , i = n.height
      , r = n.transform
      , s = n.title
      , o = n.extra
      , a = n.watchable
      , l = a === void 0 ? !1 : a
      , c = ze(ze(ze({}, o.attributes), s ? {
        title: s
    } : {}), {}, {
        class: o.classes.join(" ")
    });
    l && (c[bl] = "");
    var d = ze({}, o.styles);
    jS(r) && (d.transform = MK({
        transform: r,
        startCentered: !0,
        width: t,
        height: i
    }),
    d["-webkit-transform"] = d.transform);
    var h = q0(d);
    h.length > 0 && (c.style = h);
    var p = [];
    return p.push({
        tag: "span",
        attributes: c,
        children: [e]
    }),
    s && p.push({
        tag: "span",
        attributes: {
            class: "sr-only"
        },
        children: [s]
    }),
    p
}
function YK(n) {
    var e = n.content
      , t = n.title
      , i = n.extra
      , r = ze(ze(ze({}, i.attributes), t ? {
        title: t
    } : {}), {}, {
        class: i.classes.join(" ")
    })
      , s = q0(i.styles);
    s.length > 0 && (r.style = s);
    var o = [];
    return o.push({
        tag: "span",
        attributes: r,
        children: [e]
    }),
    t && o.push({
        tag: "span",
        attributes: {
            class: "sr-only"
        },
        children: [t]
    }),
    o
}
var zx = Ur.styles;
function uA(n) {
    var e = n[0]
      , t = n[1]
      , i = n.slice(4)
      , r = US(i, 1)
      , s = r[0]
      , o = null;
    return Array.isArray(s) ? o = {
        tag: "g",
        attributes: {
            class: "".concat(Xe.cssPrefix, "-").concat(sl.GROUP)
        },
        children: [{
            tag: "path",
            attributes: {
                class: "".concat(Xe.cssPrefix, "-").concat(sl.SECONDARY),
                fill: "currentColor",
                d: s[0]
            }
        }, {
            tag: "path",
            attributes: {
                class: "".concat(Xe.cssPrefix, "-").concat(sl.PRIMARY),
                fill: "currentColor",
                d: s[1]
            }
        }]
    } : o = {
        tag: "path",
        attributes: {
            fill: "currentColor",
            d: s
        }
    },
    {
        found: !0,
        width: e,
        height: t,
        icon: o
    }
}
var KK = {
    found: !1,
    width: 512,
    height: 512
};
function QK(n, e) {
    !OD && !Xe.showMissingIcons && n && console.error('Icon with name "'.concat(n, '" and prefix "').concat(e, '" is missing.'))
}
function cA(n, e) {
    var t = e;
    return e === "fa" && Xe.styleDefault !== null && (e = la()),
    new Promise(function(i, r) {
        if (io("missingIconAbstract"),
        t === "fa") {
            var s = ZD(n) || {};
            n = s.iconName || n,
            e = s.prefix || e
        }
        if (n && e && zx[e] && zx[e][n]) {
            var o = zx[e][n];
            return i(uA(o))
        }
        QK(n, e),
        i(ze(ze({}, KK), {}, {
            icon: Xe.showMissingIcons && n ? io("missingIconAbstract") || {} : {}
        }))
    }
    )
}
var fP = function() {}
  , fA = Xe.measurePerformance && Dm && Dm.mark && Dm.measure ? Dm : {
    mark: fP,
    measure: fP
}
  , Df = 'FA "6.4.0"'
  , ZK = function(e) {
    return fA.mark("".concat(Df, " ").concat(e, " begins")),
    function() {
        return $D(e)
    }
}
  , $D = function(e) {
    fA.mark("".concat(Df, " ").concat(e, " ends")),
    fA.measure("".concat(Df, " ").concat(e), "".concat(Df, " ").concat(e, " begins"), "".concat(Df, " ").concat(e, " ends"))
}
  , QS = {
    begin: ZK,
    end: $D
}
  , dg = function() {};
function dP(n) {
    var e = n.getAttribute ? n.getAttribute(bl) : null;
    return typeof e == "string"
}
function qK(n) {
    var e = n.getAttribute ? n.getAttribute(GS) : null
      , t = n.getAttribute ? n.getAttribute(HS) : null;
    return e && t
}
function $K(n) {
    return n && n.classList && n.classList.contains && n.classList.contains(Xe.replacementClass)
}
function eQ() {
    if (Xe.autoReplaceSvg === !0)
        return hg.replace;
    var n = hg[Xe.autoReplaceSvg];
    return n || hg.replace
}
function tQ(n) {
    return Qt.createElementNS("http://www.w3.org/2000/svg", n)
}
function nQ(n) {
    return Qt.createElement(n)
}
function ek(n) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
      , t = e.ceFn
      , i = t === void 0 ? n.tag === "svg" ? tQ : nQ : t;
    if (typeof n == "string")
        return Qt.createTextNode(n);
    var r = i(n.tag);
    Object.keys(n.attributes || []).forEach(function(o) {
        r.setAttribute(o, n.attributes[o])
    });
    var s = n.children || [];
    return s.forEach(function(o) {
        r.appendChild(ek(o, {
            ceFn: i
        }))
    }),
    r
}
function iQ(n) {
    var e = " ".concat(n.outerHTML, " ");
    return e = "".concat(e, "Font Awesome fontawesome.com "),
    e
}
var hg = {
    replace: function(e) {
        var t = e[0];
        if (t.parentNode)
            if (e[1].forEach(function(r) {
                t.parentNode.insertBefore(ek(r), t)
            }),
            t.getAttribute(bl) === null && Xe.keepOriginalSource) {
                var i = Qt.createComment(iQ(t));
                t.parentNode.replaceChild(i, t)
            } else
                t.remove()
    },
    nest: function(e) {
        var t = e[0]
          , i = e[1];
        if (~WS(t).indexOf(Xe.replacementClass))
            return hg.replace(e);
        var r = new RegExp("".concat(Xe.cssPrefix, "-.*"));
        if (delete i[0].attributes.id,
        i[0].attributes.class) {
            var s = i[0].attributes.class.split(" ").reduce(function(a, l) {
                return l === Xe.replacementClass || l.match(r) ? a.toSvg.push(l) : a.toNode.push(l),
                a
            }, {
                toNode: [],
                toSvg: []
            });
            i[0].attributes.class = s.toSvg.join(" "),
            s.toNode.length === 0 ? t.removeAttribute("class") : t.setAttribute("class", s.toNode.join(" "))
        }
        var o = i.map(function(a) {
            return Ch(a)
        }).join(`
`);
        t.setAttribute(bl, ""),
        t.innerHTML = o
    }
};
function hP(n) {
    n()
}
function tk(n, e) {
    var t = typeof e == "function" ? e : dg;
    if (n.length === 0)
        t();
    else {
        var i = hP;
        Xe.mutateApproach === aK && (i = aa.requestAnimationFrame || hP),
        i(function() {
            var r = eQ()
              , s = QS.begin("mutate");
            n.map(r),
            s(),
            t()
        })
    }
}
var ZS = !1;
function nk() {
    ZS = !0
}
function dA() {
    ZS = !1
}
var n0 = null;
function pP(n) {
    if (iP && Xe.observeMutations) {
        var e = n.treeCallback
          , t = e === void 0 ? dg : e
          , i = n.nodeCallback
          , r = i === void 0 ? dg : i
          , s = n.pseudoElementsCallback
          , o = s === void 0 ? dg : s
          , a = n.observeMutationsRoot
          , l = a === void 0 ? Qt : a;
        n0 = new iP(function(c) {
            if (!ZS) {
                var d = la();
                Bc(c).forEach(function(h) {
                    if (h.type === "childList" && h.addedNodes.length > 0 && !dP(h.addedNodes[0]) && (Xe.searchPseudoElements && o(h.target),
                    t(h.target)),
                    h.type === "attributes" && h.target.parentNode && Xe.searchPseudoElements && o(h.target.parentNode),
                    h.type === "attributes" && dP(h.target) && ~pK.indexOf(h.attributeName))
                        if (h.attributeName === "class" && qK(h.target)) {
                            var p = ev(WS(h.target))
                              , m = p.prefix
                              , y = p.iconName;
                            h.target.setAttribute(GS, m || d),
                            y && h.target.setAttribute(HS, y)
                        } else
                            $K(h.target) && r(h.target)
                })
            }
        }
        ),
        lo && n0.observe(l, {
            childList: !0,
            attributes: !0,
            characterData: !0,
            subtree: !0
        })
    }
}
function rQ() {
    n0 && n0.disconnect()
}
function sQ(n) {
    var e = n.getAttribute("style")
      , t = [];
    return e && (t = e.split(";").reduce(function(i, r) {
        var s = r.split(":")
          , o = s[0]
          , a = s.slice(1);
        return o && a.length > 0 && (i[o] = a.join(":").trim()),
        i
    }, {})),
    t
}
function oQ(n) {
    var e = n.getAttribute("data-prefix")
      , t = n.getAttribute("data-icon")
      , i = n.innerText !== void 0 ? n.innerText.trim() : ""
      , r = ev(WS(n));
    return r.prefix || (r.prefix = la()),
    e && t && (r.prefix = e,
    r.iconName = t),
    r.iconName && r.prefix || (r.prefix && i.length > 0 && (r.iconName = NK(r.prefix, n.innerText) || XS(r.prefix, sA(n.innerText))),
    !r.iconName && Xe.autoFetchSvg && n.firstChild && n.firstChild.nodeType === Node.TEXT_NODE && (r.iconName = n.firstChild.data)),
    r
}
function aQ(n) {
    var e = Bc(n.attributes).reduce(function(r, s) {
        return r.name !== "class" && r.name !== "style" && (r[s.name] = s.value),
        r
    }, {})
      , t = n.getAttribute("title")
      , i = n.getAttribute("data-fa-title-id");
    return Xe.autoA11y && (t ? e["aria-labelledby"] = "".concat(Xe.replacementClass, "-title-").concat(i || Jd()) : (e["aria-hidden"] = "true",
    e.focusable = "false")),
    e
}
function lQ() {
    return {
        iconName: null,
        title: null,
        titleId: null,
        prefix: null,
        transform: as,
        symbol: !1,
        mask: {
            iconName: null,
            prefix: null,
            rest: []
        },
        maskId: null,
        extra: {
            classes: [],
            styles: {},
            attributes: {}
        }
    }
}
function mP(n) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        styleParser: !0
    }
      , t = oQ(n)
      , i = t.iconName
      , r = t.prefix
      , s = t.rest
      , o = aQ(n)
      , a = aA("parseNodeAttributes", {}, n)
      , l = e.styleParser ? sQ(n) : [];
    return ze({
        iconName: i,
        title: n.getAttribute("title"),
        titleId: n.getAttribute("data-fa-title-id"),
        prefix: r,
        transform: as,
        mask: {
            iconName: null,
            prefix: null,
            rest: []
        },
        maskId: null,
        symbol: !1,
        extra: {
            classes: s,
            styles: l,
            attributes: o
        }
    }, a)
}
var uQ = Ur.styles;
function ik(n) {
    var e = Xe.autoReplaceSvg === "nest" ? mP(n, {
        styleParser: !1
    }) : mP(n);
    return ~e.extra.classes.indexOf(UD) ? io("generateLayersText", n, e) : io("generateSvgReplacementMutation", n, e)
}
var ua = new Set;
VS.map(function(n) {
    ua.add("fa-".concat(n))
});
Object.keys(Hd[Yt]).map(ua.add.bind(ua));
Object.keys(Hd[vn]).map(ua.add.bind(ua));
ua = Mh(ua);
function gP(n) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (!lo)
        return Promise.resolve();
    var t = Qt.documentElement.classList
      , i = function(h) {
        return t.add("".concat(rP, "-").concat(h))
    }
      , r = function(h) {
        return t.remove("".concat(rP, "-").concat(h))
    }
      , s = Xe.autoFetchSvg ? ua : VS.map(function(d) {
        return "fa-".concat(d)
    }).concat(Object.keys(uQ));
    s.includes("fa") || s.push("fa");
    var o = [".".concat(UD, ":not([").concat(bl, "])")].concat(s.map(function(d) {
        return ".".concat(d, ":not([").concat(bl, "])")
    })).join(", ");
    if (o.length === 0)
        return Promise.resolve();
    var a = [];
    try {
        a = Bc(n.querySelectorAll(o))
    } catch {}
    if (a.length > 0)
        i("pending"),
        r("complete");
    else
        return Promise.resolve();
    var l = QS.begin("onTree")
      , c = a.reduce(function(d, h) {
        try {
            var p = ik(h);
            p && d.push(p)
        } catch (m) {
            OD || m.name === "MissingIcon" && console.error(m)
        }
        return d
    }, []);
    return new Promise(function(d, h) {
        Promise.all(c).then(function(p) {
            tk(p, function() {
                i("active"),
                i("complete"),
                r("pending"),
                typeof e == "function" && e(),
                l(),
                d()
            })
        }).catch(function(p) {
            l(),
            h(p)
        })
    }
    )
}
function cQ(n) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    ik(n).then(function(t) {
        t && tk([t], e)
    })
}
function fQ(n) {
    return function(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
          , i = (e || {}).icon ? e : lA(e || {})
          , r = t.mask;
        return r && (r = (r || {}).icon ? r : lA(r || {})),
        n(i, ze(ze({}, t), {}, {
            mask: r
        }))
    }
}
var dQ = function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
      , i = t.transform
      , r = i === void 0 ? as : i
      , s = t.symbol
      , o = s === void 0 ? !1 : s
      , a = t.mask
      , l = a === void 0 ? null : a
      , c = t.maskId
      , d = c === void 0 ? null : c
      , h = t.title
      , p = h === void 0 ? null : h
      , m = t.titleId
      , y = m === void 0 ? null : m
      , v = t.classes
      , x = v === void 0 ? [] : v
      , _ = t.attributes
      , A = _ === void 0 ? {} : _
      , w = t.styles
      , M = w === void 0 ? {} : w;
    if (e) {
        var C = e.prefix
          , P = e.iconName
          , R = e.icon;
        return tv(ze({
            type: "icon"
        }, e), function() {
            return Cl("beforeDOMElementCreation", {
                iconDefinition: e,
                params: t
            }),
            Xe.autoA11y && (p ? A["aria-labelledby"] = "".concat(Xe.replacementClass, "-title-").concat(y || Jd()) : (A["aria-hidden"] = "true",
            A.focusable = "false")),
            KS({
                icons: {
                    main: uA(R),
                    mask: l ? uA(l.icon) : {
                        found: !1,
                        width: null,
                        height: null,
                        icon: {}
                    }
                },
                prefix: C,
                iconName: P,
                transform: ze(ze({}, as), r),
                symbol: o,
                title: p,
                maskId: d,
                titleId: y,
                extra: {
                    attributes: A,
                    styles: M,
                    classes: x
                }
            })
        })
    }
}
  , hQ = {
    mixout: function() {
        return {
            icon: fQ(dQ)
        }
    },
    hooks: function() {
        return {
            mutationObserverCallbacks: function(t) {
                return t.treeCallback = gP,
                t.nodeCallback = cQ,
                t
            }
        }
    },
    provides: function(e) {
        e.i2svg = function(t) {
            var i = t.node
              , r = i === void 0 ? Qt : i
              , s = t.callback
              , o = s === void 0 ? function() {}
            : s;
            return gP(r, o)
        }
        ,
        e.generateSvgReplacementMutation = function(t, i) {
            var r = i.iconName
              , s = i.title
              , o = i.titleId
              , a = i.prefix
              , l = i.transform
              , c = i.symbol
              , d = i.mask
              , h = i.maskId
              , p = i.extra;
            return new Promise(function(m, y) {
                Promise.all([cA(r, a), d.iconName ? cA(d.iconName, d.prefix) : Promise.resolve({
                    found: !1,
                    width: 512,
                    height: 512,
                    icon: {}
                })]).then(function(v) {
                    var x = US(v, 2)
                      , _ = x[0]
                      , A = x[1];
                    m([t, KS({
                        icons: {
                            main: _,
                            mask: A
                        },
                        prefix: a,
                        iconName: r,
                        transform: l,
                        symbol: c,
                        maskId: h,
                        title: s,
                        titleId: o,
                        extra: p,
                        watchable: !0
                    })])
                }).catch(y)
            }
            )
        }
        ,
        e.generateAbstractIcon = function(t) {
            var i = t.children
              , r = t.attributes
              , s = t.main
              , o = t.transform
              , a = t.styles
              , l = q0(a);
            l.length > 0 && (r.style = l);
            var c;
            return jS(o) && (c = io("generateAbstractTransformGrouping", {
                main: s,
                transform: o,
                containerWidth: s.width,
                iconWidth: s.width
            })),
            i.push(c || s.icon),
            {
                children: i,
                attributes: r
            }
        }
    }
}
  , pQ = {
    mixout: function() {
        return {
            layer: function(t) {
                var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
                  , r = i.classes
                  , s = r === void 0 ? [] : r;
                return tv({
                    type: "layer"
                }, function() {
                    Cl("beforeDOMElementCreation", {
                        assembler: t,
                        params: i
                    });
                    var o = [];
                    return t(function(a) {
                        Array.isArray(a) ? a.map(function(l) {
                            o = o.concat(l.abstract)
                        }) : o = o.concat(a.abstract)
                    }),
                    [{
                        tag: "span",
                        attributes: {
                            class: ["".concat(Xe.cssPrefix, "-layers")].concat(Mh(s)).join(" ")
                        },
                        children: o
                    }]
                })
            }
        }
    }
}
  , mQ = {
    mixout: function() {
        return {
            counter: function(t) {
                var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
                  , r = i.title
                  , s = r === void 0 ? null : r
                  , o = i.classes
                  , a = o === void 0 ? [] : o
                  , l = i.attributes
                  , c = l === void 0 ? {} : l
                  , d = i.styles
                  , h = d === void 0 ? {} : d;
                return tv({
                    type: "counter",
                    content: t
                }, function() {
                    return Cl("beforeDOMElementCreation", {
                        content: t,
                        params: i
                    }),
                    YK({
                        content: t.toString(),
                        title: s,
                        extra: {
                            attributes: c,
                            styles: h,
                            classes: ["".concat(Xe.cssPrefix, "-layers-counter")].concat(Mh(a))
                        }
                    })
                })
            }
        }
    }
}
  , gQ = {
    mixout: function() {
        return {
            text: function(t) {
                var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
                  , r = i.transform
                  , s = r === void 0 ? as : r
                  , o = i.title
                  , a = o === void 0 ? null : o
                  , l = i.classes
                  , c = l === void 0 ? [] : l
                  , d = i.attributes
                  , h = d === void 0 ? {} : d
                  , p = i.styles
                  , m = p === void 0 ? {} : p;
                return tv({
                    type: "text",
                    content: t
                }, function() {
                    return Cl("beforeDOMElementCreation", {
                        content: t,
                        params: i
                    }),
                    cP({
                        content: t,
                        transform: ze(ze({}, as), s),
                        title: a,
                        extra: {
                            attributes: h,
                            styles: m,
                            classes: ["".concat(Xe.cssPrefix, "-layers-text")].concat(Mh(c))
                        }
                    })
                })
            }
        }
    },
    provides: function(e) {
        e.generateLayersText = function(t, i) {
            var r = i.title
              , s = i.transform
              , o = i.extra
              , a = null
              , l = null;
            if (kD) {
                var c = parseInt(getComputedStyle(t).fontSize, 10)
                  , d = t.getBoundingClientRect();
                a = d.width / c,
                l = d.height / c
            }
            return Xe.autoA11y && !r && (o.attributes["aria-hidden"] = "true"),
            Promise.resolve([t, cP({
                content: t.innerHTML,
                width: a,
                height: l,
                transform: s,
                title: r,
                extra: o,
                watchable: !0
            })])
        }
    }
}
  , vQ = new RegExp('"',"ug")
  , vP = [1105920, 1112319];
function yQ(n) {
    var e = n.replace(vQ, "")
      , t = RK(e, 0)
      , i = t >= vP[0] && t <= vP[1]
      , r = e.length === 2 ? e[0] === e[1] : !1;
    return {
        value: sA(r ? e[0] : e),
        isSecondary: i || r
    }
}
function yP(n, e) {
    var t = "".concat(oK).concat(e.replace(":", "-"));
    return new Promise(function(i, r) {
        if (n.getAttribute(t) !== null)
            return i();
        var s = Bc(n.children)
          , o = s.filter(function(R) {
            return R.getAttribute(rA) === e
        })[0]
          , a = aa.getComputedStyle(n, e)
          , l = a.getPropertyValue("font-family").match(fK)
          , c = a.getPropertyValue("font-weight")
          , d = a.getPropertyValue("content");
        if (o && !l)
            return n.removeChild(o),
            i();
        if (l && d !== "none" && d !== "") {
            var h = a.getPropertyValue("content")
              , p = ~["Sharp"].indexOf(l[2]) ? vn : Yt
              , m = ~["Solid", "Regular", "Light", "Thin", "Duotone", "Brands", "Kit"].indexOf(l[2]) ? Vd[p][l[2].toLowerCase()] : dK[p][c]
              , y = yQ(h)
              , v = y.value
              , x = y.isSecondary
              , _ = l[0].startsWith("FontAwesome")
              , A = XS(m, v)
              , w = A;
            if (_) {
                var M = OK(v);
                M.iconName && M.prefix && (A = M.iconName,
                m = M.prefix)
            }
            if (A && !x && (!o || o.getAttribute(GS) !== m || o.getAttribute(HS) !== w)) {
                n.setAttribute(t, w),
                o && n.removeChild(o);
                var C = lQ()
                  , P = C.extra;
                P.attributes[rA] = e,
                cA(A, m).then(function(R) {
                    var E = KS(ze(ze({}, C), {}, {
                        icons: {
                            main: R,
                            mask: YS()
                        },
                        prefix: m,
                        iconName: w,
                        extra: P,
                        watchable: !0
                    }))
                      , B = Qt.createElement("svg");
                    e === "::before" ? n.insertBefore(B, n.firstChild) : n.appendChild(B),
                    B.outerHTML = E.map(function(I) {
                        return Ch(I)
                    }).join(`
`),
                    n.removeAttribute(t),
                    i()
                }).catch(r)
            } else
                i()
        } else
            i()
    }
    )
}
function xQ(n) {
    return Promise.all([yP(n, "::before"), yP(n, "::after")])
}
function _Q(n) {
    return n.parentNode !== document.head && !~lK.indexOf(n.tagName.toUpperCase()) && !n.getAttribute(rA) && (!n.parentNode || n.parentNode.tagName !== "svg")
}
function xP(n) {
    if (lo)
        return new Promise(function(e, t) {
            var i = Bc(n.querySelectorAll("*")).filter(_Q).map(xQ)
              , r = QS.begin("searchPseudoElements");
            nk(),
            Promise.all(i).then(function() {
                r(),
                dA(),
                e()
            }).catch(function() {
                r(),
                dA(),
                t()
            })
        }
        )
}
var AQ = {
    hooks: function() {
        return {
            mutationObserverCallbacks: function(t) {
                return t.pseudoElementsCallback = xP,
                t
            }
        }
    },
    provides: function(e) {
        e.pseudoElements2svg = function(t) {
            var i = t.node
              , r = i === void 0 ? Qt : i;
            Xe.searchPseudoElements && xP(r)
        }
    }
}
  , _P = !1
  , wQ = {
    mixout: function() {
        return {
            dom: {
                unwatch: function() {
                    nk(),
                    _P = !0
                }
            }
        }
    },
    hooks: function() {
        return {
            bootstrap: function() {
                pP(aA("mutationObserverCallbacks", {}))
            },
            noAuto: function() {
                rQ()
            },
            watch: function(t) {
                var i = t.observeMutationsRoot;
                _P ? dA() : pP(aA("mutationObserverCallbacks", {
                    observeMutationsRoot: i
                }))
            }
        }
    }
}
  , AP = function(e) {
    var t = {
        size: 16,
        x: 0,
        y: 0,
        flipX: !1,
        flipY: !1,
        rotate: 0
    };
    return e.toLowerCase().split(" ").reduce(function(i, r) {
        var s = r.toLowerCase().split("-")
          , o = s[0]
          , a = s.slice(1).join("-");
        if (o && a === "h")
            return i.flipX = !0,
            i;
        if (o && a === "v")
            return i.flipY = !0,
            i;
        if (a = parseFloat(a),
        isNaN(a))
            return i;
        switch (o) {
        case "grow":
            i.size = i.size + a;
            break;
        case "shrink":
            i.size = i.size - a;
            break;
        case "left":
            i.x = i.x - a;
            break;
        case "right":
            i.x = i.x + a;
            break;
        case "up":
            i.y = i.y - a;
            break;
        case "down":
            i.y = i.y + a;
            break;
        case "rotate":
            i.rotate = i.rotate + a;
            break
        }
        return i
    }, t)
}
  , SQ = {
    mixout: function() {
        return {
            parse: {
                transform: function(t) {
                    return AP(t)
                }
            }
        }
    },
    hooks: function() {
        return {
            parseNodeAttributes: function(t, i) {
                var r = i.getAttribute("data-fa-transform");
                return r && (t.transform = AP(r)),
                t
            }
        }
    },
    provides: function(e) {
        e.generateAbstractTransformGrouping = function(t) {
            var i = t.main
              , r = t.transform
              , s = t.containerWidth
              , o = t.iconWidth
              , a = {
                transform: "translate(".concat(s / 2, " 256)")
            }
              , l = "translate(".concat(r.x * 32, ", ").concat(r.y * 32, ") ")
              , c = "scale(".concat(r.size / 16 * (r.flipX ? -1 : 1), ", ").concat(r.size / 16 * (r.flipY ? -1 : 1), ") ")
              , d = "rotate(".concat(r.rotate, " 0 0)")
              , h = {
                transform: "".concat(l, " ").concat(c, " ").concat(d)
            }
              , p = {
                transform: "translate(".concat(o / 2 * -1, " -256)")
            }
              , m = {
                outer: a,
                inner: h,
                path: p
            };
            return {
                tag: "g",
                attributes: ze({}, m.outer),
                children: [{
                    tag: "g",
                    attributes: ze({}, m.inner),
                    children: [{
                        tag: i.icon.tag,
                        children: i.icon.children,
                        attributes: ze(ze({}, i.icon.attributes), m.path)
                    }]
                }]
            }
        }
    }
}
  , Gx = {
    x: 0,
    y: 0,
    width: "100%",
    height: "100%"
};
function wP(n) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return n.attributes && (n.attributes.fill || e) && (n.attributes.fill = "black"),
    n
}
function MQ(n) {
    return n.tag === "g" ? n.children : [n]
}
var bQ = {
    hooks: function() {
        return {
            parseNodeAttributes: function(t, i) {
                var r = i.getAttribute("data-fa-mask")
                  , s = r ? ev(r.split(" ").map(function(o) {
                    return o.trim()
                })) : YS();
                return s.prefix || (s.prefix = la()),
                t.mask = s,
                t.maskId = i.getAttribute("data-fa-mask-id"),
                t
            }
        }
    },
    provides: function(e) {
        e.generateAbstractMask = function(t) {
            var i = t.children
              , r = t.attributes
              , s = t.main
              , o = t.mask
              , a = t.maskId
              , l = t.transform
              , c = s.width
              , d = s.icon
              , h = o.width
              , p = o.icon
              , m = SK({
                transform: l,
                containerWidth: h,
                iconWidth: c
            })
              , y = {
                tag: "rect",
                attributes: ze(ze({}, Gx), {}, {
                    fill: "white"
                })
            }
              , v = d.children ? {
                children: d.children.map(wP)
            } : {}
              , x = {
                tag: "g",
                attributes: ze({}, m.inner),
                children: [wP(ze({
                    tag: d.tag,
                    attributes: ze(ze({}, d.attributes), m.path)
                }, v))]
            }
              , _ = {
                tag: "g",
                attributes: ze({}, m.outer),
                children: [x]
            }
              , A = "mask-".concat(a || Jd())
              , w = "clip-".concat(a || Jd())
              , M = {
                tag: "mask",
                attributes: ze(ze({}, Gx), {}, {
                    id: A,
                    maskUnits: "userSpaceOnUse",
                    maskContentUnits: "userSpaceOnUse"
                }),
                children: [y, _]
            }
              , C = {
                tag: "defs",
                children: [{
                    tag: "clipPath",
                    attributes: {
                        id: w
                    },
                    children: MQ(p)
                }, M]
            };
            return i.push(C, {
                tag: "rect",
                attributes: ze({
                    fill: "currentColor",
                    "clip-path": "url(#".concat(w, ")"),
                    mask: "url(#".concat(A, ")")
                }, Gx)
            }),
            {
                children: i,
                attributes: r
            }
        }
    }
}
  , CQ = {
    provides: function(e) {
        var t = !1;
        aa.matchMedia && (t = aa.matchMedia("(prefers-reduced-motion: reduce)").matches),
        e.missingIconAbstract = function() {
            var i = []
              , r = {
                fill: "currentColor"
            }
              , s = {
                attributeType: "XML",
                repeatCount: "indefinite",
                dur: "2s"
            };
            i.push({
                tag: "path",
                attributes: ze(ze({}, r), {}, {
                    d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
                })
            });
            var o = ze(ze({}, s), {}, {
                attributeName: "opacity"
            })
              , a = {
                tag: "circle",
                attributes: ze(ze({}, r), {}, {
                    cx: "256",
                    cy: "364",
                    r: "28"
                }),
                children: []
            };
            return t || a.children.push({
                tag: "animate",
                attributes: ze(ze({}, s), {}, {
                    attributeName: "r",
                    values: "28;14;28;28;14;28;"
                })
            }, {
                tag: "animate",
                attributes: ze(ze({}, o), {}, {
                    values: "1;0;1;1;0;1;"
                })
            }),
            i.push(a),
            i.push({
                tag: "path",
                attributes: ze(ze({}, r), {}, {
                    opacity: "1",
                    d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
                }),
                children: t ? [] : [{
                    tag: "animate",
                    attributes: ze(ze({}, o), {}, {
                        values: "1;0;0;0;0;1;"
                    })
                }]
            }),
            t || i.push({
                tag: "path",
                attributes: ze(ze({}, r), {}, {
                    opacity: "0",
                    d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
                }),
                children: [{
                    tag: "animate",
                    attributes: ze(ze({}, o), {}, {
                        values: "0;0;1;1;0;0;"
                    })
                }]
            }),
            {
                tag: "g",
                attributes: {
                    class: "missing"
                },
                children: i
            }
        }
    }
}
  , EQ = {
    hooks: function() {
        return {
            parseNodeAttributes: function(t, i) {
                var r = i.getAttribute("data-fa-symbol")
                  , s = r === null ? !1 : r === "" ? !0 : r;
                return t.symbol = s,
                t
            }
        }
    }
}
  , TQ = [CK, hQ, pQ, mQ, gQ, AQ, wQ, SQ, bQ, CQ, EQ];
GK(TQ, {
    mixoutsTo: $i
});
$i.noAuto;
$i.config;
$i.library;
$i.dom;
var hA = $i.parse;
$i.findIconDefinition;
$i.toHtml;
var PQ = $i.icon;
$i.layer;
$i.text;
$i.counter;
function SP(n, e) {
    var t = Object.keys(n);
    if (Object.getOwnPropertySymbols) {
        var i = Object.getOwnPropertySymbols(n);
        e && (i = i.filter(function(r) {
            return Object.getOwnPropertyDescriptor(n, r).enumerable
        })),
        t.push.apply(t, i)
    }
    return t
}
function zo(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? SP(Object(t), !0).forEach(function(i) {
            Ou(n, i, t[i])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : SP(Object(t)).forEach(function(i) {
            Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i))
        })
    }
    return n
}
function i0(n) {
    return i0 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    ,
    i0(n)
}
function Ou(n, e, t) {
    return e in n ? Object.defineProperty(n, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : n[e] = t,
    n
}
function BQ(n, e) {
    if (n == null)
        return {};
    var t = {}, i = Object.keys(n), r, s;
    for (s = 0; s < i.length; s++)
        r = i[s],
        !(e.indexOf(r) >= 0) && (t[r] = n[r]);
    return t
}
function RQ(n, e) {
    if (n == null)
        return {};
    var t = BQ(n, e), i, r;
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(n);
        for (r = 0; r < s.length; r++)
            i = s[r],
            !(e.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(n, i) && (t[i] = n[i])
    }
    return t
}
function pA(n) {
    return IQ(n) || LQ(n) || DQ(n) || kQ()
}
function IQ(n) {
    if (Array.isArray(n))
        return mA(n)
}
function LQ(n) {
    if (typeof Symbol < "u" && n[Symbol.iterator] != null || n["@@iterator"] != null)
        return Array.from(n)
}
function DQ(n, e) {
    if (n) {
        if (typeof n == "string")
            return mA(n, e);
        var t = Object.prototype.toString.call(n).slice(8, -1);
        if (t === "Object" && n.constructor && (t = n.constructor.name),
        t === "Map" || t === "Set")
            return Array.from(n);
        if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
            return mA(n, e)
    }
}
function mA(n, e) {
    (e == null || e > n.length) && (e = n.length);
    for (var t = 0, i = new Array(e); t < e; t++)
        i[t] = n[t];
    return i
}
function kQ() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function FQ(n) {
    var e, t = n.beat, i = n.fade, r = n.beatFade, s = n.bounce, o = n.shake, a = n.flash, l = n.spin, c = n.spinPulse, d = n.spinReverse, h = n.pulse, p = n.fixedWidth, m = n.inverse, y = n.border, v = n.listItem, x = n.flip, _ = n.size, A = n.rotation, w = n.pull, M = (e = {
        "fa-beat": t,
        "fa-fade": i,
        "fa-beat-fade": r,
        "fa-bounce": s,
        "fa-shake": o,
        "fa-flash": a,
        "fa-spin": l,
        "fa-spin-reverse": d,
        "fa-spin-pulse": c,
        "fa-pulse": h,
        "fa-fw": p,
        "fa-inverse": m,
        "fa-border": y,
        "fa-li": v,
        "fa-flip": x === !0,
        "fa-flip-horizontal": x === "horizontal" || x === "both",
        "fa-flip-vertical": x === "vertical" || x === "both"
    },
    Ou(e, "fa-".concat(_), typeof _ < "u" && _ !== null),
    Ou(e, "fa-rotate-".concat(A), typeof A < "u" && A !== null && A !== 0),
    Ou(e, "fa-pull-".concat(w), typeof w < "u" && w !== null),
    Ou(e, "fa-swap-opacity", n.swapOpacity),
    e);
    return Object.keys(M).map(function(C) {
        return M[C] ? C : null
    }).filter(function(C) {
        return C
    })
}
function NQ(n) {
    return n = n - 0,
    n === n
}
function rk(n) {
    return NQ(n) ? n : (n = n.replace(/[\-_\s]+(.)?/g, function(e, t) {
        return t ? t.toUpperCase() : ""
    }),
    n.substr(0, 1).toLowerCase() + n.substr(1))
}
var OQ = ["style"];
function UQ(n) {
    return n.charAt(0).toUpperCase() + n.slice(1)
}
function zQ(n) {
    return n.split(";").map(function(e) {
        return e.trim()
    }).filter(function(e) {
        return e
    }).reduce(function(e, t) {
        var i = t.indexOf(":")
          , r = rk(t.slice(0, i))
          , s = t.slice(i + 1).trim();
        return r.startsWith("webkit") ? e[UQ(r)] = s : e[r] = s,
        e
    }, {})
}
function sk(n, e) {
    var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (typeof e == "string")
        return e;
    var i = (e.children || []).map(function(l) {
        return sk(n, l)
    })
      , r = Object.keys(e.attributes || {}).reduce(function(l, c) {
        var d = e.attributes[c];
        switch (c) {
        case "class":
            l.attrs.className = d,
            delete e.attributes.class;
            break;
        case "style":
            l.attrs.style = zQ(d);
            break;
        default:
            c.indexOf("aria-") === 0 || c.indexOf("data-") === 0 ? l.attrs[c.toLowerCase()] = d : l.attrs[rk(c)] = d
        }
        return l
    }, {
        attrs: {}
    })
      , s = t.style
      , o = s === void 0 ? {} : s
      , a = RQ(t, OQ);
    return r.attrs.style = zo(zo({}, r.attrs.style), o),
    n.apply(void 0, [e.tag, zo(zo({}, r.attrs), a)].concat(pA(i)))
}
var ok = !1;
try {
    ok = !0
} catch {}
function GQ() {
    if (!ok && console && typeof console.error == "function") {
        var n;
        (n = console).error.apply(n, arguments)
    }
}
function MP(n) {
    if (n && i0(n) === "object" && n.prefix && n.iconName && n.icon)
        return n;
    if (hA.icon)
        return hA.icon(n);
    if (n === null)
        return null;
    if (n && i0(n) === "object" && n.prefix && n.iconName)
        return n;
    if (Array.isArray(n) && n.length === 2)
        return {
            prefix: n[0],
            iconName: n[1]
        };
    if (typeof n == "string")
        return {
            prefix: "fas",
            iconName: n
        }
}
function Hx(n, e) {
    return Array.isArray(e) && e.length > 0 || !Array.isArray(e) && e ? Ou({}, n, e) : {}
}
var mc = vc.forwardRef(function(n, e) {
    var t = n.icon
      , i = n.mask
      , r = n.symbol
      , s = n.className
      , o = n.title
      , a = n.titleId
      , l = n.maskId
      , c = MP(t)
      , d = Hx("classes", [].concat(pA(FQ(n)), pA(s.split(" "))))
      , h = Hx("transform", typeof n.transform == "string" ? hA.transform(n.transform) : n.transform)
      , p = Hx("mask", MP(i))
      , m = PQ(c, zo(zo(zo(zo({}, d), h), p), {}, {
        symbol: r,
        title: o,
        titleId: a,
        maskId: l
    }));
    if (!m)
        return GQ("Could not find icon", c),
        null;
    var y = m.abstract
      , v = {
        ref: e
    };
    return Object.keys(n).forEach(function(x) {
        mc.defaultProps.hasOwnProperty(x) || (v[x] = n[x])
    }),
    HQ(y[0], v)
});
mc.displayName = "FontAwesomeIcon";
mc.propTypes = {
    beat: ht.bool,
    border: ht.bool,
    beatFade: ht.bool,
    bounce: ht.bool,
    className: ht.string,
    fade: ht.bool,
    flash: ht.bool,
    mask: ht.oneOfType([ht.object, ht.array, ht.string]),
    maskId: ht.string,
    fixedWidth: ht.bool,
    inverse: ht.bool,
    flip: ht.oneOf([!0, !1, "horizontal", "vertical", "both"]),
    icon: ht.oneOfType([ht.object, ht.array, ht.string]),
    listItem: ht.bool,
    pull: ht.oneOf(["right", "left"]),
    pulse: ht.bool,
    rotation: ht.oneOf([0, 90, 180, 270]),
    shake: ht.bool,
    size: ht.oneOf(["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"]),
    spin: ht.bool,
    spinPulse: ht.bool,
    spinReverse: ht.bool,
    symbol: ht.oneOfType([ht.bool, ht.string]),
    title: ht.string,
    titleId: ht.string,
    transform: ht.oneOfType([ht.string, ht.object]),
    swapOpacity: ht.bool
};
mc.defaultProps = {
    border: !1,
    className: "",
    mask: null,
    maskId: null,
    fixedWidth: !1,
    inverse: !1,
    flip: !1,
    icon: null,
    listItem: !1,
    pull: null,
    pulse: !1,
    rotation: null,
    size: null,
    spin: !1,
    spinPulse: !1,
    spinReverse: !1,
    beat: !1,
    fade: !1,
    beatFade: !1,
    bounce: !1,
    shake: !1,
    symbol: !1,
    title: "",
    titleId: null,
    transform: null,
    swapOpacity: !1
};
var HQ = sk.bind(null, vc.createElement)
  , VQ = {
    prefix: "fab",
    iconName: "discord",
    icon: [640, 512, [], "f392", "M524.531,69.836a1.5,1.5,0,0,0-.764-.7A485.065,485.065,0,0,0,404.081,32.03a1.816,1.816,0,0,0-1.923.91,337.461,337.461,0,0,0-14.9,30.6,447.848,447.848,0,0,0-134.426,0,309.541,309.541,0,0,0-15.135-30.6,1.89,1.89,0,0,0-1.924-.91A483.689,483.689,0,0,0,116.085,69.137a1.712,1.712,0,0,0-.788.676C39.068,183.651,18.186,294.69,28.43,404.354a2.016,2.016,0,0,0,.765,1.375A487.666,487.666,0,0,0,176.02,479.918a1.9,1.9,0,0,0,2.063-.676A348.2,348.2,0,0,0,208.12,430.4a1.86,1.86,0,0,0-1.019-2.588,321.173,321.173,0,0,1-45.868-21.853,1.885,1.885,0,0,1-.185-3.126c3.082-2.309,6.166-4.711,9.109-7.137a1.819,1.819,0,0,1,1.9-.256c96.229,43.917,200.41,43.917,295.5,0a1.812,1.812,0,0,1,1.924.233c2.944,2.426,6.027,4.851,9.132,7.16a1.884,1.884,0,0,1-.162,3.126,301.407,301.407,0,0,1-45.89,21.83,1.875,1.875,0,0,0-1,2.611,391.055,391.055,0,0,0,30.014,48.815,1.864,1.864,0,0,0,2.063.7A486.048,486.048,0,0,0,610.7,405.729a1.882,1.882,0,0,0,.765-1.352C623.729,277.594,590.933,167.465,524.531,69.836ZM222.491,337.58c-28.972,0-52.844-26.587-52.844-59.239S193.056,219.1,222.491,219.1c29.665,0,53.306,26.82,52.843,59.239C275.334,310.993,251.924,337.58,222.491,337.58Zm195.38,0c-28.971,0-52.843-26.587-52.843-59.239S388.437,219.1,417.871,219.1c29.667,0,53.307,26.82,52.844,59.239C470.715,310.993,447.538,337.58,417.871,337.58Z"]
}
  , WQ = {
    prefix: "fab",
    iconName: "telegram",
    icon: [496, 512, [62462, "telegram-plane"], "f2c6", "M248,8C111.033,8,0,119.033,0,256S111.033,504,248,504,496,392.967,496,256,384.967,8,248,8ZM362.952,176.66c-3.732,39.215-19.881,134.378-28.1,178.3-3.476,18.584-10.322,24.816-16.948,25.425-14.4,1.326-25.338-9.517-39.287-18.661-21.827-14.308-34.158-23.215-55.346-37.177-24.485-16.135-8.612-25,5.342-39.5,3.652-3.793,67.107-61.51,68.335-66.746.153-.655.3-3.1-1.154-4.384s-3.59-.849-5.135-.5q-3.283.746-104.608,69.142-14.845,10.194-26.894,9.934c-8.855-.191-25.888-5.006-38.551-9.123-15.531-5.048-27.875-7.717-26.8-16.291q.84-6.7,18.45-13.7,108.446-47.248,144.628-62.3c68.872-28.647,83.183-33.623,92.511-33.789,2.052-.034,6.639.474,9.61,2.885a10.452,10.452,0,0,1,3.53,6.716A43.765,43.765,0,0,1,362.952,176.66Z"]
};
const jQ = ()=>{
    const n = U.useRef()
      , [e,t] = U.useState({
        name: "",
        email: "",
        message: ""
    })
      , [i,r] = U.useState(!1)
      , s = o=>{
        o.preventDefault(),
        r(!0),
        QY.send({}.VITE_APP_EMAILJS_SERVICE_ID, {}.VITE_APP_EMAILJS_TEMPLATE_ID, {
            from_name: e.name,
            to_name: "Graphicsdesign.io",
            from_email: e.email,
            to_email: "admin@graphicsdesign.io",
            message: e.message
        }, {}.VITE_APP_EMAILJS_PUBLIC_KEY).then(()=>{
            r(!1),
            alert("Please contact me on telegram https://github.com/dbrooks228"),
            t({
                name: "",
                email: "",
                message: ""
            })
        }
        , a=>{
            r(!1),
            console.error(a),
            alert("Ahh, something went wrong. Please try again.")
        }
        )
    }
    ;
    return it("div", {
        className: "xl:mt-12 flex xl:flex-row flex-col-reverse gap-10 overflow-hidden",
        children: [it(Qi.div, {
            variants: Y2("left", "tween", .2, 1),
            className: "flex-[0.75] bg-black-100 p-8 rounded-2xl",
            children: [he("p", {
                className: Yn.sectionSubText,
                children: "Get in touch"
            }), he("h3", {
                className: Yn.sectionHeadText,
                children: "Contact."
            }), it("form", {
                ref: n,
                onSubmit: s,
                className: "mt-12 flex flex-col gap-8",
                children: [he("label", {
                    className: "flex flex-col",
                    children: it("span", {
                        className: "text-white font-medium mb-4",
                        style: {
                            display: "flex",
                            alignItems: "center"
                        },
                        children: [he(mc, {
                            icon: WQ,
                            size: "2x",
                            style: {
                                marginRight: "10px"
                            }
                        }), " Email : brodanie33@gmail.com"]
                    })
                }), he("label", {
                    className: "flex flex-col",
                    children: it("span", {
                        className: "text-white font-medium mb-4",
                        style: {
                            display: "flex",
                            alignItems: "center"
                        },
                        children: [he(mc, {
                            icon: VQ,
                            size: "2x",
                            style: {
                                marginRight: "10px"
                            }
                        }), " Github : @dbrooks228"]
                    })
                })
            ]
            })]
        }), he(Qi.div, {
            variants: Y2("right", "tween", .2, 1),
            className: "xl:flex-1 xl:h-auto md:h-[50px] h-[350px]",
            children: he(uW, {})
        })]
    })
}
  , JQ = Pc(jQ, "contact")
  , XQ = ()=>he(e4, {
    children: it("div", {
        className: "relative z-0 bg-primary",
        children: [it("div", {
            className: "bg-hero-pattern bg-cover bg-no-repeat bg-center",
            children: [he(oY, {}), he(CX, {})]
        }), he(yY, {}), he(UY, {}), he(_Y, {}), he(HY, {}), he(jY, {}), it("div", {
            className: "relative z-0",
            children: [he(JQ, {}), he(mW, {})]
        })]
    })
});
Wx.createRoot(document.getElementById("root")).render(he(vc.StrictMode, {
    children: he(XQ, {})
}));